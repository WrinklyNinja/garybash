diff --git a/Mopy/bash/bosh.py b/Mopy/bash/bosh.py
index 69f5f27..a5000f0 100644
--- a/Mopy/bash/bosh.py
+++ b/Mopy/bash/bosh.py
@@ -21,7 +21,7 @@
 #
 # =============================================================================
 
-"""This module defines provides objects and functions for working with Oblivion
+"""This module defines provides objects and functions for working with Fallout3
 files and environment. It does not provide interface functions which are instead
 provided by separate modules: bish for CLI and bash/basher for GUI."""
 
@@ -78,14 +78,17 @@ from operator import attrgetter,itemgetter
 import subprocess
 from subprocess import Popen, PIPE
 import codecs
+from xml.etree import ElementTree
 
 #--Local
 import balt
 import bolt
 import bush
 from bolt import BoltError, AbstractError, ArgumentError, StateError, UncodedError, PermissionError
-from bolt import _, LString, Unicode, Encode, GPath, Flags, DataDict, SubProgress, cstrip, deprint, delist
+from bolt import _, LString, Unicode, Encode, GPath, Flags, DataDict, SubProgress, cstrip, deprint, delist, sio
 from cint import *
+import bapi
+
 startupinfo = bolt.startupinfo
 
 #--Unicode
@@ -105,7 +108,8 @@ oiMask = 0xFFFFFFL
 question = False
 
 #--File Singletons
-oblivionIni = None
+falloutIni = None
+falloutPrefsIni = None
 modInfos  = None  #--ModInfos singleton
 saveInfos = None #--SaveInfos singleton
 iniInfos = None #--INIInfos singleton
@@ -114,6 +118,7 @@ screensData = None #--ScreensData singleton
 bsaData = None #--bsaData singleton
 messages = None #--Message archive singleton
 configHelpers = None #--Config Helper files (Boss Master List, etc.)
+boss = None #--BossDb singleton
 links = None
 
 def listArchiveContents(fileName):
@@ -138,16 +143,18 @@ installersWindow = None
 allTags = sorted(('Body-F', 'Body-M', 'Body-Size-M', 'Body-Size-F', 'C.Climate', 'C.Light', 'C.Music', 'C.Name', 'C.RecordFlags',
                   'C.Owner', 'C.Water','Deactivate', 'Delev', 'Eyes', 'Factions', 'Relations', 'Filter', 'Graphics', 'Hair',
                   'IIM', 'Invent', 'Names', 'NoMerge', 'NpcFaces', 'R.Relations', 'Relev', 'Scripts', 'ScriptContents', 'Sound',
-                  'SpellStats', 'Stats', 'Voice-F', 'Voice-M', 'R.Teeth', 'R.Mouth', 'R.Ears', 'R.Head', 'R.Attributes-F',
-                  'R.Attributes-M', 'R.Skills', 'R.Description', 'R.AddSpells', 'R.ChangeSpells', 'Roads', 'Actors.Anims',
+                  'Stats', 'Voice-F', 'Voice-M', 'R.Teeth', 'R.Mouth', 'R.Ears', 'R.Head', 'R.Attributes-F',
+                  'R.Attributes-M', 'R.Skills', 'R.Description', 'Roads', 'Actors.Anims',
                   'Actors.AIData', 'Actors.DeathItem', 'Actors.AIPackages', 'Actors.AIPackagesForceAdd', 'Actors.Stats',
-                  'Actors.ACBS', 'NPC.Class', 'Actors.CombatStyle', 'Creatures.Blood', 'Actors.Spells','Actors.SpellsForceAdd',
-                  'NPC.Race','Actors.Skeleton', 'NpcFacesForceFullImport', 'MustBeActiveIfImported', 'Npc.HairOnly','Npc.EyesOnly')) ##, 'ForceMerge'
+                  'Actors.ACBS', 'NPC.Class', 'Actors.CombatStyle', 'Creatures.Blood',
+                  'NPC.Race','Actors.Skeleton', 'NpcFacesForceFullImport', 'MustBeActiveIfImported',
+                  'Deflst', 'Destructible'))
+
 allTagsSet = set(allTags)
 oldTags = sorted(('Merge',))
 oldTagsSet = set(oldTags)
 
-reOblivion = re.compile('^(Oblivion|Nehrim)(|_SI|_1.1|_1.1b|_1.0.7.5|_GOTY non-SI).esm$')
+reFallout = re.compile('^(Fallout3|FalloutNV)(|_1.1|_1.2|_1.3|_1.4).esm$')
 
 undefinedPath = GPath(r'C:\not\a\valid\path.exe')
 undefinedPaths = set([GPath(r'C:\Path\exe.exe'),undefinedPath])
@@ -157,6 +164,8 @@ settingDefaults = {
     'bosh.modInfos.resetMTimes':True,
     }
 
+recHeaderSize = 24
+
 # Errors ----------------------------------------------------------------------
 #------------------------------------------------------------------------------
 class FileError(BoltError):
@@ -337,13 +346,13 @@ reModExt  = re.compile(r'\.es[mp](.ghost)?$',re.I)
 reEsmExt  = re.compile(r'\.esm(.ghost)?$',re.I)
 reEspExt  = re.compile(r'\.esp(.ghost)?$',re.I)
 reBSAExt  = re.compile(r'\.bsa(.ghost)?$',re.I)
-reEssExt  = re.compile(r'\.ess$',re.I)
-reSaveExt = re.compile(r'(quicksave(\.bak)+|autosave(\.bak)+|\.es[rs])$',re.I)
+reFosExt  = re.compile(r'\.fos$',re.I)
+reSaveExt = re.compile(r'(quicksave(\.bak)+|autosave(\.bak)+|\.fo[rs])$',re.I)
 reCsvExt  = re.compile(r'\.csv$',re.I)
 reINIExt  = re.compile(r'\.ini$',re.I)
 reQuoted  = re.compile(r'^"(.*)"$')
 reGroupHeader = re.compile(r'^(\+\+|==)')
-reTesNexus = re.compile(r'(.*?)(?:-(\d{4,6})(?:\.tessource)?(?:-bain)?(?:-\d{0,6})?(?:-\d{0,6})?(?:-\d{0,6})?(?:\w)?)?(\.7z|\.zip|\.rar|\.7z\.001|)$',re.I)
+reFallout3Nexus = re.compile(r'(.*?)(?:-(\d{4,6})(?:\.tessource)?(?:-bain)?(?:-\d{0,6})?(?:-\d{0,6})?(?:-\d{0,6})?(?:\w)?)?(\.7z|\.zip|\.rar|\.7z\.001|)$',re.I)
 reTESA = re.compile(r'(.*?)(?:-(\d{1,6})(?:\.tessource)?(?:-bain)?)?(\.7z|\.zip|\.rar|)$',re.I)
 reSplitOnNonAlphaNumeric = re.compile(r'\W+')
 
@@ -543,26 +552,26 @@ class ModReader:
 
     def unpackRecHeader(self):
         """Unpack a record header."""
-        (type,size,uint0,uint1,uint2) = self.unpack('4s4I',20,'REC_HEAD')
+        (type,size,uint0,uint1,uint2,uint3) = self.unpack('4s5I',recHeaderSize,'REC_HEAD')
         #--Bad?
         if type not in bush.recordTypes:
             raise ModError(self.inName,_('Bad header type: ')+type)
         #print (type,size,uint0,uint1,uint2)
         #--Record
         if type != 'GRUP':
-            return (type,size,uint0,uint1,uint2)
+            return (type,size,uint0,uint1,uint2,uint3)
         #--Top Group
         elif uint1 == 0:
             str0 = struct.pack('I',uint0)
             if str0 in bush.topTypes:
-                return (type,size,str0,uint1,uint2)
+                return (type,size,str0,uint1,uint2,uint3)
             elif str0 in bush.topIgTypes:
-                return (type,size,bush.topIgTypes[str0],uint1,uint2)
+                return (type,size,bush.topIgTypes[str0],uint1,uint2,uint3)
             else:
                 raise ModError(self.inName,_('Bad Top GRUP type: ')+str0)
         #--Other groups
         else:
-            return (type,size,uint0,uint1,uint2)
+            return (type,size,uint0,uint1,uint2,uint3)
 
     def unpackSubHeader(self,recType='----',expType=None,expSize=0):
         """Unpack a subrecord header. Optionally checks for match with expected type and size."""
@@ -660,7 +669,7 @@ class ModWriter:
         else:
             outWrite(structPack('=4sHI','XXXX',4,lenData))
             outWrite(structPack('=4sH',type,0))
-        outWrite(Encode(data))
+        outWrite(Encode(data,'mbcs'))
         outWrite('\x00')
 
     def packRef(self,type,fid):
@@ -668,13 +677,13 @@ class ModWriter:
         #if not ModWriter.reValidType.match(type): raise _('Invalid type: ') + `type`
         if fid != None: self.out.write(struct.pack('=4sHI',type,4,fid))
 
-    def writeGroup(self,size,label,groupType,stamp):
+    def writeGroup(self,size,label,groupType,stamp,stamp2):
         if type(label) is str:
-            self.pack('=4sI4sII','GRUP',size,label,groupType,stamp)
+            self.pack('=4sI4sIII','GRUP',size,label,groupType,stamp,stamp2)
         elif type(label) is tuple:
-            self.pack('=4sIhhII','GRUP',size,label[1],label[0],groupType,stamp)
+            self.pack('=4sIhhIII','GRUP',size,label[1],label[0],groupType,stamp,stamp2)
         else:
-            self.pack('=4s4I','GRUP',size,label,groupType,stamp)
+            self.pack('=4s4II','GRUP',size,label,groupType,stamp,stamp2)
 
 
 # Mod Record Elements ---------------------------------------------------------
@@ -1229,18 +1238,18 @@ class MelConditions(MelStructs):
     of parameters depends on function index."""
     def __init__(self):
         """Initialize."""
-        MelStructs.__init__(self,'CTDA','B3sfIii4s','conditions',
-            'operFlag',('unused1',null3),'compValue','ifunc','param1','param2',('unused2',null4))
+        MelStructs.__init__(self,'CTDA','B3sfIiiii','conditions',
+            'operFlag',('unused1',null3),'compValue','ifunc','param1','param2','param3','param4')
 
     def getLoaders(self,loaders):
         """Adds self as loader for type."""
         loaders[self.subType] = self
-        loaders['CTDT'] = self #--Older CTDT type for ai package records.
+        #loaders['CTDT'] = self #--Older CTDT type for ai package records.
 
     def getDefault(self):
         """Returns a default copy of object."""
         target = MelStructs.getDefault(self)
-        target.form12 = 'ii'
+        target.form1234 = 'iiii'
         return target
 
     def hasFids(self,formElements):
@@ -1249,10 +1258,13 @@ class MelConditions(MelStructs):
 
     def loadData(self,record,ins,type,size,readId):
         """Reads data from ins into record attribute."""
-        if type == 'CTDA' and size != 24:
-            raise ModSizeError(ins.inName,readId,24,size,True)
-        if type == 'CTDT' and size != 20:
-            raise ModSizeError(ins.inName,readId,20,size,True)
+        if type == 'CTDA':
+            if size != 28 and size != 24 and size != 20:
+                raise ModSizeError(ins.inName,readId,28,size,False)
+        else:
+            raise ModError(ins.inName,_('Unexpected subrecord: ')+readId)
+        #if type == 'CTDT' and size != 20:
+        #    raise ModSizeError(ins.inName,readId,20,size,True)
         target = MelObject()
         record.conditions.append(target)
         target.__slots__ = self.attrs
@@ -1263,14 +1275,26 @@ class MelConditions(MelStructs):
             raise BoltError(_('Unknown condition function: %d') % ifunc)
         form1 = 'iI'[ifunc in bush.fid1Conditions]
         form2 = 'iI'[ifunc in bush.fid2Conditions]
-        form12 = form1+form2
-        unpacked2 = ins.unpack(form12,8,readId)
-        (target.param1,target.param2) = unpacked2
-        if size == 24:
-            target.unused2 = ins.read(4)
+        form3 = 'iI'[ifunc in bush.fid3Conditions]
+        form4 = 'iI'[ifunc in bush.fid4Conditions]
+        if size == 28:
+            form1234 = form1+form2+form3+form4
+            unpacked2 = ins.unpack(form1234,16,readId)
+            (target.param1,target.param2,target.param3,target.param4) = unpacked2
+        elif size == 24:
+            form1234 = form1+form2+form3
+            unpacked2 = ins.unpack(form1234,12,readId)
+            (target.param1,target.param2,target.param3) = unpacked2
+            target.param4 = null4
+        elif size == 20:
+            form1234 = form1+form2
+            unpacked2 = ins.unpack(form1234,8,readId)
+            (target.param1,target.param2) = unpacked2
+            target.param3 = null4
+            target.param4 = null4
         else:
-            target.unused2 = null4
-        (target.ifunc,target.form12) = (ifunc,form12)
+            raise ModSizeError(ins.inName,readId,28,size,False)
+        (target.ifunc,target.form1234) = (ifunc,form1234)
         if self._debug:
             unpacked = unpacked1+unpacked2
             print ' ',zip(self.attrs,unpacked)
@@ -1280,22 +1304,27 @@ class MelConditions(MelStructs):
     def dumpData(self,record,out):
         """Dumps data from record to outstream."""
         for target in record.conditions:
-##            format = 'B3sfI'+target.form12+'4s'
-            out.packSub('CTDA','B3sfI'+target.form12+'4s',
+            out.packSub('CTDA','B3sfI'+target.form1234,
                 target.operFlag, target.unused1, target.compValue,
-                target.ifunc, target.param1, target.param2, target.unused2)
+                target.ifunc, target.param1, target.param2, target.param3, target.param4)
 
     def mapFids(self,record,function,save=False):
         """Applies function to fids. If save is true, then fid is set
         to result of function."""
         for target in record.conditions:
-            form12 = target.form12
-            if form12[0] == 'I':
+            form1234 = target.form1234
+            if form1234[0] == 'I':
                 result = function(target.param1)
                 if save: target.param1 = result
-            if form12[1] == 'I':
+            if form1234[1] == 'I':
                 result = function(target.param2)
                 if save: target.param2 = result
+            if len(form1234) > 2 and form1234[2] == 'I':
+                result = function(target.param3)
+                if save: target.param3 = result
+            if len(form1234) > 3 and form1234[3] == 'I':
+                result = function(target.param4)
+                if save: target.param4 = result
 
 #------------------------------------------------------------------------------
 class MelEffects(MelGroups):
@@ -1303,46 +1332,64 @@ class MelEffects(MelGroups):
 
     #--Class Data
     seFlags = Flags(0x0L,Flags.getNames('hostile'))
-    class MelEffectsScit(MelStruct):
-        """Subclass to support alternate format."""
-        def __init__(self):
-            MelStruct.__init__(self,'SCIT','II4sB3s',(FID,'script',None),('school',0),
-                ('visual','REHE'),(MelEffects.seFlags,'flags',0x0L),('unused1',null3))
-        def loadData(self,record,ins,type,size,readId):
-            #--Alternate formats
-            if size == 16:
-                attrs,actions = self.attrs,self.actions
-                unpacked = ins.unpack(self.format,size,readId)
-            elif size == 12:
-                attrs,actions = ('script','school','visual'),(0,0,0)
-                unpacked = ins.unpack('II4s',size,readId)
-                record.unused1 = null3
-            else: #--size == 4
-                #--The script fid for MS40TestSpell doesn't point to a valid script.
-                #--But it's not used, so... Not a problem! It's also t
-                record.unused1 = null3
-                attrs,actions = ('script',),(0,)
-                unpacked = ins.unpack('I',size,readId)
-                if unpacked[0] & 0xFF000000L:
-                    unpacked = (0L,) #--Discard bogus MS40TestSpell fid
-            #--Unpack
-            record.__slots__ = self.attrs
-            setter = record.__setattr__
-            for attr,value,action in zip(attrs,unpacked,actions):
-                if callable(action): value = action(value)
-                setter(attr,value)
-            if self._debug: print ' ',unpacked
+    # class MelEffectsScit(MelStruct):
+    #     """Subclass to support alternate format."""
+    #     def __init__(self):
+    #         MelStruct.__init__(self,'SCIT','II4sB3s',(FID,'script',None),('school',0),
+    #             ('visual','REHE'),(MelEffects.seFlags,'flags',0x0L),('unused1',null3))
+    #     def loadData(self,record,ins,type,size,readId):
+    #         #--Alternate formats
+    #         if size == 16:
+    #             attrs,actions = self.attrs,self.actions
+    #             unpacked = ins.unpack(self.format,size,readId)
+    #         elif size == 12:
+    #             attrs,actions = ('script','school','visual'),(0,0,0)
+    #             unpacked = ins.unpack('II4s',size,readId)
+    #             record.unused1 = null3
+    #         else: #--size == 4
+    #             #--The script fid for MS40TestSpell doesn't point to a valid script.
+    #             #--But it's not used, so... Not a problem! It's also t
+    #             record.unused1 = null3
+    #             attrs,actions = ('script',),(0,)
+    #             unpacked = ins.unpack('I',size,readId)
+    #             if unpacked[0] & 0xFF000000L:
+    #                 unpacked = (0L,) #--Discard bogus MS40TestSpell fid
+    #         #--Unpack
+    #         record.__slots__ = self.attrs
+    #         setter = record.__setattr__
+    #         for attr,value,action in zip(attrs,unpacked,actions):
+    #             if callable(action): value = action(value)
+    #             setter(attr,value)
+    #         if self._debug: print ' ',unpacked
 
     #--Instance methods
     def __init__(self,attr='effects'):
         """Initialize elements."""
         MelGroups.__init__(self,attr,
-            MelStruct('EFID','4s',('name','REHE')),
-            MelStruct('EFIT','4s4Ii',('name','REHE'),'magnitude','area','duration','recipient','actorValue'),
-            MelGroup('scriptEffect',
-                MelEffects.MelEffectsScit(),
-                MelString('FULL','full'),
-                ),
+            MelFid('EFID','baseEffect'),
+            MelStruct('EFIT','5i','magnitude','area','duration','recipient','actorValue'),
+            # MelGroup('scriptEffect',
+            #     MelEffects.MelEffectsScit(),
+            #     MelString('FULL','full'),
+            #     ),
+            MelConditions(),
+            )
+
+#------------------------------------------------------------------------------
+class MelDestructible(MelGroup):
+    """Represents a set of destruct record."""
+    def __init__(self,attr='destructible'):
+        """Initialize elements."""
+        MelGroup.__init__(self,attr,
+            MelBase('DEST','header'),
+            MelStruct('DEST','IhH','health','count','flags'),
+            MelGroups('stages',
+                      MelStruct('DSTD','=4B4I','health','index','damageStage','flags',
+                                'selfDamagePerSecond',(FID,'explosion',None),(FID,'debris',None),'debrisCount'),
+                      MelString('DMDL','model'),
+                      MelBase('DMDT','dmdt'), #--Should be a struct. Maybe later.
+                      MelBase('DSTF','footer'),
+                      ),
             )
 
 #------------------------------------------------------------------------------
@@ -1358,18 +1405,20 @@ class MelFull0(MelString):
 class MelModel(MelGroup):
     """Represents a model record."""
     typeSets = (
-        ('MODL','MODB','MODT'),
-        ('MOD2','MO2B','MO2T'),
-        ('MOD3','MO3B','MO3T'),
-        ('MOD4','MO4B','MO4T'),)
+        ('MODL','MODB','MODT','MODS','MODD'),
+        ('MOD2','MO2B','MO2T','MO2S','MO2D'),
+        ('MOD3','MO3B','MO3T','MO3S','MOSD'),
+        ('MOD4','MO4B','MO4T','MO4S','MO4D'),)
 
     def __init__(self,attr='model',index=0):
         """Initialize. Index is 0,2,3,4 for corresponding type id."""
         types = MelModel.typeSets[(0,index-1)[index>0]]
         MelGroup.__init__(self,attr,
             MelString(types[0],'modPath'),
-            MelStruct(types[1],'f','modb'), ### Bound Radius, Float
-            MelBase(types[2],'modt_p'),) ###Texture Files Hashes, Byte Array
+            MelBase(types[1],'modb_p'), ### Bound Radius, Float
+            MelBase(types[2],'modt_p'), ###Texture Files Hashes, Byte Array
+            MelAlternateTextures(types[3],'alternateTextures'),
+            MelBase(types[4],'modd_p'),)
 
     def debug(self,on=True):
         """Sets debug flag on self."""
@@ -1503,11 +1552,9 @@ class MelSet:
                 else:
                     loaders[type].loadData(record,ins,type,size,readId)
                 doFullTest = doFullTest and (type != 'EFID')
-            except Exception, error:
-                print error
-                eid = getattr(record,'eid',_('<<NO EID>>'))
-                if not eid: eid = _('<<NO EID>>)')
-                print _(Unicode('Error loading %s record and/or subrecord: %08X\n  eid = %s\n  subrecord = %s\n  subrecord size = %d') % (record.recType,record.fid,eid,type,size))
+            except:
+                eid = getattr(record,'eid','<<NO EID>>')
+                print 'Loading: %08X..%s..%s.%s..%d..' % (record.fid,eid,record.recType,type,size)
                 raise
         if _debug: print '<<<<',getattr(record,'eid','[NO EID]')
 
@@ -1559,10 +1606,61 @@ class MelBipedFlags(Flags):
     """Biped flags element. Includes biped flag set by default."""
     mask = 0xFFFF
     def __init__(self,default=0L,newNames=None):
-        names = Flags.getNames('head', 'hair', 'upperBody', 'lowerBody', 'hand', 'foot', 'rightRing', 'leftRing', 'amulet', 'weapon', 'backWeapon', 'sideWeapon', 'quiver', 'shield', 'torch', 'tail')
+        names = Flags.getNames(
+            'head', 'hair', 'upperBody', 'leftHand', 'rightHand', 'weapon',
+            'pipboy', 'backpack', 'necklace', 'headband', 'hat', 'eyeGlasses',
+            'noseRing', 'earrings', 'mask', 'choker', 'mouthObject',
+            'bodyAddOn1', 'bodyAddOn2', 'bodyAddOn3')
         if newNames: names.update(newNames)
         Flags.__init__(self,default,names)
 
+# Alternate textures
+#------------------------------------------------------------------------------
+class MelAlternateTextures(MelBase):
+    """Represents a set of alternate textures element."""
+    def __init__(self,type,attr,default=None):
+        """Initialize."""
+        MelBase.__init__(self,type,attr,default)
+        self._debug = False
+    def hasFids(self,formElements):
+        """Include self if has fids."""
+        formElements.add(self)
+    def loadData(self,record,ins,type,size,readId):
+        """Reads data from ins into record attribute."""
+        textures = []
+        numTextures, = struct.unpack('I',ins.read(4,readId))
+        for count in range(numTextures):
+            size, = struct.unpack('I',ins.read(4,readId))
+            name = ins.readString(size,readId)
+            fid = ins.unpackRef(readId)
+            index, = struct.unpack('I',ins.read(4,readId))
+            textures.append((name,fid,index))
+        record.__setattr__(self.attr,textures)
+        if self._debug: print ' ',record.__getattribute__(self.attr)
+    def dumpData(self,record,out):
+        """Dumps data from record to outstream."""
+        textures = record.__getattribute__(self.attr)
+        if not textures: return
+        data = ''
+        data += struct.pack('=I',len(textures))
+        for name,fid,index in textures:
+            data += struct.pack('=I',len(name))
+            data += name
+            data += struct.pack('=I',fid)
+            data += struct.pack('=I',index)
+        out.packSub(self.subType,data)
+    def mapFids(self,record,function,save=False):
+        """Applies function to fids. If save is true, then fid is set
+        to result of function."""
+        results = []
+        targets = record.__getattribute__(self.attr)
+        if not targets: return
+        for name,fid,index in targets:
+            result = function(fid)
+            results.append((name,result,index))
+        if save:
+            record.__setattr__(self.attr,results)
+
 # Mod Records 0 ---------------------------------------------------------------
 #------------------------------------------------------------------------------
 class MreSubrecord:
@@ -1628,13 +1726,13 @@ class MreRecord(object):
         (18,'compressed'),
         (19,'cantWait'),
         ))
-    __slots__ = ['recType','size','fid','flags2','flags1','changed','subrecords','data','inName','longFids',]
+    __slots__ = ['recType','size','fid','flags3','flags2','flags1','changed','subrecords','data','inName','longFids',]
     #--Set at end of class data definitions.
     type_class = None
     simpleTypes = None
 
     def __init__(self,header,ins=None,unpack=False):
-        (self.recType,self.size,flags1,self.fid,self.flags2) = header
+        (self.recType,self.size,flags1,self.fid,self.flags2,self.flags3) = header
         self.flags1 = MreRecord._flags1(flags1)
         self.longFids = False #--False: Short (numeric); True: Long (espname,objectindex)
         self.changed = False
@@ -1652,7 +1750,7 @@ class MreRecord(object):
 
     def getHeader(self):
         """Returns header tuple."""
-        return (self.recType,self.size,int(self.flags1),self.fid,self.flags2)
+        return (self.recType,self.size,int(self.flags1),self.fid,self.flags2,self.flags3)
 
     def getBaseCopy(self):
         """Returns an MreRecord version of self."""
@@ -1793,8 +1891,8 @@ class MreRecord(object):
         if self.changed: raise StateError(_('Data changed: ')+ self.recType)
         if not self.data and not self.flags1.deleted and self.size > 0:
             raise StateError(_('Data undefined: ')+self.recType+' '+hex(self.fid))
-        out.write(struct.pack('=4s4I',self.recType,self.size,int(self.flags1),self.fid,self.flags2))
-        if self.size > 0: out.write(Encode(self.data))
+        out.write(struct.pack('=4s5I',self.recType,self.size,int(self.flags1),self.fid,self.flags2,self.flags3))
+        if self.size > 0: out.write(Encode(self.data,'mbcs'))
 
     def getReader(self):
         """Returns a ModReader wrapped around (decompressed) self.data."""
@@ -1895,24 +1993,37 @@ class MreLeveledList(MelRecord):
                 record.flags.calcFromAllLevels = True
                 record.chanceNone &= 127
 
-    class MelLevListLvlo(MelStructs):
+    class MelLevListLvlo(MelStruct):
         """Subclass to support alternate format."""
         def loadData(self,record,ins,type,size,readId):
-            target = self.getDefault()
-            record.__getattribute__(self.attr).append(target)
-            target.__slots__ = self.attrs
-            format,attrs = ((self.format,self.attrs),('iI',('level','listId'),))[size==8]####might be h2sI
+            if size == 12:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 8:
+                format,attrs = ('iI',('level','listId'))####might be h2sI
+            else:
+                raise "Unexpected size encountered for LVLO subrecord: %s" % size
             unpacked = ins.unpack(format,size,readId)
-            setter = target.__setattr__
-            map(setter,attrs,unpacked)
+            setter = record.__setattr__
+            for attr,value,action in zip(attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
     #--Element Set
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelLevListLvld('LVLD','B','chanceNone'),
         MelStruct('LVLF','B',(_flags,'flags',0L)),
         MelFid('SCRI','script'),
         MelFid('TNAM','template'),
-        MelLevListLvlo('LVLO','h2sIh2s','entries','level',('unused1',null2),(FID,'listId',None),('count',1),('unused2',null2)),
+        MelFid('LVLG','glob'),
+        MelGroups('entries',
+                  MelLevListLvlo('LVLO','h2sIh2s','level',('unused1',null2),(FID,'listId',None),('count',1),('unused2',null2)),
+                  MelOptStruct('COED','IIf',(FID,'owner',None),(FID,'glob',None),('condition',1.0)),
+                  ),
         MelNull('DATA'),
         )
     __slots__ = (MelRecord.__slots__ + melSet.getSlotsUsed() +
@@ -1943,11 +2054,13 @@ class MreLeveledList(MelRecord):
             self.script = other.script
             self.template = other.template
             self.flags = other.flags()
+            self.glob = other.glob
         else:
             self.chanceNone = other.chanceNone or self.chanceNone
             self.script   = other.script or self.script
             self.template = other.template or self.template
             self.flags |= other.flags
+            self.glob = other.glob or self.glob
         #--Remove items based on other.removes
         if other.delevs or other.relevs:
             removeItems = self.items & (other.delevs | other.relevs)
@@ -1964,22 +2077,25 @@ class MreLeveledList(MelRecord):
                 newItemsAdd(entry.listId)
         if newItems:
             self.items |= newItems
-            self.entries.sort(key=attrgetter('listId','level','count'))
+            self.entries.sort(key=attrgetter('listId','level','count','owner','condition'))
         #--Is merged list different from other? (And thus written to patch.)
         if (self.chanceNone != other.chanceNone or
             self.script != other.script or
             self.template != other.template or
             #self.flags != other.flags or
+            self.glob != other.glob or
             len(self.entries) != len(other.entries)
             ):
             self.mergeOverLast = True
         else:
             otherlist = other.entries
-            otherlist.sort(key=attrgetter('listId','level','count'))
+            otherlist.sort(key=attrgetter('listId','level','count','owner','condition'))
             for selfEntry,otherEntry in zip(self.entries,otherlist):
                 if (selfEntry.listId != otherEntry.listId or
                     selfEntry.level != otherEntry.level or
-                    selfEntry.count != otherEntry.count):
+                    selfEntry.count != otherEntry.count or
+                    selfEntry.owner != otherEntry.owner or
+                    selfEntry.condition != otherEntry.condition):
                     self.mergeOverLast = True
                     break
             else:
@@ -2087,10 +2203,17 @@ class MreActi(MelRecord):
     classType = 'ACTI'
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
         MelFid('SCRI','script'),
-        MelFid('SNAM','sound'),
+        MelDestructible(),
+        MelFid('SNAM','soundLooping'),
+        MelFid('VNAM','soundActivation'),
+        MelFid('RNAM','radioStation'),
+        MelFid('WNAM','waterType'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2101,12 +2224,22 @@ class MreAlch(MelRecord,MreHasEffects):
     _flags = Flags(0L,Flags.getNames('autoCalc','isFood'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelFull0(),
         MelModel(),
-        MelString('ICON','iconPath'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelFid('SCRI','script'),
+        MelDestructible(),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
+        #--10:chems,11:stimpack,12:food,13:alcohol
+        MelStruct('ETYP','I','etype'),
         MelStruct('DATA','f','weight'),
-        MelStruct('ENIT','iB3s','value',(_flags,'flags',0L),('unused1',null3)),
+        MelStruct('ENIT','iB3sIfI','value',(_flags,'flags',0L),('unused1',null3),
+                  (FID,'withdrawalEffect',None),'addictionChance',(FID,'soundConsume',None)),
         MelEffects(),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -2118,12 +2251,18 @@ class MreAmmo(MelRecord):
     _flags = Flags(0L,Flags.getNames('notNormalWeapon'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
-        MelString('ICON','iconPath'),
-        MelFid('ENAM','enchantment'),
-        MelOptStruct('ANAM','H','enchantPoints'),
-        MelStruct('DATA','fB3sIfH','speed',(_flags,'flags',0L),('unused1',null3),'value','weight','damage'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
+        MelDestructible(),
+        MelFid('YNAM','soundPickup'),
+        MelFid('ZNAM','soundDrop'),
+        MelStruct('DATA','fB3sIB','speed',(_flags,'flags',0L),('unused1',null3),'value','clipRounds'),
+        MelString('ONAM','shortName'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2156,21 +2295,42 @@ class MreAppa(MelRecord):
 class MreArmo(MelRecord):
     """Armor record."""
     classType = 'ARMO'
-    _flags = MelBipedFlags(0L,Flags.getNames((16,'hideRings'),(17,'hideAmulet'),(22,'notPlayable'),(23,'heavyArmor')))
+    _flags = MelBipedFlags(0L,Flags.getNames())
+    _generalFlags = Flags(0L,Flags.getNames(
+        (5,'powerArmor'),
+        (6,'notPlayable'),
+        (7,'heavyArmor')
+    ))
+    _etype = Flags(0L,Flags.getNames(
+        'alcohol','bigGuns','bodyWear','chems','energyWeapons','food','handWear','headWear',
+        'meleeWeapons','mine','none','smallGuns','stimpack','thrownWeapons','unarmedWeapon'
+    ))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelFid('SCRI','script'),
-        MelFid('ENAM','enchantment'),
-        MelOptStruct('ANAM','H','enchantPoints'),
-        MelStruct('BMDT','I',(_flags,'flags',0L)),
-        MelModel('maleBody',0),
+        MelFid('EITM','objectEffect'),
+        MelStruct('BMDT','=2I',(_flags,'bipedFlags',0L),(_generalFlags,'generalFlags',0L)),
+        MelModel('maleBody'),
         MelModel('maleWorld',2),
-        MelString('ICON','maleIconPath'),
+        MelString('ICON','maleLargeIconPath'),
+        MelString('MICO','maleSmallIconPath'),
         MelModel('femaleBody',3),
         MelModel('femaleWorld',4),
-        MelString('ICO2','femaleIconPath'),
-        MelStruct('DATA','=HIIf','strength','value','health','weight'),
+        MelString('ICO2','femaleLargeIconPath'),
+        MelString('MIC2','femaleSmallIconPath'),
+        MelString('BMCT','ragdollConstraintTemplate'),
+        MelDestructible(),
+        MelFid('REPL','repairList'),
+        MelFid('BIPL','bipedModelList'),
+        MelStruct('ETYP','I',(_etype,'etype',0L)),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
+        MelStruct('DATA','=IIf','value','health','weight'),
+        MelStruct('DNAM','=HH','ar','flags'), # AR is multiplied by 100.
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2181,13 +2341,16 @@ class MreBook(MelRecord):
     _flags = Flags(0,Flags.getNames('isScroll','isFixed'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
-        MelString('ICON','iconPath'),
-        MelString('DESC','text'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelFid('SCRI','script'),
-        MelFid('ENAM','enchantment'),
-        MelOptStruct('ANAM','H','enchantPoints'),
+        MelString('DESC','text'),
+        MelDestructible(),
         MelStruct('DATA', '=BbIf',(_flags,'flags',0L),('teaches',-1),'value','weight'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed() + ['modb']
@@ -2211,29 +2374,70 @@ class MreCell(MelRecord):
     classType = 'CELL'
     cellFlags = Flags(0L,Flags.getNames((0, 'isInterior'),(1,'hasWater'),(2,'invertFastTravel'),
         (3,'forceHideLand'),(5,'publicPlace'),(6,'handChanged'),(7,'behaveLikeExterior')))
+    inheritFlags = Flags(0L,Flags.getNames('ambientColor','directionalColor','fogColor','fogNear','fogFar',
+        'directionalRotation','directionalFade','clipDistance','fogPower'))
     class MelCoordinates(MelOptStruct):
+        """Handle older trucated XCLC for CELL subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 12:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 8:
+                unpacked = ins.unpack('ii',size,readId)
+            else:
+                raise "Unexpected size encountered for XCLC subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked, record.flags.getTrueAttrs()
         def dumpData(self,record,out):
             if not record.flags.isInterior:
                 MelOptStruct.dumpData(self,record,out)
-
+    class MelCellXcll(MelOptStruct):
+        """Handle older trucated XCLL for CELL subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 40:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 36:
+                unpacked = ins.unpack('=3Bs3Bs3Bs2f2i2f',size,readId)
+            else:
+                raise "Unexpected size encountered for XCLL subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked, record.flags.getTrueAttrs()
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
         MelStruct('DATA','B',(cellFlags,'flags',0L)),
-        MelOptStruct('XCLL','=3Bs3Bs3Bs2f2i2f','ambientRed','ambientGreen','ambientBlue',
+        MelCoordinates('XCLC','iiI',('posX',None),('posY',None),('forceHideLand',0L)),
+        MelCellXcll('XCLL','=3Bs3Bs3Bs2f2i3f','ambientRed','ambientGreen','ambientBlue',
             ('unused1',null1),'directionalRed','directionalGreen','directionalBlue',
             ('unused2',null1),'fogRed','fogGreen','fogBlue',
             ('unused3',null1),'fogNear','fogFar','directionalXY','directionalZ',
-            'directionalFade','fogClip'),
-        MelOptStruct('XCMT','B','music'),
-        MelOwnership(),
-        MelFid('XCCM','climate'),
+            'directionalFade','fogClip','fogPower'),
+        MelBase('IMPF','footstepMaterials'), #--todo rewrite specific class.
+        MelFid('LTMP','lightTemplate'),
+        MelOptStruct('LNAM','I',(inheritFlags,'lightInheritFlags',0L)),
         #--CS default for water is -2147483648, but by setting default here to -2147483649,
         #  we force the bashed patch to retain the value of the last mod.
         MelOptStruct('XCLW','f',('waterHeight',-2147483649)),
+        MelString('XNAM','waterNoiseTexture'),
         MelFidList('XCLR','regions'),
-        MelCoordinates('XCLC','ii',('posX',None),('posY',None)),
+        MelOptStruct('XCMT','B','xcmt_p'),
+        MelFid('XCIM','imageSpace'),
+        MelOptStruct('XCET','B','xcet_p'),
+        MelFid('XEZN','encounterZone'),
+        MelFid('XCCM','climate'),
         MelFid('XCWT','water'),
+        MelOwnership(),
+        MelFid('XCAS','acousticSpace'),
+        MelFid('XCMO','music'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2250,36 +2454,51 @@ class MreClas(MelRecord):
         (1,'armor'),
         (2,'clothing'),
         (3,'books'),
-        (4,'ingredients'),
+        (4,'foods'),
+        (5,'chems'),
+        (6,'stimpacks'),
         (7,'lights'),
-        (8,'apparatus'),
         (10,'miscItems'),
-        (11,'spells'),
-        (12,'magicItems'),
         (13,'potions'),
         (14,'training'),
         (16,'recharge'),
         (17,'repair'),))
+    aiTeaches = Flags(0L,Flags.getNames(
+        (0,'barter'),
+        (1,'bigGuns'),
+        (2,'energyWeapons'),
+        (3,'explosives'),
+        (4,'lockpick'),
+        (5,'medicine'),
+        (6,'meleeWeapons'),
+        (7,'none'),
+        (8,'repair'),
+        (9,'science'),
+        (10,'smallGuns'),
+        (11,'sneak'),
+        (12,'throwing'),
+        (13,'unarmed'),))
     class MelClasData(MelStruct):
         """Handle older trucated DATA for CLAS subrecords."""
-        def loadData(self,record,ins,type,size,readId):
-            if size == 52:
-                MelStruct.loadData(self,record,ins,type,size,readId)
-                return
-            #--Else 42 byte record (skips trainSkill, trainLevel,unused1...
-            unpacked = ins.unpack('2iI7i2I',size,readId)
-            unpacked += self.defaults[len(unpacked):]
-            setter = record.__setattr__
-            for attr,value,action in zip(self.attrs,unpacked,self.actions):
-                if callable(action): value = action(value)
-                setter(attr,value)
-            if self._debug: print unpacked, record.flags.getTrueAttrs()
+    #     def loadData(self,record,ins,type,size,readId):
+    #         if size == 52:
+    #             MelStruct.loadData(self,record,ins,type,size,readId)
+    #             return
+    #         #--Else 42 byte record (skips trainSkill, trainLevel,unused1...
+    #         unpacked = ins.unpack('2iI7i2I',size,readId)
+    #         unpacked += self.defaults[len(unpacked):]
+    #         setter = record.__setattr__
+    #         for attr,value,action in zip(self.attrs,unpacked,self.actions):
+    #             if callable(action): value = action(value)
+    #             setter(attr,value)
+    #         if self._debug: print unpacked, record.flags.getTrueAttrs()
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
         MelString('DESC','description'),
         MelString('ICON','iconPath'),
-        MelClasData('DATA','2iI7i2IbB2s','primary1','primary2','specialization','major1','major2','major3','major4','major5','major6','major7',(_flags,'flags',0L),(aiService,'services',0L),('trainSkill',0),('trainLevel',0),('unused1',null2)),
+        MelClasData('DATA','4I2IbB2s','tagSkill1','tagSkill2','tagSkill3','tagSkill4',(_flags,'flags',0L),(aiService,'services',0L),('trainSkill',0),('trainLevel',0),('unused1',null2)),
+        MelTuple('ATTR','7B','attributes',[0]*7),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2289,7 +2508,7 @@ class MreClmt(MelRecord):
     classType = 'CLMT'
     melSet = MelSet(
         MelString('EDID','eid'),
-        MelStructA('WLST','Ii', 'Weather', (FID,'weather'), 'chance'),
+        MelStructA('WLST','IiI', 'Weather', (FID,'weather'), 'chance', (FID,'global')),
         MelString('FNAM','sunPath'),
         MelString('GNAM','glarePath'),
         MelModel(),
@@ -2325,10 +2544,17 @@ class MreCont(MelRecord):
     _flags = Flags(0,Flags.getNames(None,'respawns'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
         MelFid('SCRI','script'),
-        MelStructs('CNTO','Ii','items',(FID,'item'),'count'),
+        MelGroups('items',
+            MelStruct('CNTO','Ii',(FID,'item',None),('count',1)),
+            MelOptStruct('COED','IIf',(FID,'owner',None),(FID,'glob',None),('condition',1.0)),
+        ),
+        MelDestructible(),
         MelStruct('DATA','=Bf',(_flags,'flags',0L),'weight'),
         MelFid('SNAM','soundOpen'),
         MelFid('QNAM','soundClose'),
@@ -2357,62 +2583,99 @@ class MreCrea(MreActor):
         (17,'noLeftArm'),
         (18,'noCombatInWater'),
         (19,'noShadow'),
-        (20,'noCorpseCheck'),
-        ))
-#    #--AI Service flags
+        (20,'noVATSMelee'),
+        (21,'allowPCDialogue'),
+        (22,'cantOpenDoors'),
+        (23,'immobile'),
+        (24,'tiltFrontBack'),
+        (25,'tiltLeftRight'),
+        (26,'noKnockDown'),
+        (27,'notPushable'),
+        (28,'allowPickpocket'),
+        (29,'isGhost'),
+        (30,'noRotatingHeadTrack'),
+        (31,'invulnerable'),))
+    #--AI Service flags
     aiService = Flags(0L,Flags.getNames(
         (0,'weapons'),
         (1,'armor'),
         (2,'clothing'),
         (3,'books'),
-        (4,'ingredients'),
+        (4,'foods'),
+        (5,'chems'),
+        (6,'stimpacks'),
         (7,'lights'),
-        (8,'apparatus'),
         (10,'miscItems'),
-        (11,'spells'),
-        (12,'magicItems'),
         (13,'potions'),
         (14,'training'),
         (16,'recharge'),
         (17,'repair'),))
+    aiTrainSkill = Flags(0L,Flags.getNames(
+        (0,'barter'),
+        (1,'bigGuns'),
+        (2,'energyWeapons'),
+        (3,'explosives'),
+        (4,'lockpick'),
+        (5,'medicine'),
+        (6,'meleeWeapons'),
+        (7,'none'),
+        (8,'repair'),
+        (9,'science'),
+        (10,'smallGuns'),
+        (11,'sneak'),
+        (12,'throwing'),
+        (13,'unarmed'),))
     #--Mel Set
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
         MelFids('SPLO','spells'),
+        MelFid('EITM','effect'),
+        MelStruct('EAMT','H', 'eamt'),
         MelStrings('NIFZ','bodyParts'),
         MelBase('NIFT','nift_p'), ###Texture File hashes, Byte Array
-        MelStruct('ACBS','=I3Hh2H',
-            (_flags,'flags',0L),'baseSpell','fatigue','barterGold',
-            ('level',1),'calcMin','calcMax'),
+        MelStruct('ACBS','=I2Hh3Hf2H',
+            (_flags,'flags',0L),'fatigue','barterGold',
+            ('level',1),'calcMin','calcMax','speedMultiplier','karma','dispotionBase','templateFlags'),
         MelStructs('SNAM','=IB3s','factions',
             (FID,'faction',None),'rank',('unused1','IFZ')),
         MelFid('INAM','deathItem'),
+        MelFid('VTCK','voice'),
+        MelFid('TPLT','template'),
+        MelDestructible(),
         MelFid('SCRI','script'),
-        MelStructs('CNTO','Ii','items',(FID,'item',None),('count',1)),
-        MelStruct('AIDT','=4BIbB2s',
-            ('aggression',5),('confidence',50),('energyLevel',50),('responsibility',50),
-            (aiService,'services',0L),'trainSkill','trainLevel',('unused1',null2)),
+        MelGroups('items',
+            MelStruct('CNTO','Ii',(FID,'item',None),('count',1)),
+            MelOptStruct('COED','IIf',(FID,'owner',None),(FID,'glob',None),('condition',1.0)),
+        ),
+        MelStruct('AIDT','=5B2I3Bi',
+            ('aggression',5),('confidence',50),('energyLevel',50),('responsibility',50),('mood',0L),
+            (aiService,'services',0L),(aiTrainSkill,'trainSkill',0L),'trainLevel','assistance',
+            'aggroRadiusBehavior','aggroRadius'),
         MelFids('PKID','aiPackages'),
         MelStrings('KFFZ','animations'),
-        MelStruct('DATA','=5BsH2sH8B','creatureType','combat','magic','stealth',
-                  'soul',('unused2',null1),'health',('unused3',null2),'attackDamage','strength',
-                  'intelligence','willpower','agility','speed','endurance',
-                  'personality','luck'),
+        MelStruct('DATA','=4BIH7B','type','combatSkill','magicSkill','StealthSkill',
+            'health','damage','strength','perception','endurance','charisma','intelligence','agility','luck'),
         MelStruct('RNAM','B','attackReach'),
         MelFid('ZNAM','combatStyle'),
+        MelFid('PNAM','bodyPartData'),
         MelStruct('TNAM','f','turningSpeed'),
         MelStruct('BNAM','f','baseScale'),
         MelStruct('WNAM','f','footWeight'),
         MelFid('CSCR','inheritsSoundsFrom'),
-        MelString('NAM0','bloodSprayPath'),
-        MelString('NAM1','bloodDecalPath'),
+        MelStruct('NAM4','I',('impactMaterialType',0L)),
+        MelStruct('NAM5','I',('soundLevel',0L)),
         MelGroups('sounds',
             MelStruct('CSDT','I','type'),
             MelFid('CSDI','sound'),
             MelStruct('CSDC','B','chance'),
         ),
+        MelFid('CNAM','impactDataset'),
+        MelFid('LNAM','meleeWeaponList'),
         )
     __slots__ = MreActor.__slots__ + melSet.getSlotsUsed()
 
@@ -2487,6 +2750,10 @@ class MreCsty(MelRecord):
                      'dodgeFAtkMult', 'dodgeFNAtkMult', 'blockMult', 'blockBase',
                      'blockAtkMult', 'blockNAtkMult', 'atkMult','atkBase', 'atkAtkMult',
                      'atkNAtkMult', 'atkBlockMult', 'pAtkFBase', 'pAtkFMult'),
+        MelOptStruct('CSSD', '9fII5f', 'coverSearchRadius', 'takeCoverChance', 'waitTimerMin', 'waitTimerMax',
+                     'waitToFireTimerMin', 'waitToFireTimerMax', 'fireTimerMin', 'fireTimerMax'
+                     'rangedWeaponRangeMultMin','weaponRestrictions','unknown1','rangedWeaponRangeMultMax',
+                     'maxTargetingFov','combatRadius','semiAutomaticFireDelayMultMin','semiAutomaticFireDelayMultMax'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 #------------------------------------------------------------------------------
@@ -2499,12 +2766,13 @@ class MreDial(MelRecord):
         MelString('FULL','full'),
         MelStruct('DATA','B','dialType'),
     )
-    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed() + ['infoStamp','infos']
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed() + ['infoStamp','infoStamp2','infos']
 
     def __init__(self,header,ins=None,unpack=False):
         """Initialize."""
         MelRecord.__init__(self,header,ins,unpack)
         self.infoStamp = 0 #--Stamp for info GRUP
+        self.infoStamp2 = 0 #--Stamp for info GRUP
         self.infos = []
 
     def loadInfos(self,ins,endPos,infoClass):
@@ -2528,7 +2796,7 @@ class MreDial(MelRecord):
         MreRecord.dump(self,out)
         if not self.infos: return
         size = 20 + sum([20 + info.getSize() for info in self.infos])
-        out.pack('4sIIII','GRUP',size,self.fid,7,self.infoStamp)
+        out.pack('4sIIIII','GRUP',size,self.fid,7,self.infoStamp,self.infoStamp2)
         for info in self.infos: info.dump(out)
 
     def updateMasters(self,masters):
@@ -2551,14 +2819,18 @@ class MreDoor(MelRecord):
     _flags = Flags(0,Flags.getNames('oblivionGate','automatic','hidden','minimalUse'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
         MelFid('SCRI','script'),
+        MelDestructible(),
         MelFid('SNAM','soundOpen'),
         MelFid('ANAM','soundClose'),
         MelFid('BNAM','soundLoop'),
         MelStruct('FNAM','B',(_flags,'flags',0L)),
-        MelFids('TNAM','destinations'),
+        #MelFids('TNAM','destinations'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -2576,15 +2848,21 @@ class MreEfsh(MelRecord):
     class MelEfshData(MelStruct):
         """Handle older trucated DATA for EFSH subrecord."""
         def loadData(self,record,ins,type,size,readId):
-            if size == 224:
+            if size == 308:
                 MelStruct.loadData(self,record,ins,type,size,readId)
                 return
-            elif size == 96:
-                #--Else 96 byte record (skips particle variables, and color keys
-                # Only used twice in test shaders (0004b6d5, 0004b6d6)
-                unpacked = ins.unpack('B3s3I3Bs9f3Bs8fI',size,readId)
+            elif size == 300:
+                unpacked = ins.unpack('B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f5fI5f3BsfII4f',size,readId)
+            elif size == 284:
+                unpacked = ins.unpack('B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f5fI5f3BsfII',size,readId)
+            elif size == 248:
+                unpacked = ins.unpack('B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f5fI',size,readId)
+            elif size == 244:
+                unpacked = ins.unpack('B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f5f',size,readId)
+            elif size == 224:
+                unpacked = ins.unpack('B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f',size,readId)
             else:
-                raise ModError(ins.inName,_('Unexpected size encountered for EFSH subrecord: ')+str(size))
+                raise "Unexpected size encountered for EFSH subrecord: %s" % size
             unpacked += self.defaults[len(unpacked):]
             setter = record.__setattr__
             for attr,value,action in zip(self.attrs,unpacked,self.actions):
@@ -2595,27 +2873,36 @@ class MreEfsh(MelRecord):
         MelString('EDID','eid'),
         MelString('ICON','fillTexture'),
         MelString('ICO2','particleTexture'),
-        MelEfshData('DATA','B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f',(_flags,'flags'),('unused1',null3),'memSBlend',
-                    'memBlendOp','memZFunc','fillRed','fillGreen','fillBlue',('unused2',null1),
-                    'fillAIn','fillAFull','fillAOut','fillAPRatio','fillAAmp',
-                    'fillAFreq','fillAnimSpdU','fillAnimSpdV','edgeOff','edgeRed',
-                    'edgeGreen','edgeBlue',('unused3',null1),'edgeAIn','edgeAFull',
-                    'edgeAOut','edgeAPRatio','edgeAAmp','edgeAFreq','fillAFRatio',
-                    'edgeAFRatio','memDBlend',('partSBlend',5),('partBlendOp',1),
-                    ('partZFunc',4),('partDBlend',6),('partBUp',0.0),('partBFull',0.0),('partBDown',0.0),
-                    ('partBFRatio',1.0),('partBPRatio',1.0),('partLTime',1.0),('partLDelta',0.0),('partNSpd',0.0),
-                    ('partNAcc',0.0),('partVel1',0.0),('partVel2',0.0),('partVel3',0.0),('partAcc1',0.0),
-                    ('partAcc2',0.0),('partAcc3',0.0),('partKey1',1.0),('partKey2',1.0),('partKey1Time',0.0),
-                    ('partKey2Time',1.0),('key1Red',255),('key1Green',255),('key1Blue',255),('unused4',null1),
-                    ('key2Red',255),('key2Green',255),('key2Blue',255),('unused5',null1),('key3Red',255),('key3Green',255),
-                    ('key3Blue',255),('unused6',null1),('key1A',1.0),('key2A',1.0),('key3A',1.0),('key1Time',0.0),
-                    ('key2Time',0.5),('key3Time',1.0)),
+        MelString('NAM7','holesTexture'),
+        MelEfshData('DATA','B3s3I3Bs9f3Bs8f5I19f3Bs3Bs3Bs6f5fI5f3BsfII6f',(_flags,'flags'),('unused1',null3),'memSBlend',
+            'memBlendOp','memZFunc','fillRed','fillGreen','fillBlue',('unused2',null1),
+            'fillAIn','fillAFull','fillAOut','fillAPRatio','fillAAmp',
+            'fillAFreq','fillAnimSpdU','fillAnimSpdV','edgeOff','edgeRed',
+            'edgeGreen','edgeBlue',('unused3',null1),'edgeAIn','edgeAFull',
+            'edgeAOut','edgeAPRatio','edgeAAmp','edgeAFreq','fillAFRatio',
+            'edgeAFRatio','memDBlend',('partSBlend',5),('partBlendOp',1),
+            ('partZFunc',4),('partDBlend',6),('partBUp',0.0),('partBFull',0.0),('partBDown',0.0),
+            ('partBFRatio',1.0),('partBPRatio',1.0),('partLTime',1.0),('partLDelta',0.0),('partNSpd',0.0),
+            ('partNAcc',0.0),('partVel1',0.0),('partVel2',0.0),('partVel3',0.0),('partAcc1',0.0),
+            ('partAcc2',0.0),('partAcc3',0.0),('partKey1',1.0),('partKey2',1.0),('partKey1Time',0.0),
+            ('partKey2Time',1.0),('key1Red',255),('key1Green',255),('key1Blue',255),('unused4',null1),
+            ('key2Red',255),('key2Green',255),('key2Blue',255),('unused5',null1),('key3Red',255),('key3Green',255),
+            ('key3Blue',255),('unused6',null1),('key1A',1.0),('key2A',1.0),('key3A',1.0),('key1Time',0.0),
+            ('key2Time',0.5),('key3Time',1.0),
+            ('partNSpdDelta',0.00000),('partRot',0.00000),('partRotDelta',0.00000),('partRotSpeed',0.00000),('partRotSpeedDelta',0.00000),
+            (FID,'addonModels',None),('holesStartTime',0.00000),('holesEndTime',0.00000),('holesStartVal',0.00000),('holesEndVal',0.00000),
+            ('edgeWidth',0.00000),('edgeRed',255),('edgeGreen',255),('edgeBlue',255),('unused7',null1),
+            ('explosionWindSpeed',0.00000),('textureCountU',1),('textureCountV',1),
+            ('addonModelsFadeInTime',1.00000),('addonModelsFadeOutTime',1.00000),
+            ('addonModelsScaleStart',1.00000),('addonModelsScaleEnd',1.00000),
+            ('addonModelsScaleInTime',1.00000),('addonModelsScaleOutTime',1.00000),
+            ),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
 #------------------------------------------------------------------------------
 class MreEnch(MelRecord,MreHasEffects):
-    """Enchantment record."""
+    """Enchantment (Object Effect) record."""
     classType = 'ENCH'
     _flags = Flags(0L,Flags.getNames('noAutoCalc'))
     melSet = MelSet(
@@ -2645,11 +2932,33 @@ class MreFact(MelRecord):
     """Faction record."""
     classType = 'FACT'
     _flags = Flags(0L,Flags.getNames('hiddenFromPC','evil','specialCombat'))
+
+    class MelFactData(MelStruct):
+        """Handle older trucated DATA for FACT subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 4:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 2:
+                #--Else 2 byte record
+                unpacked = ins.unpack('2B',size,readId)
+            elif size == 1:
+                #--Else 1 byte record
+                unpacked = ins.unpack('B',size,readId)
+            else:
+                raise "Unexpected size encountered for FACT:DATA subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
-        MelStructs('XNAM','Ii','relations',(FID,'faction'),'mod'),
-        MelStruct('DATA','B',(_flags,'flags',0L)),
+        MelStructs('XNAM','I2i','relations',(FID,'faction'),'mod','groupCombatReaction'),
+        MelFactData('DATA','2BH',(_flags,'flags',0L),'flags2','unknown'),
         MelOptStruct('CNAM','f',('crimeGoldMultiplier',None)),
         MelGroups('ranks',
             MelStruct('RNAM','i','rank'),
@@ -2681,9 +2990,13 @@ class MreFurn(MelRecord):
     #--E.g., whether it's a bed, and which of the bed entry/exit animations are available
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
         MelFid('SCRI','script'),
+        MelDestructible(),
         MelStruct('MNAM','I',(_flags,'activeMarkers',0L)), ####ByteArray
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -2704,7 +3017,7 @@ class MreGlob(MelRecord):
 #------------------------------------------------------------------------------
 class MreGmst(MelRecord):
     """Gmst record"""
-    oblivionIds = None
+    falloutIds = None
     classType = 'GMST'
     class MelGmstValue(MelBase):
         def loadData(self,record,ins,type,size,readId):
@@ -2726,25 +3039,25 @@ class MreGmst(MelRecord):
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
     def getGMSTFid(self):
-        """Returns Oblivion.esm fid in long format for specified eid."""
+        """Returns Fallout3.esm fid in long format for specified eid."""
         myClass = self.__class__
-        if not myClass.oblivionIds:
+        if not myClass.falloutIds:
             try:
-                myClass.oblivionIds = cPickle.load(dirs['db'].join('Oblivion_ids.pkl').open())['GMST']
+                myClass.falloutIds = cPickle.load(dirs['db'].join('Fallout3_ids.pkl').open())['GMST']
             except:
                 old = bolt.deprintOn
                 bolt.deprintOn = True
                 print
-                print 'Error loading Oblivion_ids.pkl:'
+                print 'Error loading Fallout3_ids.pkl:'
                 deprint(' ',traceback=True)
                 bolt.deprintOn = old
                 print
-                print 'Manually testing if file exists:', dirs['db'].join('Oblivion_ids.pkl').exists()
+                print 'Manually testing if file exists:', dirs['db'].join('Fallout3_ids.pkl').exists()
                 print 'Current working directory:', os.getcwd()
                 print "dirs['db']:", dirs['db']
                 print
                 raise
-        return (modInfos.masterName, myClass.oblivionIds[self.eid])
+        return (modInfos.masterName, myClass.falloutIds[self.eid])
 
 #------------------------------------------------------------------------------
 class MreGras(MelRecord):
@@ -2753,6 +3066,9 @@ class MreGras(MelRecord):
     _flags = Flags(0,Flags.getNames('vLighting','uScaling','fitSlope'))
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelModel(),
         MelStruct('DATA','3BsH2sI4fB3s','density','minSlope',
                   'maxSlope',('unused1',null1),'waterDistance',('unused2',null2),
@@ -2778,12 +3094,30 @@ class MreHair(MelRecord):
 class MreIdle(MelRecord):
     """Idle record."""
     classType = 'IDLE'
+    #--Mel IDLE DATA
+    class MelIdleData(MelStruct):
+        """Handle older trucated DATA for IDLE subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 8:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 6:
+                #--Else 6 byte record (skips flags and unknown2...
+                unpacked = ins.unpack('4BH',size,readId)
+            else:
+                raise "Unexpected size encountered for IDLE:DATA subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked, record.flags.getTrueAttrs()
     melSet = MelSet(
         MelString('EDID','eid'),
         MelModel(),
         MelConditions(),
-        MelStruct('ANAM','B','group'),
-        MelStruct('DATA','II',(FID,'parent'),(FID,'prevId')),####Array?
+        MelStruct('ANAM','II',(FID,'parent'),(FID,'prevId')),
+        MelIdleData('DATA','4BH2B','group','loopMin','loopMax','unknown1','delay','flags','unknown2'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 #------------------------------------------------------------------------------
@@ -2791,14 +3125,14 @@ class MreInfo(MelRecord):
     """Info (dialog entry) record."""
     classType = 'INFO'
     _flags = Flags(0,Flags.getNames(
-        'goodbye','random','sayOnce','runImmediately','infoRefusal','randomEnd','runForRumors'))
+        'goodbye','random','sayOnce','runImmediately','infoRefusal','randomEnd','runForRumors','sayOnceADay','alwaysDarken'))
     class MelInfoData(MelStruct):
-        """Support truncated 2 byte version."""
+        """Support older 2 byte version."""
         def loadData(self,record,ins,type,size,readId):
             if size != 2:
                 MelStruct.loadData(self,record,ins,type,size,readId)
                 return
-            unpacked = ins.unpack('H',size,readId)
+            unpacked = ins.unpack('2B',size,readId)
             unpacked += self.defaults[len(unpacked):]
             setter = record.__setattr__
             for attr,value,action in zip(self.attrs,unpacked,self.actions):
@@ -2813,7 +3147,7 @@ class MreInfo(MelRecord):
                 MelStruct.dumpData(self,record,out)
     #--MelSet
     melSet = MelSet(
-        MelInfoData('DATA','HB','dialType',(_flags,'flags')),
+        MelInfoData('DATA','HH','dialType',(_flags,'flags')),
         MelFid('QSTI','quests'),
         MelFid('TPIC','topic'),
         MelFid('PNAM','prevInfo'),
@@ -2827,7 +3161,7 @@ class MreInfo(MelRecord):
         MelFids('TCLT','choices'),
         MelFids('TCLF','linksFrom'),
         MelBase('SCHD','schd_p'), #--Old format script header?
-        MelInfoSchr('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+        MelInfoSchr('SCHR','4s4I',('unused2',null4),'numRefs','compiledSize','lastIndex','scriptType'),
         MelBase('SCDA','compiled_p'),
         MelString('SCTX','scriptText'),
         MelScrxen('SCRV/SCRO','references')
@@ -2839,12 +3173,17 @@ class MreIngr(MelRecord,MreHasEffects):
     """INGR (ingredient) record."""
     classType = 'INGR'
     _flags = Flags(0L,Flags.getNames('noAutoCalc','isFood'))
+    _etype = Flags(0L,Flags.getNames(
+        'alcohol','bigGuns','bodyWear','chems','energyWeapons','food','handWear','headWear',
+        'meleeWeapons','mine','none','smallGuns','stimpack','thrownWeapons','unarmedWeapon'
+    ))
     melSet = MelSet(
         MelString('EDID','eid'),
         MelFull0(),
         MelModel(),
         MelString('ICON','iconPath'),
         MelFid('SCRI','script'),
+        MelStruct('ETYP','I',(_etype,'etype',0L)),
         MelStruct('DATA','f','weight'),
         MelStruct('ENIT','iB3s','value',(_flags,'flags',0L),('unused1',null3)),
         MelEffects(),
@@ -2857,10 +3196,17 @@ class MreKeym(MelRecord):
     classType = 'KEYM'
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
-        MelString('ICON','iconPath'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelFid('SCRI','script'),
+        MelDestructible(),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
         MelStruct('DATA','if','value','weight'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -2913,6 +3259,9 @@ class MreLigh(MelRecord):
             if self._debug: print unpacked, record.flags.getTrueAttrs()
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelModel(),
         MelFid('SCRI','script'),
         MelString('FULL','full'),
@@ -2959,6 +3308,7 @@ class MreLtex(MelRecord):
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('ICON','iconPath'),
+        MelFid('TNAM', 'texture'),
         MelOptStruct('HNAM','3B',(_flags,'flags'),'friction','restitution'), ####flags are actually an enum....
         MelOptStruct('SNAM','B','specular'),
         MelFids('GNAM', 'grass'),
@@ -2984,6 +3334,12 @@ class MreLvsp(MreLeveledList):
     __slots__ = MreLeveledList.__slots__
 
 #------------------------------------------------------------------------------
+class MreLvln(MreLeveledList):
+    """LVLN record. Leveled list for NPC."""
+    classType = 'LVLN'
+    __slots__ = MreLeveledList.__slots__
+
+#------------------------------------------------------------------------------
 class MreMgef(MelRecord):
     """MGEF (magic effect) record."""
     classType = 'MGEF'
@@ -3017,7 +3373,7 @@ class MreMgef(MelRecord):
     class MelMgefData(MelStruct):
         """Handle older trucated DATA for DARK subrecord."""
         def loadData(self,record,ins,type,size,readId):
-            if size == 64:
+            if size == 72:
                 MelStruct.loadData(self,record,ins,type,size,readId)
                 return
             elif size == 36:
@@ -3037,11 +3393,11 @@ class MreMgef(MelRecord):
         MelString('DESC','text'),
         MelString('ICON','iconPath'),
         MelModel(),
-        MelMgefData('DATA','IfIiiH2sIf6I2f',
-            (_flags,'flags'),'baseCost',(FID,'associated'),'school','resistValue','numCounters',
-            ('unused1',null2),(FID,'light'),'projectileSpeed',(FID,'effectShader'),(FID,'enchantEffect',0),
+        MelMgefData('DATA','IfIiiIIf6I2fII',
+            (_flags,'flags'),'baseCost',(FID,'associated'),'school','resistValue','unk1',
+            (FID,'light',0),'projectileSpeed',(FID,'effectShader',0),(FID,'objectDisplayShader',0),
             (FID,'castingSound',0),(FID,'boltSound',0),(FID,'hitSound',0),(FID,'areaSound',0),
-            ('cefEnchantment',0.0),('cefBarter',0.0)),
+            ('cefEnchantment',0.0),('cefBarter',0.0),'archType','actorValue'),
         MelStructA('ESCE','4s','counterEffects','effect'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3052,10 +3408,17 @@ class MreMisc(MelRecord):
     classType = 'MISC'
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
         MelModel(),
-        MelString('ICON','iconPath'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelFid('SCRI','script'),
+        MelDestructible(),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
         MelStruct('DATA','if','value','weight'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3068,77 +3431,134 @@ class MreNpc(MreActor):
     _flags = Flags(0L,Flags.getNames(
         ( 0,'female'),
         ( 1,'essential'),
+        ( 2,'isChargenFacePreset'),
         ( 3,'respawn'),
         ( 4,'autoCalc'),
         ( 7,'pcLevelOffset'),
+        ( 8,'useTemplate'),
         ( 9,'noLowLevel'),
-        (13,'noRumors'),
-        (14,'summonable'),
-        (15,'noPersuasion'),
-        (20,'canCorpseCheck'),))
+        (11,'noBloodSpray'),
+        (12,'noBloodDecal'),
+        (20,'noVATSMelee'),
+        (22,'canBeAllRaces'),
+        (26,'noKnockDown'),
+        (27,'notPushable'),
+        (30,'noRotatingHeadTrack'),))
     #--AI Service flags
     aiService = Flags(0L,Flags.getNames(
         (0,'weapons'),
         (1,'armor'),
         (2,'clothing'),
         (3,'books'),
-        (4,'ingredients'),
+        (4,'foods'),
+        (5,'chems'),
+        (6,'stimpacks'),
         (7,'lights'),
-        (8,'apparatus'),
         (10,'miscItems'),
-        (11,'spells'),
-        (12,'magicItems'),
         (13,'potions'),
         (14,'training'),
         (16,'recharge'),
         (17,'repair'),))
+    aiTrainSkill = Flags(0L,Flags.getNames(
+        (0,'barter'),
+        (1,'bigGuns'),
+        (2,'energyWeapons'),
+        (3,'explosives'),
+        (4,'lockpick'),
+        (5,'medicine'),
+        (6,'meleeWeapons'),
+        (7,'none'),
+        (8,'repair'),
+        (9,'science'),
+        (10,'smallGuns'),
+        (11,'sneak'),
+        (12,'throwing'),
+        (13,'unarmed'),))
     #--Mel NPC DATA
     class MelNpcData(MelStruct):
         """Convert npc stats into skills, health, attributes."""
         def loadData(self,record,ins,type,size,readId):
-            unpacked = list(ins.unpack('=21BH2s8B',size,readId))
+            if size == 11:
+                unpacked = list(ins.unpack('=I7B',size,readId))
+            else:
+                unpacked = list(ins.unpack('=I21B',size,readId))
+            recordSetAttr = record.__setattr__
+            recordSetAttr('health',unpacked[0])
+            recordSetAttr('attributes',unpacked[1:])
+            if self._debug: print unpacked[0],unpacked[1:]
+        def dumpData(self,record,out):
+            """Dumps data from record to outstream."""
+            recordGetAttr = record.__getattribute__
+            values = [recordGetAttr('health')]+recordGetAttr('attributes')
+            if len(recordGetAttr('attributes')) == 7:
+                out.packSub(self.subType,'=I7B',*values)
+            else:
+                out.packSub(self.subType,'=I21B',*values)
+
+    #--Mel NPC DNAM
+    class MelNpcDnam(MelStruct):
+        """Convert npc stats into skills."""
+        def loadData(self,record,ins,type,size,readId):
+            unpacked = list(ins.unpack('=28B',size,readId))
             recordSetAttr = record.__setattr__
-            recordSetAttr('skills',unpacked[:21])
-            recordSetAttr('health',unpacked[21])
-            recordSetAttr('unused1',unpacked[22])
-            recordSetAttr('attributes',unpacked[23:])
-            if self._debug: print unpacked[:21],unpacked[21],unpacked[23:]
+            recordSetAttr('skillValues',unpacked[:14])
+            recordSetAttr('skillOffsets',unpacked[14:])
+            if self._debug: print unpacked[:14]+unpacked[14:]
         def dumpData(self,record,out):
             """Dumps data from record to outstream."""
             recordGetAttr = record.__getattribute__
-            values = recordGetAttr('skills')+[recordGetAttr('health')]+[recordGetAttr('unused1')]+recordGetAttr('attributes')
-            out.packSub(self.subType,'=21BH2s8B',*values)
+            values = recordGetAttr('skillValues')+recordGetAttr('skillOffsets')
+            out.packSub(self.subType,'=28B',*values)
+
     #--Mel Set
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelModel(),
-        MelStruct('ACBS','=I3Hh2H',
-            (_flags,'flags',0L),'baseSpell','fatigue','barterGold',
-            ('level',1),'calcMin','calcMax'),
+        MelStruct('ACBS','=I2Hh3Hf2H',
+            (_flags,'flags',0L),'fatigue','barterGold',
+            ('level',1),'calcMin','calcMax','speedMultiplier','karma','dispotionBase','templateFlags'),
         MelStructs('SNAM','=IB3s','factions',
             (FID,'faction',None),'rank',('unused1','ODB')),
         MelFid('INAM','deathItem'),
+        MelFid('VTCK','voice'),
+        MelFid('TPLT','template'),
         MelFid('RNAM','race'),
+        #MelFid('????','actorEffects'),
+        MelFid('EITM','unarmedAttackEffect'),
+        MelStruct('EAMT','H', 'unarmedAttackAnimation'),
+        MelDestructible(),
         MelFids('SPLO','spells'),
         MelFid('SCRI','script'),
-        MelStructs('CNTO','Ii','items',(FID,'item',None),('count',1)),
-        MelStruct('AIDT','=4BIbB2s',
-            ('aggression',5),('confidence',50),('energyLevel',50),('responsibility',50),
-            (aiService,'services',0L),'trainSkill','trainLevel',('unused1',null2)),
+        MelGroups('items',
+            MelStruct('CNTO','Ii',(FID,'item',None),('count',1)),
+            MelOptStruct('COED','IIf',(FID,'owner',None),(FID,'glob',None),('condition',1.0)),
+        ),
+        MelStruct('AIDT','=5B2I3Bi',
+            ('aggression',5),('confidence',50),('energyLevel',50),('responsibility',50),('mood',0L),
+            (aiService,'services',0L),(aiTrainSkill,'trainSkill',0L),'trainLevel','assistance',
+            'aggroRadiusBehavior','aggroRadius'),
         MelFids('PKID','aiPackages'),
         MelStrings('KFFZ','animations'),
         MelFid('CNAM','iclass'),
-        MelNpcData('DATA','',('skills',[0]*21),'health',('unused2',null2),('attributes',[0]*8)),
+        MelNpcData('DATA','','health',('attributes',[0]*21)),
+        MelFids('PNAM','headParts'),
+        MelNpcDnam('DNAM','',('skillValues',[0]*14),('skillOffsets',[0]*14)),
         MelFid('HNAM','hair'),
-        MelOptStruct('LNAM','f',('hairLength',None)),
+        MelOptStruct('LNAM','f',('hairLength',1)),
         MelFid('ENAM','eye'), ####fid Array
         MelStruct('HCLR','3Bs','hairRed','hairBlue','hairGreen',('unused3',null1)),
         MelFid('ZNAM','combatStyle'),
+        MelStruct('NAM4','I',('impactMaterialType',0L)),
         MelBase('FGGS','fggs_p'), ####FaceGen Geometry-Symmetric
         MelBase('FGGA','fgga_p'), ####FaceGen Geometry-Asymmetric
         MelBase('FGTS','fgts_p'), ####FaceGen Texture-Symmetric
-        MelStruct('FNAM','H','fnam'), ####Byte Array
+        MelStruct('NAM5','H',('unknown',0L)),
+        MelStruct('NAM6','f',('height',0L)),
+        MelStruct('NAM7','f',('weight',0L)),
         )
     __slots__ = MreActor.__slots__ + melSet.getSlotsUsed()
 
@@ -3180,24 +3600,71 @@ class MrePack(MelRecord):
         None,'alwaysSneak','allowSwimming','allowFalls',
         'unequipArmor','unequipWeapons','defensiveCombat','useHorse',
         'noIdleAnims',))
+    _variableFlags = Flags(0L,Flags.getNames('isLongOrShort'))
     class MelPackPkdt(MelStruct):
-        """Support older 4 byte version."""
+        """Support older 8 byte version."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 12:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 8:
+                unpacked = ins.unpack('IHH',size,readId)
+            else:
+                raise "Unexpected size encountered for PACK:PKDT subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+    class MelPackPkdd(MelOptStruct):
+        """Handle older trucated PKDD for PACK subrecord."""
         def loadData(self,record,ins,type,size,readId):
-            if size != 4:
+            if size == 24:
                 MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 20:
+                unpacked = ins.unpack('fII4sI',size,readId)
+            elif size == 16:
+                unpacked = ins.unpack('fII4s',size,readId)
+            elif size == 12:
+                unpacked = ins.unpack('fII',size,readId)
             else:
-                record.flags,record.aiType,junk = ins.unpack('HBs',4,readId)
-                record.flags = MrePack._flags(record.flags)
-                record.unused1 = null3
-                if self._debug: print (record.flags.getTrueAttrs(),record.aiType,record.unused1)
-    class MelPackLT(MelStruct):
+                raise "Unexpected size encountered for PACK:PKDD subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+    class MelPackLT(MelOptStruct):
         """For PLDT and PTDT. Second element of both may be either an FID or a long,
         depending on value of first element."""
+        def loadData(self,record,ins,type,size,readId):
+            if ((self.subType == 'PLDT' and size == 12) or
+                (self.subType == 'PLD2' and size == 12) or
+                (self.subType == 'PTDT' and size == 16) or
+                (self.subType == 'PTD2' and size == 16)):
+                MelOptStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif ((self.subType == 'PTDT' and size == 12) or
+                  (self.subType == 'PTD2' and size == 12)):
+                unpacked = ins.unpack('iIi',size,readId)
+            else:
+                raise "Unexpected size encountered for PACK:%s subrecord: %s" % (self.subType, size)
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
         def hasFids(self,formElements):
             formElements.add(self)
         def dumpData(self,record,out):
             if ((self.subType == 'PLDT' and (record.locType or record.locId)) or
-                (self.subType == 'PTDT' and (record.targetType or record.targetId))):
+                (self.subType == 'PLD2' and (record.locType2 or record.locId2)) or
+                (self.subType == 'PTDT' and (record.targetType or record.targetId)) or
+                (self.subType == 'PTD2' and (record.targetType2 or record.targetId2))):
                 MelStruct.dumpData(self,record,out)
         def mapFids(self,record,function,save=False):
             """Applies function to fids. If save is true, then fid is set
@@ -3205,18 +3672,108 @@ class MrePack(MelRecord):
             if self.subType == 'PLDT' and record.locType != 5:
                 result = function(record.locId)
                 if save: record.locId = result
+            elif self.subType == 'PLD2' and record.locType2 != 5:
+                result = function(record.locId2)
+                if save: record.locId2 = result
             elif self.subType == 'PTDT' and record.targetType != 2:
                 result = function(record.targetId)
                 if save: record.targetId = result
+            elif self.subType == 'PTD2' and record.targetType2 != 2:
+                result = function(record.targetId2)
+                if save: record.targetId2 = result
+    class MelPackDistributor(MelNull):
+        """Handles embedded script records. Distributes load
+        duties to other elements as needed."""
+        def __init__(self):
+            self._debug = False
+        def getLoaders(self,loaders):
+            """Self as loader for structure types."""
+            for type in ('POBA','POEA','POCA'):
+                loaders[type] = self
+        def setMelSet(self,melSet):
+            """Set parent melset. Need this so that can reassign loaders later."""
+            self.melSet = melSet
+            self.loaders = {}
+            for element in melSet.elements:
+                attr = element.__dict__.get('attr',None)
+                if attr: self.loaders[attr] = element
+        def loadData(self,record,ins,type,size,readId):
+            if type == 'POBA':
+                element = self.loaders['onBegin']
+            elif type == 'POEA':
+                element = self.loaders['onEnd']
+            elif type == 'POCA':
+                element = self.loaders['onChange']
+            for subtype in ('INAM','SCHR','SCDA','SCTX','SLSD','SCVR','SCRV','SCRO','TNAM'):
+                self.melSet.loaders[subtype] = element
+            element.loadData(record,ins,type,size,readId)
     #--MelSet
     melSet = MelSet(
         MelString('EDID','eid'),
-        MelPackPkdt('PKDT','IB3s',(_flags,'flags'),'aiType',('unused1',null3)),
+        MelPackPkdt('PKDT','IHHI',(_flags,'flags'),'aiType','falloutBehaviorFlags','typeSpecificFlags'),
         MelPackLT('PLDT','iIi','locType','locId','locRadius'),
+        MelPackLT('PLD2','iIi','locType2','locId2','locRadius2'),
         MelStruct('PSDT','2bBbi','month','day','date','time','duration'),
-        MelPackLT('PTDT','iIi','targetType','targetId','targetCount'),
+        MelPackLT('PTDT','iIif','targetType','targetId','targetCount','targetUnknown1'),
         MelConditions(),
+        MelGroup('idleAnimations',
+            MelStruct('IDLF','B','animationFlags'),
+            MelBase('IDLC','animationCount'), # byte or short
+            MelStruct('IDLT','f','idleTimerSetting'),
+            MelFidList('IDLA','animations'),
+            MelBase('IDLB','idlb_p'),
+            ),
+        MelBase('PKED','eatMarker'),
+        MelOptStruct('PKE2','I','escordDistance'),
+        MelFid('CNAM','combatStyle'),
+        MelOptStruct('PKFD','f','followStartLocationTrigerRadius'),
+        MelBase('PKPT','patrolFlags'), # byte or short
+        MelOptStruct('PKW3','IBB3Hff4s','weaponFlags','fireRate','fireCount','numBursts',
+                     'shootPerVolleysMin','shootPerVolleysMax','pauseBetweenVolleysMin','pauseBetweenVolleysMax','weaponUnknown'),
+        MelPackLT('PTD2','iIif','targetType2','targetId2','targetCount2','targetUnknown2'),
+        MelBase('PUID','useItemMarker'),
+        MelBase('PKAM','ambushMarker'),
+        MelPackPkdd('PKDD','fII4sI4s','dialFov','dialTopic','dialFlags','dialUnknown1','dialType','dialUnknown2'),
+        MelGroup('onBegin',
+            MelBase('POBA', 'marker', ''), #### onBegin Marker, wbEmpty
+            MelFid('INAM', 'idle'),
+            MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+            MelBase('SCDA','compiled_p'),
+            MelString('SCTX','scriptText'),
+            MelGroups('vars',
+                MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                MelString('SCVR','name')),
+            MelScrxen('SCRV/SCRO','references'),
+            MelFid('TNAM', 'topic'),
+            ),
+        MelGroup('onEnd',
+            MelBase('POEA', 'marker', ''), #### onEnd Marker, wbEmpty
+            MelFid('INAM', 'idle'),
+            MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+            MelBase('SCDA','compiled_p'),
+            MelString('SCTX','scriptText'),
+            MelGroups('vars',
+                MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                MelString('SCVR','name')),
+            MelScrxen('SCRV/SCRO','references'),
+            MelFid('TNAM', 'topic'),
+            ),
+        MelGroup('onChange',
+            MelBase('POCA', 'marker', ''), #### onChange Marker, wbEmpty
+            MelFid('INAM', 'idle'),
+            MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+            MelBase('SCDA','compiled_p'),
+            MelString('SCTX','scriptText'),
+            MelGroups('vars',
+                MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                MelString('SCVR','name')),
+            MelScrxen('SCRV/SCRO','references'),
+            MelFid('TNAM', 'topic'),
+            ),
+        #--Distributor for embedded script entries.
+        MelPackDistributor(),
         )
+    melSet.elements[-1].setMelSet(melSet)
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 #------------------------------------------------------------------------------
 ## See the comments on MreLand. Commented out for same reasons.
@@ -3254,11 +3811,20 @@ class MrePack(MelRecord):
 ##        MelPgrl('PGRL','','pgrl',(FID,'reference'),'points'),
 ##    )
 ##    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
+###------------------------------------------------------------------------------
+## class MrePgre(MelRecord):
+##     classType = 'PGRE'
+##     melSet = MelSet(
+##         MelBase('DATA','data_p'),
+##     )
+##     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
+
 #------------------------------------------------------------------------------
 class MreQust(MelRecord):
     """Quest record."""
     classType = 'QUST'
     _questFlags = Flags(0,Flags.getNames('startGameEnabled',None,'repeatedTopics','repeatedStages'))
+    _variableFlags = Flags(0L,Flags.getNames('isLongOrShort'))
     stageFlags = Flags(0,Flags.getNames('complete'))
     targetFlags = Flags(0,Flags.getNames('ignoresLocks'))
 
@@ -3277,13 +3843,31 @@ class MreQust(MelRecord):
             self.ctda = self.type_ctda.get(key, self.ctda)
             return self.data[key]
 
+    class MelQustData(MelStruct):
+        """Handle older trucated DATA for QUST subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 8:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 2:
+                #--Else 2 byte record
+                unpacked = ins.unpack('BB',size,readId)
+            else:
+                raise "Unexpected size encountered for QUST:DATA subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+
     #--MelSet
     melSet = MelSet(
         MelString('EDID','eid'),
         MelFid('SCRI','script'),
         MelString('FULL','full'),
         MelString('ICON','iconPath'),
-        MelStruct('DATA','BB',(_questFlags,'questFlags',0),'priority'),
+        MelQustData('DATA','=BB2sf',(_questFlags,'questFlags',0),('priority',0),('unused2',null2),('questDelay',0.0)),
         MelConditions(),
         MelGroups('stages',
             MelStruct('INDX','h','stage'),
@@ -3294,13 +3878,21 @@ class MreQust(MelRecord):
                 MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
                 MelBase('SCDA','compiled_p'),
                 MelString('SCTX','scriptText'),
-                MelScrxen('SCRV/SCRO','references')
+                MelGroups('vars',
+                    MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                    MelString('SCVR','name')),
+                MelScrxen('SCRV/SCRO','references'),
+                MelFid('NAM0', 'nextQuest'),
                 ),
             ),
-        MelGroups('targets',
-            MelStruct('QSTA','IB3s',(FID,'targetId'),(targetFlags,'flags'),('unused1',null3)),
-            MelConditions(),
-            ),
+        MelGroups('objectives',
+             MelStruct('QOBJ','i','index'),
+             MelString('NNAM','description'),
+             MelGroups('targets',
+                 MelStruct('QSTA','IB3s',(FID,'targetId'),(targetFlags,'flags'),('unused1',null3)),
+                 MelConditions(),
+                 ),
+             ),
         )
     melSet.loaders = MelQustLoaders(melSet.loaders,*melSet.elements[5:8])
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3322,7 +3914,7 @@ class MreRace(MelRecord):
     think of."""
 
     classType = 'RACE'
-    _flags = Flags(0L,Flags.getNames('playable'))
+    _flags = Flags(0L,Flags.getNames('playable','child'))
 
     class MelRaceVoices(MelStruct):
         """Set voices to zero, if equal race fid. If both are zero, then don't skip dump."""
@@ -3332,15 +3924,33 @@ class MreRace(MelRecord):
             if (record.maleVoice,record.femaleVoice) != (0,0):
                 MelStruct.dumpData(self,record,out)
 
-    class MelRaceModel(MelGroup):
-        """Most face data, like a MelModel - MODT + ICON. Load is controlled by MelRaceDistributor."""
+    class MelRaceHeadModel(MelGroup):
+        """Most face data, like a MelModel + ICON + MICO. Load is controlled by MelRaceDistributor."""
         def __init__(self,attr,index):
             MelGroup.__init__(self,attr,
                 MelString('MODL','modPath'),
                 MelBase('MODB','modb_p'),
-                MelString('ICON','iconPath'),)
+                MelBase('MODT','modt_p'),
+                MelBase('MODS','mods_p'),
+                MelOptStruct('MODD','B','modd_p'),
+                MelString('ICON','iconPath'),
+                MelBase('MICO','mico'))
             self.index = index
+        def dumpData(self,record,out):
+            out.packSub('INDX','I',self.index)
+            MelGroup.dumpData(self,record,out)
 
+    class MelRaceBodyModel(MelGroup):
+        """Most body data, like a MelModel - MODB + ICON + MICO. Load is controlled by MelRaceDistributor."""
+        def __init__(self,attr,index):
+            MelGroup.__init__(self,attr,
+                MelString('ICON','iconPath'),
+                MelBase('MICO','mico'),
+                MelString('MODL','modPath'),
+                MelBase('MODT','modt_p'),
+                MelBase('MODS','mods_p'),
+                MelOptStruct('MODD','B','modd_p'))
+            self.index = index
         def dumpData(self,record,out):
             out.packSub('INDX','I',self.index)
             MelGroup.dumpData(self,record,out)
@@ -3354,26 +3964,42 @@ class MreRace(MelRecord):
             out.packSub('INDX','I',self.index)
             MelString.dumpData(self,record,out)
 
+    class MelRaceFaceGen(MelGroup):
+        """Most fecegen data. Load is controlled by MelRaceDistributor."""
+        def __init__(self,attr):
+            MelGroup.__init__(self,attr,
+                MelBase('FGGS','fggs_p'), ####FaceGen Geometry-Symmetric
+                MelBase('FGGA','fgga_p'), ####FaceGen Geometry-Asymmetric
+                MelBase('FGTS','fgts_p'), ####FaceGen Texture-Symmetric
+                MelStruct('SNAM','2s',('snam_p',null2)))
+
     class MelRaceDistributor(MelNull):
         """Handles NAM0, NAM1, MNAM, FMAN and INDX records. Distributes load
         duties to other elements as needed."""
         def __init__(self):
-            bodyAttrs = ('UpperBodyPath','LowerBodyPath','HandPath','FootPath','TailPath')
-            self.attrs = {
+            headAttrs = ('Head', 'Ears', 'Mouth', 'TeethLower', 'TeethUpper', 'Tongue', 'LeftEye', 'RightEye')
+            bodyAttrs = ('UpperBody','LeftHand','RightHand','UpperBodyTexture')
+            self.headModelAttrs = {
+                'MNAM':tuple('male'+text for text in headAttrs),
+                'FNAM':tuple('female'+text for text in headAttrs),
+                }
+            self.bodyModelAttrs = {
                 'MNAM':tuple('male'+text for text in bodyAttrs),
                 'FNAM':tuple('female'+text for text in bodyAttrs),
-                'NAM0':('head', 'maleEars', 'femaleEars', 'mouth',
-                'teethLower', 'teethUpper', 'tongue', 'leftEye', 'rightEye',)
                 }
-            self.tailModelAttrs = {'MNAM':'maleTailModel','FNAM':'femaleTailModel'}
+            self.attrs = {
+                'NAM0':self.headModelAttrs,
+                'NAM1':self.bodyModelAttrs
+                }
+            self.facegenAttrs = {'MNAM':'maleFaceGen','FNAM':'femaleFaceGen'}
             self._debug = False
 
         def getSlotsUsed(self):
-            return ('_loadAttrs',)
+            return ('_loadAttrs','_modelAttrs')
 
         def getLoaders(self,loaders):
             """Self as loader for structure types."""
-            for type in ('NAM0','MNAM','FNAM','INDX'):
+            for type in ('NAM0','NAM1','MNAM','FNAM','INDX'):
                 loaders[type] = self
 
         def setMelSet(self,melSet):
@@ -3385,72 +4011,79 @@ class MreRace(MelRecord):
                 if attr: self.loaders[attr] = element
 
         def loadData(self,record,ins,type,size,readId):
-            if type in ('NAM0','MNAM','FNAM'):
-                record._loadAttrs = self.attrs[type]
-                attr = self.tailModelAttrs.get(type)
-                if not attr: return
+            if type in ('NAM0','NAM1'):
+                record._modelAttrs = self.attrs[type]
+                return
+            elif type in ('MNAM','FNAM'):
+                record._loadAttrs = record._modelAttrs[type]
+                attr = self.facegenAttrs.get(type)
+                element = self.loaders[attr]
+                for type in ('FGGS','FGGA','FGTS','SNAM'):
+                    self.melSet.loaders[type] = element
             else: #--INDX
                 index, = ins.unpack('I',4,readId)
                 attr = record._loadAttrs[index]
-            element = self.loaders[attr]
-            for type in ('MODL','MODB','ICON'):
-                self.melSet.loaders[type] = element
+                element = self.loaders[attr]
+                for type in ('MODL','MODB','MODT','MODS','MODD','ICON','MICO'):
+                    self.melSet.loaders[type] = element
 
     #--Mel Set
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
         MelString('DESC','text'),
-        MelFids('SPLO','spells'),
-        MelStructs('XNAM','Ii','relations',(FID,'faction'),'mod'),
         MelStruct('DATA','14b2s4fI','skill1','skill1Boost','skill2','skill2Boost',
                   'skill3','skill3Boost','skill4','skill4Boost','skill5','skill5Boost',
                   'skill6','skill6Boost','skill7','skill7Boost',('unused1',null2),
                   'maleHeight','femaleHeight','maleWeight','femaleWeight',(_flags,'flags',0L)),
-        MelRaceVoices('VNAM','2I',(FID,'maleVoice'),(FID,'femaleVoice')), #--0 same as race fid.
+        MelFid('ONAM','Older'),
+        MelFid('YNAM','Younger'),
+        MelBase('NAM2','_nam2',''),
+        MelRaceVoices('VTCK','2I',(FID,'maleVoice'),(FID,'femaleVoice')), #--0 same as race fid.
         MelOptStruct('DNAM','2I',(FID,'defaultHairMale',0L),(FID,'defaultHairFemale',0L)), #--0=None
-        MelStruct('CNAM','B','defaultHairColor'), #--Int corresponding to GMST sHairColorNN
+        MelStruct('CNAM','2B','defaultHairColorMale','defaultHairColorFemale'), #--Int corresponding to GMST sHairColorNN
         MelOptStruct('PNAM','f','mainClamp'),
         MelOptStruct('UNAM','f','faceClamp'),
-        #--Male: Str,Int,Wil,Agi,Spd,End,Per,luck; Female Str,Int,...
-        MelStruct('ATTR','16B','maleStrength','maleIntelligence','maleWillpower',
-                  'maleAgility','maleSpeed','maleEndurance','malePersonality',
-                  'maleLuck','femaleStrength','femaleIntelligence',
-                  'femaleWillpower','femaleAgility','femaleSpeed',
-                  'femaleEndurance','femalePersonality','femaleLuck'),
+        MelStruct('ATTR','2B','maleBaseAttribute','femaleBaseAttribute'),
         #--Begin Indexed entries
         MelBase('NAM0','_nam0',''), ####Face Data Marker, wbEmpty
-        MelRaceModel('head',0),
-        MelRaceModel('maleEars',1),
-        MelRaceModel('femaleEars',2),
-        MelRaceModel('mouth',3),
-        MelRaceModel('teethLower',4),
-        MelRaceModel('teethUpper',5),
-        MelRaceModel('tongue',6),
-        MelRaceModel('leftEye',7),
-        MelRaceModel('rightEye',8),
+        MelBase('MNAM','_mnam',''),
+        MelRaceHeadModel('maleHead',0),
+        MelRaceIcon('maleEars',1),
+        MelRaceHeadModel('maleMouth',2),
+        MelRaceHeadModel('maleTeethLower',3),
+        MelRaceHeadModel('maleTeethUpper',4),
+        MelRaceHeadModel('maleTongue',5),
+        MelRaceHeadModel('maleLeftEye',6),
+        MelRaceHeadModel('maleRightEye',7),
+        MelBase('FNAM','_fnam',''),
+        MelRaceHeadModel('femaleHead',0),
+        MelRaceIcon('femaleEars',1),
+        MelRaceHeadModel('femaleMouth',2),
+        MelRaceHeadModel('femaleTeethLower',3),
+        MelRaceHeadModel('femaleTeethUpper',4),
+        MelRaceHeadModel('femaleTongue',5),
+        MelRaceHeadModel('femaleLeftEye',6),
+        MelRaceHeadModel('femaleRightEye',7),
         MelBase('NAM1','_nam1',''), ####Body Data Marker, wbEmpty
         MelBase('MNAM','_mnam',''), ####Male Body Data Marker, wbEmpty
-        MelModel('maleTailModel'),
-        MelRaceIcon('maleUpperBodyPath',0),
-        MelRaceIcon('maleLowerBodyPath',1),
-        MelRaceIcon('maleHandPath',2),
-        MelRaceIcon('maleFootPath',3),
-        MelRaceIcon('maleTailPath',4),
+        MelRaceBodyModel('maleUpperBody',0),
+        MelRaceBodyModel('maleLeftHand',1),
+        MelRaceBodyModel('maleRightHand',2),
+        MelRaceBodyModel('maleUpperBodyTexture',3),
         MelBase('FNAM','_fnam',''), ####Female Body Data Marker, wbEmpty
-        MelModel('femaleTailModel'),
-        MelRaceIcon('femaleUpperBodyPath',0),
-        MelRaceIcon('femaleLowerBodyPath',1),
-        MelRaceIcon('femaleHandPath',2),
-        MelRaceIcon('femaleFootPath',3),
-        MelRaceIcon('femaleTailPath',4),
+        MelRaceBodyModel('femaleUpperBody',0),
+        MelRaceBodyModel('femaleLeftHand',1),
+        MelRaceBodyModel('femaleRightHand',2),
+        MelRaceBodyModel('femaleUpperBodyTexture',3),
         #--Normal Entries
         MelFidList('HNAM','hairs'),
         MelFidList('ENAM','eyes'),
-        MelBase('FGGS','fggs_p'), ####FaceGen Geometry-Symmetric
-        MelBase('FGGA','fgga_p'), ####FaceGen Geometry-Asymmetric
-        MelBase('FGTS','fgts_p'), ####FaceGen Texture-Symmetric
-        MelStruct('SNAM','2s',('snam_p',null2)),
+        #--FaceGen Entries
+        MelBase('MNAM','_mnam',''),
+        MelRaceFaceGen('maleFaceGen'),
+        MelBase('FNAM','_fnam',''),
+        MelRaceFaceGen('femaleFaceGen'),
         #--Distributor for face and body entries.
         MelRaceDistributor(),
         )
@@ -3464,16 +4097,20 @@ class MreRefr(MelRecord):
     _parentFlags = Flags(0L,Flags.getNames('oppositeParent'))
     _actFlags = Flags(0L,Flags.getNames('useDefault', 'activate','open','openByDefault'))
     _lockFlags = Flags(0L,Flags.getNames(None, None, 'leveledLock'))
+    _destinationFlags = Flags(0L,Flags.getNames('noAlarm'))
+    _variableFlags = Flags(0L,Flags.getNames('isLongOrShort'))
     class MelRefrXloc(MelOptStruct):
         """Handle older trucated XLOC for REFR subrecord."""
         def loadData(self,record,ins,type,size,readId):
-            if size == 16:
+            if size == 20:
                 MelStruct.loadData(self,record,ins,type,size,readId)
                 return
+            #elif size == 16:
+            #    unpacked = ins.unpack('B3sIB3s',size,readId)
             elif size == 12:
-                #--Else is skipping unused2
-                unpacked = ins.unpack('B3sIB3s',size,readId)
+                unpacked = ins.unpack('B3sI4s',size,readId)
             else:
+                print ins.unpack(('%dB' % size),size)
                 raise ModError(ins.inName,_('Unexpected size encountered for REFR:XLOC subrecord: ')+str(size))
             unpacked = unpacked[:-2] + self.defaults[len(unpacked)-2:-2] + unpacked[-2:]
             setter = record.__setattr__
@@ -3492,7 +4129,7 @@ class MreRefr(MelRecord):
             insUnpack = ins.unpack
             pos = insTell()
             (type,size) = insUnpack('4sH',6,readId+'.FULL')
-            while type in ['FNAM','FULL','TNAM']:
+            while type in ['FNAM','FULL','TNAM','WMI1']:
                 if type == 'FNAM':
                     value = insUnpack('B',size,readId)
                     record.flags = MreRefr._flags(*value)
@@ -3500,13 +4137,14 @@ class MreRefr(MelRecord):
                     record.full = ins.readString(size,readId)
                 elif type == 'TNAM':
                     record.markerType, record.unused5 = insUnpack('Bs',size,readId)
+                elif type == 'WMI1':
+                    record.reputation = insUnpack('I',size,readId)
                 pos = insTell()
                 (type,size) = insUnpack('4sH',6,readId+'.FULL')
             ins.seek(pos)
             if self._debug: print ' ',record.flags,record.full,record.markerType
-
         def dumpData(self,record,out):
-            if (record.flags,record.full,record.markerType,record.unused5) != self.defaults[1:]:
+            if (record.flags,record.full,record.markerType,record.unused5,record.reputation) != self.defaults[1:]:
                 record.hasXmrk = True
             if record.hasXmrk:
                 try:
@@ -3516,35 +4154,104 @@ class MreRefr(MelRecord):
                     if value != None:
                         out.packSub0('FULL',value)
                     out.packSub('TNAM','Bs',record.markerType, record.unused5)
+                    out.packRef('WMI1',record.reputation)
                 except struct.error:
                     print self.subType,self.format,record.flags,record.full,record.markerType
                     raise
 
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelOptStruct('RCLR','8B','referenceStartColorRed','referenceStartColorGreen','referenceStartColorBlue',('referenceColorUnused1',null1),
+                     'referenceEndColorRed','referenceEndColorGreen','referenceEndColorBlue',('referenceColorUnused2',null1)),
         MelFid('NAME','base'),
-        MelOptStruct('XTEL','I6f',(FID,'destinationFid'),'destinationPosX','destinationPosY',
-            'destinationPosZ','destinationRotX','destinationRotY','destinationRotZ'),
-        MelRefrXloc('XLOC','B3sI4sB3s','lockLevel',('unused1',null3),(FID,'lockKey'),('unused2',null4),(_lockFlags,'lockFlags'),('unused3',null3)),
-        MelOwnership(),
-        MelOptStruct('XESP','IB3s',(FID,'parent'),(_parentFlags,'parentFlags'),('unused4',null3)),
+        MelFid('XEZN','encounterZone'),
+        MelBase('XRGD','ragdollData'),
+        MelBase('XRGB','ragdollBipedData'),
+        MelOptStruct('XPRM','3f3IfI','primitiveBoundX','primitiveBoundY','primitiveBoundX',
+                     'primitiveColorRed','primitiveColorGreen','primitiveColorBlue','primitiveUnknown','primitiveType'),
+        MelOptStruct('XTRI','I','collisionLayer'),
+        MelBase('XMBP','multiboundPrimitiveMarker'),
+        MelOptStruct('XMBO','3f','boundHalfExtentsX','boundHalfExtentsY','boundHalfExtentsZ'),
+        MelOptStruct('XTEL','I6fI',(FID,'destinationFid'),'destinationPosX','destinationPosY',
+            'destinationPosZ','destinationRotX','destinationRotY','destinationRotZ',(_destinationFlags,'destinationFlags')),
+        MelRefrXmrk('XMRK','',('hasXmrk',False),(_flags,'flags',0L),'full','markerType',('unused5',null1),(FID,'reputation')), ####Map Marker Start Marker, wbEmpty
+        MelGroup('audioData',
+            MelBase('MMRK','audioMarker'),
+            MelBase('FULL','full_p'),
+            MelFid('CNAM','audioLocation'),
+            MelBase('BNAM','bnam_p'),
+            MelBase('MNAM','mnam_p'),
+            MelBase('NNAM','nnam_p'),
+            ),
+        MelBase('XSRF','xsrf_p'),
+        MelBase('XSRD','xsrd_p'),
         MelFid('XTRG','targetId'),
-        MelBase('XSED','seed_p'),
-        ####SpeedTree Seed, if it's a single byte then it's an offset into the list of seed values in the TREE record
-        ####if it's 4 byte it's the seed value directly.
-        MelOptStruct('XLOD','3f',('lod1',None),('lod2',None),('lod3',None)), ####Distant LOD Data, unknown
-        MelOptStruct('XCHG','f',('charge',None)),
-        MelOptStruct('XHLT','i',('health',None)),
-        MelXpci('XPCI'), ####fid, unknown
         MelOptStruct('XLCM','i',('levelMod',None)),
-        MelFid('XRTM','xrtm'), ####unknown
-        MelOptStruct('XACT','I',(_actFlags,'actFlags',0L)), ####Action Flag
+        MelGroup('patrolData',
+            MelStruct('XPRD','f','idleTime'),
+            MelBase('XPPA','patrolScriptMarker'),
+            MelFid('INAM', 'idle'),
+            MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+            MelBase('SCDA','compiled_p'),
+            MelString('SCTX','scriptText'),
+            MelGroups('vars',
+                MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                MelString('SCVR','name')),
+            MelScrxen('SCRV/SCRO','references'),
+            MelFid('TNAM','topic'),
+            ),
+        MelOptStruct('XRDO','fIfI','rangeRadius','broadcastRangeType','staticPercentage',(FID,'positionReference')),
+        MelOwnership(),
+        MelRefrXloc('XLOC','B3sI4sB3s4s','lockLevel',('unused1',null3),(FID,'lockKey'),('unused2',null4),(_lockFlags,'lockFlags'),('unused3',null3),('unused4',null4)),
         MelOptStruct('XCNT','i','count'),
-        MelRefrXmrk('XMRK','',('hasXmrk',False),(_flags,'flags',0L),'full','markerType',('unused5',null1)), ####Map Marker Start Marker, wbEmpty
+        MelOptStruct('XRDS','f','radius'),
+        MelOptStruct('XHLP','f','health'),
+        MelOptStruct('XRAD','f','radiation'),
+        MelOptStruct('XCHG','f',('charge',None)),
+        MelGroup('ammo',
+            MelFid('XAMT','type'),
+            MelStruct('XAMC','I','count'),
+            ),
+        MelStructs('XPWR','II','reflectedByWaters',(FID,'reference'),'type'),
+        MelFids('XLTW','litWaters'),
+        MelStructs('XDCR','II','linkedDecals',(FID,'reference'),'unknown'), # ??
+        MelFid('XLKR','linkedReference'),
+        MelOptStruct('XCLP','8B','linkStartColorRed','linkStartColorGreen','linkStartColorBlue',('linkColorUnused1',null1),
+                     'linkEndColorRed','linkEndColorGreen','linkEndColorBlue',('linkColorUnused2',null1)),
+        MelGroup('activateParents',
+            MelStruct('XAPD','B','flags'),
+            MelStructs('XAPR','If','activateParentRefs',(FID,'reference'),'delay')
+            ),
+        MelString('XATO','activationPrompt'),
+        MelOptStruct('XESP','IB3s',(FID,'parent'),(_parentFlags,'parentFlags'),('unused6',null3)),
+        MelOptStruct('XEMI','I',(FID,'emitance')),
+        MelFid('XMBR','multiboundReference'),
+        MelOptStruct('XACT','I',(_actFlags,'actFlags',0L)), ####Action Flag
         MelBase('ONAM','onam_p'), ####Open by Default, wbEmpty
+        MelBase('XIBS','ignoredBySandbox'),
+        MelOptStruct('XNDP','2I',(FID,'navMesh'),'unknown'),
+        MelOptStruct('XPOD','II',(FID,'portalDataRoom0'),(FID,'portalDataRoom1')),
+        MelOptStruct('XPTL','9f','portalWidth','portalHeight','portalPosX','portalPosY','portalPosZ',
+                     'portalRot1','portalRot2','portalRot3','portalRot4'),
+        MelBase('XSED','speedTreeSeed'),
+        ####SpeedTree Seed, if it's a single byte then it's an offset into the list of seed values in the TREE record
+        ####if it's 4 byte it's the seed value directly.
+        MelGroup('roomData',
+            MelStruct('XRMR','H2s','linkedRoomsCount','unknown'),
+            MelFids('XLRM','linkedRoom'),
+            ),
+        MelOptStruct('XOCP','9f','occlusionPlaneWidth','occlusionPlaneHeight','occlusionPlanePosX','occlusionPlanePosY','occlusionPlanePosZ',
+                     'occlusionPlaneRot1','occlusionPlaneRot2','occlusionPlaneRot3','occlusionPlaneRot4'),
+        MelOptStruct('XORD','4I',(FID,'linkedOcclusionPlane0'),(FID,'linkedOcclusionPlane1'),(FID,'linkedOcclusionPlane2'),(FID,'linkedOcclusionPlane3')),
+        MelOptStruct('XLOD','3f',('lod1',None),('lod2',None),('lod3',None)), ####Distant LOD Data, unknown
         MelOptStruct('XSCL','f',('scale',1.0)),
-        MelOptStruct('XSOL','B',('soul',None)), ####Was entirely missing. Confirmed by creating a test mod...it isn't present in any of the official esps
         MelOptStruct('DATA','=6f',('posX',None),('posY',None),('posZ',None),('rotX',None),('rotY',None),('rotZ',None)),
+
+        ##Oblivion subrecords
+        #MelOptStruct('XHLT','i',('health',None)),
+        #MelXpci('XPCI'), ####fid, unknown
+        #MelFid('XRTM','xrtm'), ####unknown
+        #MelOptStruct('XSOL','B',('soul',None)), ####Was entirely missing. Confirmed by creating a test mod...it isn't present in any of the official esps
     )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -3625,7 +4332,8 @@ class MreRegn(MelRecord):
 
     melSet = MelSet(
         MelString('EDID','eid'),
-        MelString('ICON','iconPath'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelStruct('RCLR','3Bs','mapRed','mapBlue','mapGreen',('unused1',null1)),
         MelFid('WNAM','worldspace'),
         MelGroups('areas',
@@ -3639,13 +4347,11 @@ class MreRegn(MelRecord):
             'maxHeight', 'sink', 'sinkVar', 'sizeVar', 'angleVarX',
             'angleVarY',  'angleVarZ', ('unused2',null2), ('unk2',null4)),
             MelRegnString('RDMP', 'mapName'),
-## Disabled support due to bug when loading.
-## Apparently group records can't contain subrecords that are also present outside of the group.
-##            MelRegnString('ICON', 'iconPath'),  ####Obsolete? Only one record in oblivion.esm
+            #MelRegnString('ICON', 'iconPath'),  ####Obsolete? Only one record in Fallout3.esm
             MelRegnStructA('RDGS', 'I4s', 'grasses', (FID,'grass'), ('unk1',null4)),
             MelRegnOptStruct('RDMD', 'I', ('musicType',None)),
             MelRegnStructA('RDSD', '3I', 'sounds', (FID, 'sound'), (sdflags, 'flags'), 'chance'),
-            MelRegnStructA('RDWT', '2I', 'weather', (FID, 'weather'), 'chance')),
+            MelRegnStructA('RDWT', '3I', 'weather', (FID, 'weather', None), 'chance', (FID, 'global', None))),
     )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -3741,24 +4447,36 @@ class MreSoun(MelRecord):
     classType = 'SOUN'
     _flags = Flags(0L,Flags.getNames('randomFrequencyShift', 'playAtRandom',
         'environmentIgnored', 'randomLocation', 'loop','menuSound', '2d', '360LFE'))
-    class MelSounSndd(MelStruct):
-        """SNDD is an older version of SNDX. Allow it to read in, but not set defaults or write."""
+    class MelSounSndx(MelStruct):
+        """SNDX is a reduced version of SNDD. Allow it to read in, but not set defaults or write."""
         def loadData(self,record,ins,type,size,readId):
             MelStruct.loadData(self,record,ins,type,size,readId)
-            record.staticAtten = 0
-            record.stopTime = 0
-            record.startTime = 0
+            record.point0 = 0
+            record.point1 = 0
+            record.point2 = 0
+            record.point3 = 0
+            record.point4 = 0
+            record.reverb = 0
+            record.priority = 0
+            record.unknown = "\0"*8
         def getSlotsUsed(self):
             return ()
         def setDefault(self,record): return
         def dumpData(self,record,out): return
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FNAM','soundFile'),
-        MelSounSndd('SNDD','=2BbsH2s','minDistance', 'maxDistance', 'freqAdjustment', ('unused1',null1),
-            (_flags,'flags'), ('unused2',null2)),
-        MelOptStruct('SNDX','=2BbsH2sh2B',('minDistance',None), ('maxDistance',None), ('freqAdjustment',None), ('unused1',null1),
-            (_flags,'flags',None), ('unused2',null2), ('staticAtten',None),('stopTime',None),('startTime',None),)
+        MelOptStruct('SNDD','=2BbsIh2B6HI8s',('minDistance',None), ('maxDistance',None), ('freqAdjustment',None), ('unused1',null1),
+            (_flags,'flags',None),('staticAtten',None),('stopTime',None),('startTime',None),
+            ('point0',0),('point1',0),('point2',0),('point3',0),('point4',0),('reverb',0),('priority',0),'unknown'),
+        MelSounSndx('SNDX','=2BbsIh2B',('minDistance',None), ('maxDistance',None), ('freqAdjustment',None), ('unused1',null1),
+            (_flags,'flags',None),('staticAtten',None),('stopTime',None),('startTime',None),),
+        MelBase('ANAM','_anam'), #--Should be a struct. Maybe later.
+        MelBase('GNAM','_gnam'), #--Should be a struct. Maybe later.
+        MelBase('HNAM','_hnam'), #--Should be a struct. Maybe later.
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -3790,6 +4508,9 @@ class MreStat(MelRecord):
     classType = 'STAT'
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelModel(),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3819,6 +4540,7 @@ class MreTes4(MelRecord):
         MelString('CNAM','author','',512),
         MelString('SNAM','description','',512),
         MelTes4Name('MAST','masters'),
+        MelBase('ONAM','onam'),
         MelNull('DATA'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3835,6 +4557,9 @@ class MreTree(MelRecord):
     classType = 'TREE'
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelModel(),
         MelString('ICON','iconPath'),
         MelStructA('SNAM','I','speedTree','seed'),
@@ -3853,61 +4578,83 @@ class MreWatr(MelRecord):
     class MelWatrData(MelStruct):
         """Handle older trucated DATA for WATR subrecord."""
         def loadData(self,record,ins,type,size,readId):
-            if size == 102:
+            if size == 186:
                 MelStruct.loadData(self,record,ins,type,size,readId)
                 return
-            elif size == 86:
-                #--Else 86 byte record (skips dispVelocity,
-                #-- dispFalloff, dispDampner, dispSize, and damage
-                #-- Two junk? bytes are tacked onto the end
-                #-- Hex editing and the CS confirms that it is NOT
-                #-- damage, so it is probably just filler
-                unpacked = ins.unpack('11f3Bs3Bs3BsB3s6f2s',size,readId)
-            elif size == 62:
-                #--Else 62 byte record (skips most everything
-                #-- Two junk? bytes are tacked onto the end
-                #-- No testing done, but assumed that its the same as the
-                #-- previous truncated record.
-                unpacked = ins.unpack('11f3Bs3Bs3BsB3s2s',size,readId)
-            elif size == 42:
-                #--Else 42 byte record (skips most everything
-                #-- Two junk? bytes are tacked onto the end
-                #-- No testing done, but assumed that its the same as the
-                #-- previous truncated record.
-                unpacked = ins.unpack('10f2s',size,readId)
             elif size == 2:
-                #--Else 2 byte record (skips everything
-                #-- Two junk? bytes are tacked onto the end
-                #-- No testing done, but assumed that its the same as the
-                #-- previous truncated record.
-                unpacked = ins.unpack('2s',size,readId)
+                (record.damage,) = ins.unpack('H',size,readId)
+                return
             else:
-                raise ModError(ins.inName,_('Unexpected size encountered for WATR subrecord: ')+str(size))
-            unpacked = unpacked[:-1]
-            unpacked += self.defaults[len(unpacked):]
-            setter = record.__setattr__
-            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                raise "Unexpected size encountered for WATR subrecord: %s" % size
+        def dumpData(self,record,out):
+            out.packSub(self.subType,'H',record.damage)
+
+    class MelWatrDnam(MelStruct):
+        """Handle older trucated DNAM for WATR subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 196:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 184:
+                unpacked = ins.unpack('10f3Bs3Bs3BsI32f',size,readId)
+            else:
+                raise ModError(ins.inName,_('Unexpected size encountered for WATR subrecord: ')+str(size))
+            unpacked = unpacked[:-1]
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
                 if callable(action): value = action(value)
                 setter(attr,value)
             if self._debug: print unpacked
 
     melSet = MelSet(
         MelString('EDID','eid'),
-        MelString('TNAM','texture'),
+        MelString('FULL','full'),
+        MelString('NNAM','texture'),
         MelStruct('ANAM','B','opacity'),
         MelStruct('FNAM','B',(_flags,'flags',0)),
         MelString('MNAM','material'),
         MelFid('SNAM','sound'),
-        MelWatrData('DATA', '11f3Bs3Bs3BsB3s10fH',('windVelocity',0.100),
-                    ('windDirection',90.0),('waveAmp',0.5),('waveFreq',1.0),('sunPower',50.0),
-                    ('reflectAmt',0.5),('fresnelAmt',0.0250),('xSpeed',0.0),('ySpeed',0.0),
-                    ('fogNear',27852.8),('fogFar',163840.0),('shallowRed',0),('shallowGreen',128),
-                    ('shallowBlue',128),('unused1',null1),('deepRed',0),('deepGreen',0),
-                    ('deepBlue',25),('unused2',null1),('reflRed',255),('reflGreen',255),
-                    ('reflBlue',255),('unused3',null1),('blend',50),('unused4',null3),('rainForce',0.1000),
-                    ('rainVelocity',0.6000),('rainFalloff',0.9850),('rainDampner',2.0000),
-                    ('rainSize',0.0100),('dispForce',0.4000),('dispVelocity', 0.6000),
-                    ('dispFalloff',0.9850),('dispDampner',10.0000),('dispSize',0.0500),('damage',0)),
+        MelFid('XNAM','effect'),
+        MelWatrData('DATA','10f3Bs3Bs3BsI32fH',('windVelocity',0.100),('windDirection',90.0),
+            ('waveAmp',0.5),('waveFreq',1.0),('sunPower',50.0),('reflectAmt',0.5),
+            ('fresnelAmt',0.0250),('unknown1',0.0),('fogNear',27852.8),('fogFar',163840.0),
+            ('shallowRed',0),('shallowGreen',128),('shallowBlue',128),('unused1',null1),
+            ('deepRed',0),('deepGreen',0),('deepBlue',25),('unused2',null1),
+            ('reflRed',255),('reflGreen',255),('reflBlue',255),('unused3',null1),
+            ('unknown2',0),
+            ('rainForce',0.1000),('rainVelocity',0.6000),('rainFalloff',0.9850),('rainDampner',2.0000),('rainSize',0.0100),
+            ('dispForce',0.4000),('dispVelocity', 0.6000),('dispFalloff',0.9850),('dispDampner',10.0000),('dispSize',0.0500),
+            ('noiseNormalsScale',1.8000),('noiseLayer1WindDirection',0.0000),('noiseLayer2WindDirection',-431602080.0500),
+            ('noiseLayer3WindDirection',-431602080.0500),('noiseLayer1WindVelocity',0.0000),
+            ('noiseLayer2WindVelocity',-431602080.0500),('noiseLayer3WindVelocity',-431602080.0500),
+            ('noiseNormalsDepthFalloffStart',0.00000),('noiseNormalsDepthFalloffEnd',0.10000),
+            ('fogAboveWaterAmount',1.00000),('noiseNormalsUvScale',500.00000),
+            ('fogUnderWaterAmount',1.00000),('fogUnderWaterNear',0.00000),('fogUnderWaterFar',1000.00000),
+            ('distortionAmount',250.00000),('shininess',100.00000),('reflectHdrMult',1.00000),
+            ('lightRadius',10000.00000),('lightBrightness',1.00000),
+            ('noiseLayer1UvScale',100.00000),('noiseLayer2UvScale',100.00000),('noiseLayer3UvScale',100.00000),
+            ('damage',0)),
+        MelWatrDnam('DNAM','10f3Bs3Bs3BsI35f',('windVelocity',0.100),('windDirection',90.0),
+            ('waveAmp',0.5),('waveFreq',1.0),('sunPower',50.0),('reflectAmt',0.5),
+            ('fresnelAmt',0.0250),('unknown1',0.0),('fogNear',27852.8),('fogFar',163840.0),
+            ('shallowRed',0),('shallowGreen',128),('shallowBlue',128),('unused1',null1),
+            ('deepRed',0),('deepGreen',0),('deepBlue',25),('unused2',null1),
+            ('reflRed',255),('reflGreen',255),('reflBlue',255),('unused3',null1),
+            ('unknown2',0),
+            ('rainForce',0.1000),('rainVelocity',0.6000),('rainFalloff',0.9850),('rainDampner',2.0000),('rainSize',0.0100),
+            ('dispForce',0.4000),('dispVelocity', 0.6000),('dispFalloff',0.9850),('dispDampner',10.0000),('dispSize',0.0500),
+            ('noiseNormalsScale',1.8000),('noiseLayer1WindDirection',0.0000),('noiseLayer2WindDirection',-431602080.0500),
+            ('noiseLayer3WindDirection',-431602080.0500),('noiseLayer1WindVelocity',0.0000),
+            ('noiseLayer2WindVelocity',-431602080.0500),('noiseLayer3WindVelocity',-431602080.0500),
+            ('noiseNormalsDepthFalloffStart',0.00000),('noiseNormalsDepthFalloffEnd',0.10000),
+            ('fogAboveWaterAmount',1.00000),('noiseNormalsUvScale',500.00000),
+            ('fogUnderWaterAmount',1.00000),('fogUnderWaterNear',0.00000),('fogUnderWaterFar',1000.00000),
+            ('distortionAmount',250.00000),('shininess',100.00000),('reflectHdrMult',1.00000),
+            ('lightRadius',10000.00000),('lightBrightness',1.00000),
+            ('noiseLayer1UvScale',100.00000),('noiseLayer2UvScale',100.00000),('noiseLayer3UvScale',100.00000),
+            ('noiseLayer1Amp',0.00000),('noiseLayer2Amp',0.00000),('noiseLayer3Amp',0.00000),
+            ),
         MelFidList('GNAM','relatedWaters'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3917,17 +4664,109 @@ class MreWeap(MelRecord):
     """Weapon record."""
     classType = 'WEAP'
     _flags = Flags(0L,Flags.getNames('notNormalWeapon'))
+    _dflags1 = Flags(0L,Flags.getNames(
+            'ignoresNormalWeaponResistance',
+            'isAutomatic',
+            'hasScope',
+            'cantDrop',
+            'hideBackpack',
+            'embeddedWeapon',
+            'dontUse1stPersonISAnimations',
+            'nonPlayable',
+        ))
+    _dflags2 = Flags(0L,Flags.getNames(
+            'playerOnly',
+            'npcsUseAmmo',
+            'noJamAfterReload',
+            'overrideActionPoint',
+            'minorCrime',
+            'rangeFixed',
+            'notUseInNormalCombat',
+            'overrideDamageToWeaponMult',
+            'dontUse3rdPersonISAnimations',
+            'shortBurst',
+            'RumbleAlternate',
+            'longBurst',
+            'unknown12','unknown13','unknown14','unknown15',
+            'unknown16','unknown17','unknown18','unknown19',
+            'unknown20','unknown21','unknown22','unknown23',
+            'unknown24','unknown25','unknown26','unknown27',
+            'unknown28','unknown29','unknown30','unknown31',
+        ))
+    _cflags = Flags(0L,Flags.getNames(
+            'onDeath',
+            'unknown1','unknown2','unknown3','unknown4',
+            'unknown5','unknown6','unknown7',
+        ))
+
+    class MelWeapDnam(MelStruct):
+        """Handle older trucated DNAM for WEAP subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 136:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 124:
+                #--Else 124 byte record (skips sightUsage, semiAutomaticFireDelayMin and semiAutomaticFireDelayMax...
+                unpacked = ins.unpack('Iff4B5fI4BffII11fIIffI',size,readId)
+            elif size == 120:
+                #--Else 120 byte record (skips resistType, sightUsage, semiAutomaticFireDelayMin and semiAutomaticFireDelayMax...
+                unpacked = ins.unpack('Iff4B5fI4BffII11fIIff',size,readId)
+            else:
+                raise "Unexpected size encountered for WEAP:DNAM subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+
     melSet = MelSet(
         MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
         MelString('FULL','full'),
-        MelModel(),
-        MelString('ICON','iconPath'),
+        MelModel('model'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
         MelFid('SCRI','script'),
-        MelFid('ENAM','enchantment'),
-        MelOptStruct('ANAM','H','enchantPoints'),
-        MelStruct('DATA','I2f3IfH','weaponType','speed','reach',(_flags,'flags',0L),
-            'value','health','weight','damage'),
-        #--weaponType = 0: Blade 1Hand, 1: Blade 2Hand, 2: Blunt 1Hand, 3: Blunt 2Hand, 4: Staff, 5: Bow
+        MelFid('EITM','effect'),
+        MelOptStruct('EAMT','H', 'enchantment'),
+        MelFid('NAM0','ammo'),
+        MelDestructible(),
+        MelFid('REPL','repairList'),
+        #0:bigGuns,1:energyWeapons,2:smallGuns,3:meleeWeapons,4:unarmedWeapon,5:thrownWeapons,6:mine,
+        MelStruct('ETYP','I','etype'),
+        MelFid('BIPL','bipedModelList'),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
+        MelModel('shellCasingModel',2),
+        MelModel('scopeModel',3),
+        MelFid('EFSD','scopeEffect'),
+        MelModel('worldModel',4),
+        MelString('NNAM','embeddedWeaponNode'),
+        MelFid('INAM','impactDataset'),
+        MelFid('WNAM','firstPersonModel'),
+        MelFid('SNAM','soundGunShot3D'),
+        MelFid('XNAM','soundGunShot2D'),
+        MelFid('NAM7','soundGunShot3DLooping'),
+        MelFid('TNAM','soundMeleeSwingGunNoAmmo'),
+        MelFid('NAM6','soundBlock'),
+        MelFid('UNAM','idle'),
+        MelFid('NAM9','equip'),
+        MelFid('NAM8','unequip'),
+        MelStruct('DATA','2IfHB','value','health','weight','damage','clipsize'),
+        MelWeapDnam('DNAM','Iff4B5fI4BffII11fIIffIfff',
+                    'animationType','animationMultiplier','reach',(_dflags1,'dnamFlags1',0L),
+                    'gripAnimation','ammoUse','reloadAnimation','minSpread','spread',
+                    'unknown','sightFov','unknown2',(FID,'projectile',0L),
+                    'baseVatsToHitChance','attackAnimation','projectileCount','embeddedWeaponActorValue','minRange','maxRange',
+                    'onHit',(_dflags2,'dnamFlags2',0L),'animationAttackMultiplier','fireRate','overrideActionPoint',
+                    'rumbleLeftMotorStrength','rumbleRightMotorStrength','rumbleDuration','overrideDamageToWeaponMult',
+                    'attackShotsPerSec','reloadTime','jamTime','aimArc','skill','rumblePattern','rambleWavelangth','limbDmgMult',
+                    ('resistType',0xFFFFFFFF),'sightUsage','semiAutomaticFireDelayMin','semiAutomaticFireDelayMax'),
+        MelStruct('CRDT','IfHI','criticalDamage','criticalMultiplier',(_cflags,'criticalFlags',0L),(FID,'criticalEffect',0L)),
+        MelBase('VNAM','soundLevel'),
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
@@ -3935,19 +4774,30 @@ class MreWeap(MelRecord):
 class MreWrld(MelRecord):
     """Worldspace record."""
     classType = 'WRLD'
-    _flags = Flags(0L,Flags.getNames('smallWorld','noFastTravel','oblivionWorldspace',None,'noLODWater'))
+    _flags = Flags(0L,Flags.getNames('smallWorld','noFastTravel','oblivionWorldspace',None,'noLODWater','noLODNoise','noAllowNPCFallDamage'))
     melSet = MelSet(
         MelString('EDID','eid'),
         MelString('FULL','full'),
+        MelFid('XEZN','encounterZone'),
         MelFid('WNAM','parent'),
+        MelOptStruct('PNAM','BB','parentFlags',('unknownff',0xff)),
         MelFid('CNAM','climate'),
         MelFid('NAM2','water'),
+        MelFid('NAM3','waterType'),
+        MelStruct('NAM4','f','waterHeight'),
+        MelStruct('DNAM','ff','defaultLandHeight','defaultWaterHeight'),
         MelString('ICON','mapPath'),
         MelOptStruct('MNAM','2i4h',('dimX',None),('dimY',None),('NWCellX',None),('NWCellY',None),('SECellX',None),('SECellY',None)),
+        MelStruct('ONAM','fff','worldMapScale','cellXOffset','cellYOffset'),
+        MelFid('INAM','imageSpace'),
         MelStruct('DATA','B',(_flags,'flags',0L)),
         MelTuple('NAM0','ff','unknown0',(None,None)),
         MelTuple('NAM9','ff','unknown9',(None,None)),
-        MelOptStruct('SNAM','I','sound'),
+        MelFid('ZNAM','music'),
+        MelString('NNAM','canopyShadow'),
+        MelString('XNAM','waterNoiseTexture'),
+        MelStructs('IMPS','III','swappedImpacts', 'materialType',(FID,'old'),(FID,'new')),
+        MelBase('IMPF','footstepMaterials'), #--todo rewrite specific class.
         MelBase('OFST','ofst_p'),
     )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
@@ -3958,20 +4808,26 @@ class MreWthr(MelRecord):
     classType = 'WTHR'
     melSet = MelSet(
         MelString('EDID','eid'),
-        MelString('CNAM','lowerLayer'),
+        MelFid("\x00IAD", 'sunriseImageSpaceModifier'),
+        MelFid("\x01IAD", 'dayImageSpaceModifier'),
+        MelFid("\x02IAD", 'sunsetImageSpaceModifier'),
+        MelFid("\x03IAD", 'nightImageSpaceModifier'),
         MelString('DNAM','upperLayer'),
+        MelString('CNAM','lowerLayer'),
+        MelString('ANAM','layer2'),
+        MelString('BNAM','layer3'),
         MelModel(),
-        MelStructA('NAM0','3Bs3Bs3Bs3Bs','colors','riseRed','riseGreen','riseBlue',('unused1',null1),
+        MelBase('LNAM','unknown1'),
+        MelStruct('ONAM','4B','cloudSpeed0','cloudSpeed1','cloudSpeed3','cloudSpeed4'),
+        MelBase('PNAM','_pnam'), #--RGB(3Bs) * 16?
+        MelStructA('NAM0','3Bs3Bs3Bs3Bs','colors',
+                   'riseRed','riseGreen','riseBlue',('unused1',null1),
                    'dayRed','dayGreen','dayBlue',('unused2',null1),
                    'setRed','setGreen','setBlue',('unused3',null1),
                    'nightRed','nightGreen','nightBlue',('unused4',null1),
                    ),
-        MelStruct('FNAM','4f','fogDayNear','fogDayFar','fogNightNear','fogNightFar'),
-        MelStruct('HNAM','14f',
-            'eyeAdaptSpeed', 'blurRadius', 'blurPasses', 'emissiveMult',
-            'targetLum', 'upperLumClamp', 'brightScale', 'brightClamp',
-            'lumRampNoTex', 'lumRampMin', 'lumRampMax', 'sunlightDimmer',
-            'grassDimmer', 'treeDimmer'),
+        MelStruct('FNAM','6f','fogDayNear','fogDayFar','fogNightNear','fogNightFar','fogDayPower','fogNightPower'),
+        MelBase('INAM','_inam'), #--Should be a struct. Maybe later.
         MelStruct('DATA','15B',
             'windSpeed','lowerCloudSpeed','upperCloudSpeed','transDelta',
             'sunGlare','sunDamage','rainFadeIn','rainFadeOut','boltFadeIn',
@@ -3980,957 +4836,1551 @@ class MreWthr(MelRecord):
         )
     __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-# MreRecord.type_class
-MreRecord.type_class = dict((x.classType,x) for x in (
-    MreAchr, MreAcre, MreActi, MreAlch, MreAmmo, MreAnio, MreAppa, MreArmo, MreBook, MreBsgn,
-    MreCell, MreClas, MreClot, MreCont, MreCrea, MreDoor, MreEfsh, MreEnch, MreEyes, MreFact,
-    MreFlor, MreFurn, MreGlob, MreGmst, MreGras, MreHair, MreIngr, MreKeym, MreLigh, MreLscr,
-    MreLvlc, MreLvli, MreLvsp, MreMgef, MreMisc, MreNpc,  MrePack, MreQust, MreRace, MreRefr,
-    MreRoad, MreScpt, MreSgst, MreSkil, MreSlgm, MreSoun, MreSpel, MreStat, MreTree, MreTes4,
-    MreWatr, MreWeap, MreWrld, MreWthr, MreClmt, MreCsty, MreIdle, MreLtex, MreRegn, MreSbsp,
-    MreDial, MreInfo
-    ))
-MreRecord.simpleTypes = (set(MreRecord.type_class) -
-    set(('TES4','ACHR','ACRE','REFR','CELL','PGRD','ROAD','LAND','WRLD','INFO','DIAL')))
-
-# Mod Blocks, File ------------------------------------------------------------
 #------------------------------------------------------------------------------
-class MasterMapError(BoltError):
-    """Attempt to map a fid when mapping does not exist."""
-    def __init__(self,modIndex):
-        BoltError.__init__(self,_('No valid mapping for mod index 0x%02X') % modIndex)
+class MreTxst(MelRecord):
+    """Texture set record."""
+    classType = 'TXST'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('TX00','baseImage'),
+        MelString('TX01','normalMap'),
+        MelString('TX02','environmentMapMask'),
+        MelString('TX03','growMap'),
+        MelString('TX04','parallaxMap'),
+        MelString('TX05','environmentMap'),
+        MelOptStruct('DODT','7fBB2s3Bs','minWidth','maxWidth','minHeight','maxHeight','depth','shininess',
+                     'parallaxScale','parallaxPasses','decalFlags',('unused1',null2),'red','green','blue',('unused2',null1)),
+        MelStruct('DNAM','H','flags'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
 #------------------------------------------------------------------------------
-class MasterMap:
-    """Serves as a map between two sets of masters."""
-    def __init__(self,inMasters,outMasters):
-        """Initiation."""
-        map = {}
-        outMastersIndex = outMasters.index
-        for index,master in enumerate(inMasters):
-            if master in outMasters:
-                map[index] = outMastersIndex(master)
-            else:
-                map[index] = -1
-        self.map = map
-
-    def __call__(self,fid,default=-1):
-        """Maps a fid from first set of masters to second. If no mapping
-        is possible, then either returns default (if defined) or raises MasterMapError."""
-        if not fid: return fid
-        inIndex = int(fid >> 24)
-        outIndex = self.map.get(inIndex,-2)
-        if outIndex >= 0:
-            return (long(outIndex) << 24 ) | (fid & 0xFFFFFFL)
-        elif default != -1:
-            return default
-        else:
-            raise MasterMapError(inIndex)
+class MreMicn(MelRecord):
+    """Menu icon record."""
+    classType = 'MICN'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
 #------------------------------------------------------------------------------
-class MasterSet(set):
-    """Set of master names."""
-
-    def add(self,element):
-        """Add an element it's not empty. Special handling for tuple."""
-        if isinstance(element,tuple):
-            set.add(self,element[0])
-        elif element:
-            set.add(self,element)
-
-    def getOrdered(self):
-        """Returns masters in proper load order."""
-        return list(modInfos.getOrdered(list(self)))
+class MreFlst(MelRecord):
+    """FormID list record."""
+    classType = 'FLST'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelFids('LNAM','fids'),
+        )
+    __slots__ = (MelRecord.__slots__ + melSet.getSlotsUsed() +
+        ['mergeOverLast','mergeSources','items','deflsts'])
 
-#------------------------------------------------------------------------------
-class LoadFactory:
-    """Factory for mod representation objects."""
-    def __init__(self,keepAll,*recClasses):
+    def __init__(self,header,ins=None,unpack=False):
         """Initialize."""
-        self.keepAll = keepAll
-        self.recTypes = set()
-        self.topTypes = set()
-        self.type_class = {}
-        self.cellType_class = {}
-        addClass = self.addClass
-        for recClass in recClasses:
-            addClass(recClass)
+        MelRecord.__init__(self,header,ins,unpack)
+        self.mergeOverLast = False #--Merge overrides last mod merged
+        self.mergeSources = None #--Set to list by other functions
+        self.items  = None #--Set of items included in list
+        self.deflsts = None #--Set of items deleted by list (Deflst mods)
 
-    def addClass(self,recClass):
-        """Adds specified class."""
-        cellTypes = ('WRLD','ROAD','CELL','REFR','ACHR','ACRE','PGRD','LAND')
-        if isinstance(recClass,str):
-            recType = recClass
-            recClass = MreRecord
+    def mergeFilter(self,modSet):
+        """Filter out items that don't come from specified modSet."""
+        if not self.longFids: raise StateError(_("Fids not in long format"))
+        self.fids = [fid for fid in self.fids if fid[0] in modSet]
+
+    def mergeWith(self,other,otherMod):
+        """Merges newLevl settings and entries with self.
+        Requires that: self.items, other.deflsts be defined."""
+        if not self.longFids: raise StateError(_("Fids not in long format"))
+        if not other.longFids: raise StateError(_("Fids not in long format"))
+        #--Remove items based on other.removes
+        if other.deflsts:
+            removeItems = self.items & other.deflsts
+            #self.entries = [entry for entry in self.entries if entry.listId not in removeItems]
+            self.fids = [fid for fid in self.fids if fid not in removeItems]
+            self.items = (self.items | other.deflsts)
+        hasOldItems = bool(self.items)
+        #--Add new items from other
+        newItems = set()
+        fidsAppend = self.fids.append
+        newItemsAdd = newItems.add
+        for fid in other.fids:
+            if fid not in self.items:
+                fidsAppend(fid)
+                newItemsAdd(fid)
+        if newItems:
+            self.items |= newItems
+            #self.fids.sort(key=attrgetter('level'))
+            self.fids.sort
+        #--Is merged list different from other? (And thus written to patch.)
+        if len(self.fids) != len(other.fids):
+            self.mergeOverLast = True
         else:
-            recType = recClass.classType
-        #--Don't replace complex class with default (MreRecord) class
-        if recType in self.type_class and recClass == MreRecord:
-            return
-        self.recTypes.add(recType)
-        self.type_class[recType] = recClass
-        #--Top type
-        if recType in cellTypes:
-            topAdd = self.topTypes.add
-            topAdd('CELL')
-            topAdd('WRLD')
-            if self.keepAll:
-                setterDefault = self.type_class.setdefault
-                for type in cellTypes:
-                    setterDefault(type,MreRecord)
-        elif recType == 'INFO':
-            self.topTypes.add('DIAL')
+            for selfEntry,otherEntry in zip(self.fids,other.fids):
+                if selfEntry != otherEntry:
+                    self.mergeOverLast = True
+                    break
+            else:
+                self.mergeOverLast = False
+        if self.mergeOverLast:
+            self.mergeSources.append(otherMod)
         else:
-            self.topTypes.add(recType)
-
-    def getRecClass(self,type):
-        """Returns class for record type or None."""
-        default = (self.keepAll and MreRecord) or None
-        return self.type_class.get(type,default)
-
-    def getCellTypeClass(self):
-        """Returns type_class dictionary for cell objects."""
-        if not self.cellType_class:
-            types = ('REFR','ACHR','ACRE','PGRD','LAND','CELL','ROAD')
-            getterRecClass = self.getRecClass
-            self.cellType_class.update((x,getterRecClass(x)) for x in types)
-        return self.cellType_class
+            self.mergeSources = [otherMod]
+        #--Done
+        self.setChanged()
 
-    def getUnpackCellBlocks(self,topType):
-        """Returns whether cell blocks should be unpacked or not. Only relevant
-        if CELL and WRLD top types are expanded."""
-        return (
-            self.keepAll or
-            (self.recTypes & set(('REFR','ACHR','ACRE','PGRD','LAND'))) or
-            (topType == 'WRLD' and 'LAND' in self.recTypes))
+#------------------------------------------------------------------------------
+class MrePerk(MelRecord):
+    """Perk record."""
+    classType = 'PERK'
+    class MelPerkData(MelStruct):
+        """Handle older trucated DATA for PERK subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 5:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 4:
+                unpacked = ins.unpack('BBBB',size,readId)
+            else:
+                raise "Unexpected size encountered for DATA subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked, record.flagsA.getTrueAttrs()
+    class MelPerkEffectData(MelBase):
+        def hasFids(self,formElements):
+            formElements.add(self)
+        def loadData(self,record,ins,type,size,readId):
+            target = MelObject()
+            record.__setattr__(self.attr,target)
+            if record.type == 0:
+                format,attrs = ('II',('quest','queststage'))
+            elif record.type == 1:
+                format,attrs = ('I',('ability',))
+            elif record.type == 2:
+                format,attrs = ('HB',('entrypoint','function'))
+            else:
+                raise ModError(ins.inName,_('Unexpected type: %d') % record.type)
+            unpacked = ins.unpack(format,size,readId)
+            setter = target.__setattr__
+            for attr,value in zip(attrs,unpacked):
+                setter(attr,value)
+            if self._debug: print unpacked
+        def dumpData(self,record,out):
+            target = record.__getattribute__(self.attr)
+            if not target: return
+            if record.type == 0:
+                format,attrs = ('II',('quest','queststage'))
+            elif record.type == 1:
+                format,attrs = ('I',('ability',))
+            elif record.type == 2:
+                format,attrs = ('HB',('entrypoint','function'))
+            else:
+                raise ModError(ins.inName,_('Unexpected type: %d') % record.type)
+            values = []
+            valuesAppend = values.append
+            getter = target.__getattribute__
+            for attr in attrs:
+                value = getter(attr)
+                valuesAppend(value)
+            try:
+                out.packSub(self.subType,format,*values)
+            except struct.error:
+                print self.subType,format,values
+                raise
+        def mapFids(self,record,function,save=False):
+            target = record.__getattribute__(self.attr)
+            if not target: return
+            if record.type == 0:
+                result = function(target.quest)
+                if save: target.quest = result
+            elif record.type == 1:
+                result = function(target.ability)
+                if save: target.ability = result
+    class MelPerkEffects(MelGroups):
+        def __init__(self,attr,*elements):
+            MelGroups.__init__(self,attr,*elements)
+        def setMelSet(self,melSet):
+            self.melSet = melSet
+            self.attrLoaders = {}
+            for element in melSet.elements:
+                attr = element.__dict__.get('attr',None)
+                if attr: self.attrLoaders[attr] = element
+        def loadData(self,record,ins,type,size,readId):
+            if type == 'DATA' or type == 'CTDA':
+                effects = record.__getattribute__(self.attr)
+                if not effects:
+                    if type == 'DATA':
+                        element = self.attrLoaders['_data']
+                    elif type == 'CTDA':
+                        element = self.attrLoaders['conditions']
+                    element.loadData(record,ins,type,size,readId)
+                    return
+            MelGroups.loadData(self,record,ins,type,size,readId)
+    class MelPerkEffectParams(MelGroups):
+        def loadData(self,record,ins,type,size,readId):
+            if type in ('EPFD','EPFT','EPF2','EPF3','SCHR'):
+                target = self.getDefault()
+                record.__getattribute__(self.attr).append(target)
+            else:
+                target = record.__getattribute__(self.attr)[-1]
+            element = self.loaders[type]
+            slots = ['recordType']
+            slots.extend(element.getSlotsUsed())
+            target.__slots__ = slots
+            target.recordType = type
+            element.loadData(target,ins,type,size,readId)
+        def dumpData(self,record,out):
+            for target in record.__getattribute__(self.attr):
+                element = self.loaders[target.recordType]
+                if not element:
+                    raise ModError(ins.inName,_('Unexpected type: %d') % target.recordType)
+                element.dumpData(target,out)
 
-    def getTopClass(self,type):
-        """Returns top block class for top block type, or None."""
-        if type in self.topTypes:
-            if   type == 'DIAL': return MobDials
-            elif type == 'CELL': return MobICells
-            elif type == 'WRLD': return MobWorlds
-            else: return MobObjects
-        elif self.keepAll:
-            return MobBase
-        else:
-            return None
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelString('FULL','full'),
+        MelString('DESC','description'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
+        MelConditions(),
+        MelGroup('_data',
+            MelPerkData('DATA', 'BBBBB', ('trait',0), ('minLevel',0), ('ranks',0), ('playable',0), ('hidden',0)),
+            ),
+        MelPerkEffects('effects',
+            MelStruct('PRKE', 'BBB', 'type', 'rank', 'priority'),
+            MelPerkEffectData('DATA','effectData'),
+            MelGroups('effectConditions',
+                MelStruct('PRKC', 'B', 'runOn'),
+                MelConditions(),
+            ),
+            MelPerkEffectParams('effectParams',
+                MelBase('EPFD', 'floats'), # [Float] or [Float,Float], todo rewrite specific class
+                MelStruct('EPFT','B','_epft'),
+                MelString('EPF2','buttonLabel'),
+                MelStruct('EPF3','H','scriptFlag'),
+                MelGroup('embeddedScript',
+                    MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+                    MelBase('SCDA','compiled_p'),
+                    MelString('SCTX','scriptText'),
+                    MelScrxen('SCRV/SCRO','references'),
+                ),
+            ),
+            MelBase('PRKF','footer'),
+            ),
+        )
+    melSet.elements[-1].setMelSet(melSet)
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
 #------------------------------------------------------------------------------
-class MobBase(object):
-    """Group of records and/or subgroups. This basic implementation does not
-    support unpacking, but can report its number of records and be written."""
+class MreExpl(MelRecord):
+    """Explosion record."""
+    classType = 'EXPL'
+    _flags = Flags(0,Flags.getNames('unknown1',
+                                    'alwaysUsesWorldOrientation',
+                                    'knockDownAlways',
+                                    'knockDownByFormular',
+                                    'IgnoreLosCheck',
+                                    'pushExplosionSourceRefOnly',
+                                    'ignoreImageSpaceSwap'))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelFid('EITM','objectEffect'),
+        MelFid('MNAM','imageSpaceModifier'),
+        MelStruct('DATA','fffIIHfIIfffI','force','damage','radius',(FID,'light',None),
+                  (FID,'sound1',None),(_flags,'flags'),'isRadius',(FID,'impactDataset',None),
+                  (FID,'sound2',None),'radiationLevel','radiationTime','radiationRadius','soundLevel'),
+        MelFid('INAM','placedImpactObject'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    __slots__=['size','label','groupType','stamp','debug','data','changed','numRecords','loadFactory','inName']
+#------------------------------------------------------------------------------
+class MreIpct(MelRecord):
+    """Impact record."""
+    classType = 'IPCT'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelModel(),
+        MelStruct('DATA','fIffII','effectDuration','effectOrientation','angleThreshold','placementRadius',
+                  'soundLevel','flags'),
+        MelOptStruct('DODT','7fBB2s3Bs','minWidth','maxWidth','minHeight','maxHeight','depth','shininess',
+                     'parallaxScale','parallaxPasses','decalFlags',('unused1',null2),'red','green','blue',('unused2',null1)),
+        MelFid('DNAM','textureSet'),
+        MelFid('SNAM','sound1'),
+        MelFid('NAM1','sound2'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def __init__(self,header,loadFactory,ins=None,unpack=False):
-        """Initialize."""
-        (grup, self.size, self.label, self.groupType, self.stamp) = header
-        self.debug = False
-        self.data = None
-        self.changed = False
-        self.numRecords = -1
-        self.loadFactory = loadFactory
-        self.inName = ins and ins.inName
-        if ins: self.load(ins,unpack)
+#------------------------------------------------------------------------------
+class MreIpds(MelRecord):
+    """Impact Dataset record."""
+    classType = 'IPDS'
+    class MelIpdsData(MelStruct):
+        """Handle older trucated DATA for IPDS subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 48:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 40:
+                unpacked = ins.unpack('10I',size,readId)
+            elif size == 36:
+                unpacked = ins.unpack('9I',size,readId)
+            else:
+                raise "Unexpected size encountered for IPDS:DATA subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelIpdsData('DATA','12I',(FID,'stone',0),(FID,'dirt',0),(FID,'grass',0),(FID,'metal',0),
+                    (FID,'wood',0),(FID,'organic',0),(FID,'cloth',0),(FID,'water',0),
+                    (FID,'hollowMetal',0),(FID,'organicBug',0),(FID,'organicGlow',0)),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def load(self,ins=None,unpack=False):
-        """Load data from ins stream or internal data buffer."""
-        if self.debug: print 'GRUP load:',self.label
-        #--Read, but don't analyze.
-        if not unpack:
-            self.data = ins.read(self.size-20,type)
-        #--Analyze ins.
-        elif ins is not None:
-            self.loadData(ins, ins.tell()+self.size-20)
-        #--Analyze internal buffer.
-        else:
-            reader = self.getReader()
-            self.loadData(reader,reader.size)
-            reader.close()
-        #--Discard raw data?
-        if unpack:
-            self.data = None
-            self.setChanged()
+#------------------------------------------------------------------------------
+class MreProj(MelRecord):
+    """Projectile record."""
+    classType = 'PROJ'
+    _flags = Flags(0,Flags.getNames('hitscan',
+                                    'explosive',
+                                    'altTriger',
+                                    'muzzleFlash',
+                                    'unknown4',
+                                    'canbeDisable',
+                                    'canbePickedUp',
+                                    'superSonic',
+                                    'pinsLimbs',
+                                    'passThroughSmallTransparent'))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelDestructible(),
+        MelStruct('DATA','HHfffIIfffIIfffIII',(_flags,'flags'),'type',
+                  ('gravity',0.00000),('speed',10000.00000),('range',10000.00000),
+                  (FID,'light',0),(FID,'muzzleFlash',0),('tracerChance',0.00000),
+                  ('explosionAltTrigerProximity',0.00000),('explosionAltTrigerTimer',0.00000),
+                  (FID,'explosion',0),(FID,'sound',0),('muzzleFlashDuration',0.00000),
+                  ('fadeDuration',0.00000),('impactForce',0.00000),
+                  (FID,'soundCountDown',0),(FID,'soundDisable',0),(FID,'defaultWeaponSource',0)),
+        MelString('NAM1','muzzleFlashPath'),
+        MelBase('NAM2','_nam2'), #--Should be a struct. Maybe later.
+        MelStruct('VNAM','I','soundLevel'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def loadData(self,ins,endPos):
-        """Loads data from input stream. Called by load()."""
-        raise AbstractError
+#------------------------------------------------------------------------------
+class MreDebr(MelRecord):
+    """Debris record."""
+    classType = 'DEBR'
+    class MelDebrData(MelStruct):
+        def __init__(self):
+            """Initialize."""
+            MelStruct.__init__(self,'DATA','IsI',('percentage',0),('modPath',null1),('flags',0))
+        def loadData(self,record,ins,type,size,readId):
+            """Reads data from ins into record attribute."""
+            data = ins.read(size,readId)
+            (record.percentage,) = struct.unpack('B',data[0:1])
+            record.modPath = data[1:-2]
+            if data[-2] != null1:
+                raise ModError(ins.inName,_('Unexpected subrecord: ')+readId)
+            (record.flags,) = struct.unpack('B',data[-1])
+        def dumpData(self,record,out):
+            """Dumps data from record to outstream."""
+            data = ''
+            data += struct.pack('B',record.percentage)
+            data += record.modPath
+            data += null1
+            data += struct.pack('B',record.flags)
+            out.packSub('DATA',data)
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelGroups('models',
+            MelDebrData(),
+            MelBase('MODT','modt_p'),
+        ),
+    )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def setChanged(self,value=True):
-        """Sets changed attribute to value. [Default = True.]"""
-        self.changed = value
+#------------------------------------------------------------------------------
+class MreImad(MelRecord):
+    """Image space modifier record."""
+    classType = 'IMAD'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelBase('DNAM','dnam_p'),
+        MelBase('BNAM','bnam_p'),
+        MelBase('VNAM','vnam_p'),
+        MelBase('TNAM','tnam_p'),
+        MelBase('NAM3','nam3_p'),
+        MelBase('RNAM','rnam_p'),
+        MelBase('SNAM','snam_p'),
+        MelBase('UNAM','unam_p'),
+        MelBase('NAM1','nam1_p'),
+        MelBase('NAM2','nam2_p'),
+        MelBase('WNAM','wnam_p'),
+        MelBase('XNAM','xnam_p'),
+        MelBase('YNAM','ynam_p'),
+        MelBase('NAM4','nam4_p'),
+        MelBase('aIAD','_aiad_p'),
+        MelBase('\x00IAD','_00iad_p'),
+        MelBase('@IAD','_atiad_p'),
+        MelBase('bIAD','_biad_p'),
+        MelBase('\x01IAD','_01iad_p'),
+        MelBase('AIAD','aiad_p'),
+        MelBase('cIAD','_ciad_p'),
+        MelBase('\x02IAD','_02iad_p'),
+        MelBase('BIAD','biad_p'),
+        MelBase('\x03IAD','_03iad_p'),
+        MelBase('dIAD','_diad_p'),
+        MelBase('CIAD','ciad_p'),
+        MelBase('\x04IAD','_04iad_p'),
+        MelBase('eIAD','_eiad_p'),
+        MelBase('DIAD','diad_p'),
+        MelBase('\x05IAD','_05iad_p'),
+        MelBase('fIAD','_fiad_p'),
+        MelBase('EIAD','eiad_p'),
+        MelBase('\x06IAD','_06iad_p'),
+        MelBase('gIAD','_giad_p'),
+        MelBase('FIAD','fiad_p'),
+        MelBase('\x07IAD','_07iad_p'),
+        MelBase('hIAD','_hiad_p'),
+        MelBase('GIAD','giad_p'),
+        MelBase('\x08IAD','_08iad_p'),
+        MelBase('iIAD','_iiad_p'),
+        MelBase('HIAD','hiad_p'),
+        MelBase('\x09IAD','_09iad_p'),
+        MelBase('jIAD','_jiad_p'),
+        MelBase('IIAD','iiad_p'),
+        MelBase('\x0aIAD','_0aiad_p'),
+        MelBase('kIAD','_kiad_p'),
+        MelBase('JIAD','jiad_p'),
+        MelBase('\x0bIAD','_0biad_p'),
+        MelBase('lIAD','_liad_p'),
+        MelBase('KIAD','kiad_p'),
+        MelBase('\x0cIAD','_0ciad_p'),
+        MelBase('mIAD','_miad_p'),
+        MelBase('LIAD','liad_p'),
+        MelBase('\x0dIAD','_0diad_p'),
+        MelBase('nIAD','_niad_p'),
+        MelBase('MIAD','miad_p'),
+        MelBase('\x0eIAD','_0eiad_p'),
+        MelBase('oIAD','_oiad_p'),
+        MelBase('NIAD','niad_p'),
+        MelBase('\x0fIAD','_0fiad_p'),
+        MelBase('pIAD','_piad_p'),
+        MelBase('OIAD','oiad_p'),
+        MelBase('\x10IAD','_10iad_p'),
+        MelBase('qIAD','_qiad_p'),
+        MelBase('PIAD','piad_p'),
+        MelBase('\x11IAD','_11iad_p'),
+        MelBase('rIAD','_riad_p'),
+        MelBase('QIAD','qiad_p'),
+        MelBase('\x12IAD','_12iad_p'),
+        MelBase('sIAD','_siad_p'),
+        MelBase('RIAD','riad_p'),
+        MelBase('\x13IAD','_13iad_p'),
+        MelBase('tIAD','_tiad_p'),
+        MelBase('SIAD','siad_p'),
+        MelBase('\x14IAD','_14iad_p'),
+        MelBase('uIAD','_uiad_p'),
+        MelBase('TIAD','tiad_p'),
+    )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getSize(self):
-        """Returns size (incuding size of any group headers)."""
-        if self.changed: raise AbstractError
-        return self.size
+#------------------------------------------------------------------------------
+class MreMstt(MelRecord):
+    """Moveable static record."""
+    classType = 'MSTT'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelDestructible(),
+        MelBase('DATA','data_p'),
+        MelFid('SNAM','sound'),
+    )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getNumRecords(self,includeGroups=True):
-        """Returns number of records, including self (if plusSelf), unless there's no
-        subrecords, in which case, it returns 0."""
-        if self.changed:
-            raise AbstractError
-        elif self.numRecords > -1: #--Cached value.
-            return self.numRecords
-        elif not self.data: #--No data >> no records, not even self.
-            self.numRecords = 0
-            return self.numRecords
-        else:
-            numSubRecords = 0
-            reader = self.getReader()
-            errLabel = bush.groupTypes[self.groupType]
-            readerAtEnd = reader.atEnd
-            readerRecHeader = reader.unpackRecHeader
-            readerSeek = reader.seek
-            while not readerAtEnd(reader.size,errLabel):
-                header = readerRecHeader()
-                type,size = header[0:2]
-                if type == 'GRUP': size = 0
-                readerSeek(size,1)
-                numSubRecords += 1
-            self.numRecords = numSubRecords + includeGroups
-            return self.numRecords
+#------------------------------------------------------------------------------
+class MreNote(MelRecord):
+    """Note record."""
+    classType = 'NOTE'
+    _type = Flags(0,Flags.getNames(
+            ( 0,'sound' ),
+            ( 1,'text' ),
+            ( 2,'image' ),
+            ( 3,'voice' ),
+            ))
+    class MelNoteTnam(MelBase):
+        """text or topic"""
+        def hasFids(self,formElements):
+            formElements.add(self)
+        def loadData(self,record,ins,type,size,readId):
+            if record.dataType == 1: # text (string)
+                value = ins.readString(size,readId)
+                record.__setattr__(self.attr, (False, value))
+            elif record.dataType == 3: # voice (fid:DIAL)
+                (value,) = ins.unpack('I',size,readId)
+                record.__setattr__(self.attr, (True, value))
+            else:
+                raise ModError(ins.inName,_('Unexpected type: %d') % record.type)
+            if self._debug: print unpacked
+        def dumpData(self,record,out):
+            value = record.__getattribute__(self.attr)
+            if value is None: return
+            (isFid, value) = value
+            if value is not None:
+                if record.dataType == 1: # text (string)
+                    out.packSub0(self.subType,value)
+                elif record.dataType == 3: # voice (fid:DIAL)
+                    out.packRef(self.subType,value)
+                else:
+                    raise ModError(ins.inName,_('Unexpected type: %d') % record.type)
+        def mapFids(self,record,function,save=False):
+            value = record.__getattribute__(self.attr)
+            if value is None: return
+            (isFid, value) = value
+            if isFid:
+                result = function(value)
+                if save: record.__setattr__(self.attr,(isFid,result))
+    class MelNoteSnam(MelBase):
+        """sound or npc"""
+        def hasFids(self,formElements):
+            formElements.add(self)
+        def loadData(self,record,ins,type,size,readId):
+            if record.dataType == 0: # sound (fid:SOUN)
+                (value,) = ins.unpack('I',size,readId)
+                record.__setattr__(self.attr, (True, value))
+            elif record.dataType == 3: # voice (fid:NPC_)
+                (value,) = ins.unpack('I',size,readId)
+                record.__setattr__(self.attr, (True, value))
+            else:
+                raise ModError(ins.inName,_('Unexpected type: %d') % record.type)
+            if self._debug: print unpacked
+        def dumpData(self,record,out):
+            value = record.__getattribute__(self.attr)
+            if value is None: return
+            (isFid, value) = value
+            if value is not None: out.packRef(self.subType,value)
+        def mapFids(self,record,function,save=False):
+            value = record.__getattribute__(self.attr)
+            if value is None: return
+            (isFid, value) = value
+            if isFid:
+                result = function(value)
+                if save: record.__setattr__(self.attr,(isFid,result))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
+        MelFid('YNAM','soundPickUp'),
+        MelFid('ZNAM','soundDrop'),
+        MelStruct('DATA','B','dataType'),
+        MelFidList('ONAM','quests'),
+        MelString('XNAM','texture'),
+        MelNoteTnam('TNAM', 'textTopic'),
+        MelNoteSnam('SNAM', 'soundNpc'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def dump(self,out):
-        """Dumps record header and data into output file stream."""
-        if self.changed:
-            raise AbstractError
-        if self.numRecords == -1:
-            self.getNumRecords()
-        if self.numRecords > 0:
-            out.pack('4sI4sII','GRUP',self.size,self.label,self.groupType,self.stamp)
-            out.write(self.data)
+#------------------------------------------------------------------------------
+class MreTerm(MelRecord):
+    """Terminal record."""
+    classType = 'TERM'
+    _flags = Flags(0L,Flags.getNames('leveled','unlocked','alternateColors','hideWellcomeTextWhenDisplayingImage'))
+    _menuFlags = Flags(0L,Flags.getNames('addNote','forceRedraw'))
+    _variableFlags = Flags(0L,Flags.getNames('isLongOrShort'))
+    class MelTermDnam(MelStruct):
+        """Handle older trucated DNAM for TERM subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 4:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 3:
+                unpacked = ins.unpack('BBB',size,readId)
+            else:
+                raise "Unexpected size encountered for TERM:DNAM subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelFid('SCRI','script'),
+        MelDestructible(),
+        MelString('DESC','description'),
+        MelFid('SNAM','soundLooping'),
+        MelFid('PNAM','passwordNote'),
+        MelTermDnam('DNAM','BBH','baseHackingDifficulty',(_flags,'flags'),'serverType'),
+        MelGroups('menuItems',
+            MelString('ITXT','itemText'),
+            MelString('RNAM','resultText'),
+            MelStruct('ANAM','B',(_menuFlags,'menuFlags')),
+            MelFid('INAM','displayNote'),
+            MelFid('TNAM','subMenu'),
+            MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+            MelBase('SCDA','compiled_p'),
+            MelString('SCTX','scriptText'),
+            MelGroups('vars',
+                MelStruct('SLSD','I12sB7s','index',('unused1',null4+null4+null4),(_variableFlags,'flags',0L),('unused2',null4+null3)),
+                MelString('SCVR','name')),
+            MelScrxen('SCRV/SCRO','references'),
+            MelConditions(),
+        ),
+    )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getReader(self):
-        """Returns a ModReader wrapped around self.data."""
-        return ModReader(self.inName,stringBuffer(self.data))
+#------------------------------------------------------------------------------
+class MreAvif(MelRecord):
+    """ActorValue Information record."""
+    classType = 'AVIF'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelString('FULL','full'),
+        MelString('DESC','description'),
+        MelString('ICON','largeIconPath'),
+        MelString('MICO','smallIconPath'),
+        MelString('ANAM','shortName'),
+    )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def convertFids(self,mapper,toLong):
-        """Converts fids between formats according to mapper.
-        toLong should be True if converting to long format or False if converting to short format."""
-        raise AbstractError
+#------------------------------------------------------------------------------
+class MreEczn(MelRecord):
+    """Encounter Zone record."""
+    classType = 'ECZN'
+    _flags = Flags(0L,Flags.getNames('neverResets','matchPCBelowMinimumLevel'))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('DATA','=I2b2B',(FID,'owner',None),'rank','minimumLevel',(_flags,'flags',0L),('unused1',null1)),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def updateRecords(self,block,mapper,toLong):
-        """Looks through all of the records in 'block', and updates any records in self that
-        exist with the data in 'block'."""
-        raise AbstractError
+#------------------------------------------------------------------------------
+class MreBptd(MelRecord):
+    """Body part data record."""
+    classType = 'BPTD'
+    _flags = Flags(0L,Flags.getNames('severable','ikData','ikBipedData','explodable','ikIsHead','ikHeadtracking','toHitChanceAbsolute'))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelModel(),
+        MelGroups('bodyParts',
+            MelString('BPTN','partName'),
+            MelString('BPNN','nodeName'),
+            MelString('BPNT','vatsTarget'),
+            MelString('BPNI','ikDataStartNode'),
+            MelStruct('BPND','f6BH2I2f3I7f2I2B2sf','damageMult',(_flags,'flags'),'partType','healthPercent','actorValue',
+                      'toHitChance','explodableChancePercent','explodableDebrisCount',(FID,'explodableDebris',0L),(FID,'explodableExplosion',0L),
+                      'trackingMaxAngle','explodableDebrisScale','severableDebrisCount',(FID,'severableDebris',0L),(FID,'severableExplosion',0L),
+                      'severableDebrisScale','goreEffectPosTransX','goreEffectPosTransY','goreEffectPosTransZ',
+                      'goreEffectPosRotX','goreEffectPosRotY','goreEffectPosRotZ',(FID,'severableImpactDataSet',0L),(FID,'explodableImpactDataSet',0L),
+                      'severableDecalCount','explodableDecalCount',('unused',null2),'limbReplacementScale'),
+            MelString('NAM1','limbReplacementModel'),
+            MelString('NAM4','goreEffectsTargetBone'),
+            MelBase('NAM5','endMarker'),
+            ),
+        MelFid('RAGA','ragdoll'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
 #------------------------------------------------------------------------------
-class MobObjects(MobBase):
-    """Represents a top level group consisting of one type of record only. I.e.
-    all top groups except CELL, WRLD and DIAL."""
+class MreVtyp(MelRecord):
+    """Voice type record."""
+    classType = 'VTYP'
+    _flags = Flags(0L,Flags.getNames('allowDefaultDialog','female'))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('DNAM','B',(_flags,'flags')),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def __init__(self,header,loadFactory,ins=None,unpack=False):
-        """Initialize."""
-        self.records = []
-        self.id_records = {}
-        MobBase.__init__(self,header,loadFactory,ins,unpack)
+#------------------------------------------------------------------------------
+class MreMusc(MelRecord):
+    """Music type record."""
+    classType = 'MUSC'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelString('FNAM','filename'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def loadData(self,ins,endPos):
-        """Loads data from input stream. Called by load()."""
-        debug = self.debug
-        expType = self.label
-        recClass = self.loadFactory.getRecClass(expType)
-        errLabel = expType+' Top Block'
-        records = self.records
-        insAtEnd = ins.atEnd
-        insRecHeader = ins.unpackRecHeader
-        recordsAppend = records.append
-        while not insAtEnd(endPos,errLabel):
-            #--Get record info and handle it
-            header = insRecHeader()
-            recType = header[0]
-            if recType != expType:
-                raise ModError(ins.inName,_('Unexpected %s record in %s group.')
-                    % (recType,expType))
-            record = recClass(header,ins,True)
-            recordsAppend(record)
-        self.setChanged()
+#------------------------------------------------------------------------------
+class MrePwat(MelRecord):
+    """Placeable water record."""
+    classType = 'PWAT'
+    _flags = Flags(0L,Flags.getNames(
+        ( 0,'reflects'),
+        ( 1,'reflectsActers'),
+        ( 2,'reflectsLand'),
+        ( 3,'reflectsLODLand'),
+        ( 4,'reflectsLODBuildings'),
+        ( 5,'reflectsTrees'),
+        ( 6,'reflectsSky'),
+        ( 7,'reflectsDynamicObjects'),
+        ( 8,'reflectsDeadBodies'),
+        ( 9,'reflects2'),
+        (10,'reflects2Actors'),
+        (11,'reflects2Lands'),
+        (16,'reflects2DynamicObjects'),
+        (17,'reflects2DeadBodies'),
+        (18,'silhouetteReflections'),
+        (28,'depth'),
+        (29,'objectTextureCoordinates'),
+        (31,'noUnderwaterFog'),
+        ))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelModel(),
+        MelStruct('DNAM','2I',(_flags,'flags'),(FID,'water'))
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getActiveRecords(self,getIgnored=True,getDeleted=True):
-        """Returns non-ignored records."""
-        return [record for record in self.records if not record.flags1.ignored]
+#------------------------------------------------------------------------------
+class MreAspc(MelRecord):
+    """Acoustic space record."""
+    classType = 'ASPC'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelFid('SNAM','soundLooping'),
+        MelFid('RDAT','useSoundFromRegion'),
+        MelStruct('ANAM','I','environmentType'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getNumRecords(self,includeGroups=True):
-        """Returns number of records, including self."""
-        numRecords = len(self.records)
-        if numRecords: numRecords += includeGroups #--Count self
-        self.numRecords = numRecords
-        return numRecords
-
-    def getSize(self):
-        """Returns size (incuding size of any group headers)."""
-        if not self.changed:
-            return self.size
-        else:
-            return 20 + sum((20 + record.getSize()) for record in self.records)
-
-    def dump(self,out):
-        """Dumps group header and then records."""
-        if not self.changed:
-            out.pack('4sI4sII','GRUP',self.size,self.label,0,self.stamp)
-            out.write(self.data)
-        else:
-            size = self.getSize()
-            if size == 20: return
-            out.pack('4sI4sII','GRUP',size,self.label,0,self.stamp)
-            for record in self.records:
-                record.dump(out)
+#------------------------------------------------------------------------------
+class MreHdpt(MelRecord):
+    """Head part record."""
+    classType = 'HDPT'
+    _flags = Flags(0L,Flags.getNames('playable',))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelString('FULL','full'),
+        MelModel(),
+        MelStruct('DATA','B',(_flags,'flags')),
+        MelFids('HNAM','extraParts'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def updateMasters(self,masters):
-        """Updates set of master names according to masters actually used."""
-        for record in self.records:
-            record.updateMasters(masters)
+#------------------------------------------------------------------------------
+class MreDobj(MelRecord):
+    """Default object manager record."""
+    classType = 'DOBJ'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('DATA','21I',(FID,'stimpack'),(FID,'superStimpack'),(FID,'radX'),(FID,'radAway'),
+            (FID,'morphine'),(FID,'perkParalysis'),(FID,'playerFaction'),(FID,'mysteriousStrangerNpc'),
+            (FID,'mysteriousStrangerFaction'),(FID,'defaultMusic'),(FID,'battleMusic'),(FID,'deathMusic'),
+            (FID,'successMusic'),(FID,'levelUpMusic'),(FID,'playerVoiceMale'),(FID,'playerVoiceMaleChild'),
+            (FID,'playerVoiceFemale'),(FID,'playerVoiceFemaleChild'),(FID,'eatPackageDefaultFood'),
+            (FID,'everyActorAbility'),(FID,'drugWearsOffImageSpace'),),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def convertFids(self,mapper,toLong):
-        """Converts fids between formats according to mapper.
-        toLong should be True if converting to long format or False if converting to short format."""
-        for record in self.records:
-            record.convertFids(mapper,toLong)
-        self.id_records.clear()
+#------------------------------------------------------------------------------
+class MreIdlm(MelRecord):
+    """Idle marker record."""
+    classType = 'IDLM'
+    class MelIdlmIdlc(MelStruct):
+        """Handle older trucated IDLC for IDLM subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size == 4:
+                MelStruct.loadData(self,record,ins,type,size,readId)
+                return
+            elif size == 1:
+                unpacked = ins.unpack('B',size,readId)
+            else:
+                raise "Unexpected size encountered for TERM:DNAM subrecord: %s" % size
+            unpacked += self.defaults[len(unpacked):]
+            setter = record.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelStruct('IDLF','B','flags'),
+        MelIdlmIdlc('IDLC','B3s','animationCount',('unused',null3)),
+        MelStruct('IDLT','f','idleTimerSetting'),
+        MelFidList('IDLA','animations'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def indexRecords(self):
-        """Indexes records by fid."""
-        self.id_records.clear()
-        for record in self.records:
-            self.id_records[record.fid] = record
+#------------------------------------------------------------------------------
+class MreArma(MelRecord):
+    """Armor addon record."""
+    classType = 'ARMA'
+    _flags = MelBipedFlags(0L,Flags.getNames())
+    _generalFlags = Flags(0L,Flags.getNames(
+        (5,'powerArmor'),
+        (6,'notPlayable'),
+        (7,'heavyArmor')
+    ))
+    _etype = Flags(0L,Flags.getNames(
+        'alcohol','bigGuns','bodyWear','chems','energyWeapons','food','handWear','headWear',
+        'meleeWeapons','mine','none','smallGuns','stimpack','thrownWeapons','unarmedWeapon'
+    ))
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelStruct('BMDT','=2I',(_flags,'bipedFlags',0L),(_generalFlags,'generalFlags',0L)),
+        MelModel('maleBody'),
+        MelModel('maleWorld',2),
+        MelString('ICON','maleLargeIconPath'),
+        MelString('MICO','maleSmallIconPath'),
+        MelModel('femaleBody',3),
+        MelModel('femaleWorld',4),
+        MelString('ICO2','femaleLargeIconPath'),
+        MelString('MIC2','femaleSmallIconPath'),
+        MelStruct('ETYP','I',(_etype,'etype',0L)),
+        MelStruct('DATA','IIf','value','health','weight'),
+        MelStruct('DNAM','HH','ar','flags'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getRecord(self,fid,default=None):
-        """Gets record with corresponding id.
-        If record doesn't exist, returns None."""
-        if not self.records: return default
-        if not self.id_records: self.indexRecords()
-        return self.id_records.get(fid,default)
+#------------------------------------------------------------------------------
+class MreTact(MelRecord):
+    """Talking activator record."""
+    classType = 'TACT'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('OBND','=6h',
+                  'corner0X','corner0Y','corner0Z',
+                  'corner1X','corner1Y','corner1Z'),
+        MelString('FULL','full'),
+        MelModel('model'),
+        MelFid('SCRI','script'),
+        MelDestructible(),
+        MelFid('SNAM','sound'),
+        MelFid('VNAM','voiceType'),
+        )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def getRecordByEid(self,eid,default=None):
-        """Gets record by eid, or returns default."""
-        if not self.records: return default
-        for record in self.records:
-            if record.eid == eid:
-                return record
-        else:
-            return default
 
-    def setRecord(self,record):
-        """Adds record to record list and indexed."""
-        if self.records and not self.id_records:
-            self.indexRecords()
-        fid = record.fid
-        if fid in self.id_records:
-            oldRecord = self.id_records[fid]
-            index = self.records.index(oldRecord)
-            self.records[index] = record
-        else:
-            self.records.append(record)
-        self.id_records[fid] = record
+#------------------------------------------------------------------------------
+class MreNavm(MelRecord):
+    """Navigation Mesh."""
+    classType = 'NAVM'
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('NVER','I',('version',11)),
+        MelStruct('DATA','I5I',(FID,'cell'),'vertexCount','triangleCount','enternalConnectionsCount','nvcaCount','doorsCount'),
+        MelStructA('NVVX','3f','vertices','vertexX','vertexY','vertexZ'),
+        MelStructA('NVTR','6hI','triangles','vertex0','vertex1','vertex2','triangle0','triangle1','triangle2','flags'),
+        MelOptStruct('NVCA','h','nvca_p'),
+        MelStructA('NVDP','II','doors',(FID,'doorReference'),'doorUnknown'),
+        MelBase('NVGD','nvgd_p'),
+        MelStructA('NVEX','=IIH','externalConnections','nvexUnknown',(FID,'navigationMesh'),'triangle'),
+       )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def keepRecords(self,keepIds):
-        """Keeps records with fid in set keepIds. Discards the rest."""
-        self.records = [record for record in self.records if record.fid in keepIds]
-        self.id_records.clear()
-        self.setChanged()
+#------------------------------------------------------------------------------
+class MreNavi(MelRecord):
+    """Navigation Mesh Info Map."""
+    classType = 'NAVI'
+    class MelNaviNvmi(MelStructs):
+        """Handle older trucated NVMI for NAVI subrecord."""
+        def loadData(self,record,ins,type,size,readId):
+            if size <= 16:
+                raise "Unexpected size encountered for NAVI subrecord: %s" % size
+            format = '4s2I2H %ds'%(size-16)
+            target = self.getDefault()
+            record.__getattribute__(self.attr).append(target)
+            target.__slots__ = self.attrs
+            unpacked = ins.unpack(format,size,readId)
+            setter = target.__setattr__
+            for attr,value,action in zip(self.attrs,unpacked,self.actions):
+                if callable(action): value = action(value)
+                setter(attr,value)
+            if self._debug: print unpacked, target.flags.getTrueAttrs()
+        def dumpData(self,record,out):
+            """Dumps data from record to outstream."""
+            for target in record.__getattribute__(self.attr):
+                format = '4s2I2H %ds'%len(target.unknown2)
+                values = []
+                valuesAppend = values.append
+                getter = target.__getattribute__
+                for attr,action in zip(self.attrs,self.actions):
+                    value = getter(attr)
+                    if action: value = value.dump()
+                    valuesAppend(value)
+                try:
+                    out.packSub(self.subType,format,*values)
+                except struct.error:
+                    print self.subType,format,values
+                    raise
+    melSet = MelSet(
+        MelString('EDID','eid'),
+        MelStruct('NVER','I',('version',11)),
+        MelNaviNvmi('NVMI','','unknowns',
+                   'unknown1',(FID,'navigationMesh'),(FID,'location'),'gridX','gridY','unknown2'),
+       )
+    __slots__ = MelRecord.__slots__ + melSet.getSlotsUsed()
 
-    def updateRecords(self,srcBlock,mapper,mergeIds):
-        """Looks through all of the records in 'srcBlock', and updates any records in self that
-        exist within the data in 'block'."""
-        fids = set([record.fid for record in self.records])
-        for record in srcBlock.getActiveRecords():
-            if mapper(record.fid) in fids:
-                record = record.getTypeCopy(mapper)
-                self.setRecord(record)
-                mergeIds.discard(record.fid)
+#------------------------------------------------------------------------------
+# MreRecord.type_class
+MreRecord.type_class = dict((x.classType,x) for x in (
+    MreAchr, MreAcre, MreActi, MreAlch, MreAmmo, MreAnio, MreAppa, MreArmo, MreBook, MreBsgn,
+    MreCell, MreClas, MreClot, MreCont, MreCrea, MreDoor, MreEfsh, MreEnch, MreEyes, MreFact,
+    MreFlor, MreFurn, MreGlob, MreGmst, MreGras, MreHair, MreIngr, MreKeym, MreLigh, MreLscr,
+    MreLvlc, MreLvli, MreLvsp, MreMgef, MreMisc, MreNpc,  MrePack, MreQust, MreRace, MreRefr,
+    MreRoad, MreScpt, MreSgst, MreSkil, MreSlgm, MreSoun, MreSpel, MreStat, MreTree, MreTes4,
+    MreWatr, MreWeap, MreWrld, MreWthr, MreClmt, MreCsty, MreIdle, MreLtex, MreRegn, MreSbsp,
+    MreDial, MreInfo, MreTxst, MreMicn, MreFlst, MrePerk, MreExpl, MreIpct, MreIpds, MreProj,
+    MreLvln, MreDebr, MreImad, MreMstt, MreNote, MreTerm, MreAvif, MreEczn, MreBptd, MreVtyp,
+    MreMusc, MrePwat, MreAspc, MreHdpt, MreDobj, MreIdlm, MreArma, MreTact, MreNavm))
+MreRecord.simpleTypes = (set(MreRecord.type_class) -
+    set(('TES4','ACHR','ACRE','REFR','CELL','PGRD','ROAD','LAND','WRLD','INFO','DIAL','PGRE','NAVM')))
 
+# Mod Blocks, File ------------------------------------------------------------
 #------------------------------------------------------------------------------
-class MobDials(MobObjects):
-    """DIAL top block of mod file."""
+class MasterMapError(BoltError):
+    """Attempt to map a fid when mapping does not exist."""
+    def __init__(self,modIndex):
+        BoltError.__init__(self,_('No valid mapping for mod index 0x%02X') % modIndex)
 
-    def loadData(self,ins,endPos):
-        """Loads data from input stream. Called by load()."""
-        expType = self.label
-        recClass = self.loadFactory.getRecClass(expType)
-        errLabel = expType+' Top Block'
-        records = self.records
-        insAtEnd = ins.atEnd
-        insRecHeader = ins.unpackRecHeader
-        recordsAppend = records.append
-        loadGetRecClass = self.loadFactory.getRecClass
-        while not insAtEnd(endPos,errLabel):
-            #--Get record info and handle it
-            header = insRecHeader()
-            recType = header[0]
-            if recType == expType:
-                record = recClass(header,ins,True)
-                recordLoadInfos = record.loadInfos
-                recordsAppend(record)
-            elif recType == 'GRUP':
-                (recType,size,label,groupType,stamp) = header
-                if groupType == 7:
-                    record.infoStamp = stamp
-                    infoClass = loadGetRecClass('INFO')
-                    recordLoadInfos(ins,ins.tell()+size-20,infoClass)
-                else:
-                    raise ModError(self.inName,'Unexpected subgroup %d in DIAL group.' % groupType)
+#------------------------------------------------------------------------------
+class MasterMap:
+    """Serves as a map between two sets of masters."""
+    def __init__(self,inMasters,outMasters):
+        """Initiation."""
+        map = {}
+        outMastersIndex = outMasters.index
+        for index,master in enumerate(inMasters):
+            if master in outMasters:
+                map[index] = outMastersIndex(master)
             else:
-                raise ModError(self.inName,_('Unexpected %s record in %s group.')
-                    % (recType,expType))
-        self.setChanged()
+                map[index] = -1
+        self.map = map
 
-    def getSize(self):
-        """Returns size of records plus group and record headers."""
-        if not self.changed:
-            return self.size
-        size = 20
-        for record in self.records:
-            size += 20 + record.getSize()
-            if record.infos:
-                size += 20 + sum(20+info.getSize() for info in record.infos)
-        return size
+    def __call__(self,fid,default=-1):
+        """Maps a fid from first set of masters to second. If no mapping
+        is possible, then either returns default (if defined) or raises MasterMapError."""
+        if not fid: return fid
+        inIndex = int(fid >> 24)
+        outIndex = self.map.get(inIndex,-2)
+        if outIndex >= 0:
+            return (long(outIndex) << 24 ) | (fid & 0xFFFFFFL)
+        elif default != -1:
+            return default
+        else:
+            raise MasterMapError(inIndex)
 
-    def getNumRecords(self,includeGroups=1):
-        """Returns number of records, including self plus info records."""
-        self.numRecords = (
-            len(self.records) + includeGroups*bool(self.records) +
-            sum((includeGroups + len(x.infos)) for x in self.records if x.infos)
-            )
-        return self.numRecords
+#------------------------------------------------------------------------------
+class MasterSet(set):
+    """Set of master names."""
 
-#-------------------------------------------------------------------------------
-class MobCell(MobBase):
-    """Represents cell block structure -- including the cell and all subrecords."""
+    def add(self,element):
+        """Add an element it's not empty. Special handling for tuple."""
+        if isinstance(element,tuple):
+            set.add(self,element[0])
+        elif element:
+            set.add(self,element)
 
-    __slots__ = MobBase.__slots__ + ['cell','persistent','distant','temp','land','pgrd']
+    def getOrdered(self):
+        """Returns masters in proper load order."""
+        return list(modInfos.getOrdered(list(self)))
 
-    def __init__(self,header,loadFactory,cell,ins=None,unpack=False):
+#------------------------------------------------------------------------------
+class LoadFactory:
+    """Factory for mod representation objects."""
+    def __init__(self,keepAll,*recClasses):
         """Initialize."""
-        self.cell=cell
-        self.persistent=[]
-        self.distant=[]
-        self.temp=[]
-        self.land=None
-        self.pgrd=None
-        MobBase.__init__(self,header,loadFactory,ins,unpack)
+        self.keepAll = keepAll
+        self.recTypes = set()
+        self.topTypes = set()
+        self.type_class = {}
+        self.cellType_class = {}
+        addClass = self.addClass
+        for recClass in recClasses:
+            addClass(recClass)
 
-    def loadData(self,ins,endPos):
-        """Loads data from input stream. Called by load()."""
-        cellType_class = self.loadFactory.getCellTypeClass()
-        persistent,temp,distant = self.persistent,self.temp,self.distant
-        insAtEnd = ins.atEnd
-        insRecHeader = ins.unpackRecHeader
-        cellGet = cellType_class.get
-        persistentAppend = persistent.append
-        tempAppend = temp.append
-        distantAppend = distant.append
-        insSeek = ins.seek
-        while not insAtEnd(endPos,'Cell Block'):
-            subgroupLoaded=[False,False,False]
-            header=insRecHeader()
-            recType=header[0]
-            recClass = cellGet(recType)
-            if recType == 'GRUP':
-                groupType=header[3]
-                if groupType not in (8, 9, 10):
-                    raise ModError(self.inName,'Unexpected subgroup %d in cell children group.' % groupType)
-                if subgroupLoaded[groupType - 8]:
-                    raise ModError(self.inName,'Extra subgroup %d in cell children group.' % groupType)
-                else:
-                    subgroupLoaded[groupType - 8] = True
-            elif recType not in cellType_class:
-                raise ModError(self.inName,'Unexpected %s record in cell children group.' % recType)
-            elif not recClass:
-                insSeek(header[1],1)
-            elif recType in ('REFR','ACHR','ACRE'):
-                record = recClass(header,ins,True)
-                if   groupType ==  8: persistentAppend(record)
-                elif groupType ==  9: tempAppend(record)
-                elif groupType == 10: distantAppend(record)
-            elif recType == 'LAND':
-                self.land=recClass(header,ins,False)
-            elif recType == 'PGRD':
-                self.pgrd=recClass(header,ins,False)
-        self.setChanged()
+    def addClass(self,recClass):
+        """Adds specified class."""
+        cellTypes = ('WRLD','ROAD','CELL','REFR','ACHR','ACRE','PGRD','LAND','PGRE','NAVM')
+        if isinstance(recClass,str):
+            recType = recClass
+            recClass = MreRecord
+        else:
+            recType = recClass.classType
+        #--Don't replace complex class with default (MreRecord) class
+        if recType in self.type_class and recClass == MreRecord:
+            return
+        self.recTypes.add(recType)
+        self.type_class[recType] = recClass
+        #--Top type
+        if recType in cellTypes:
+            topAdd = self.topTypes.add
+            topAdd('CELL')
+            topAdd('WRLD')
+            if self.keepAll:
+                setterDefault = self.type_class.setdefault
+                for type in cellTypes:
+                    setterDefault(type,MreRecord)
+        elif recType == 'INFO':
+            self.topTypes.add('DIAL')
+        else:
+            self.topTypes.add(recType)
 
-    def getSize(self):
-        """Returns size (incuding size of any group headers)."""
-        return 20 + self.cell.getSize() + self.getChildrenSize()
+    def getRecClass(self,type):
+        """Returns class for record type or None."""
+        default = (self.keepAll and MreRecord) or None
+        return self.type_class.get(type,default)
 
-    def getChildrenSize(self):
-        """Returns size of all childen, including the group header.  This does not include the cell itself."""
-        size = self.getPersistentSize() + self.getTempSize() + self.getDistantSize()
-        return size + 20*bool(size)
+    def getCellTypeClass(self):
+        """Returns type_class dictionary for cell objects."""
+        if not self.cellType_class:
+            types = ('REFR','ACHR','ACRE','PGRD','LAND','CELL','ROAD','PGRE','NAVM')
+            getterRecClass = self.getRecClass
+            self.cellType_class.update((x,getterRecClass(x)) for x in types)
+        return self.cellType_class
 
-    def getPersistentSize(self):
-        """Returns size of all persistent children, including the persistent children group."""
-        size = sum(20 + x.getSize() for x in self.persistent)
-        return size + 20*bool(size)
+    def getUnpackCellBlocks(self,topType):
+        """Returns whether cell blocks should be unpacked or not. Only relevant
+        if CELL and WRLD top types are expanded."""
+        return (
+            self.keepAll or
+            (self.recTypes & set(('REFR','ACHR','ACRE','PGRD','LAND','PGRE','NAVM'))) or
+            (topType == 'WRLD' and 'LAND' in self.recTypes))
 
-    def getTempSize(self):
-        """Returns size of all temporary children, including the temporary children group."""
-        size = sum(20 + x.getSize() for x in self.temp)
-        if self.pgrd: size += 20 + self.pgrd.getSize()
-        if self.land: size += 20 + self.land.getSize()
-        return size + 20*bool(size)
+    def getTopClass(self,type):
+        """Returns top block class for top block type, or None."""
+        if type in self.topTypes:
+            if   type == 'DIAL': return MobDials
+            elif type == 'CELL': return MobICells
+            elif type == 'WRLD': return MobWorlds
+            else: return MobObjects
+        elif self.keepAll:
+            return MobBase
+        else:
+            return None
 
-    def getDistantSize(self):
-        """Returns size of all distant children, including the distant children group."""
-        size = sum(20 + x.getSize() for x in self.distant)
-        return size + 20*bool(size)
+#------------------------------------------------------------------------------
+class MobBase(object):
+    """Group of records and/or subgroups. This basic implementation does not
+    support unpacking, but can report its number of records and be written."""
 
-    def getNumRecords(self,includeGroups=True):
-        """Returns number of records, including self and all children."""
-        count = 1 + includeGroups # Cell GRUP and CELL record
-        if self.persistent:
-            count += len(self.persistent) + includeGroups
-        if self.temp or self.pgrd or self.land:
-            count += len(self.temp) + includeGroups
-            count += bool(self.pgrd) + bool(self.land)
-        if self.distant:
-            count += len(self.distant) + includeGroups
-        return count
+    __slots__=['size','label','groupType','stamp','stamp2','debug','data','changed','numRecords','loadFactory','inName']
 
-    def getBsb(self):
-        """Returns tesfile block and sub-block indices for cells in this group.
-        For interior cell, bsb is (blockNum,subBlockNum). For exterior cell, bsb is
-        ((blockX,blockY),(subblockX,subblockY))."""
-        cell = self.cell
-        #--Interior cell
-        if cell.flags.isInterior:
-            baseFid = cell.fid & 0x00FFFFFF
-            return (baseFid%10, baseFid%100//10)
-        #--Exterior cell
+    def __init__(self,header,loadFactory,ins=None,unpack=False):
+        """Initialize."""
+        (grup, self.size, self.label, self.groupType, self.stamp, self.stamp2) = header
+        self.debug = False
+        self.data = None
+        self.changed = False
+        self.numRecords = -1
+        self.loadFactory = loadFactory
+        self.inName = ins and ins.inName
+        if ins: self.load(ins,unpack)
+
+    def load(self,ins=None,unpack=False):
+        """Load data from ins stream or internal data buffer."""
+        if self.debug: print 'GRUP load:',self.label
+        #--Read, but don't analyze.
+        if not unpack:
+            self.data = ins.read(self.size-recHeaderSize,type)
+        #--Analyze ins.
+        elif ins is not None:
+            self.loadData(ins, ins.tell()+self.size-recHeaderSize)
+        #--Analyze internal buffer.
         else:
-            x,y = cell.posX,cell.posY
-            if x is None: x = 0
-            if y is None: y = 0
-            return ((x//32, y//32), (x//8, y//8))
+            reader = self.getReader()
+            self.loadData(reader,reader.size)
+            reader.close()
+        #--Discard raw data?
+        if unpack:
+            self.data = None
+            self.setChanged()
+
+    def loadData(self,ins,endPos):
+        """Loads data from input stream. Called by load()."""
+        raise AbstractError
+
+    def setChanged(self,value=True):
+        """Sets changed attribute to value. [Default = True.]"""
+        self.changed = value
+
+    def getSize(self):
+        """Returns size (incuding size of any group headers)."""
+        if self.changed: raise AbstractError
+        return self.size
+
+    def getNumRecords(self,includeGroups=True):
+        """Returns number of records, including self (if plusSelf), unless there's no
+        subrecords, in which case, it returns 0."""
+        if self.changed:
+            raise AbstractError
+        elif self.numRecords > -1: #--Cached value.
+            return self.numRecords
+        elif not self.data: #--No data >> no records, not even self.
+            self.numRecords = 0
+            return self.numRecords
+        else:
+            numSubRecords = 0
+            reader = self.getReader()
+            errLabel = bush.groupTypes[self.groupType]
+            readerAtEnd = reader.atEnd
+            readerRecHeader = reader.unpackRecHeader
+            readerSeek = reader.seek
+            while not readerAtEnd(reader.size,errLabel):
+                header = readerRecHeader()
+                type,size = header[0:2]
+                if type == 'GRUP': size = 0
+                readerSeek(size,1)
+                numSubRecords += 1
+            self.numRecords = numSubRecords + includeGroups
+            return self.numRecords
 
     def dump(self,out):
-        """Dumps group header and then records."""
-        self.cell.getSize()
-        self.cell.dump(out)
-        childrenSize = self.getChildrenSize()
-        if not childrenSize: return
-        out.writeGroup(childrenSize,self.cell.fid,6,self.stamp)
-        if self.persistent:
-            out.writeGroup(self.getPersistentSize(),self.cell.fid,8,self.stamp)
-            for record in self.persistent:
-                record.dump(out)
-        if self.temp or self.pgrd or self.land:
-            out.writeGroup(self.getTempSize(),self.cell.fid,9,self.stamp)
-            if self.pgrd:
-                self.pgrd.dump(out)
-            if self.land:
-                self.land.dump(out)
-            for record in self.temp:
-                record.dump(out)
-        if self.distant:
-            out.writeGroup(self.getDistantSize(),self.cell.fid,10,self.stamp)
-            for record in self.distant:
-                record.dump(out)
+        """Dumps record header and data into output file stream."""
+        if self.changed:
+            raise AbstractError
+        if self.numRecords == -1:
+            self.getNumRecords()
+        if self.numRecords > 0:
+            out.pack('4sI4sIII','GRUP',self.size,self.label,self.groupType,self.stamp,self.stamp2)
+            out.write(self.data)
+
+    def getReader(self):
+        """Returns a ModReader wrapped around self.data."""
+        return ModReader(self.inName,stringBuffer(self.data))
 
-    #--Fid manipulation, record filtering ----------------------------------
     def convertFids(self,mapper,toLong):
         """Converts fids between formats according to mapper.
         toLong should be True if converting to long format or False if converting to short format."""
-        self.cell.convertFids(mapper,toLong)
-        for record in self.temp:
-            record.convertFids(mapper,toLong)
-        for record in self.persistent:
-            record.convertFids(mapper,toLong)
-        for record in self.distant:
-            record.convertFids(mapper,toLong)
-        if self.land:
-            self.land.convertFids(mapper,toLong)
-        if self.pgrd:
-            self.pgrd.convertFids(mapper,toLong)
-
-    def updateMasters(self,masters):
-        """Updates set of master names according to masters actually used."""
-        self.cell.updateMasters(masters)
-        for record in self.persistent:
-            record.updateMasters(masters)
-        for record in self.distant:
-            record.updateMasters(masters)
-        for record in self.temp:
-            record.updateMasters(masters)
-        if self.land:
-            self.land.updateMasters(masters)
-        if self.pgrd:
-            self.pgrd.updateMasters(masters)
+        raise AbstractError
 
-    def updateRecords(self,srcBlock,mapper,mergeIds):
-        """Updates any records in 'self' that exist in 'srcBlock'."""
-        mergeDiscard = mergeIds.discard
-        selfGetter = self.__getattribute__
-        srcGetter = srcBlock.__getattribute__
-        selfSetter = self.__setattr__
-        for attr in ('cell','pgrd','land'):
-            myRecord = selfGetter(attr)
-            record = srcGetter(attr)
-            if myRecord and record:
-                if myRecord.fid != mapper(record.fid):
-                    raise ArgumentError("Fids don't match! %08x, %08x" % (myRecord.fid, record.fid))
-                if not record.flags1.ignored:
-                    record = record.getTypeCopy(mapper)
-                    selfSetter(attr,record)
-                    mergeDiscard(record.fid)
-        for attr in ('persistent','temp','distant'):
-            recordList = selfGetter(attr)
-            fids = dict((record.fid,index) for index,record in enumerate(recordList))
-            for record in srcGetter(attr):
-                if not record.flags1.ignored and mapper(record.fid) in fids:
-                    record = record.getTypeCopy(mapper)
-                    recordList[fids[record.fid]]=record
-                    mergeDiscard(record.fid)
-
-    def keepRecords(self,keepIds):
-        """Keeps records with fid in set keepIds. Discards the rest."""
-        if self.pgrd and self.pgrd.fid not in keepIds:
-            self.pgrd = None
-        if self.land and self.land.fid not in keepIds:
-            self.land = None
-        self.temp       = [x for x in self.temp if x.fid in keepIds]
-        self.persistent = [x for x in self.persistent if x.fid in keepIds]
-        self.distant    = [x for x in self.distant if x.fid in keepIds]
-        if self.pgrd or self.land or self.persistent or self.temp or self.distant:
-            keepIds.add(self.cell.fid)
-        self.setChanged()
-
-#-------------------------------------------------------------------------------
-class MobCells(MobBase):
-    """A block containing cells. Subclassed by MobWorld and MobICells.
-
-    Note that "blocks" here only roughly match the file block structure.
+    def updateRecords(self,block,mapper,toLong):
+        """Looks through all of the records in 'block', and updates any records in self that
+        exist with the data in 'block'."""
+        raise AbstractError
 
-    "Bsb" is a tuple of the file (block,subblock) labels. For interior cells, bsbs are tuples
-    of two numbers, while for exterior cells, bsb labels are tuples of grid tuples."""
+#------------------------------------------------------------------------------
+class MobObjects(MobBase):
+    """Represents a top level group consisting of one type of record only. I.e.
+    all top groups except CELL, WRLD and DIAL."""
 
     def __init__(self,header,loadFactory,ins=None,unpack=False):
         """Initialize."""
-        self.cellBlocks = [] #--Each cellBlock is a cell and it's related records.
-        self.id_cellBlock = {}
+        self.records = []
+        self.id_records = {}
         MobBase.__init__(self,header,loadFactory,ins,unpack)
 
-    def indexRecords(self):
-        """Indexes records by fid."""
-        self.id_cellBlock = dict((x.cell.fid,x) for x in self.cellBlocks)
+    def loadData(self,ins,endPos):
+        """Loads data from input stream. Called by load()."""
+        debug = self.debug
+        expType = self.label
+        recClass = self.loadFactory.getRecClass(expType)
+        errLabel = expType+' Top Block'
+        records = self.records
+        insAtEnd = ins.atEnd
+        insRecHeader = ins.unpackRecHeader
+        recordsAppend = records.append
+        while not insAtEnd(endPos,errLabel):
+            #--Get record info and handle it
+            header = insRecHeader()
+            recType = header[0]
+            if recType != expType:
+                raise ModError(ins.inName,_('Unexpected %s record in %s group.')
+                    % (recType,expType))
+            record = recClass(header,ins,True)
+            recordsAppend(record)
+        self.setChanged()
 
-    def setCell(self,cell):
-        """Adds record to record list and indexed."""
-        if self.cellBlocks and not self.id_cellBlock:
-            self.indexRecords()
-        fid = cell.fid
-        if fid in self.id_cellBlock:
-            self.id_cellBlock[fid].cell = cell
+    def getActiveRecords(self,getIgnored=True,getDeleted=True):
+        """Returns non-ignored records."""
+        return [record for record in self.records if not record.flags1.ignored]
+
+    def getNumRecords(self,includeGroups=True):
+        """Returns number of records, including self."""
+        numRecords = len(self.records)
+        if numRecords: numRecords += includeGroups #--Count self
+        self.numRecords = numRecords
+        return numRecords
+
+    def getSize(self):
+        """Returns size (incuding size of any group headers)."""
+        if not self.changed:
+            return self.size
         else:
-            cellBlock = MobCell(('GRUP',0,0,6,self.stamp),self.loadFactory,cell)
-            cellBlock.setChanged()
-            self.cellBlocks.append(cellBlock)
-            self.id_cellBlock[fid] = cellBlock
+            return recHeaderSize + sum((recHeaderSize + record.getSize()) for record in self.records)
 
-    def getUsedBlocks(self):
-        """Returns a set of blocks that exist in this group."""
-        return set(x.getBsb()[0] for x in self.cellBlocks)
+    def dump(self,out):
+        """Dumps group header and then records."""
+        if not self.changed:
+            out.pack('4sI4sIII','GRUP',self.size,self.label,0,self.stamp,self.stamp2)
+            out.write(self.data)
+        else:
+            size = self.getSize()
+            if size == recHeaderSize: return
+            out.pack('4sI4sIII','GRUP',size,self.label,0,self.stamp,self.stamp2)
+            for record in self.records:
+                record.dump(out)
 
-    def getUsedSubblocks(self):
-        """Returns a set of block/sub-blocks that exist in this group."""
-        return set(x.getBsb() for x in self.cellBlocks)
+    def updateMasters(self,masters):
+        """Updates set of master names according to masters actually used."""
+        for record in self.records:
+            record.updateMasters(masters)
 
-    def getBsbSizes(self):
-        """Returns the total size of the block, but also returns a dictionary containing the sizes
-        of the individual block,subblocks."""
-        bsbCellBlocks = [(x.getBsb(),x) for x in self.cellBlocks]
-        bsbCellBlocks.sort(key = lambda x: x[1].cell.fid)
-        bsbCellBlocks.sort(key = itemgetter(0))
-        bsb_size = {}
-        totalSize = 20
-        bsb_setDefault = bsb_size.setdefault
-        for bsb,cellBlock in bsbCellBlocks:
-            cellBlockSize = cellBlock.getSize()
-            totalSize += cellBlockSize
-            bsb0 = (bsb[0],None) #--Block group
-            bsb_setDefault(bsb0,20)
-            if bsb_setDefault(bsb,20) == 20:
-                bsb_size[bsb0] += 20
-            bsb_size[bsb] += cellBlockSize
-            bsb_size[bsb0] += cellBlockSize
-        totalSize += 20 * len(bsb_size)
-        return totalSize,bsb_size,bsbCellBlocks
+    def convertFids(self,mapper,toLong):
+        """Converts fids between formats according to mapper.
+        toLong should be True if converting to long format or False if converting to short format."""
+        for record in self.records:
+            record.convertFids(mapper,toLong)
+        self.id_records.clear()
 
-    def dumpBlocks(self,out,bsbCellBlocks,bsb_size,blockGroupType,subBlockGroupType):
-        """Dumps the cell blocks and their block and sub-block groups to out."""
-        curBlock = None
-        curSubblock = None
-        stamp = self.stamp
-        outWriteGroup = out.writeGroup
-        for bsb,cellBlock in bsbCellBlocks:
-            (block,subblock) = bsb
-            bsb0 = (block,None)
-            if block != curBlock:
-                curBlock,curSubblock = bsb0
-                outWriteGroup(bsb_size[bsb0],block,blockGroupType,stamp)
-            if subblock != curSubblock:
-                curSubblock = subblock
-                outWriteGroup(bsb_size[bsb],subblock,subBlockGroupType,stamp)
-            cellBlock.dump(out)
+    def indexRecords(self):
+        """Indexes records by fid."""
+        self.id_records.clear()
+        for record in self.records:
+            self.id_records[record.fid] = record
 
-    def getNumRecords(self,includeGroups=1):
-        """Returns number of records, including self and all children."""
-        count = sum(x.getNumRecords(includeGroups) for x in self.cellBlocks)
-        if count and includeGroups:
-            count += 1 + len(self.getUsedBlocks()) + len(self.getUsedSubblocks())
-        return count
+    def getRecord(self,fid,default=None):
+        """Gets record with corresponding id.
+        If record doesn't exist, returns None."""
+        if not self.records: return default
+        if not self.id_records: self.indexRecords()
+        return self.id_records.get(fid,default)
+
+    def getRecordByEid(self,eid,default=None):
+        """Gets record by eid, or returns default."""
+        if not self.records: return default
+        for record in self.records:
+            if record.eid == eid:
+                return record
+        else:
+            return default
+
+    def setRecord(self,record):
+        """Adds record to record list and indexed."""
+        if self.records and not self.id_records:
+            self.indexRecords()
+        fid = record.fid
+        if fid in self.id_records:
+            oldRecord = self.id_records[fid]
+            index = self.records.index(oldRecord)
+            self.records[index] = record
+        else:
+            self.records.append(record)
+        self.id_records[fid] = record
 
-    #--Fid manipulation, record filtering ----------------------------------
     def keepRecords(self,keepIds):
         """Keeps records with fid in set keepIds. Discards the rest."""
-        #--Note: this call will add the cell to keepIds if any of its related records are kept.
-        for cellBlock in self.cellBlocks: cellBlock.keepRecords(keepIds)
-        self.cellBlocks = [x for x in self.cellBlocks if x.cell.fid in keepIds]
-        self.id_cellBlock.clear()
+        self.records = [record for record in self.records if record.fid in keepIds]
+        self.id_records.clear()
         self.setChanged()
 
-    def convertFids(self,mapper,toLong):
-        """Converts fids between formats according to mapper.
-        toLong should be True if converting to long format or False if converting to short format."""
-        for cellBlock in self.cellBlocks:
-            cellBlock.convertFids(mapper,toLong)
-
     def updateRecords(self,srcBlock,mapper,mergeIds):
-        """Updates any records in 'self' that exist in 'srcBlock'."""
-        if self.cellBlocks and not self.id_cellBlock:
-            self.indexRecords()
-        id_cellBlock = self.id_cellBlock
-        id_Get = id_cellBlock.get
-        for srcCellBlock in srcBlock.cellBlocks:
-            fid = mapper(srcCellBlock.cell.fid)
-            cellBlock = id_Get(fid)
-            if cellBlock:
-                cellBlock.updateRecords(srcCellBlock,mapper,mergeIds)
+        """Looks through all of the records in 'srcBlock', and updates any records in self that
+        exist within the data in 'block'."""
+        fids = set([record.fid for record in self.records])
+        for record in srcBlock.getActiveRecords():
+            if mapper(record.fid) in fids:
+                record = record.getTypeCopy(mapper)
+                self.setRecord(record)
+                mergeIds.discard(record.fid)
 
-    def updateMasters(self,masters):
-        """Updates set of master names according to masters actually used."""
-        for cellBlock in self.cellBlocks:
-            cellBlock.updateMasters(masters)
+    def mergeRecords(self,rhs):
+        if self.data:
+            self.load(None,True)
+        if rhs.data:
+            rhs.load(None,True)
+        self.records.extend(rhs.records)
+        self.id_records.update(rhs.id_records)
+        self.numRecords = -1
+        self.setChanged()
 
-#-------------------------------------------------------------------------------
-class MobICells(MobCells):
-    """Tes4 top block for interior cell records."""
+#------------------------------------------------------------------------------
+class MobDials(MobObjects):
+    """DIAL top block of mod file."""
 
     def loadData(self,ins,endPos):
         """Loads data from input stream. Called by load()."""
         expType = self.label
-        recCellClass = self.loadFactory.getRecClass(expType)
+        recClass = self.loadFactory.getRecClass(expType)
         errLabel = expType+' Top Block'
-        cellBlocks = self.cellBlocks
-        cell = None
-        endBlockPos = endSubblockPos = 0
-        unpackCellBlocks = self.loadFactory.getUnpackCellBlocks('CELL')
+        records = self.records
         insAtEnd = ins.atEnd
         insRecHeader = ins.unpackRecHeader
-        cellBlocksAppend = cellBlocks.append
-        selfLoadFactory = self.loadFactory
-        insTell = ins.tell
-        insSeek = ins.seek
+        recordsAppend = records.append
+        loadGetRecClass = self.loadFactory.getRecClass
         while not insAtEnd(endPos,errLabel):
+            #--Get record info and handle it
             header = insRecHeader()
             recType = header[0]
             if recType == expType:
-                if cell:
-                    cellBlock = MobCell(header,selfLoadFactory,cell)
-                    cellBlocksAppend(cellBlock)
-                cell = recCellClass(header,ins,True)
-                if insTell() > endBlockPos or insTell() > endSubblockPos:
-                    raise ModError(self.inName,'Interior cell <%X> %s outside of block or subblock.' % (cell.fid, cell.eid))
+                record = recClass(header,ins,True)
+                recordLoadInfos = record.loadInfos
+                recordsAppend(record)
             elif recType == 'GRUP':
-                size,groupFid,groupType = header[1:4]
-                if groupType == 2: # Block number
-                    endBlockPos = insTell()+size-20
-                elif groupType == 3: # Sub-block number
-                    endSubblockPos = insTell()+size-20
-                elif groupType == 6: # Cell Children
-                    if cell:
-                        if groupFid != cell.fid:
-                            raise ModError(self.inName,'Cell subgroup (%X) does not match CELL <%X> %s.' %
-                                (groupFid, cell.fid, cell.eid))
-                        if unpackCellBlocks:
-                            cellBlock = MobCell(header,selfLoadFactory,cell,ins,True)
-                        else:
-                            cellBlock = MobCell(header,selfLoadFactory,cell)
-                            insSeek(header[1]-20,1)
-                        cellBlocksAppend(cellBlock)
-                        cell = None
-                    else:
-                        raise ModError(self.inName,'Extra subgroup %d in CELL group.' % groupType)
+                (recType,size,label,groupType,stamp,stamp2) = header
+                if groupType == 7:
+                    record.infoStamp = stamp
+                    record.infoStamp2 = stamp2
+                    infoClass = loadGetRecClass('INFO')
+                    recordLoadInfos(ins,ins.tell()+size-24,infoClass)
                 else:
-                    raise ModError(self.inName,'Unexpected subgroup %d in CELL group.' % groupType)
+                    raise ModError(self.inName,'Unexpected subgroup %d in DIAL group.' % groupType)
             else:
-                raise ModError(self.inName,'Unexpected %s record in %s group.' % (recType,expType))
+                raise ModError(self.inName,_('Unexpected %s record in %s group.')
+                    % (recType,expType))
         self.setChanged()
 
-    def dump(self,out):
-        """Dumps group header and then records."""
+    def getSize(self):
+        """Returns size of records plus group and record headers."""
         if not self.changed:
-            out.writeGroup(*self.headers[1:])
-            out.write(self.data)
-        elif self.cellBlocks:
-            (totalSize, bsb_size, blocks) = self.getBsbSizes()
-            out.writeGroup(totalSize,self.label,self.groupType,self.stamp)
-            self.dumpBlocks(out,blocks,bsb_size,2,3)
+            return self.size
+        size = 24
+        for record in self.records:
+            size += 24 + record.getSize()
+            if record.infos:
+                size += 24 + sum(24+info.getSize() for info in record.infos)
+        return size
+
+    def getNumRecords(self,includeGroups=1):
+        """Returns number of records, including self plus info records."""
+        self.numRecords = (
+            len(self.records) + includeGroups*bool(self.records) +
+            sum((includeGroups + len(x.infos)) for x in self.records if x.infos)
+            )
+        return self.numRecords
 
 #-------------------------------------------------------------------------------
-class MobWorld(MobCells):
-    def __init__(self,header,loadFactory,world,ins=None,unpack=False):
+class MobCell(MobBase):
+    """Represents cell block structure -- including the cell and all subrecords."""
+
+    __slots__ = MobBase.__slots__ + ['cell','persistent','distant','temp','land','pgrd','pgre','navm']
+
+    def __init__(self,header,loadFactory,cell,ins=None,unpack=False):
         """Initialize."""
-        self.world = world
-        self.worldCellBlock = None
-        self.road = None
-        MobCells.__init__(self,header,loadFactory,ins,unpack)
+        self.cell=cell
+        self.persistent=[]
+        self.distant=[]
+        self.temp=[]
+        self.land=None
+        self.pgrd=None
+        self.pgre=None
+        self.navm=None
+        MobBase.__init__(self,header,loadFactory,ins,unpack)
 
     def loadData(self,ins,endPos):
         """Loads data from input stream. Called by load()."""
         cellType_class = self.loadFactory.getCellTypeClass()
-        recCellClass = self.loadFactory.getRecClass('CELL')
-        errLabel = 'World Block'
-        cell = None
-        block = None
-        subblock = None
-        endBlockPos = endSubblockPos = 0
-        cellBlocks = self.cellBlocks
-        unpackCellBlocks = self.loadFactory.getUnpackCellBlocks('WRLD')
+        persistent,temp,distant = self.persistent,self.temp,self.distant
         insAtEnd = ins.atEnd
         insRecHeader = ins.unpackRecHeader
         cellGet = cellType_class.get
+        persistentAppend = persistent.append
+        tempAppend = temp.append
+        distantAppend = distant.append
         insSeek = ins.seek
-        insTell = ins.tell
-        selfLoadFactory = self.loadFactory
-        cellBlocksAppend = cellBlocks.append
-        structUnpack = struct.unpack
-        structPack = struct.pack
-        while not insAtEnd(endPos,errLabel):
-            curPos = insTell()
-            if curPos >= endBlockPos:
-                block = None
-            if curPos >= endSubblockPos:
-                subblock = None
-            #--Get record info and handle it
-            header = insRecHeader()
-            recType = header[0]
+        while not insAtEnd(endPos,'Cell Block'):
+            subgroupLoaded=[False,False,False]
+            header=insRecHeader()
+            recType=header[0]
             recClass = cellGet(recType)
-            if recType == 'ROAD':
-                if not recClass: insSeek(header[1],1)
-                else: self.road = recClass(header,ins,True)
-            elif recType == 'CELL':
-                if cell:
-                    cellBlock = MobCell(header,selfLoadFactory,cell)
-                    if block:
-                        cellBlocksAppend(cellBlock)
-                    else:
-                        if self.worldCellBlock:
-                            raise ModError(self.inName,'Extra exterior cell <%s> %s before block group.' % (hex(cell.fid), cell.eid))
-                        self.worldCellBlock = cellBlock
-                cell = recClass(header,ins,True)
-                if block:
-                    if insTell() > endBlockPos or insTell() > endSubblockPos:
-                        raise ModError(self.inName,'Exterior cell <%s> %s after block or'
-                                ' subblock.' % (hex(cell.fid), cell.eid))
-            elif recType == 'GRUP':
-                size,groupFid,groupType = header[1:4]
-                if groupType == 4: # Exterior Cell Block
-                    block = structUnpack('2h',structPack('I',groupFid))
-                    block = (block[1],block[0])
-                    endBlockPos = insTell() + size - 20
-                elif groupType == 5: # Exterior Cell Sub-Block
-                    subblock = structUnpack('2h',structPack('I',groupFid))
-                    subblock = (subblock[1],subblock[0])
-                    endSubblockPos = insTell() + size - 20
-                elif groupType == 6: # Cell Children
-                    if cell:
-                        if groupFid != cell.fid:
-                            raise ModError(self.inName,'Cell subgroup (%s) does not match CELL <%s> %s.' %
-                                (hex(groupFid), hex(cell.fid), cell.eid))
-                        if unpackCellBlocks:
-                            cellBlock = MobCell(header,selfLoadFactory,cell,ins,True)
-                        else:
-                            cellBlock = MobCell(header,selfLoadFactory,cell)
-                            insSeek(header[1]-20,1)
-                        if block:
-                            cellBlocksAppend(cellBlock)
-                        else:
-                            if self.worldCellBlock:
-                                raise ModError(self.inName,'Extra exterior cell <%s> %s before block group.' % (hex(cell.fid), cell.eid))
-                            self.worldCellBlock = cellBlock
-                        cell = None
-                    else:
-                        raise ModError(self.inName,'Extra cell children subgroup in world children group.')
+            if recType == 'GRUP':
+                groupType=header[3]
+                if groupType not in (8, 9, 10):
+                    raise ModError(self.inName,'Unexpected subgroup %d in cell children group.' % groupType)
+                if subgroupLoaded[groupType - 8]:
+                    raise ModError(self.inName,'Extra subgroup %d in cell children group.' % groupType)
                 else:
-                    raise ModError(self.inName,'Unexpected subgroup %d in world children group.' % groupType)
-            else:
-                raise ModError(self.inName,'Unexpected %s record in world children group.' % recType)
+                    subgroupLoaded[groupType - 8] = True
+            elif recType not in cellType_class:
+                raise ModError(self.inName,'Unexpected %s record in cell children group.' % recType)
+            elif not recClass:
+                insSeek(header[1],1)
+            elif recType in ('REFR','ACHR','ACRE'):
+                record = recClass(header,ins,True)
+                if   groupType ==  8: persistentAppend(record)
+                elif groupType ==  9: tempAppend(record)
+                elif groupType == 10: distantAppend(record)
+                else:
+                    raise ModError(self.inName,'Extra subgroup %d in cell children group.' % groupType)
+            elif recType == 'LAND':
+                self.land=recClass(header,ins,False)
+            elif recType == 'PGRD':
+                self.pgrd=recClass(header,ins,False)
+            elif recType == 'PGRE':
+                self.pgre=recClass(header,ins,False)
+            elif recType == 'NAVM':
+                self.navm=recClass(header,ins,False)
         self.setChanged()
 
+    def getSize(self):
+        """Returns size (incuding size of any group headers)."""
+        return recHeaderSize + self.cell.getSize() + self.getChildrenSize()
+
+    def getChildrenSize(self):
+        """Returns size of all childen, including the group header.  This does not include the cell itself."""
+        size = self.getPersistentSize() + self.getTempSize() + self.getDistantSize()
+        return size + recHeaderSize*bool(size)
+
+    def getPersistentSize(self):
+        """Returns size of all persistent children, including the persistent children group."""
+        size = sum(recHeaderSize + x.getSize() for x in self.persistent)
+        return size + recHeaderSize*bool(size)
+
+    def getTempSize(self):
+        """Returns size of all temporary children, including the temporary children group."""
+        size = sum(recHeaderSize + x.getSize() for x in self.temp)
+        if self.pgrd: size += recHeaderSize + self.pgrd.getSize()
+        if self.land: size += recHeaderSize + self.land.getSize()
+        if self.pgre: size += recHeaderSize + self.pgre.getSize()
+        if self.navm: size += recHeaderSize + self.navm.getSize()
+        return size + recHeaderSize*bool(size)
+
+    def getDistantSize(self):
+        """Returns size of all distant children, including the distant children group."""
+        size = sum(recHeaderSize + x.getSize() for x in self.distant)
+        return size + recHeaderSize*bool(size)
+
     def getNumRecords(self,includeGroups=True):
         """Returns number of records, including self and all children."""
-        if not self.changed:
-            return MobBase.getNumRecords(self)
-        count = 1 + includeGroups #--world record & group
-        count += bool(self.road)
-        if self.worldCellBlock:
-            count += self.worldCellBlock.getNumRecords(includeGroups)
-        count += MobCells.getNumRecords(self,includeGroups)
+        count = 1 + includeGroups # Cell GRUP and CELL record
+        if self.persistent:
+            count += len(self.persistent) + includeGroups
+        if self.temp or self.pgrd or self.land or self.pgre or self.navm:
+            count += len(self.temp) + includeGroups
+            count += bool(self.pgrd) + bool(self.land) + bool(self.pgre) + bool(self.navm)
+        if self.distant:
+            count += len(self.distant) + includeGroups
         return count
 
-    def dump(self,out):
-        """Dumps group header and then records.  Returns the total size of the world block."""
-        worldSize = self.world.getSize() + 20
-        self.world.dump(out)
-        if not self.changed:
-            out.writeGroup(*self.headers[1:])
-            out.write(self.data)
-            return self.size + worldSize
-        elif self.cellBlocks or self.road or self.worldCellBlock:
-            (totalSize, bsb_size, blocks) = self.getBsbSizes()
-            if self.road:
-                totalSize += self.road.getSize() + 20
-            if self.worldCellBlock:
-                totalSize += self.worldCellBlock.getSize()
-            out.writeGroup(totalSize,self.world.fid,1,self.stamp)
-            if self.road:
-                self.road.dump(out)
-            if self.worldCellBlock:
-                self.worldCellBlock.dump(out)
-            self.dumpBlocks(out,blocks,bsb_size,4,5)
-            return totalSize + worldSize
+    def getBsb(self):
+        """Returns tesfile block and sub-block indices for cells in this group.
+        For interior cell, bsb is (blockNum,subBlockNum). For exterior cell, bsb is
+        ((blockX,blockY),(subblockX,subblockY))."""
+        cell = self.cell
+        #--Interior cell
+        if cell.flags.isInterior:
+            baseFid = cell.fid & 0x00FFFFFF
+            return (baseFid%10, baseFid%100//10)
+        #--Exterior cell
         else:
-            return worldSize
+            x,y = cell.posX,cell.posY
+            if x is None: x = 0
+            if y is None: y = 0
+            return ((x//32, y//32), (x//8, y//8))
+
+    def dump(self,out):
+        """Dumps group header and then records."""
+        self.cell.getSize()
+        self.cell.dump(out)
+        childrenSize = self.getChildrenSize()
+        if not childrenSize: return
+        out.writeGroup(childrenSize,self.cell.fid,6,self.stamp,self.stamp2)
+        if self.persistent:
+            out.writeGroup(self.getPersistentSize(),self.cell.fid,8,self.stamp,self.stamp2)
+            for record in self.persistent:
+                record.dump(out)
+        if self.temp or self.pgrd or self.land or self.pgre or self.navm:
+            out.writeGroup(self.getTempSize(),self.cell.fid,9,self.stamp,self.stamp2)
+            if self.pgrd:
+                self.pgrd.dump(out)
+            if self.land:
+                self.land.dump(out)
+            if self.pgre:
+                self.pgre.dump(out)
+            if self.navm:
+                self.navm.dump(out)
+            for record in self.temp:
+                record.dump(out)
+        if self.distant:
+            out.writeGroup(self.getDistantSize(),self.cell.fid,10,self.stamp,self.stamp2)
+            for record in self.distant:
+                record.dump(out)
 
     #--Fid manipulation, record filtering ----------------------------------
     def convertFids(self,mapper,toLong):
         """Converts fids between formats according to mapper.
         toLong should be True if converting to long format or False if converting to short format."""
-        self.world.convertFids(mapper,toLong)
-        if self.road:
-            self.road.convertFids(mapper,toLong)
-        if self.worldCellBlock:
-            self.worldCellBlock.convertFids(mapper,toLong)
-        MobCells.convertFids(self,mapper,toLong)
-
-    def updateMasters(self,masters):
-        """Updates set of master names according to masters actually used."""
-        self.world.updateMasters(masters)
-        if self.road:
-            self.road.updateMasters(masters)
-        if self.worldCellBlock:
-            self.worldCellBlock.updateMasters(masters)
-        MobCells.updateMasters(self,masters)
+        self.cell.convertFids(mapper,toLong)
+        for record in self.temp:
+            record.convertFids(mapper,toLong)
+        for record in self.persistent:
+            record.convertFids(mapper,toLong)
+        for record in self.distant:
+            record.convertFids(mapper,toLong)
+        if self.land:
+            self.land.convertFids(mapper,toLong)
+        if self.pgrd:
+            self.pgrd.convertFids(mapper,toLong)
+        if self.pgre:
+            self.pgre.convertFids(mapper,toLong)
+        if self.navm:
+            self.navm.convertFids(mapper,toLong)
+
+    def updateMasters(self,masters):
+        """Updates set of master names according to masters actually used."""
+        self.cell.updateMasters(masters)
+        for record in self.persistent:
+            record.updateMasters(masters)
+        for record in self.distant:
+            record.updateMasters(masters)
+        for record in self.temp:
+            record.updateMasters(masters)
+        if self.land:
+            self.land.updateMasters(masters)
+        if self.pgrd:
+            self.pgrd.updateMasters(masters)
+        if self.pgre:
+            self.pgre.updateMasters(masters)
+        if self.navm:
+            self.navm.updateMasters(masters)
 
     def updateRecords(self,srcBlock,mapper,mergeIds):
         """Updates any records in 'self' that exist in 'srcBlock'."""
+        mergeDiscard = mergeIds.discard
         selfGetter = self.__getattribute__
         srcGetter = srcBlock.__getattribute__
         selfSetter = self.__setattr__
-        mergeDiscard = mergeIds.discard
-        for attr in ('world','road'):
+        for attr in ('cell','pgrd','land','pgre','navm'):
             myRecord = selfGetter(attr)
             record = srcGetter(attr)
             if myRecord and record:
@@ -4940,95 +6390,482 @@ class MobWorld(MobCells):
                     record = record.getTypeCopy(mapper)
                     selfSetter(attr,record)
                     mergeDiscard(record.fid)
-        if self.worldCellBlock and srcBlock.worldCellBlock:
-            self.worldCellBlock.updateRecords(srcBlock.worldCellBlock,mapper,mergeIds)
-        MobCells.updateRecords(self,srcBlock,mapper,mergeIds)
+        for attr in ('persistent','temp','distant'):
+            recordList = selfGetter(attr)
+            fids = dict((record.fid,index) for index,record in enumerate(recordList))
+            for record in srcGetter(attr):
+                if not record.flags1.ignored and mapper(record.fid) in fids:
+                    record = record.getTypeCopy(mapper)
+                    recordList[fids[record.fid]]=record
+                    mergeDiscard(record.fid)
 
     def keepRecords(self,keepIds):
         """Keeps records with fid in set keepIds. Discards the rest."""
-        if self.road and self.road.fid not in keepIds:
-            self.road = None
-        if self.worldCellBlock:
-            self.worldCellBlock.keepRecords(keepIds)
-            if self.worldCellBlock.cell.fid not in keepIds:
-                self.worldCellBlock = None
-        MobCells.keepRecords(self,keepIds)
-        if self.road or self.worldCellBlock or self.cellBlocks:
-            keepIds.add(self.world.fid)
+        if self.pgrd and self.pgrd.fid not in keepIds:
+            self.pgrd = None
+        if self.land and self.land.fid not in keepIds:
+            self.land = None
+        if self.pgre and self.pgre.fid not in keepIds:
+            self.pgre = None
+        if self.navm and self.navm.fid not in keepIds:
+            self.navm = None
+        self.temp       = [x for x in self.temp if x.fid in keepIds]
+        self.persistent = [x for x in self.persistent if x.fid in keepIds]
+        self.distant    = [x for x in self.distant if x.fid in keepIds]
+        if self.pgrd or self.land or self.pgre or self.navm or self.persistent or self.temp or self.distant:
+            keepIds.add(self.cell.fid)
+        self.setChanged()
 
 #-------------------------------------------------------------------------------
-class MobWorlds(MobBase):
-    """Tes4 top block for world records and related roads and cells. Consists
-    of world blocks."""
+class MobCells(MobBase):
+    """A block containing cells. Subclassed by MobWorld and MobICells.
+
+    Note that "blocks" here only roughly match the file block structure.
+
+    "Bsb" is a tuple of the file (block,subblock) labels. For interior cells, bsbs are tuples
+    of two numbers, while for exterior cells, bsb labels are tuples of grid tuples."""
 
     def __init__(self,header,loadFactory,ins=None,unpack=False):
         """Initialize."""
-        self.worldBlocks = []
-        self.id_worldBlocks = {}
-        self.orphansSkipped = 0
+        self.cellBlocks = [] #--Each cellBlock is a cell and it's related records.
+        self.id_cellBlock = {}
         MobBase.__init__(self,header,loadFactory,ins,unpack)
 
+    def indexRecords(self):
+        """Indexes records by fid."""
+        self.id_cellBlock = dict((x.cell.fid,x) for x in self.cellBlocks)
+
+    def setCell(self,cell):
+        """Adds record to record list and indexed."""
+        if self.cellBlocks and not self.id_cellBlock:
+            self.indexRecords()
+        fid = cell.fid
+        if fid in self.id_cellBlock:
+            self.id_cellBlock[fid].cell = cell
+        else:
+            cellBlock = MobCell(('GRUP',0,0,6,self.stamp,self.stamp2),self.loadFactory,cell)
+            cellBlock.setChanged()
+            self.cellBlocks.append(cellBlock)
+            self.id_cellBlock[fid] = cellBlock
+
+    def getUsedBlocks(self):
+        """Returns a set of blocks that exist in this group."""
+        return set(x.getBsb()[0] for x in self.cellBlocks)
+
+    def getUsedSubblocks(self):
+        """Returns a set of block/sub-blocks that exist in this group."""
+        return set(x.getBsb() for x in self.cellBlocks)
+
+    def getBsbSizes(self):
+        """Returns the total size of the block, but also returns a dictionary containing the sizes
+        of the individual block,subblocks."""
+        bsbCellBlocks = [(x.getBsb(),x) for x in self.cellBlocks]
+        bsbCellBlocks.sort(key = lambda x: x[1].cell.fid)
+        bsbCellBlocks.sort(key = itemgetter(0))
+        bsb_size = {}
+        totalSize = 24
+        bsb_setDefault = bsb_size.setdefault
+        for bsb,cellBlock in bsbCellBlocks:
+            cellBlockSize = cellBlock.getSize()
+            totalSize += cellBlockSize
+            bsb0 = (bsb[0],None) #--Block group
+            bsb_setDefault(bsb0,24)
+            if bsb_setDefault(bsb,24) == 24:
+                bsb_size[bsb0] += 24
+            bsb_size[bsb] += cellBlockSize
+            bsb_size[bsb0] += cellBlockSize
+        totalSize += 24 * len(bsb_size)
+        return totalSize,bsb_size,bsbCellBlocks
+
+    def dumpBlocks(self,out,bsbCellBlocks,bsb_size,blockGroupType,subBlockGroupType):
+        """Dumps the cell blocks and their block and sub-block groups to out."""
+        curBlock = None
+        curSubblock = None
+        stamp = self.stamp
+        stamp2 = self.stamp2
+        outWriteGroup = out.writeGroup
+        for bsb,cellBlock in bsbCellBlocks:
+            (block,subblock) = bsb
+            bsb0 = (block,None)
+            if block != curBlock:
+                curBlock,curSubblock = bsb0
+                outWriteGroup(bsb_size[bsb0],block,blockGroupType,stamp,stamp2)
+            if subblock != curSubblock:
+                curSubblock = subblock
+                outWriteGroup(bsb_size[bsb],subblock,subBlockGroupType,stamp,stamp2)
+            cellBlock.dump(out)
+
+    def getNumRecords(self,includeGroups=1):
+        """Returns number of records, including self and all children."""
+        count = sum(x.getNumRecords(includeGroups) for x in self.cellBlocks)
+        if count and includeGroups:
+            count += 1 + len(self.getUsedBlocks()) + len(self.getUsedSubblocks())
+        return count
+
+    #--Fid manipulation, record filtering ----------------------------------
+    def keepRecords(self,keepIds):
+        """Keeps records with fid in set keepIds. Discards the rest."""
+        #--Note: this call will add the cell to keepIds if any of its related records are kept.
+        for cellBlock in self.cellBlocks: cellBlock.keepRecords(keepIds)
+        self.cellBlocks = [x for x in self.cellBlocks if x.cell.fid in keepIds]
+        self.id_cellBlock.clear()
+        self.setChanged()
+
+    def convertFids(self,mapper,toLong):
+        """Converts fids between formats according to mapper.
+        toLong should be True if converting to long format or False if converting to short format."""
+        for cellBlock in self.cellBlocks:
+            cellBlock.convertFids(mapper,toLong)
+
+    def updateRecords(self,srcBlock,mapper,mergeIds):
+        """Updates any records in 'self' that exist in 'srcBlock'."""
+        if self.cellBlocks and not self.id_cellBlock:
+            self.indexRecords()
+        id_cellBlock = self.id_cellBlock
+        id_Get = id_cellBlock.get
+        for srcCellBlock in srcBlock.cellBlocks:
+            fid = mapper(srcCellBlock.cell.fid)
+            cellBlock = id_Get(fid)
+            if cellBlock:
+                cellBlock.updateRecords(srcCellBlock,mapper,mergeIds)
+
+    def updateMasters(self,masters):
+        """Updates set of master names according to masters actually used."""
+        for cellBlock in self.cellBlocks:
+            cellBlock.updateMasters(masters)
+
+    def mergeRecords(self,rhs):
+        if self.data:
+            self.load(None,True)
+        if rhs.data:
+            rhs.load(None,True)
+        self.cellBlocks.extend(rhs.cellBlocks)
+        self.id_cellBlock.update(rhs.id_cellBlock)
+        self.numRecords = -1
+        self.setChanged()
+
+#-------------------------------------------------------------------------------
+class MobICells(MobCells):
+    """Tes4 top block for interior cell records."""
+
     def loadData(self,ins,endPos):
         """Loads data from input stream. Called by load()."""
         expType = self.label
-        recWrldClass = self.loadFactory.getRecClass(expType)
-        errLabel = expType + ' Top Block'
-        worldBlocks = self.worldBlocks
-        world = None
+        recCellClass = self.loadFactory.getRecClass(expType)
+        errLabel = expType+' Top Block'
+        cellBlocks = self.cellBlocks
+        cell = None
+        endBlockPos = endSubblockPos = 0
+        unpackCellBlocks = self.loadFactory.getUnpackCellBlocks('CELL')
         insAtEnd = ins.atEnd
         insRecHeader = ins.unpackRecHeader
-        insSeek = ins.seek
+        cellBlocksAppend = cellBlocks.append
         selfLoadFactory = self.loadFactory
-        worldBlocksAppend = worldBlocks.append
+        insTell = ins.tell
+        insSeek = ins.seek
         while not insAtEnd(endPos,errLabel):
-            #--Get record info and handle it
             header = insRecHeader()
             recType = header[0]
             if recType == expType:
-                world = recWrldClass(header,ins,True)
+                if cell:
+                    cellBlock = MobCell(header,selfLoadFactory,cell)
+                    cellBlocksAppend(cellBlock)
+                cell = recCellClass(header,ins,True)
+                if insTell() > endBlockPos or insTell() > endSubblockPos:
+                    raise ModError(self.inName,'Interior cell <%X> %s outside of block or subblock.' % (cell.fid, cell.eid))
             elif recType == 'GRUP':
-                groupFid,groupType = header[2:4]
-                if groupType != 1:
-                    raise ModError(ins.inName,'Unexpected subgroup %d in CELL group.' % groupType)
-                if not world:
-                    #raise ModError(ins.inName,'Extra subgroup %d in WRLD group.' % groupType)
-                    #--Orphaned world records. Skip over.
-                    insSeek(header[1]-20,1)
-                    self.orphansSkipped += 1
-                    continue
-                if groupFid != world.fid:
-                    raise ModError(ins.inName,'WRLD subgroup (%s) does not match WRLD <%s> %s.' %
-                        (hex(groupFid), hex(world.fid), world.eid))
-                worldBlock = MobWorld(header,selfLoadFactory,world,ins,True)
-                worldBlocksAppend(worldBlock)
-                world = None
+                size,groupFid,groupType = header[1:4]
+                if groupType == 2: # Block number
+                    endBlockPos = insTell()+size-24
+                elif groupType == 3: # Sub-block number
+                    endSubblockPos = insTell()+size-24
+                elif groupType == 6: # Cell Children
+                    if cell:
+                        if groupFid != cell.fid:
+                            raise ModError(self.inName,'Cell subgroup (%X) does not match CELL <%X> %s.' %
+                                (groupFid, cell.fid, cell.eid))
+                        if unpackCellBlocks:
+                            cellBlock = MobCell(header,selfLoadFactory,cell,ins,True)
+                        else:
+                            cellBlock = MobCell(header,selfLoadFactory,cell)
+                            insSeek(header[1]-24,1)
+                        cellBlocksAppend(cellBlock)
+                        cell = None
+                    else:
+                        raise ModError(self.inName,'Extra subgroup %d in CELL group.' % groupType)
+                else:
+                    raise ModError(self.inName,'Unexpected subgroup %d in CELL group.' % groupType)
             else:
-                raise ModError(ins.inName,'Unexpected %s record in %s group.' % (recType,expType))
-
-    def getSize(self):
-        """Returns size (incuding size of any group headers)."""
-        return 20 + sum(x.getSize() for x in self.worldBlocks)
+                raise ModError(self.inName,'Unexpected %s record in %s group.' % (recType,expType))
+        self.setChanged()
 
     def dump(self,out):
         """Dumps group header and then records."""
         if not self.changed:
             out.writeGroup(*self.headers[1:])
             out.write(self.data)
-        else:
-            if not self.worldBlocks: return
-            worldHeaderPos = out.tell()
-            out.writeGroup(0,self.label,0,self.stamp)
-            totalSize = 20 + sum(x.dump(out) for x in self.worldBlocks)
-            out.seek(worldHeaderPos + 4)
-            out.pack('I', totalSize)
-            out.seek(worldHeaderPos + totalSize)
+        elif self.cellBlocks:
+            (totalSize, bsb_size, blocks) = self.getBsbSizes()
+            out.writeGroup(totalSize,self.label,self.groupType,self.stamp,self.stamp2)
+            self.dumpBlocks(out,blocks,bsb_size,2,3)
 
-    def getNumRecords(self,includeGroups=True):
-        """Returns number of records, including self and all children."""
-        count = sum(x.getNumRecords(includeGroups) for x in self.worldBlocks)
-        return count + includeGroups*bool(count)
+#-------------------------------------------------------------------------------
+class MobWorld(MobCells):
+    def __init__(self,header,loadFactory,world,ins=None,unpack=False):
+        """Initialize."""
+        self.world = world
+        self.worldCellBlock = None
+        self.road = None
+        MobCells.__init__(self,header,loadFactory,ins,unpack)
 
-    def convertFids(self,mapper,toLong):
+    def loadData(self,ins,endPos):
+        """Loads data from input stream. Called by load()."""
+        cellType_class = self.loadFactory.getCellTypeClass()
+        recCellClass = self.loadFactory.getRecClass('CELL')
+        errLabel = 'World Block'
+        cell = None
+        cells = {}
+        block = None
+        subblock = None
+        endBlockPos = endSubblockPos = 0
+        cellBlocks = self.cellBlocks
+        unpackCellBlocks = self.loadFactory.getUnpackCellBlocks('WRLD')
+        insAtEnd = ins.atEnd
+        insRecHeader = ins.unpackRecHeader
+        cellGet = cellType_class.get
+        insSeek = ins.seek
+        insTell = ins.tell
+        selfLoadFactory = self.loadFactory
+        cellBlocksAppend = cellBlocks.append
+        structUnpack = struct.unpack
+        structPack = struct.pack
+        while not insAtEnd(endPos,errLabel):
+            curPos = insTell()
+            if curPos >= endBlockPos:
+                block = None
+            if curPos >= endSubblockPos:
+                subblock = None
+            #--Get record info and handle it
+            header = insRecHeader()
+            recType = header[0]
+            recClass = cellGet(recType)
+            if recType == 'ROAD':
+                if not recClass: insSeek(header[1],1)
+                else: self.road = recClass(header,ins,True)
+            elif recType == 'CELL':
+                if cell:
+                    cellBlock = MobCell(header,selfLoadFactory,cell)
+                    if block:
+                        cellBlocksAppend(cellBlock)
+                    else:
+                        if self.worldCellBlock:
+                            raise ModError(self.inName,'Extra exterior cell <%s> %s before block group.' % (hex(cell.fid), cell.eid))
+                        self.worldCellBlock = cellBlock
+                cell = recClass(header,ins,True)
+                cells[cell.fid] = cell
+                if block:
+                    if insTell() > endBlockPos or insTell() > endSubblockPos:
+                        raise ModError(self.inName,'Exterior cell <%s> %s after block or'
+                                ' subblock.' % (hex(cell.fid), cell.eid))
+            elif recType == 'GRUP':
+                size,groupFid,groupType = header[1:4]
+                if groupType == 4: # Exterior Cell Block
+                    block = structUnpack('2h',structPack('I',groupFid))
+                    block = (block[1],block[0])
+                    endBlockPos = insTell() + size - 24
+                elif groupType == 5: # Exterior Cell Sub-Block
+                    subblock = structUnpack('2h',structPack('I',groupFid))
+                    subblock = (subblock[1],subblock[0])
+                    endSubblockPos = insTell() + size - 24
+                elif groupType == 6: # Cell Children
+                    cell = cells.get(groupFid,None)
+                    if cell:
+                        #if groupFid != cell.fid:
+                        #    raise ModError(self.inName,'Cell subgroup (%s) does not match CELL <%s> %s.' %
+                        #        (hex(groupFid), hex(cell.fid), cell.eid))
+                        if unpackCellBlocks:
+                            cellBlock = MobCell(header,selfLoadFactory,cell,ins,True)
+                        else:
+                            cellBlock = MobCell(header,selfLoadFactory,cell)
+                            insSeek(header[1]-24,1)
+                        if block:
+                            cellBlocksAppend(cellBlock)
+                        else:
+                            if self.worldCellBlock:
+                                raise ModError(self.inName,'Extra exterior cell <%s> %s before block group.' % (hex(cell.fid), cell.eid))
+                            self.worldCellBlock = cellBlock
+                        cell = None
+                    else:
+                        raise ModError(self.inName,'Extra cell children subgroup in world children group.')
+                else:
+                    raise ModError(self.inName,'Unexpected subgroup %d in world children group.' % groupType)
+            else:
+                raise ModError(self.inName,'Unexpected %s record in world children group.' % recType)
+        self.setChanged()
+
+    def getNumRecords(self,includeGroups=True):
+        """Returns number of records, including self and all children."""
+        if not self.changed:
+            return MobBase.getNumRecords(self)
+        count = 1 + includeGroups #--world record & group
+        count += bool(self.road)
+        if self.worldCellBlock:
+            count += self.worldCellBlock.getNumRecords(includeGroups)
+        count += MobCells.getNumRecords(self,includeGroups)
+        return count
+
+    def dump(self,out):
+        """Dumps group header and then records.  Returns the total size of the world block."""
+        worldSize = self.world.getSize() + recHeaderSize
+        self.world.dump(out)
+        if not self.changed:
+            out.writeGroup(*self.headers[1:])
+            out.write(self.data)
+            return self.size + worldSize
+        elif self.cellBlocks or self.road or self.worldCellBlock:
+            (totalSize, bsb_size, blocks) = self.getBsbSizes()
+            if self.road:
+                totalSize += self.road.getSize() + 24
+            if self.worldCellBlock:
+                totalSize += self.worldCellBlock.getSize()
+            out.writeGroup(totalSize,self.world.fid,1,self.stamp,self.stamp2)
+            if self.road:
+                self.road.dump(out)
+            if self.worldCellBlock:
+                self.worldCellBlock.dump(out)
+            self.dumpBlocks(out,blocks,bsb_size,4,5)
+            return totalSize + worldSize
+        else:
+            return worldSize
+
+    #--Fid manipulation, record filtering ----------------------------------
+    def convertFids(self,mapper,toLong):
+        """Converts fids between formats according to mapper.
+        toLong should be True if converting to long format or False if converting to short format."""
+        self.world.convertFids(mapper,toLong)
+        if self.road:
+            self.road.convertFids(mapper,toLong)
+        if self.worldCellBlock:
+            self.worldCellBlock.convertFids(mapper,toLong)
+        MobCells.convertFids(self,mapper,toLong)
+
+    def updateMasters(self,masters):
+        """Updates set of master names according to masters actually used."""
+        self.world.updateMasters(masters)
+        if self.road:
+            self.road.updateMasters(masters)
+        if self.worldCellBlock:
+            self.worldCellBlock.updateMasters(masters)
+        MobCells.updateMasters(self,masters)
+
+    def updateRecords(self,srcBlock,mapper,mergeIds):
+        """Updates any records in 'self' that exist in 'srcBlock'."""
+        selfGetter = self.__getattribute__
+        srcGetter = srcBlock.__getattribute__
+        selfSetter = self.__setattr__
+        mergeDiscard = mergeIds.discard
+        for attr in ('world','road'):
+            myRecord = selfGetter(attr)
+            record = srcGetter(attr)
+            if myRecord and record:
+                if myRecord.fid != mapper(record.fid):
+                    raise ArgumentError("Fids don't match! %08x, %08x" % (myRecord.fid, record.fid))
+                if not record.flags1.ignored:
+                    record = record.getTypeCopy(mapper)
+                    selfSetter(attr,record)
+                    mergeDiscard(record.fid)
+        if self.worldCellBlock and srcBlock.worldCellBlock:
+            self.worldCellBlock.updateRecords(srcBlock.worldCellBlock,mapper,mergeIds)
+        MobCells.updateRecords(self,srcBlock,mapper,mergeIds)
+
+    def keepRecords(self,keepIds):
+        """Keeps records with fid in set keepIds. Discards the rest."""
+        if self.road and self.road.fid not in keepIds:
+            self.road = None
+        if self.worldCellBlock:
+            self.worldCellBlock.keepRecords(keepIds)
+            if self.worldCellBlock.cell.fid not in keepIds:
+                self.worldCellBlock = None
+        MobCells.keepRecords(self,keepIds)
+        if self.road or self.worldCellBlock or self.cellBlocks:
+            keepIds.add(self.world.fid)
+
+#-------------------------------------------------------------------------------
+class MobWorlds(MobBase):
+    """Tes4 top block for world records and related roads and cells. Consists
+    of world blocks."""
+
+    def __init__(self,header,loadFactory,ins=None,unpack=False):
+        """Initialize."""
+        self.worldBlocks = []
+        self.id_worldBlocks = {}
+        self.orphansSkipped = 0
+        MobBase.__init__(self,header,loadFactory,ins,unpack)
+
+    def loadData(self,ins,endPos):
+        """Loads data from input stream. Called by load()."""
+        expType = self.label
+        recWrldClass = self.loadFactory.getRecClass(expType)
+        errLabel = expType + ' Top Block'
+        worldBlocks = self.worldBlocks
+        world = None
+        worlds = {}
+        insAtEnd = ins.atEnd
+        insRecHeader = ins.unpackRecHeader
+        insSeek = ins.seek
+        selfLoadFactory = self.loadFactory
+        worldBlocksAppend = worldBlocks.append
+        while not insAtEnd(endPos,errLabel):
+            #--Get record info and handle it
+            header = insRecHeader()
+            recType = header[0]
+            if recType == expType:
+                world = recWrldClass(header,ins,True)
+                worlds[world.fid] = world
+            elif recType == 'GRUP':
+                groupFid,groupType = header[2:4]
+                if groupType != 1:
+                    raise ModError(ins.inName,'Unexpected subgroup %d in CELL group.' % groupType)
+                world = worlds.get(groupFid,None)
+                if not world:
+                    #raise ModError(ins.inName,'Extra subgroup %d in WRLD group.' % groupType)
+                    #--Orphaned world records. Skip over.
+                    insSeek(header[1]-24,1)
+                    self.orphansSkipped += 1
+                    continue
+                #if groupFid != world.fid:
+                #    raise ModError(ins.inName,'WRLD subgroup (%s) does not match WRLD <%s> %s.' %
+                #        (hex(groupFid), hex(world.fid), world.eid))
+                worldBlock = MobWorld(header,selfLoadFactory,world,ins,True)
+                worldBlocksAppend(worldBlock)
+                world = None
+            else:
+                raise ModError(ins.inName,'Unexpected %s record in %s group.' % (recType,expType))
+
+    def getSize(self):
+        """Returns size (incuding size of any group headers)."""
+        return recHeaderSize + sum(x.getSize() for x in self.worldBlocks)
+
+    def dump(self,out):
+        """Dumps group header and then records."""
+        if not self.changed:
+            out.writeGroup(*self.headers[1:])
+            out.write(self.data)
+        else:
+            if not self.worldBlocks: return
+            worldHeaderPos = out.tell()
+            out.writeGroup(0,self.label,0,self.stamp,self.stamp2)
+            totalSize = recHeaderSize + sum(x.dump(out) for x in self.worldBlocks)
+            out.seek(worldHeaderPos + 4)
+            out.pack('I', totalSize)
+            out.seek(worldHeaderPos + totalSize)
+
+    def getNumRecords(self,includeGroups=True):
+        """Returns number of records, including self and all children."""
+        count = sum(x.getNumRecords(includeGroups) for x in self.worldBlocks)
+        return count + includeGroups*bool(count)
+
+    def convertFids(self,mapper,toLong):
         """Converts fids between formats according to mapper.
         toLong should be True if converting to long format or False if converting to short format."""
         for worldBlock in self.worldBlocks:
@@ -5062,7 +6899,7 @@ class MobWorlds(MobBase):
         if fid in self.id_worldBlocks:
             self.id_worldBlocks[fid].world = world
         else:
-            worldBlock = MobWorld(('GRUP',0,0,1,self.stamp),self.loadFactory,world)
+            worldBlock = MobWorld(('GRUP',0,0,1,self.stamp,self.stamp2),self.loadFactory,world)
             worldBlock.setChanged()
             self.worldBlocks.append(worldBlock)
             self.id_worldBlocks[fid] = worldBlock
@@ -5074,6 +6911,16 @@ class MobWorlds(MobBase):
         self.id_worldBlocks.clear()
         self.setChanged()
 
+    def mergeRecords(self,rhs):
+        if self.data:
+            self.load(None,True)
+        if rhs.data:
+            rhs.load(None,True)
+        self.worldBlocks.extend(rhs.worldBlocks)
+        self.id_worldBlocks.update(rhs.id_worldBlocks)
+        self.numRecords = -1
+        self.setChanged()
+
 #------------------------------------------------------------------------------
 class ModFile:
     """TES4 file representation."""
@@ -5082,7 +6929,7 @@ class ModFile:
         self.fileInfo = fileInfo
         self.loadFactory = loadFactory or LoadFactory(True)
         #--Variables to load
-        self.tes4 = MreTes4(('TES4',0,0,0,0))
+        self.tes4 = MreTes4(('TES4',0,0,0,0,0))
         self.tes4.setChanged()
         self.tops = {} #--Top groups.
         self.topsSkipped = set() #--Types skipped
@@ -5098,7 +6945,7 @@ class ModFile:
             return self.tops[topType]
         elif topType in bush.topTypes:
             topClass = self.loadFactory.getTopClass(topType)
-            self.tops[topType] = topClass(('GRUP',0,topType,0,0),self.loadFactory)
+            self.tops[topType] = topClass(('GRUP',0,topType,0,0,0),self.loadFactory)
             self.tops[topType].setChanged()
             return self.tops[topType]
         elif topType == '__repr__':
@@ -5122,17 +6969,22 @@ class ModFile:
         selfLoadFactory = self.loadFactory
         while not insAtEnd():
             #--Get record info and handle it
-            (type,size,label,groupType,stamp) = header = insRecHeader()
+            (type,size,label,groupType,stamp,stamp2) = header = insRecHeader()
             if type != 'GRUP' or groupType != 0:
                 raise ModError(self.fileInfo.name,_('Improperly grouped file.'))
             topClass = selfGetTopClass(label)
             try:
                 if topClass:
-                    self.tops[label] = topClass(header,selfLoadFactory)
-                    self.tops[label].load(ins,unpack and (topClass != MobBase))
+                    records = topClass(header,selfLoadFactory)
+                    if size - recHeaderSize > 0:
+                        records.load(ins,unpack and (topClass != MobBase))
+                    if self.tops.get(label):
+                        self.tops[label].mergeRecords(records)
+                    else:
+                        self.tops[label] = records
                 else:
                     selfTopsSkipAdd(label)
-                    insSeek(size-20,1,type + '.' + label)
+                    insSeek(size-recHeaderSize,1,type + '.' + label)
             except:
                 if isinstance(self.fileInfo.name,str):
                     print "Error in %s" % self.fileInfo.name
@@ -5240,10 +7092,8 @@ class ModFile:
     def getMastersUsed(self):
         """Updates set of master names according to masters actually used."""
         if not self.longFids: raise StateError("ModFile fids not in long form.")
-        if dirs['mods'].join('Oblivion.esm').exists():
-            masters = MasterSet([GPath('Oblivion.esm')])
-        elif dirs['mods'].join('Nehrim.esm').exists():
-            masters = MasterSet([GPath('Nehrim.esm')]) # insert witty joke here about the old comment
+        if dirs['mods'].join('Fallout3.esm').exists():
+            masters = MasterSet([GPath('Fallout3.esm')])
         for block in self.tops.values():
             block.updateMasters(masters)
         return masters.getOrdered()
@@ -5567,16 +7417,16 @@ class PluggyFile:
         self.path.untemp()
 
 #------------------------------------------------------------------------------
-class ObseFile:
-    """Represents a .obse cofile for saves. Used for editing masters list."""
+class FoseFile:
+    """Represents a .fose cofile for saves. Used for editing masters list."""
     def __init__(self,path):
         self.path = path
         self.name = path.tail
         self.signature = None
         self.formatVersion = None
-        self.obseVersion = None
-        self.obseMinorVersion = None
-        self.oblivionVersion = None
+        self.foseVersion = None
+        self.foseMinorVersion = None
+        self.falloutVersion = None
         self.plugins = None
         self.valid = False
 
@@ -5592,9 +7442,9 @@ class ObseFile:
         def unpack(format,size):
             return struct.unpack(format,ins.read(size))
         self.signature = ins.read(4)
-        if self.signature != 'OBSE':
-            raise FileError(self.name,'File signature != "OBSE"')
-        self.formatVersion,self.obseVersion,self.obseMinorVersion,self.oblivionVersion, = unpack('IHHI',12)
+        if self.signature != 'FOSE':
+            raise FileError(self.name,'File signature != "FOSE"')
+        self.formatVersion,self.foseVersion,self.foseMinorVersion,self.falloutVersion, = unpack('IHHI',12)
         # if self.formatVersion < X:
         #   raise FileError(self.name,'Unsupported file version: %I' % self.formatVersion)
         #--Plugins
@@ -5626,11 +7476,11 @@ class ObseFile:
         #--Save
         def pack(format,*args):
             buff.write(struct.pack(format,*args))
-        buff.write('OBSE')
+        buff.write('FOSE')
         pack('=I',self.formatVersion)
-        pack('=H',self.obseVersion)
-        pack('=H',self.obseMinorVersion)
-        pack('=I',self.oblivionVersion)
+        pack('=H',self.foseVersion)
+        pack('=H',self.foseMinorVersion)
+        pack('=I',self.falloutVersion)
         #--Plugins
         pack('=I',len(self.plugins))
         for (opcodeBase,chunks) in self.plugins:
@@ -5698,9 +7548,9 @@ class SaveHeader:
     def __init__(self,path=None):
         """Initialize."""
         self.pcName = None
+        self.pcNick = None
         self.pcLocation = None
-        self.gameDays = 0
-        self.gameTicks = 0
+        self.playTime = None
         self.pcLevel = 0
         self.masters = []
         self.image = None
@@ -5711,27 +7561,37 @@ class SaveHeader:
         ins = path.open('rb')
         try:
             #--Header
-            ins.seek(34)
+            ins.seek(11) # FO3SAVEGAME
             headerSize, = struct.unpack('I',ins.read(4))
-            #posMasters = 38 + headerSize
-            #--Name, location
-            ins.seek(38+4)
-            size, = struct.unpack('B',ins.read(1))
+            unknown,delim = struct.unpack('Ic',ins.read(5))
+            ssWidth,delim1,ssHeight,delim2,ssDepth,delim3 = struct.unpack('=IcIcIc',ins.read(15))
+            #--Name, nickname, level, location, playtime
+            size,delim = struct.unpack('Hc',ins.read(3))
             self.pcName = cstrip(ins.read(size))
-            self.pcLevel, = struct.unpack('H',ins.read(2))
-            size, = struct.unpack('B',ins.read(1))
+            delim, = struct.unpack('c',ins.read(1))
+            size,delim = struct.unpack('Hc',ins.read(3))
+            self.pcNick = cstrip(ins.read(size))
+            delim, = struct.unpack('c',ins.read(1))
+            self.pcLevel,delim = struct.unpack('Ic',ins.read(5))
+            size,delim = struct.unpack('Hc',ins.read(3))
             self.pcLocation = cstrip(ins.read(size))
+            delim, = struct.unpack('c',ins.read(1))
+            size,delim = struct.unpack('Hc',ins.read(3))
+            self.playTime = cstrip(ins.read(size))
+            delim, = struct.unpack('c',ins.read(1))
             #--Image Data
-            self.gameDays,self.gameTicks,self.gameTime,ssSize,ssWidth,ssHeight = struct.unpack('=fI16s3I',ins.read(36))
             ssData = ins.read(3*ssWidth*ssHeight)
             self.image = (ssWidth,ssHeight,ssData)
             #--Masters
-            #ins.seek(posMasters)
+            unknown,masterListSize = struct.unpack('=BI',ins.read(5))
+            if unknown != 0x15:
+                raise "%s: Unknown byte is not 0x15." % path
             del self.masters[:]
-            numMasters, = struct.unpack('B',ins.read(1))
+            numMasters,delim = struct.unpack('Bc',ins.read(2))
             for count in range(numMasters):
-                size, = struct.unpack('B',ins.read(1))
+                size,delim = struct.unpack('Hc',ins.read(3))
                 self.masters.append(GPath(ins.read(size)))
+                delim, = struct.unpack('c',ins.read(1))
         #--Errors
         except:
             raise SaveFileError(path.tail,_('File header is corrupted..'))
@@ -5749,26 +7609,52 @@ class SaveHeader:
         def pack(format,*args):
             out.write(struct.pack(format,*args))
         #--Header
-        out.write(ins.read(34))
+        out.write(ins.read(11))
         #--SaveGameHeader
         size, = unpack('I',4)
         pack('I',size)
-        out.write(ins.read(size))
+        out.write(ins.read(5))
+        ssWidth,delim1,ssHeight,delim2 = unpack('=IcIc',10)
+        pack('=IcIc',ssWidth,delim1,ssHeight,delim2)
+        out.write(ins.read(size-15))
+        #--Image Data
+        out.write(ins.read(3*ssWidth*ssHeight))
         #--Skip old masters
-        numMasters, = unpack('B',1)
+        unknown,oldMasterListSize = unpack('=BI',5)
+        if unknown != 0x15:
+            raise "%s: Unknown byte is not 0x15." % path
+        numMasters,delim = unpack('Bc',2)
         oldMasters = []
         for count in range(numMasters):
-            size, = unpack('B',1)
+            size,delim = unpack('Hc',3)
             oldMasters.append(GPath(ins.read(size)))
+            delim, = unpack('c',1)
         #--Write new masters
-        pack('B',len(self.masters))
+        newMasterListSize = 2 + (4 * len(self.masters))
         for master in self.masters:
-            pack('B',len(master))
+            newMasterListSize += len(master)
+        pack('=BI',unknown,newMasterListSize)
+        pack('Bc',len(self.masters),'|')
+        for master in self.masters:
+            pack('Hc',len(master),'|')
             out.write(master.s)
+            pack('c','|')
         #--Fids Address
         offset = out.tell() - ins.tell()
         fidsAddress, = unpack('I',4)
         pack('I',fidsAddress+offset)
+        #--???? Address
+        unknownAddress, = unpack('I',4)
+        pack('I',unknownAddress+offset)
+        #--???? Address
+        unknownAddress, = unpack('I',4)
+        pack('I',unknownAddress+offset)
+        #--???? Address
+        unknownAddress, = unpack('I',4)
+        pack('I',unknownAddress+offset)
+        #--???? Address
+        unknownAddress, = unpack('I',4)
+        pack('I',unknownAddress+offset)
         #--Copy remainder
         while True:
             buffer= ins.read(0x5000000)
@@ -5787,13 +7673,13 @@ class SaveHeader:
             pluggy.load()
             pluggy.mapMasters(masterMap)
             pluggy.safeSave()
-        #--OBSE File?
-        obsePath = CoSaves.getPaths(path)[1]
-        if masterMap and obsePath.exists():
-            obse = ObseFile(obsePath)
-            obse.load()
-            obse.mapMasters(masterMap)
-            obse.safeSave()
+        #--FOSE File?
+        fosePath = CoSaves.getPaths(path)[1]
+        if masterMap and fosePath.exists():
+            fose = FoseFile(fosePath)
+            fose.load()
+            fose.mapMasters(masterMap)
+            fose.safeSave()
 
 #------------------------------------------------------------------------------
 class BSAHeader:
@@ -5827,7 +7713,7 @@ class SaveFile:
         'form','baseid','moved','havocMoved','scale','allExtra','lock','owner','unk8','unk9',
         'mapMarkerFlags','hadHavokMoveFlag','unk12','unk13','unk14','unk15',
         'emptyFlag','droppedItem','doorDefaultState','doorState','teleport',
-        'extraMagic','furnMarkers','oblivionFlag','movementExtra','animation',
+        'extraMagic','furnMarkers','falloutFlag','movementExtra','animation',
         'script','inventory','created','unk29','enabled'))
 
     def __init__(self,saveInfo=None,canSave=True):
@@ -5905,7 +7791,7 @@ class SaveFile:
         createdNum, = ins.unpack('I',4)
         for count in xrange(createdNum):
             progress(ins.tell(),_('Reading created...'))
-            header = ins.unpack('4s4I',20)
+            header = ins.unpack('4s4II',recHeaderSize)
             self.created.append(MreRecord(header,modReader))
         #--Pre-records: Quickkeys, reticule, interface, regions
         buff = cStringIO.StringIO()
@@ -6212,21 +8098,21 @@ class SaveFile:
                 else:
                     parentid = self.fids[iref]
                 log('%6d %08X %08X %6d kb' % (count,iref,parentid,cumSize/1024))
-    def logStatObse(self,log=None):
+    def logStatFose(self,log=None):
         """Print stats to log."""
         log = log or bolt.Log()
-        obseFileName = self.fileInfo.getPath().root+'.obse'
-        obseFile = ObseFile(obseFileName)
-        obseFile.load()
+        foseFileName = self.fileInfo.getPath().root+'.fose'
+        foseFile = FoseFile(foseFileName)
+        foseFile.load()
         #--Header
         log.setHeader(_('Header'))
         log('=' * 80)
-        log(_('  Format version:   %08X') % (obseFile.formatVersion,))
-        log(_('  OBSE version:     %u.%u') % (obseFile.obseVersion,obseFile.obseMinorVersion,))
-        log(_('  Oblivion version: %08X') % (obseFile.oblivionVersion,))
+        log(_('  Format version:  %08X') % (foseFile.formatVersion,))
+        log(_('  FOSE version:    %u.%u') % (foseFile.foseVersion,foseFile.foseMinorVersion,))
+        log(_('  Fallout version: %08X') % (foseFile.falloutVersion,))
         #--Plugins
-        if obseFile.plugins != None:
-            for (opcodeBase,chunks) in obseFile.plugins:
+        if foseFile.plugins != None:
+            for (opcodeBase,chunks) in foseFile.plugins:
                 log.setHeader(_('Plugin opcode=%08X chunkNum=%u') % (opcodeBase,len(chunks),))
                 log('=' * 80)
                 log(_('  Type  Ver   Size'))
@@ -6241,16 +8127,16 @@ class SaveFile:
                     ins = cStringIO.StringIO(chunkBuff)
                     def unpack(format,size):
                         return struct.unpack(format,ins.read(size))
-                    if (opcodeBase == 0x1400):  # OBSE
+                    if (opcodeBase == 0x1400):  # FOSE
                         if chunkType == 'RVTS':
-                            #--OBSE String
+                            #--FOSE String
                             modIndex,stringID,stringLength, = unpack('=BIH',7)
                             stringData = ins.read(stringLength)
                             log(_('    Mod :  %02X (%s)') % (modIndex, self.masters[modIndex].s))
                             log(_('    ID  :  %u') % stringID)
                             log(_('    Data:  %s') % Unicode(stringData,'mbcs'))
                         elif chunkType == 'RVRA':
-                            #--OBSE Array
+                            #--FOSE Array
                             modIndex,arrayID,keyType,isPacked, = unpack('=BIBB',7)
                             if modIndex == 255:
                                 log(_('    Mod :  %02X (Save File)') % (modIndex))
@@ -6526,7 +8412,7 @@ class SaveFile:
 
 #--------------------------------------------------------------------------------
 class CoSaves:
-    """Handles co-files (.pluggy, .obse) for saves."""
+    """Handles co-files (.pluggy, .fose) for saves."""
     reSave  = re.compile(r'\.ess(f?)$',re.I)
 
     @staticmethod
@@ -6535,7 +8421,7 @@ class CoSaves:
         maSave = CoSaves.reSave.search(savePath.s)
         if maSave: savePath = savePath.root
         first = maSave and maSave.group(1) or ''
-        return tuple(savePath+ext+first for ext in  ('.pluggy','.obse'))
+        return tuple(savePath+ext+first for ext in  ('.pluggy','.fose'))
 
     def __init__(self,savePath,saveName=None):
         """Initialize with savePath."""
@@ -6565,14 +8451,14 @@ class CoSaves:
 
     def getTags(self):
         """Returns tags expressing whether cosaves exist and are correct."""
-        cPluggy,cObse = ('','')
+        cPluggy,cFose = ('','')
         save = self.savePath
-        pluggy,obse = self.paths
+        pluggy,fose = self.paths
         if pluggy.exists():
             cPluggy = 'XP'[abs(pluggy.mtime - save.mtime) < 10]
-        if obse.exists():
-            cObse = 'XO'[abs(obse.mtime - save.mtime) < 10]
-        return (cObse,cPluggy)
+        if fose.exists():
+            cFose = 'XO'[abs(fose.mtime - save.mtime) < 10]
+        return (cFose,cPluggy)
 
 # File System -----------------------------------------------------------------
 #--------------------------------------------------------------------------------
@@ -6673,12 +8559,12 @@ class BsaFile:
         """Reset dates of bsa files to 'correct' values."""
         #--Fix the data of a few archive files
         bsaTimes = (
-            ('Oblivion - Meshes.bsa',1138575220),
-            ('Oblivion - Misc.bsa',1139433736),
-            ('Oblivion - Sounds.bsa',1138660560),
-            (inisettings['OblivionTexturesBSAName'],1138162634),
-            ('Oblivion - Voices1.bsa',1138162934),
-            ('Oblivion - Voices2.bsa',1138166742),
+            ('Fallout - MenuVoices.bsa',1138575220),
+            ('Fallout - Meshes.bsa',1139433736),
+            ('Fallout - Misc.bsa',1138660560),
+            ('Fallout - Sound.bsa',1138162634),
+            (inisettings['FalloutTexturesBSAName'].stail,1138162634),
+            ('Fallout - Voices.bsa',1138166742),
             )
         for bsaFile,mtime in bsaTimes:
             dirs['mods'].join(bsaFile).mtime = mtime
@@ -6910,7 +8796,7 @@ class IniFile:
         self.path.untemp()
 
     def applyTweakFile(self,tweakPath):
-        """Read Ini tweak file and apply its settings to oblivion.ini.
+        """Read Ini tweak file and apply its settings to FALLOUT.INI.
         Note: Will ONLY apply settings that already exist."""
         if not self.path.exists() or not self.path.isfile():
             return
@@ -6937,20 +8823,20 @@ class IniFile:
 
 #-----------------------------------------------------------------------------------------------
 def BestIniFile(path):
-    if path.csbody == 'oblivion':
-        return oblivionIni
+    if path.csbody == 'fallout':
+        return falloutIni
     ini = IniFile(path)
     ini_settings = ini.getSettings()
     if len(ini_settings) > 0:
         return ini
-    obse = OBSEIniFile(path)
-    ini_settings = obse.getSettings()
+    fose = FOSEIniFile(path)
+    ini_settings = fose.getSettings()
     if len(ini_settings) > 0:
-        return obse
+        return fose
     return ini
 
-class OBSEIniFile(IniFile):
-    """OBSE Configuration ini file.  Minimal support provided, only can
+class FOSEIniFile(IniFile):
+    """FOSE Configuration ini file.  Minimal support provided, only can
     handle 'set' and 'setGS' statements."""
     reSet     = re.compile(r'\s*set\s+(.+?)\s+to\s+(.*)', re.I)
     reSetGS   = re.compile(r'\s*setGS\s+(.+?)\s+(.*)', re.I)
@@ -7124,27 +9010,27 @@ class OBSEIniFile(IniFile):
         self.saveSettings(ini_settings)
 
 #--------------------------------------------------------------------------------
-class OblivionIni(IniFile):
-    """Oblivion.ini file."""
-    bsaRedirectors = set(('archiveinvalidationinvalidated!.bsa',r'..\obmm\bsaredirection.bsa'))
+class FalloutIni(IniFile):
+    """FALLOUT.INI file."""
+    bsaRedirectors = set(('archiveinvalidationinvalidated!.bsa',r'..\fomm\bsaredirection.bsa'))
 
     def __init__(self):
         """Initialize."""
-        # Use local copy of the oblivion.ini if present
-        if dirs['app'].join('oblivion.ini').exists():
-            IniFile.__init__(self,dirs['app'].join('Oblivion.ini'),'General')
+        # Use local copy of the fallout.ini if present
+        if dirs['app'].join('FALLOUT.INI').exists():
+            IniFile.__init__(self,dirs['app'].join('FALLOUT.INI'),'General')
             # is bUseMyGamesDirectory set to 0?
             if self.getSetting('General','bUseMyGamesDirectory','1') == '0':
                 return
-        # oblivion.ini was not found in the game directory or bUseMyGamesDirectory was not set."""
+        # fallout.ini was not found in the game directory or bUseMyGamesDirectory was not set."""
         # default to user profile directory"""
-        IniFile.__init__(self,dirs['saveBase'].join('Oblivion.ini'),'General')
+        IniFile.__init__(self,dirs['saveBase'].join('FALLOUT.INI'),'General')
 
 
     def ensureExists(self):
-        """Ensures that Oblivion.ini file exists. Copies from default oblvion.ini if necessary."""
+        """Ensures that FALLOUT.INI file exists. Copies from default fallout.ini if necessary."""
         if self.path.exists(): return
-        srcPath = dirs['app'].join('Oblivion_default.ini')
+        srcPath = dirs['app'].join('Fallout_default.ini')
         srcPath.copyTo(self.path)
 
     def getSettings(self):
@@ -7160,7 +9046,7 @@ class OblivionIni(IniFile):
         IniFile.saveSettings(self,settings)
 
     def applyTweakFile(self,tweakPath):
-        """Read Ini tweak file and apply its settings to oblivion.ini.
+        """Read Ini tweak file and apply its settings to FALLOUT.INI.
         Note: Will ONLY apply settings that already exist."""
         self.ensureExists()
         IniFile.applyTweakFile(self,tweakPath)
@@ -7188,6 +9074,13 @@ class OblivionIni(IniFile):
         sArchives = ', '.join(archives)
         self.saveSetting('Archive','sArchiveList',sArchives)
 
+#--------------------------------------------------------------------------------
+class FalloutPrefsIni(FalloutIni):
+    """FalloutPrefs.ini file."""
+    def __init__(self):
+        """Initialize."""
+        IniFile.__init__(self,dirs['saveBase'].join('FalloutPrefs.ini'),'General')
+
 #------------------------------------------------------------------------------
 class OmodFile:
     """Class for extracting data from omods."""
@@ -7470,9 +9363,9 @@ class Plugins:
         """Write data to Plugins.txt file."""
         self.selected.sort()
         out = self.path.open('w')
-        out.write('# This file is used to tell Oblivion which data files to load.\n\n')
+        out.write('# This file is used to tell Fallout3 which data files to load.\n\n')
         for modName in self.selected:
-            out.write(modName.s+'\n')
+            out.write(Encode(modName.s+'\n','mbcs'))
         out.close()
         self.mtime = self.path.mtime
         self.size = self.path.size
@@ -7754,6 +9647,7 @@ class FileInfo:
         normal = self.dir.join(self.name)
         ghost = normal+'.ghost'
         try:
+            if not normal.editable() or not ghost.editable(): return self.isGhost
             if isGhost: normal.moveTo(ghost)
             else: ghost.moveTo(normal)
             self.isGhost = isGhost
@@ -7851,7 +9745,7 @@ class ModInfo(FileInfo):
 
     def writeNew(self,masters=[],mtime=0):
         """Creates a new file with the given name, masters and mtime."""
-        header = MreTes4(('TES4',0,(self.isEsm() and 1 or 0),0,0))
+        header = MreTes4(('TES4',0,(self.isEsm() and 1 or 0),0,0,0))
         for master in masters:
             header.masters.append(master)
         header.setChanged()
@@ -7920,8 +9814,7 @@ class ModInfo(FileInfo):
         """Returns a dirty message from BOSS."""
         if modInfos.table.getItem(self.name,'ignoreDirty',False):
             return (False,'')
-        crc = self.cachedCrc()
-        return configHelpers.getDirtyMessage(crc)
+        return configHelpers.getDirtyMessage(self.name)
 
     #--Header Editing ---------------------------------------------------------
     def getHeader(self):
@@ -8255,6 +10148,10 @@ class FileInfos(DataDict):
             if name in newNames: continue #--Must be a ghost duplicate. Ignore it.
             oldInfo = self.data.get(name)
             isAdded = name not in oldNames
+            # sanity check.
+            if oldInfo is None and isAdded == False:
+                deprint(oldInfo,name,isAdded,oldNames,self.data)
+                isAdded = True
             isUpdated = not isAdded and not fileInfo.sameAs(oldInfo)
             if isAdded or isUpdated:
                 errorMessage = fileInfo.getHeaderError()
@@ -8284,6 +10181,7 @@ class FileInfos(DataDict):
         fileInfo = self[oldName]
         #--File system
         newPath = self.dir.join(newName)
+        oldIndex = boss.GetPluginLoadOrder(oldName)
         if fileInfo.isGhost: newPath += '.ghost'
         oldPath = fileInfo.getPath()
         oldPath.moveTo(newPath)
@@ -8293,6 +10191,7 @@ class FileInfos(DataDict):
         self[newName] = self[oldName]
         del self[oldName]
         self.table.moveRow(oldName,newName)
+        boss.SetPluginLoadOrder(newName, oldIndex)
         #--Done
         fileInfo.madeBackup = False
 
@@ -8360,7 +10259,7 @@ class ResourceReplacer:
         'fonts': ['.fnt', '.tex'],
         'menus': ['.bat', '.html', '.scc', '.txt', '.xml'],
         'meshes': ['.egm', '.egt', '.fim', '.kf', '.kfm', '.nif', '.tri', '.txt'],
-        'obse':['.dll','.dlx','.txt','.mp3'],
+        'fose':['.dll','.dlx','.txt','.mp3'],
         'shaders': ['.sdp','.fx'],
         'sound': ['.lip', '.mp3', '.wav'],
         'textures': ['.dds', '.ifl', '.psd', '.txt'],
@@ -8380,7 +10279,7 @@ class ResourceReplacer:
     def validate(self):
         """Does archive invalidation according to settings."""
         if settings.get('bash.replacers.autoEditBSAs',False):
-            bsaPath = dirs['mods'].join(inisettings['OblivionTexturesBSAName'])
+            bsaPath = dirs['mods'].join(inisettings['FalloutTexturesBSAName'])
             bsaFile = BsaFile(bsaPath)
             bsaFile.scan()
             bsaFile.invalidate()
@@ -8498,12 +10397,12 @@ class ResourceReplacer:
         aiModsPath.remove()
         #--Fix the data of a few archive files
         bsaTimes = (
-            ('Oblivion - Meshes.bsa',1138575220),
-            ('Oblivion - Misc.bsa',1139433736),
-            ('Oblivion - Sounds.bsa',1138660560),
-            (inisettings['OblivionTexturesBSAName'],1138162634),
-            ('Oblivion - Voices1.bsa',1138162934),
-            ('Oblivion - Voices2.bsa',1138166742),
+            ('Fallout - MenuVoices.bsa',1138575220),
+            ('Fallout - Meshes.bsa',1139433736),
+            ('Fallout - Misc.bsa',1138660560),
+            ('Fallout - Sound.bsa',1138162634),
+            (inisettings['FalloutTexturesBSAName'],1138162634),
+            ('Fallout - Voices.bsa',1138162934),
             )
         for bsaFile,mtime in bsaTimes:
             bsaPath = dirs['mods'].join(bsaFile)
@@ -8513,7 +10412,7 @@ class ResourceReplacer:
 class INIInfos(FileInfos):
     def __init__(self):
         FileInfos.__init__(self, dirs['mods'].join('INI Tweaks'),INIInfo)
-        self.ini = oblivionIni
+        self.ini = falloutIni
 
     def rightFileType(self,fileName):
         """Bool: File is an ini."""
@@ -8527,7 +10426,7 @@ class INIInfos(FileInfos):
         return dirs['modsBash'].join('INI Data')
 #------------------------------------------------------------------------------
 class ModInfos(FileInfos):
-    """Collection of modinfos. Represents mods in the Oblivion\Data directory."""
+    """Collection of modinfos. Represents mods in the Fallout 3\Data directory."""
 
     def __init__(self):
         """Initialize."""
@@ -8542,13 +10441,13 @@ class ModInfos(FileInfos):
         self.plugins = Plugins() #--Plugins instance.
         self.ordered = tuple() #--Active mods arranged in load order.
         #--Info lists/sets
-        if dirs['mods'].join('Oblivion.esm').exists():
-            self.masterName = GPath('Oblivion.esm')
-        elif dirs['mods'].join('Nehrim.esm').exists():
-            self.masterName = GPath('Nehrim.esm')
+        if dirs['mods'].join('Fallout3.esm').exists():
+            self.masterName = GPath('Fallout3.esm')
+        #elif dirs['mods'].join('Fallout3.esm').exists():
+        #    self.masterName = GPath('Fallout3.esm')
         else:
-            self.masterName = GPath('Oblivion.esm')
-            deprint(_('Missing master file; Neither Oblivion.esm or Nehrim.esm exists in an unghosted state in %s - presuming that Oblivion.esm is the correct masterfile.') % (dirs['mods'].s))
+            self.masterName = GPath('Fallout3.esm')
+            deprint(_('Missing master file; Neither Fallout3.esm exists in an unghosted state in %s - presuming that Fallout3.esm is the correct masterfile.') % (dirs['mods'].s))
         self.mtime_mods = {}
         self.mtime_selected = {}
         self.exGroup_mods = {}
@@ -8559,13 +10458,12 @@ class ModInfos(FileInfos):
         self.autoHeaders = set() #--Full balo headers
         self.autoGroups = {} #--Auto groups as read from group files.
         self.group_header = {}
-        #--Oblivion version
+        #--Fallout version
         self.version_voSize = {
-            '1.1':        247388848, #--Standard
-            '1.1b':       247388894, # Arthmoor has this size.
-            'GOTY non-SI':247388812, # GOTY version
-            '1.0.7.5':    108369128, # Nehrim
-            'SI':         277504985} # Shivering Isles 1.2
+            '1.0':int(_("288769595")),
+            '1.1':int(_("288771181")),
+            '1.4':int(_("288771262")),
+            }
         self.size_voVersion = bolt.invertDict(self.version_voSize)
         self.voCurrent = None
         self.voAvailable = set()
@@ -8579,11 +10477,11 @@ class ModInfos(FileInfos):
         """Returns a boolean indicating if mtime setting is allowed."""
         self.lockTimes = settings['bosh.modInfos.resetMTimes']
         self.fullBalo = settings.get('bash.balo.full',False)
-        obmmWarn = settings.setdefault('bosh.modInfos.obmmWarn',0)
-        if self.lockTimes and obmmWarn == 0 and dirs['app'].join('obmm').exists():
-            settings['bosh.modInfos.obmmWarn'] = 1
+        fommWarn = settings.setdefault('bosh.modInfos.fommWarn',0)
+        if self.lockTimes and fommWarn == 0 and dirs['app'].join('fomm').exists():
+            settings['bosh.modInfos.fommWarn'] = 1
         if not self.lockTimes: return False
-        if settings['bosh.modInfos.obmmWarn'] == 1: return False
+        if settings['bosh.modInfos.fommWarn'] == 1: return False
         if settings.dictFile.readOnly: return False
         #--Else
         return True
@@ -8601,7 +10499,7 @@ class ModInfos(FileInfos):
         hasGhosted = self.autoGhost()
         hasSorted = self.autoSort()
         self.refreshInfoLists()
-        self.getOblivionVersions()
+        self.getFalloutVersions()
         return bool(hasChanged) or hasSorted or hasGhosted
 
     def refreshHeaders(self):
@@ -8772,7 +10670,7 @@ class ModInfos(FileInfos):
         progress.setFull(len(names))
         for i,fileName in enumerate(names):
             progress(i,fileName.s)
-            if reOblivion.match(fileName.s): continue
+            if reFallout.match(fileName.s): continue
             fileInfo = self[fileName]
             try:
                 if not doCBash:
@@ -8782,7 +10680,7 @@ class ModInfos(FileInfos):
             except Exception, e:
                 deprint (_("Error scanning mod %s (%s)" %(fileName, str(e))))
                 canMerge = False #presume non-mergeable.
-            if fileName == "Oscuro's_Oblivion_Overhaul.esp": canMerge = False #can't be above because otherwise if the mergeability had already been set true this wouldn't unset it.
+            #if fileName == "Oscuro's_Oblivion_Overhaul.esp": canMerge = False #can't be above because otherwise if the mergeability had already been set true this wouldn't unset it.
             if canMerge == True:
                 self.mergeable.add(fileName)
                 mod_mergeInfo[fileName] = (fileInfo.size,True)
@@ -9024,66 +10922,82 @@ class ModInfos(FileInfos):
         else:
             return None
 
-    def getModList(self,fileInfo=None,wtxt=False):
+    def getModList(self,showCRC=False,showVersion=True,fileInfo=None,wtxt=False):
         """Returns mod list as text. If fileInfo is provided will show mod list
         for its masters. Otherwise will show currently loaded mods."""
         #--Setup
-        log = bolt.LogFile(stringBuffer())
-        head = ('','=== ')[wtxt]
-        bul = ('','* ')[wtxt]
-        sMissing = (_('----> MISSING MASTER: '),_('  * __Missing Master:__ '))[wtxt]
-        sDelinquent = (_('----> Delinquent MASTER: '),_('  * __Delinquent Master:__ '))[wtxt]
-        sImported = ('**','&bull; &bull;')[wtxt]
-        if fileInfo:
-            masters = set(fileInfo.header.masters)
-            missing = sorted([x for x in masters if x not in self])
-            log.setHeader(head+_('Missing Masters for: ')+fileInfo.name.s)
-            for mod in missing:
-                log(bul+'xx '+mod.s)
-            log.setHeader(head+_('Masters for: ')+fileInfo.name.s)
-            present = set(x for x in masters if x in self)
-            if fileInfo.name in self: #--In case is bashed patch
-                present.add(fileInfo.name)
-            merged,imported = self.getSemiActive(present)
-        else:
-            log.setHeader(head+_('Active Mod Files:'))
-            masters = set(self.ordered)
-            merged,imported = self.merged,self.imported
-        headers = set(mod for mod in self.data if mod.s[0] in '.=+')
-        allMods = masters | merged | imported | headers
-        allMods = self.getOrdered([x for x in allMods if x in self])
-        #--List
-        modIndex,header = 0, None
-        if not wtxt: log('[spoiler][xml]', False)
-        for name in allMods:
-            if name in masters:
-                prefix = bul+'%02X' % (modIndex)
-                modIndex += 1
-            elif name in headers:
-                match = re.match('^[\.+= ]*(.*?)\.es[pm]',name.s)
-                if match: name = GPath(match.group(1))
-                header = bul+'==  ' +name.s
-                continue
-            elif name in merged:
-                prefix = bul+'++'
+        with sio() as out:
+            log = bolt.LogFile(out)
+            head,bul,sMissing,sDelinquent,sImported = (
+                '=== ',
+                '* ',
+                _('  * __Missing Master:__ '),
+                _('  * __Delinquent Master:__ '),
+                '&bull; &bull;'
+                ) if wtxt else (
+                '',
+                '',
+                _('----> MISSING MASTER: '),
+                _('----> Delinquent MASTER: '),
+                '**')
+            if fileInfo:
+                masters = set(fileInfo.header.masters)
+                missing = sorted([x for x in masters if x not in self])
+                log.setHeader(head+Unicode(_('Missing Masters for: '))+fileInfo.name.s)
+                for mod in missing:
+                    log(bul+'xx '+mod.s)
+                log.setHeader(head+_('Masters for: ')+fileInfo.name.s)
+                present = set(x for x in masters if x in self)
+                if fileInfo.name in self: #--In case is bashed patch
+                    present.add(fileInfo.name)
+                merged,imported = self.getSemiActive(present)
             else:
-                prefix = bul+sImported
-            version = self.getVersion(name)
-            if header:
-                log(header)
-                header = None
-            if version:
-                log(_('%s  %s  [Version %s] [CRC: %08X]') % (prefix,name.s,version,self[name].cachedCrc()))
-            else:
-                log('%s  %s [CRC: %08X]' % (prefix,name.s,self[name].cachedCrc()))
-            if name in masters:
-                for master2 in self[name].header.masters:
-                    if master2 not in self:
-                        log(sMissing+master2.s)
-                    elif self.getOrdered((name,master2))[1] == master2:
-                        log(sDelinquent+master2.s)
-        if not wtxt: log('[/xml][/spoiler]')
-        return bolt.winNewLines(log.out.getvalue())
+                log.setHeader(head+_('Active Mod Files:'))
+                masters = set(self.ordered)
+                merged,imported = self.merged,self.imported
+            headers = set(mod for mod in self.data if mod.s[0] in '.=+')
+            allMods = masters | merged | imported | headers
+            allMods = self.getOrdered([x for x in allMods if x in self])
+            #--List
+            modIndex,header = 0, None
+            bUseUnicode = inisettings['EnableUnicode']
+            if not wtxt: log('[spoiler][xml]', False)
+            for name in allMods:
+                if name in masters:
+                    prefix = bul+'%02X' % (modIndex)
+                    modIndex += 1
+                elif name in headers:
+                    match = re.match('^[\.+= ]*(.*?)\.es[pm]',name.s,flags=re.U)
+                    if match: name = GPath(match.group(1))
+                    header = bul+'==  ' +name.s
+                    continue
+                elif name in merged:
+                    prefix = bul+'++'
+                else:
+                    prefix = bul+sImported
+                if header:
+                    log(header)
+                    header = None
+                text = '%s  %s' % (prefix,name.s,)
+                if showVersion:
+                    version = self.getVersion(name)
+                    if version: text += _('  [Version %s]') % (version)
+                if showCRC:
+                    text +=_('  [CRC: %08X]') % (self[name].cachedCrc())
+                if not bUseUnicode and isinstance(text,unicode): text = text.encode('mbcs')
+                log(text)
+                if name in masters:
+                    for master2 in self[name].header.masters:
+                        if master2 not in self:
+                            text = sMissing+master2.s
+                            if not bUseUnicode and isinstance(text,unicode): text = text.encode('mbcs')
+                            log(text)
+                        elif self.getOrdered((name,master2))[1] == master2:
+                            text = sDelinquent+master2.s
+                            if not bUseUnicode and isinstance(text,unicode): text = text.encode('mbcs')
+                            log(text)
+            if not wtxt: log('[/xml][/spoiler]')
+            return bolt.winNewLines(log.out.getvalue())
 
     def getTagList(self,modList=None):
         """Returns the list as wtxt of current bash tags (but doesn't say what ones are applied via a patch).
@@ -9256,18 +11170,19 @@ class ModInfos(FileInfos):
                         requires[key] = float(value or 0)
         return requires
 
-    #--Oblivion 1.1/SI Swapping -----------------------------------------------
-    def getOblivionVersions(self):
-        """Returns tuple of Oblivion versions."""
+    #--Fallout3 1.0/1.1/1.4 Swapping -----------------------------------------------
+    def getFalloutVersions(self):
+        """Returns tuple of Fallout(3|NV) versions."""
+        reFallout = re.compile('^Fallout3(|_1.0|_1.1|_1.4).esm$')
         self.voAvailable.clear()
         for name,info in self.data.iteritems():
-            maOblivion = reOblivion.match(name.s)
-            if maOblivion and info.size in self.size_voVersion:
+            maFallout = reFallout.match(name.s)
+            if maFallout and info.size in self.size_voVersion:
                 self.voAvailable.add(self.size_voVersion[info.size])
         self.voCurrent = self.size_voVersion.get(self.data[self.masterName].size,None)
 
-    def setOblivionVersion(self,newVersion):
-        """Swaps Oblivion.esm to to specified version."""
+    def setFalloutVersion(self,newVersion):
+        """Swaps Fallout(3|NV).esm to to specified version."""
         #--Old info
         baseName = self.masterName
         newSize = self.version_voSize[newVersion]
@@ -9400,19 +11315,19 @@ class SaveInfos(FileInfos):
         self.localSave = getattr(self,'localSave','Saves\\')
         self.dir = dirs['saveBase'].join(self.localSave)
         self.bashDir = self.getBashDir()
-        if oblivionIni.path.exists() and (oblivionIni.path.mtime != self.iniMTime):
-            self.localSave = oblivionIni.getSetting('General','SLocalSavePath','Saves\\')
-            self.iniMTime = oblivionIni.path.mtime
+        if falloutIni.path.exists() and (falloutIni.path.mtime != self.iniMTime):
+            self.localSave = falloutIni.getSetting('General','SLocalSavePath','Saves\\')
+            self.iniMTime = falloutIni.path.mtime
             return True
         else:
             return False
 
     def setLocalSave(self,localSave):
-        """Sets SLocalSavePath in Oblivion.ini."""
+        """Sets SLocalSavePath in FALLOUT.INI."""
         self.table.save()
         self.localSave = localSave
-        oblivionIni.saveSetting('General','SLocalSavePath',localSave)
-        self.iniMTime = oblivionIni.path.mtime
+        falloutIni.saveSetting('General','SLocalSavePath',localSave)
+        self.iniMTime = falloutIni.path.mtime
         bashDir = dirs['saveBase'].join(localSave,'Bash')
         self.table = bolt.Table(PickleDict(bashDir.join('Table.dat')))
         self.refresh()
@@ -9423,12 +11338,12 @@ class SaveInfos(FileInfos):
         return (fileName.cext == '.ess')
 
     def enable(self,fileName,value=True):
-        """Enables file by changing extension to 'ess' (True) or 'esr' (False)."""
+        """Enables file by changing extension to 'fos' (True) or 'for' (False)."""
         isEnabled = self.isEnabled(fileName)
         if isEnabled or value == isEnabled or re.match('(autosave|quicksave)',fileName.s,re.I):
             return fileName
         (root,ext) = fileName.rootExt
-        newName = root + ((value and '.ess') or '.esr')
+        newName = root + ((value and '.fos') or '.for')
         self.rename(fileName,newName)
         return newName
 
@@ -9649,145 +11564,131 @@ class ConfigHelpers:
     def __init__(self):
         """Initialialize."""
         #--Boss Master List or if that doesn't exist use the taglist
-        #version notes:
-        # 1.8   = 3
-        # 1.7   = 2
-        #>1.6.2 = 393218+
-        # 1.6.1 = 393217
-        # 1.6   = 1
-        #<1.6   = 0
-        if dirs['app'].join('BOSS//BOSS.exe').exists():
-            self.bossVersion = 2
-            try:
-                import win32api
-                info = win32api.GetFileVersionInfo(dirs['app'].join('BOSS','BOSS.exe').s, '\\')
-                ms = info['FileVersionMS']
-                ls = info['FileVersionLS']
-                version = (win32api.HIWORD(ms), win32api.LOWORD(ms), win32api.HIWORD(ls), win32api.LOWORD(ls))
-                if version >= (1,8,0,0):
-                    self.bossVersion = 3
-            except:
-                pass
-            self.bossMasterPath = dirs['app'].join('BOSS','masterlist.txt')
-            self.bossUserPath = dirs['app'].join('BOSS','userlist.txt')
-        else:
-            try:
-                import win32api
-                self.bossVersion = win32api.GetFileVersionInfo(dirs['mods'].join('BOSS.exe').s, '\\')[u'FileVersionLS']
-            except: #any version prior to 1.6.1 will fail and hence set to None and then try to set based on masterlist path.
-                self.bossVersion = None
-            self.bossMasterPath = dirs['mods'].join('BOSS','masterlist.txt')
-            if self.bossVersion == None:
-                if not self.bossMasterPath.exists():
-                    self.bossMasterPath = dirs['mods'].join('masterlist.txt')
-                    self.bossVersion = 0
-                    if not self.bossMasterPath.exists():
-                        self.bossVersion = 1 # in case the BOSS masterlist hasn't yet been created but BOSS.exe exists.
-                        self.bossMasterPath = dirs['patches'].join('taglist.txt')
-                else: self.bossVersion = 1
-            elif self.bossVersion in [393217,393218]: self.bossVersion = 1
-            self.bossUserPath = dirs['mods'].join('BOSS','userlist.txt')
-        self.bossMasterTime = 0
-        self.bossUserTime = 0
-        self.bossMasterTags = {}
-        self.bossRemoveTags = {}
-        self.bossDirtyMods = {}
-        #--Mod Rules
-        self.name_ruleSet = {}
+        # version notes:
+        #  Support for < 1.8 is dropped. Support is for 1.8+.
 
-    def refresh(self):
+        # Detect locally installed (into game folder) BOSS
+        if dirs['app'].join('BOSS','BOSS.exe').exists():
+            dirs['boss'] = dirs['app'].join('BOSS')
+        else:
+            dirs['boss'] = GPath('C:\\**DNE**')
+        # Detect globally installed (into Program Files) BOSS
+        try:
+            import _winreg
+            for hkey in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE):
+                for wow6432 in ('','Wow6432Node\\'):
+                    try:
+                        key = _winreg.OpenKey(hkey,'Software\\%sBoss' % wow6432)
+                        value = _winreg.QueryValueEx(key,'Installed Path')
+                    except:
+                        continue
+                    if value[1] != _winreg.REG_SZ: continue
+                    installedPath = GPath(value[0])
+                    if not installedPath.exists(): continue
+                    dirs['boss'] = installedPath
+                    break
+                else:
+                    continue
+                break
+        except ImportError:
+            pass
+
+        
+        bapi.Init(dirs['compiled'].s)
+        # That didn't work - Wrye Bash isn't installed correctly
+        if not bapi.BAPI:
+            raise bolt.BoltError('The BOSS API could not be loaded.')
+            
+
+        global boss
+        #boss = bapi.BossDb(GPath(dirs['mods'].s).s,bush.game.name)
+        boss = bapi.BossDb(GPath(dirs['app'].s).s,'Fallout 3')
+        deprint('Using BOSS API version:', bapi.version)
+        bapi.RegisterCallback(bapi.BOSS_API_WARN_LO_MISMATCH,
+                              ConfigHelpers.bossLOMismatchCallback)
+
+        self.bossVersion = dirs['boss'].join('BOSS.exe').version
+        if self.bossVersion >= (2,0,0,0):
+            # BOSS 2.0+ stores the masterlist/userlist in a subdirectory
+            #self.bossMasterPath = dirs['boss'].join(bush.game.name,'masterlist.txt')
+            #self.bossUserPath = dirs['boss'].join(bush.game.name,'userlist.txt')
+            self.bossMasterPath = dirs['boss'].join('Fallout 3','masterlist.txt')
+            self.bossUserPath = dirs['boss'].join('Fallout 3','userlist.txt')
+        else:
+            self.bossMasterPath = dirs['boss'].join('masterlist.txt')
+            self.bossUserPath = dirs['boss'].join('userlist.txt')
+        self.bossMasterTime = None
+        self.bossUserTime = None
+        #--Bash Tags
+        self.tagCache = {}
+        #--Mod Rules
+        self.name_ruleSet = {}
+        #--Refresh
+        self.refresh(True)
+
+    @staticmethod
+    def bossLOMismatchCallback():
+        """Called whenever a mismatched loadorder.txt and plugins.txt is found"""
+        # Force a rewrite of both plugins.txt and loadorder.txt
+        # In other words, use what's in loadorder.txt to write plugins.txt
+        modInfos.plugins.loadLoadOrder()
+        modInfos.plugins.saveLoadOrder()
+
+    def refresh(self,firstTime=False):
         """Reloads tag info if file dates have changed."""
-        #--Boss Master List or Taglist
-        path,userpath,mtime,utime,tags,removeTags = (self.bossMasterPath, self.bossUserPath, self.bossMasterTime, self.bossUserTime, self.bossMasterTags,self.bossRemoveTags)
-        reFcomSwitch = re.compile('^[<>]')
-        reComment = re.compile(r'^\\.*')
-        reMod = re.compile(r'(^[_[(\w!].*?\.es[pm]$)',re.I)
-        reBashTags = re.compile(r'(APPEND:\s|REPLACE:\s)?(%\s+{{BASH:|TAG\s+{{BASH:)([^}]+)(}})(.*remove \[)?([^\]]+)?(\])?')
-        reDirty = re.compile(r'.*?IF\s*\(\s*([a-fA-F0-9]*)\s*\|\s*[\"\'](.*?)[\'\"]\s*\).*?DIRTY:\s*(.*?)\s*$')
+        path,userpath,mtime,utime = (self.bossMasterPath, self.bossUserPath, self.bossMasterTime, self.bossUserTime)
+        #--Masterlist is present, use it
         if path.exists():
-            if path.mtime != mtime:
-                tags.clear()
-                ins = path.open('r')
-                mod = None
-                for line in ins:
-                    line = reFcomSwitch.sub('',line)
-                    line = reComment.sub('',line)
-                    maMod = reMod.match(line)
-                    maBashTags = reBashTags.match(line)
-                    maDirty = reDirty.match(line)
-                    if maMod:
-                        mod = maMod.group(1)
-                    elif maBashTags and mod:
-                        modTags = maBashTags.group(3).split(',')
-                        modTags = map(string.strip,modTags)
-                        if maBashTags.group(5) and maBashTags.group(6):
-                            modRemoveTags = maBashTags.group(6).split(',')
-                            modRemoveTags = map(string.strip,modRemoveTags)
-                            removeTags[GPath(mod)] = tuple(modRemoveTags)
-                        tags[GPath(mod)] = tuple(modTags)
-                    elif maDirty:
-                        # BOSS 1.7+ dirty mod listing
-                        try:
-                            crc = long(maDirty.group(1),16)
-                            ##mod = LString(maDirty.group(2))
-                            action = maDirty.group(3)
-                            if 'tes4edit' in action.lower():
-                                cleanIt = True
-                            else:
-                                cleanIt = False
-                            self.bossDirtyMods[crc] = (cleanIt, action)
-                        except:
-                            deprint("An error occured parsing BOSS's masterlist for dirty crc's:\n", traceback=True)
-                ins.close()
-                self.bossMasterTime = path.mtime
-        if userpath.exists():
-            if userpath.mtime != utime:
-                ins = userpath.open('r')
-                mod = None
-                reRule = re.compile(r'(ADD:\s|FOR:\s|OVERIDE:\s)([_[(\w!].*?\.es[pm]$)')
-                for line in ins:
-                    maMod = reRule.match(line)
-                    maBashTags = reBashTags.match(line)
-                    if maMod:
-                        mod = maMod.group(2)
-                    elif maBashTags and mod:
-                        modTags = maBashTags.group(3).split(',')
-                        modTags = map(string.strip,modTags)
-                        if GPath(mod) in tags and maBashTags.group(1) != 'REPLACE: ':
-                            tags[GPath(mod)] = tuple(list(tags[GPath(mod)]) + list(modTags))
-                            if maBashTags.group(5) and maBashTags.group(6):
-                                modRemoveTags = maBashTags.group(6).split(',')
-                                modRemoveTags = map(string.strip,modRemoveTags)
-                                removeTags[GPath(mod)] = tuple(list(removeTags[GPath(mod)]) + list(modRemoveTags))
-                            continue
-                        tags[GPath(mod)] = tuple(modTags)
-                        if maBashTags.group(6) and maBashTags.group(7):
-                            modRemoveTags = maBashTags.group(7).split(',')
-                            modRemoveTags = map(string.strip,modTags)
-                            removeTags[GPath(mod)] = tuple(modRemoveTags)
-                ins.close()
-                self.bossUserTime = userpath.mtime
+            if (path.mtime != mtime or
+                (userpath.exists() and userpath.mtime != utime)):
+                self.tagCache = {}
+                try:
+                    boss.Load(path.s,userpath.s)
+                    self.bossMasterTime = path.mtime
+                    self.bossUserTime = userpath.mtime
+                    return
+                except bapi.BossError:
+                    deprint('An error occured while using the BOSS API:',traceback=True)
+            if not firstTime: return
+        #--No masterlist, use the taglist
+        taglist = dirs['mods'].join('Bash Patches','taglist.txt')
+        if not taglist.exists():
+            raise bolt.BoltError('Data\\Bash Patches\\taglist.txt could not be found.  Please ensure Wrye Bash is installed correctly.')
+        try:
+            self.tagCache = {}
+            boss.Load(taglist.s)
+        except bapi.BossError:
+            deprint('An error occured while parsing taglist.txt with the BOSS API.', traceback=True)
+            raise bolt.BoltError('An error occured while parsing taglist.txt with the BOSS API.')
 
     def getBashTags(self,modName):
         """Retrieves bash tags for given file."""
-        if modName in self.bossMasterTags:
-            return set(self.bossMasterTags[modName])
-        else: return None
+        if modName not in self.tagCache:
+            tags = boss.GetModBashTags(modName)
+            self.tagCache[modName] = tags
+            return tags[0]
+        else:
+            return self.tagCache[modName][0]
 
     def getBashRemoveTags(self,modName):
         """Retrieves bash tags for given file."""
-        if modName in self.bossRemoveTags:
-            return set(self.bossRemoveTags[modName])
-        else: return None
+        if modName not in self.tagCache:
+            tags = boss.GetModBashTags(modName)
+            self.tagCache[modName] = tags
+            return tags[1]
+        else:
+            return self.tagCache[modName][1]
 
-    def getDirtyMessage(self, crc):
-        return self.bossDirtyMods.get(long(crc), (False, ''))
+    def getDirtyMessage(self,modName):
+        message,clean = boss.GetDirtyMessage(modName)
+        cleanIt = clean == bapi.BOSS_API_CLEAN_YES
+        return (cleanIt,message)
 
     #--Mod Checker ------------------------------------------------------------
     def refreshRuleSets(self):
         """Reloads ruleSets if file dates have changed."""
         name_ruleSet = self.name_ruleSet
-        reRulesFile = re.compile('Rules.txt$',re.I)
+        reRulesFile = re.compile('Rules.txt$',re.I|re.U)
         ruleFiles = set(x for x in dirs['patches'].list() if reRulesFile.search(x.s))
         for name in name_ruleSet.keys():
             if name not in ruleFiles: del name_ruleSet[name]
@@ -9799,168 +11700,173 @@ class ConfigHelpers:
             if path.mtime != ruleSet.mtime:
                 ModRuleSet.RuleParser(ruleSet).parse(path)
 
-    def checkMods(self,showModList=False,showRuleSets=False,showNotes=False,showConfig=True,showSuggest=True,showWarn=True,scanDirty=None):
+    def checkMods(self,showModList=False,showRuleSets=False,showNotes=False,showConfig=True,showSuggest=True,showCRC=False,showVersion=True,showWarn=True,scanDirty=None):
         """Checks currently loaded mods against ruleset.
            scanDirty should be the instance of ModChecker, to scan."""
         active = set(modInfos.ordered)
         merged = modInfos.merged
         imported = modInfos.imported
         activeMerged = active | merged
-        warning = _('=== <font color=red>WARNING:</font> ')
+        warning = '=== <font color=red>'+_('WARNING:')+'</font> '
         #--Header
-        log = bolt.LogFile(stringBuffer())
-        log.setHeader(_('= Check Mods'),True)
-        log(_("This is a report on your currently active/merged mods."))
-        #--Mergeable/NoMerge/Deactivate tagged mods
-        shouldMerge = active & modInfos.mergeable
-        shouldDeactivateA = [x for x in active if 'Deactivate' in modInfos[x].getBashTags()]
-        shouldDeactivateB = [x for x in active if 'NoMerge' in modInfos[x].getBashTags()]
-        shouldActivateA = [x for x in imported if 'MustBeActiveIfImported' in modInfos[x].getBashTags() and x not in active]
-        #--Mods with invalid TES4 version
-        invalidVersion = [(x,str(round(modInfos[x].header.version,6))) for x in active if round(modInfos[x].header.version,6) not in (0.8,1.0)]
-        if True:
-            #--Look for dirty edits
-            shouldClean = {}
-            scan = []
-            for x in active:
-                dirtyMessage = modInfos[x].getDirtyMessage()
-                if dirtyMessage[0]:
-                    shouldClean[x] = dirtyMessage[1]
-                elif scanDirty:
-                    scan.append(modInfos[x])
-            if scanDirty:
-                try:
-                    with balt.Progress(_('Scanning for Dirty Edits...'),'\n'+' '*60,parent=scanDirty,abort=True) as progress:
-                        ret = ModCleaner.scan_Many(scan,ModCleaner.ITM|ModCleaner.UDR,progress)
-                        for i,mod in enumerate(scan):
-                            udrs,itms,fog = ret[i]
-                            if mod.name == GPath('Unofficial Oblivion Patch.esp'): itms.discard((GPath('Oblivion.esm'),0x00AA3C))
-                            if mod.header.author in ('BASHED PATCH','BASHED LISTS'): itms = set()
-                            if udrs or itms:
-                                cleanMsg = []
-                                if udrs:
-                                    cleanMsg.append('UDR(%i)' % len(udrs))
-                                if itms:
-                                    cleanMsg.append('ITM(%i)' % len(itms))
-                                cleanMsg = ', '.join(cleanMsg)
-                                shouldClean[mod.name] = cleanMsg
-                except bolt.CancelError:
-                    pass
-        shouldCleanMaybe = [(x,modInfos[x].getDirtyMessage()[1]) for x in active if not modInfos[x].getDirtyMessage()[0] and modInfos[x].getDirtyMessage()[1] != '']
-        for mod in tuple(shouldMerge):
-            if 'NoMerge' in modInfos[mod].getBashTags():
-                shouldMerge.discard(mod)
-        if shouldMerge:
-            log.setHeader(_("=== Mergeable"))
-            log(_("Following mods are active, but could be merged into the bashed patch."))
-            for mod in sorted(shouldMerge):
-                log('* __'+mod.s+'__')
-        if shouldDeactivateB:
-            log.setHeader(_("=== NoMerge Tagged Mods"))
-            log(_("Following mods are tagged NoMerge and should be deactivated and imported into the bashed patch but are currently active."))
-            for mod in sorted(shouldDeactivateB):
-                log('* __'+mod.s+'__')
-        if shouldDeactivateA:
-            log.setHeader(_("=== Deactivate Tagged Mods"))
-            log(_("Following mods are tagged Deactivate and should be deactivated and imported into the bashed patch but are currently active."))
-            for mod in sorted(shouldDeactivateA):
-                log('* __'+mod.s+'__')
-        if shouldActivateA:
-            log.setHeader(_("=== MustBeActiveIfImported Tagged Mods"))
-            log(_("Following mods to work correctly have to be active as well as imported into the bashed patch but are currently only imported."))
-            for mod in sorted(shouldActivateA):
-                log('* __'+mod.s+'__')
-        if shouldClean:
-            log.setHeader(_("=== Mods that need cleaning with TES4Edit"))
-            log(_("Following mods have identical to master (ITM) records, deleted records (UDR), or other issues that should be fixed with TES4Edit.  Visit the [[!http://cs.elderscrolls.com/constwiki/index.php/TES4Edit_Cleaning_Guide|TES4Edit Cleaning Guide]] for more information."))
-            for mod in sorted(shouldClean.keys()):
-                log('* __'+mod.s+':__  %s' % shouldClean[mod])
-        if shouldCleanMaybe:
-            log.setHeader(_("=== Mods with special cleaning instructions"))
-            log(_("Following mods have special instructions for cleaning with TES4Edit"))
-            for mod in sorted(shouldCleanMaybe):
-                log('* __'+mod[0].s+':__  '+mod[1])
-        if invalidVersion:
-            log.setHeader(_("=== Mods with non standard TES4 versions"))
-            log(_("Following mods have a TES4 version that isn't recognized as one of the standard versions (0.8 and 1.0).  It is untested what effect this can have on the game, but presumably Oblivion will refuse to load anything above 1.0"))
-            for mod in sorted(invalidVersion):
-                log('* __'+mod[0].s+':__  '+mod[1])
-        #--Missing/Delinquent Masters
-        if showModList:
-            log('\n'+modInfos.getModList(wtxt=True).strip())
-        else:
-            log.setHeader(warning+_('Missing/Delinquent Masters'))
-            previousMods = set()
-            for mod in modInfos.ordered:
-                loggedMod = False
-                for master in modInfos[mod].header.masters:
-                    if master not in active:
-                        label = _('MISSING')
-                    elif master not in previousMods:
-                        label = _('DELINQUENT')
-                    else:
-                        label = ''
-                    if label:
-                        if not loggedMod:
-                            log('* '+mod.s)
-                            loggedMod = True
-                        log('  * __%s__ %s' %(label,master.s))
-                previousMods.add(mod)
-        #--Rule Sets
-        if showRuleSets:
-            self.refreshRuleSets()
-            for fileName in sorted(self.name_ruleSet):
-                ruleSet = self.name_ruleSet[fileName]
-                modRules = ruleSet.modGroups
-                log.setHeader('= ' + fileName.s[:-4],True)
-                if ruleSet.header: log(ruleSet.header)
-                #--One ofs
-                for modSet in ruleSet.onlyones:
-                    modSet &= activeMerged
-                    if len(modSet) > 1:
-                        log.setHeader(warning+_('Only one of these should be active/merged'))
-                        for mod in sorted(modSet):
-                            log('* '+mod.s)
-                #--Mod Rules
-                for modGroup in ruleSet.modGroups:
-                    if not modGroup.isActive(activeMerged): continue
-                    modList = ' + '.join([x.s for x in modGroup.getActives(activeMerged)])
-                    if showNotes and modGroup.notes:
-                        log.setHeader(_('=== NOTES: ') + modList )
-                        log(modGroup.notes)
-                    if showConfig:
-                        log.setHeader(_('=== CONFIGURATION: ') + modList )
-                        #    + _('\nLegend: x: Active, +: Merged, -: Inactive'))
-                        for ruleType,ruleMod,comment in modGroup.config:
-                            if ruleType != 'o': continue
-                            if ruleMod in active: bullet = 'x'
-                            elif ruleMod in merged: bullet = '+'
-                            elif ruleMod in imported: bullet = '*'
-                            else: bullet = 'o'
-                            log('%s __%s__ -- %s' % (bullet,ruleMod.s,comment))
-                    if showSuggest:
-                        log.setHeader(_('=== SUGGESTIONS: ') + modList)
-                        for ruleType,ruleMod,comment in modGroup.suggest:
-                            if ((ruleType == 'x' and ruleMod not in activeMerged) or
-                                (ruleType == '+' and (ruleMod in active or ruleMod not in merged)) or
-                                (ruleType == '-' and ruleMod in activeMerged) or
-                                (ruleType == '-+' and ruleMod in active)
-                                ):
-                                log(_('* __%s__ -- %s') % (ruleMod.s,comment))
-                            elif ruleType == 'e' and not dirs['mods'].join(ruleMod).exists():
-                                log('* '+comment)
-                    if showWarn:
-                        log.setHeader(warning + modList)
-                        for ruleType,ruleMod,comment in modGroup.warn:
-                            if ((ruleType == 'x' and ruleMod not in activeMerged) or
-                                (ruleType == '+' and (ruleMod in active or ruleMod not in merged)) or
-                                (ruleType == '-' and ruleMod in activeMerged) or
-                                (ruleType == '-+' and ruleMod in active)
-                                ):
-                                log(_('* __%s__ -- %s') % (ruleMod.s,comment))
-                            elif ruleType == 'e' and not dirs['mods'].join(ruleMod).exists():
-                                log('* '+comment)
-        return log.out.getvalue()
+        with sio() as out:
+            log = bolt.LogFile(out)
+            log.setHeader('= '+_('Check Mods'),True)
+            log(_('This is a report on your currently active/merged mods.'))
+            #--Mergeable/NoMerge/Deactivate tagged mods
+            shouldMerge = active & modInfos.mergeable
+            shouldDeactivateA = [x for x in active if 'Deactivate' in modInfos[x].getBashTags()]
+            shouldDeactivateB = [x for x in active if 'NoMerge' in modInfos[x].getBashTags() and x in modInfos.mergeable]
+            shouldActivateA = [x for x in imported if 'MustBeActiveIfImported' in modInfos[x].getBashTags() and x not in active]
+            #--Mods with invalid TES4 version
+            #invalidVersion = [(x,unicode(round(modInfos[x].header.version,6))) for x in active if round(modInfos[x].header.version,6) not in bush.game.esp.validHeaderVersions]
+            invalidVersion = [(x,unicode(round(modInfos[x].header.version,6))) for x in active if round(modInfos[x].header.version,6) not in (1.32,1.33,1.34)]
+            if True:
+                #--Look for dirty edits
+                shouldClean = {}
+                scan = []
+                for x in active:
+                    dirtyMessage = modInfos[x].getDirtyMessage()
+                    if dirtyMessage[0]:
+                        shouldClean[x] = dirtyMessage[1]
+                    elif scanDirty:
+                        scan.append(modInfos[x])
+                if scanDirty:
+                    try:
+                        with balt.Progress(_('Scanning for Dirty Edits...'),'\n'+' '*60,parent=scanDirty,abort=True) as progress:
+                            ret = ModCleaner.scan_Many(scan,ModCleaner.ITM|ModCleaner.UDR,progress)
+                            for i,mod in enumerate(scan):
+                                udrs,itms,fog = ret[i]
+                                if mod.name == GPath('Unofficial Oblivion Patch.esp'): itms.discard((GPath('Oblivion.esm'),0x00AA3C))
+                                if mod.header.author in ('BASHED PATCH','BASHED LISTS'): itms = set()
+                                if udrs or itms:
+                                    cleanMsg = []
+                                    if udrs:
+                                        cleanMsg.append('UDR(%i)' % len(udrs))
+                                    if itms:
+                                        cleanMsg.append('ITM(%i)' % len(itms))
+                                    cleanMsg = ', '.join(cleanMsg)
+                                    shouldClean[mod.name] = cleanMsg
+                    except bolt.CancelError:
+                        pass
+            shouldCleanMaybe = [(x,modInfos[x].getDirtyMessage()[1]) for x in active if not modInfos[x].getDirtyMessage()[0] and modInfos[x].getDirtyMessage()[1] != '']
+            for mod in tuple(shouldMerge):
+                if 'NoMerge' in modInfos[mod].getBashTags():
+                    shouldMerge.discard(mod)
+            if shouldMerge:
+                log.setHeader('=== '+_('Mergeable'))
+                log(_('Following mods are active, but could be merged into the bashed patch.'))
+                for mod in sorted(shouldMerge):
+                    log('* __'+mod.s+'__')
+            if shouldDeactivateB:
+                log.setHeader('=== '+_('NoMerge Tagged Mods'))
+                log(_('Following mods are tagged NoMerge and should be deactivated and imported into the bashed patch but are currently active.'))
+                for mod in sorted(shouldDeactivateB):
+                    log('* __'+mod.s+'__')
+            if shouldDeactivateA:
+                log.setHeader('=== '+_('Deactivate Tagged Mods'))
+                log(_('Following mods are tagged Deactivate and should be deactivated and imported into the bashed patch but are currently active.'))
+                for mod in sorted(shouldDeactivateA):
+                    log('* __'+mod.s+'__')
+            if shouldActivateA:
+                log.setHeader('=== '+_('MustBeActiveIfImported Tagged Mods'))
+                log(_('Following mods to work correctly have to be active as well as imported into the bashed patch but are currently only imported.'))
+                for mod in sorted(shouldActivateA):
+                    log('* __'+mod.s+'__')
+            if shouldClean:
+                log.setHeader('=== '+_('Mods that need cleaning with TES4Edit'))
+                log(_('Following mods have identical to master (ITM) records, deleted records (UDR), or other issues that should be fixed with TES4Edit.  Visit the [[!http://cs.elderscrolls.com/constwiki/index.php/TES4Edit_Cleaning_Guide|TES4Edit Cleaning Guide]] for more information.'))
+                for mod in sorted(shouldClean.keys()):
+                    log('* __'+mod.s+':__  %s' % shouldClean[mod])
+            if shouldCleanMaybe:
+                log.setHeader('=== '+_('Mods with special cleaning instructions'))
+                log(_('Following mods have special instructions for cleaning with TES4Edit'))
+                for mod in sorted(shouldCleanMaybe):
+                    log('* __'+mod[0].s+':__  '+mod[1])
+            elif scanDirty and not shouldClean:
+                log.setHeader('=== '+_('Mods that need cleaning with TES4Edit'))
+                log(_('Congratulations all mods appear clean.'))
+            if invalidVersion:
+                log.setHeader('=== '+_('Mods with non standard TES4 versions'))
+                log(_("Following mods have a TES4 version that isn't recognized as one of the standard versions (0.8 and 1.0).  It is untested what effect this can have on the game, but presumably Oblivion will refuse to load anything above 1.0"))
+                for mod in sorted(invalidVersion):
+                    log('* __'+mod[0].s+':__  '+mod[1])
+            #--Missing/Delinquent Masters
+            if showModList:
+                log('\n'+modInfos.getModList(showCRC,showVersion,wtxt=True).strip())
+            else:
+                log.setHeader(warning+_('Missing/Delinquent Masters'))
+                previousMods = set()
+                for mod in modInfos.ordered:
+                    loggedMod = False
+                    for master in modInfos[mod].header.masters:
+                        if master not in active:
+                            label = _('MISSING')
+                        elif master not in previousMods:
+                            label = _('DELINQUENT')
+                        else:
+                            label = ''
+                        if label:
+                            if not loggedMod:
+                                log('* '+mod.s)
+                                loggedMod = True
+                            log('  * __%s__ %s' %(label,master.s))
+                    previousMods.add(mod)
+            #--Rule Sets
+            if showRuleSets:
+                self.refreshRuleSets()
+                for fileName in sorted(self.name_ruleSet):
+                    ruleSet = self.name_ruleSet[fileName]
+                    modRules = ruleSet.modGroups
+                    log.setHeader('= ' + fileName.s[:-4],True)
+                    if ruleSet.header: log(ruleSet.header)
+                    #--One ofs
+                    for modSet in ruleSet.onlyones:
+                        modSet &= activeMerged
+                        if len(modSet) > 1:
+                            log.setHeader(warning+_('Only one of these should be active/merged'))
+                            for mod in sorted(modSet):
+                                log('* '+mod.s)
+                    #--Mod Rules
+                    for modGroup in ruleSet.modGroups:
+                        if not modGroup.isActive(activeMerged): continue
+                        modList = ' + '.join([x.s for x in modGroup.getActives(activeMerged)])
+                        if showNotes and modGroup.notes:
+                            log.setHeader('=== '+_('NOTES: ') + modList )
+                            log(modGroup.notes)
+                        if showConfig:
+                            log.setHeader('=== '+_('CONFIGURATION: ') + modList )
+                            #    + _('\nLegend: x: Active, +: Merged, -: Inactive'))
+                            for ruleType,ruleMod,comment in modGroup.config:
+                                if ruleType != 'o': continue
+                                if ruleMod in active: bullet = 'x'
+                                elif ruleMod in merged: bullet = '+'
+                                elif ruleMod in imported: bullet = '*'
+                                else: bullet = 'o'
+                                log('%s __%s__ -- %s' % (bullet,ruleMod.s,comment))
+                        if showSuggest:
+                            log.setHeader('=== '+_('SUGGESTIONS: ') + modList)
+                            for ruleType,ruleMod,comment in modGroup.suggest:
+                                if ((ruleType == 'x' and ruleMod not in activeMerged) or
+                                    (ruleType == '+' and (ruleMod in active or ruleMod not in merged)) or
+                                    (ruleType == '-' and ruleMod in activeMerged) or
+                                    (ruleType == '-+' and ruleMod in active)
+                                    ):
+                                    log('* __%s__ -- %s' % (ruleMod.s,comment))
+                                elif ruleType == 'e' and not dirs['mods'].join(ruleMod).exists():
+                                    log('* '+comment)
+                        if showWarn:
+                            log.setHeader(warning + modList)
+                            for ruleType,ruleMod,comment in modGroup.warn:
+                                if ((ruleType == 'x' and ruleMod not in activeMerged) or
+                                    (ruleType == '+' and (ruleMod in active or ruleMod not in merged)) or
+                                    (ruleType == '-' and ruleMod in activeMerged) or
+                                    (ruleType == '-+' and ruleMod in active)
+                                    ):
+                                    log('* __%s__ -- %s' % (ruleMod.s,comment))
+                                elif ruleType == 'e' and not dirs['mods'].join(ruleMod).exists():
+                                    log('* '+comment)
+            return log.out.getvalue()
 
 # TankDatas -------------------------------------------------------------------
 #------------------------------------------------------------------------------
@@ -10352,7 +12258,7 @@ class ScreensData(DataDict):
     def refresh(self):
         """Refresh list of screenshots."""
         self.dir = dirs['app']
-        ssBase = GPath(oblivionIni.getSetting('Display','SScreenShotBaseName','ScreenShot'))
+        ssBase = GPath(falloutIni.getSetting('Display','SScreenShotBaseName','ScreenShot'))
         if ssBase.head:
             self.dir = self.dir.join(ssBase.head)
         newData = {}
@@ -10390,13 +12296,13 @@ class Installer(object):
     docDirs = set(('screenshots',))
     dataDirs = set(('bash patches','distantlod','docs','facegen','fonts',
         'menus','meshes','music','shaders','sound', 'textures', 'trees','video'))
-    dataDirsPlus = dataDirs | docDirs | set(('streamline','_tejon','ini tweaks','scripts','pluggy','ini','obse'))
+    dataDirsPlus = dataDirs | docDirs | set(('streamline','_tejon','ini tweaks','scripts','pluggy','ini','fose'))
     dataDirsMinus = set(('bash','replacers','--')) #--Will be skipped even if hasExtraData == True.
     reDataFile = re.compile(r'(masterlist.txt|dlclist.txt|\.(esp|esm|bsa|ini))$',re.I)
     reReadMe = re.compile(r'^([^\\]*)(read[ _]?me|lisez[ _]?moi)([^\\]*)\.(txt|rtf|htm|html|doc|odt)$',re.I)
-    skipExts = set(('.exe','.py','.pyc','.7z','.zip','.rar','.db','.ace','.tgz','.tar','.gz','.bz2','.omod','.tb2','.lzma'))
+    skipExts = set(('.exe','.py','.pyc','.7z','.zip','.rar','.db','.ace','.tgz','.tar','.gz','.bz2','.fomod','.tb2','.lzma'))
     skipExts.update(set(readExts))
-    docExts = set(('.txt','.rtf','.htm','.html','.doc','.docx','.odt','.mht','.pdf','.css','.xls','.ods','.odp','.ppt'))
+    docExts = set(('.txt','.rtf','.htm','.html','.doc','.docx','.odt','.mht','.pdf','.css','.xls','.xlsx','.ods','.odp','.ppt','.pptx'))
     imageExts = set(('.gif','.jpg','.png','.jpeg','.bmp'))
     scriptExts = set(('.txt','.ini'))
     #--Temp Files/Dirs
@@ -10481,8 +12387,8 @@ class Installer(object):
                     sDirs[:] = [x for x in sDirs if x.lower() != 'distantlod']
                 if settings['bash.installers.skipScreenshots']:
                     sDirs[:] = [x for x in sDirs if x.lower() != 'screenshots']
-                if not settings['bash.installers.allowOBSEPlugins']:
-                    sDirs[:] = [x for x in sDirs if x.lower() != 'obse']
+                if not settings['bash.installers.allowFOSEPlugins']:
+                    sDirs[:] = [x for x in sDirs if x.lower() != 'fose']
                 if settings['bash.installers.skipDocs'] and settings['bash.installers.skipImages']:
                     sDirs[:] = [x for x in sDirs if x.lower() != 'docs']
                 if inisettings['KeepLog'] >= 1:
@@ -10662,7 +12568,7 @@ class Installer(object):
             setter(clone,attr,copier(getter(self,attr)))
         return clone
 
-    def refreshDataSizeCrc(self,checkOBSE=False):
+    def refreshDataSizeCrc(self,checkFOSE=False):
         """Updates self.data_sizeCrc and related variables.
         Also, returns dest_src map for install operation."""
         if isinstance(self,InstallerArchive):
@@ -10733,7 +12639,7 @@ class Installer(object):
         for full,size,crc in self.fileSizeCrcs:
             file = full
             fileLower = file.lower()
-            if fileLower.startswith(('--','omod conversion data','wizard images')):
+            if fileLower.startswith(('--','fomod conversion data','wizard images')):
                 continue
             sub = ''
             bSkip = False
@@ -10793,23 +12699,23 @@ class Installer(object):
                 continue
             elif fileStartsWith('--'):
                 continue
-            elif not settings['bash.installers.allowOBSEPlugins'] and fileStartsWith('obse\\'):
+            elif not settings['bash.installers.allowFOSEPlugins'] and fileStartsWith('fose\\'):
                 continue
             elif fileExt in ['.dll','.dlx']:
-                if not settings['bash.installers.allowOBSEPlugins']: continue
-                if not fileStartsWith('obse\\'):
+                if not settings['bash.installers.allowFOSEPlugins']: continue
+                if not fileStartsWith('fose\\'):
                     continue
                 if fileLower in badDlls and [archiveRoot,size,crc] in badDlls[fileLower]: continue
-                if not checkOBSE:
+                if not checkFOSE:
                     pass
                 elif fileLower in goodDlls and [archiveRoot,size,crc] in goodDlls[fileLower]: pass
-                elif checkOBSE:
-                    message = _('This installer (%s) has an OBSE plugin DLL.\nThe file is %s\nSuch files can be malicious and hence you should be very sure you know what this file is and that it is legitimate.\nAre you sure you want to install this?') % (archiveRoot, full)
+                elif checkFOSE:
+                    message = _('This installer (%s) has an FOSE plugin DLL.\nThe file is %s\nSuch files can be malicious and hence you should be very sure you know what this file is and that it is legitimate.\nAre you sure you want to install this?') % (archiveRoot, full)
                     if fileLower in goodDlls:
                         message += _(' You have previously chosen to install a dll by this name but with a different size, crc and or source archive name.')
                     elif fileLower in badDlls:
                         message += _(' You have previously chosen to NOT install a dll by this name but with a different size, crc and or source archive name - make extra sure you want to install this one before saying yes.')
-                    if not balt.askYes(installersWindow,message,_('OBSE DLL Warning')):
+                    if not balt.askYes(installersWindow,message,_('FOSE DLL Warning')):
                         badDlls.setdefault(fileLower,[])
                         badDlls[fileLower].append([archiveRoot,size,crc])
                         continue
@@ -11006,7 +12912,7 @@ class Installer(object):
         return (self.status != oldStatus or self.underrides != oldUnderrides)
 
     def install(self,archive,destFiles,data_sizeCrcDate,progress=None):
-        """Install specified files to Oblivion\Data directory."""
+        """Install specified files to Fallout 3\Data directory."""
         raise AbstractError
 
     def listSource(self,archive):
@@ -11424,7 +13330,7 @@ class InstallerMarker(Installer):
         pass
 
     def install(self,name,destFiles,data_sizeCrcDate,progress=None):
-        """Install specified files to Oblivion\Data directory."""
+        """Install specified files to Fallout 3\Data directory."""
         pass
 
 #------------------------------------------------------------------------------
@@ -11561,7 +13467,7 @@ class InstallerArchive(Installer):
         #--Done
 
     def install(self,archive,destFiles,data_sizeCrcDate,progress=None):
-        """Install specified files to Oblivion\Data directory."""
+        """Install specified files to Fallout 3\Data directory."""
         progress = progress or bolt.Progress()
         destDir = dirs['mods']
         destFiles = set(destFiles)
@@ -11635,7 +13541,7 @@ class InstallerArchive(Installer):
         bUseUnicode = inisettings['EnableUnicode']
         log = bolt.LogFile(stringBuffer())
         if bUseUnicode:
-            log.setHeader(_(u'Package Structure:'))
+            log.setHeader(_('Package Structure:'))
             log(u'[spoiler][xml]', False)
             reList = re.compile(u'(Solid|Path|Size|CRC|Attributes|Method) = (.*?)(?:\r\n|\n)')
             file = u''
@@ -11742,7 +13648,7 @@ class InstallerProject(Installer):
         self.refreshed = True
 
     def install(self,name,destFiles,data_sizeCrcDate,progress=None):
-        """Install specified files to Oblivion\Data directory."""
+        """Install specified files to Fallout 3\Data directory."""
         destDir = dirs['mods']
         destFiles = set(destFiles)
         data_sizeCrc = self.data_sizeCrc
@@ -11775,7 +13681,7 @@ class InstallerProject(Installer):
         return count
 
     def syncToData(self,package,projFiles):
-        """Copies specified projFiles from Oblivion\Data to project directory."""
+        """Copies specified projFiles from Fallout 3\Data to project directory."""
         srcDir = dirs['mods']
         projFiles = set(projFiles)
         srcProj = tuple((x,y) for x,y in self.refreshDataSizeCrc().iteritems() if x in projFiles)
@@ -11856,51 +13762,69 @@ class InstallerProject(Installer):
             raise StateError(_("%s: Compression failed:\n%s") % (archive.s, "\n".join(errorLine)))
         outFile.untemp()
 
-    #--Omod Config ------------------------------------------------------------
-    class OmodConfig:
-        """Tiny little omod config class."""
+    #--Fomod Config ------------------------------------------------------------
+    class FomodConfig:
+        """Tiny little fomod config class."""
         def __init__(self,name):
             self.name = name.s
-            self.vMajor = 0
-            self.vMinor = 1
-            self.vBuild = 0
-            self.author = ''
+            self.version = '1.0'
+            self.machineVersion = '1.0'
+            self.author = 'DEFAULT'
             self.email = ''
             self.website = ''
-            self.abstract = ''
-
-    def getOmodConfig(self,name):
-        """Get obmm config file for project."""
-        config = InstallerProject.OmodConfig(name)
-        configPath = dirs['installers'].join(name,'omod conversion data','config')
+            self.description = ''
+            self.minFommVersion = ''
+            self.groups = []
+
+    def getFomodConfig(self,name):
+        """Get fomm config file for project."""
+        config = InstallerProject.FomodConfig(name)
+        configPath = dirs['installers'].join(name,'fomod','info.xml')
         if configPath.exists():
-            ins = bolt.StructFile(configPath.s,'rb')
-            ins.read(1) #--Skip first four bytes
-            config.name = ins.readNetString()
-            config.vMajor, = ins.unpack('i',4)
-            config.vMinor, = ins.unpack('i',4)
-            for attr in ('author','email','website','abstract'):
-                setattr(config,attr,ins.readNetString())
-            ins.read(8) #--Skip date-time
-            ins.read(1) #--Skip zip-compression
-            #config['vBuild'], = ins.unpack('I',4)
-            ins.close()
+            doc = ElementTree.parse(configPath.s)
+            def find_text(xpath, default=''):
+                element = doc.find(xpath)
+                return element.text if element is not None else default
+            config.name = find_text('//Name')
+            version = doc.find('//Version')
+            if version is not None:
+                config.version = version.text
+                config.machineVersion = version.get('MachineVersion','')
+            config.author = find_text('//Author')
+            config.email = find_text('//Email')
+            config.website = find_text('//Website')
+            config.description = find_text('//Description')
+            config.minFommVersion = find_text('//MinFommVersion')
+            config.groups = [group.text for group in doc.findall('//Groups/element')]
         return config
 
-    def writeOmodConfig(self,name,config):
-        """Write obmm config file for project."""
-        configPath = dirs['installers'].join(name,'omod conversion data','config')
+    def writeFomodConfig(self,name,config):
+        """Write fomm config file for project."""
+        configPath = dirs['installers'].join(name,'fomod','info.xml')
         configPath.head.makedirs()
-        out = bolt.StructFile(configPath.temp.s,'wb')
-        out.pack('B',4)
-        out.writeNetString(Encode(config.name))
-        out.pack('i',config.vMajor)
-        out.pack('i',config.vMinor)
-        for attr in ('author','email','website','abstract'):
-            out.writeNetString(Encode(getattr(config,attr)))
-        out.write('\x74\x1a\x74\x67\xf2\x7a\xca\x88') #--Random date time
-        out.pack('b',0) #--zip compression (will be ignored)
-        out.write('\xFF\xFF\xFF\xFF')
+        out = configPath.temp.open('wb')
+        enc = 'UTF-16'
+        info = '<?xml version="1.0" encoding="%s"?>\n' % enc
+        info += '<fomod>\n'
+        info += '  <Name>%s</Name>\n' % config.name
+        if config.author:
+            info += '  <Author>%s</Author>\n' % config.author
+        info += '  <Version MachineVersion="%s">%s</Version>\n' % (config.machineVersion, config.version)
+        if config.description:
+            info += '  <Description>%s</Description>\n' % config.description
+        if config.email:
+            info += '  <Email>%s</Email>\n' % config.email
+        if config.website:
+            info += '  <Website>%s</Website>\n' % config.website
+        if config.minFommVersion:
+            info += '  <MinFommVersion>%s</MinFommVersion>\n' % config.minFommVersion
+        if config.groups:
+            info += '  <Groups>\n'
+            for group in config.Groups:
+                info += '    <element>%s</element>\n' % group
+            info += '  </Groups>\n'
+        info += '</fomod>\n'
+        out.write(info.encode(enc))
         out.close()
         configPath.untemp()
 
@@ -11976,7 +13900,7 @@ class InstallersData(bolt.TankData, DataDict):
         self.bashDir.makedirs()
         #--Archive invalidation
         if settings.get('bash.bsaRedirection'):
-            oblivionIni.setBsaRedirection(True)
+            falloutIni.setBsaRedirection(True)
         #--Refresh Data
         changed = False
         if not self.loaded:
@@ -12608,19 +14532,30 @@ class InstallersData(bolt.TankData, DataDict):
 
     def clean(self,progress):
         data = self.data
-        getArchiveOrder =  lambda x: data[x].order
+        getArchiveOrder = lambda x: data[x].order
         installed = []
         for package in sorted(data,key=getArchiveOrder,reverse=True):
             installer = data[package]
             if installer.isActive:
                 installed += installer.data_sizeCrc
-        bethFiles = [GPath(f) for f in bush.allBethFiles]
-        keepFiles = set(installed + bethFiles)
+        keepFiles = set(installed)
+        keepFiles.update((GPath(f) for f in bush.allBethFiles))
+        keepFiles.update((GPath(f) for f in bush.wryeBashDataFiles))
+        keepFiles.update((GPath(f) for f in bush.ignoreDataFiles))
         data_sizeCrcDate = self.data_sizeCrcDate
         removes = set(data_sizeCrcDate) - keepFiles
         destDir = dirs['bainData'].join('Data Folder Contents (%s)' %(datetime.datetime.now().strftime('%d-%m-%Y %H%M.%S')))
         emptyDirs = set()
+        skipDirs = [skipDir+os.sep for skipDir in bush.wryeBashDataDirs]
+        skipDirs.extend([skipDir+os.sep for skipDir in bush.ignoreDataDirs])
         for file in removes:
+            # don't remove files in Wyre Bash-related directories
+            skip = False
+            for skipDir in skipDirs:
+                if file.s.startswith(skipDir):
+                    skip = True
+                    break
+            if skip: continue
             path = dirs['mods'].join(file)
             try:
                 path.moveTo(destDir.join(file))
@@ -12815,123 +14750,123 @@ class ActorFactions:
                     out.write(rowFormat % (type,actorEid,id[0].s,id[1],factionEid,faction[0].s,faction[1],rank))
         out.close()
 
-class CBash_ActorFactions:
-    """Factions for npcs and creatures with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,aliases=None):
-        """Initialize."""
-        self.group_fid_factions = {'CREA':{},'NPC_':{}} #--factions = group_fid_factions[group][longid]
-        self.fid_eid = {}
-        self.aliases = aliases or {}
-        self.gotFactions = set()
-
-    def readFromMod(self,modInfo):
-        """Imports faction data from specified mod."""
-        group_fid_factions,fid_eid,gotFactions = self.group_fid_factions,self.fid_eid,self.gotFactions
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
-        Current.load()
-        try:
-            importFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ActorFactions:readFromMod"
-            print error[0]
-            return
-
-        for modFile in Current.LoadOrderMods:
-            modName = modFile.GName
-            if modName in gotFactions: continue
-            for record in modFile.FACT:
-                fid_eid[record.fid] = record.eid
-            if modFile != importFile: continue
-            types = dict((('CREA', modFile.CREA),('NPC_', modFile.NPC_)))
-            for group,block in types.iteritems():
-                fid_factions = group_fid_factions[group]
-                for record in block:
-                    fid = record.fid
-                    factions = record.factions_list
-                    if factions:
-                        fid_eid[fid] = record.eid
-                        fid_factions[fid] = factions
-                    record.UnloadRecord()
-            gotFactions.add(modName)
-        del Current
-
-    def writeToMod(self,modInfo):
-        """Exports faction data to specified mod."""
-        group_fid_factions,fid_eid = self.group_fid_factions,self.fid_eid
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ActorFactions:writeToMod"
-            print error[0]
-            return
-
-        changed = {'CREA':0,'NPC_':0}
-        types = dict((('CREA', modFile.CREA),('NPC_', modFile.NPC_)))
-        for group,block in types.iteritems():
-            fid_factions = group_fid_factions.get(group,None)
-            for record in block:
-                fid = record.fid
-                if fid not in fid_factions: continue
-                newFactions = set(fid_factions[fid])
-                curFactions = set(record.factions_list)
-                changes = newFactions - curFactions
-                if not changes: continue
-                for faction,rank in changes:
-                    for entry in record.factions:
-                        if entry.faction == faction:
-                            entry.rank = rank
-                            break
-                    else:
-                        entry = record.create_faction()
-                        entry.faction = faction
-                        entry.rank = rank
-                changed[group] += 1
-        #--Done
-        if sum(changed.values()): modFile.save()
-        del Current
-        return changed
-
-    def readFromText(self,textPath):
-        """Imports faction data from specified text file."""
-        group_fid_factions,fid_eid = self.group_fid_factions, self.fid_eid
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 8 or fields[3][:2] != '0x': continue
-            group,aed,amod,aobj,fed,fmod,fobj,rank = fields[:9]
-            group = _coerce(group,str)
-            amod = GPath(_coerce(amod,str))
-            fmod = GPath(_coerce(fmod,str))
-            aid = (aliases.get(amod,amod),_coerce(aobj[2:],int,16))
-            fid = (aliases.get(fmod,fmod),_coerce(fobj[2:],int,16))
-            rank = _coerce(rank, int)
-            fid_factions = group_fid_factions[group]
-            factions = fid_factions.get(aid)
-            factiondict = dict(factions or [])
-            factiondict.update({fid:rank})
-            fid_factions[aid] = [(fid,rank) for fid,rank in factiondict.iteritems()]
-        ins.close()
-
-    def writeToText(self,textPath):
-        """Exports faction data to specified text file."""
-        group_fid_factions,fid_eid = self.group_fid_factions, self.fid_eid
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","%s","0x%06X","%s","%s","0x%06X","%s"\n'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Type'),_('Actor Eid'),_('Actor Mod'),_('Actor Object'),_('Faction Eid'),_('Faction Mod'),_('Faction Object'),_('Rank')), 'mbcs'))
-        for group in sorted(group_fid_factions):
-            fid_factions = group_fid_factions[group]
-            for fid in sorted(fid_factions,key = lambda x: fid_eid.get(x)):
-                actorEid = fid_eid.get(fid,'Unknown')
-                for faction, rank in sorted(fid_factions[fid],key=lambda x: fid_eid.get(x[0])):
-                    factionEid = fid_eid.get(faction,'Unknown')
-                    out.write(rowFormat % (group,actorEid,fid[0].s,fid[1],factionEid,faction[0].s,faction[1],rank))
-        out.close()
+# class CBash_ActorFactions:
+#     """Factions for npcs and creatures with functions for importing/exporting from/to mod/text file."""
+#     def __init__(self,aliases=None):
+#         """Initialize."""
+#         self.group_fid_factions = {'CREA':{},'NPC_':{}} #--factions = group_fid_factions[group][longid]
+#         self.fid_eid = {}
+#         self.aliases = aliases or {}
+#         self.gotFactions = set()
+
+#     def readFromMod(self,modInfo):
+#         """Imports faction data from specified mod."""
+#         group_fid_factions,fid_eid,gotFactions = self.group_fid_factions,self.fid_eid,self.gotFactions
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
+#         Current.load()
+#         try:
+#             importFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ActorFactions:readFromMod"
+#             print error[0]
+#             return
+
+#         for modFile in Current.LoadOrderMods:
+#             modName = modFile.GName
+#             if modName in gotFactions: continue
+#             for record in modFile.FACT:
+#                 fid_eid[record.fid] = record.eid
+#             if modFile != importFile: continue
+#             types = dict((('CREA', modFile.CREA),('NPC_', modFile.NPC_)))
+#             for group,block in types.iteritems():
+#                 fid_factions = group_fid_factions[group]
+#                 for record in block:
+#                     fid = record.fid
+#                     factions = record.factions_list
+#                     if factions:
+#                         fid_eid[fid] = record.eid
+#                         fid_factions[fid] = factions
+#                     record.UnloadRecord()
+#             gotFactions.add(modName)
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports faction data to specified mod."""
+#         group_fid_factions,fid_eid = self.group_fid_factions,self.fid_eid
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ActorFactions:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = {'CREA':0,'NPC_':0}
+#         types = dict((('CREA', modFile.CREA),('NPC_', modFile.NPC_)))
+#         for group,block in types.iteritems():
+#             fid_factions = group_fid_factions.get(group,None)
+#             for record in block:
+#                 fid = record.fid
+#                 if fid not in fid_factions: continue
+#                 newFactions = set(fid_factions[fid])
+#                 curFactions = set(record.factions_list)
+#                 changes = newFactions - curFactions
+#                 if not changes: continue
+#                 for faction,rank in changes:
+#                     for entry in record.factions:
+#                         if entry.faction == faction:
+#                             entry.rank = rank
+#                             break
+#                     else:
+#                         entry = record.create_faction()
+#                         entry.faction = faction
+#                         entry.rank = rank
+#                 changed[group] += 1
+#         #--Done
+#         if sum(changed.values()): modFile.save()
+#         del Current
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports faction data from specified text file."""
+#         group_fid_factions,fid_eid = self.group_fid_factions, self.fid_eid
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 8 or fields[3][:2] != '0x': continue
+#             group,aed,amod,aobj,fed,fmod,fobj,rank = fields[:9]
+#             group = _coerce(group,str)
+#             amod = GPath(_coerce(amod,str))
+#             fmod = GPath(_coerce(fmod,str))
+#             aid = (aliases.get(amod,amod),_coerce(aobj[2:],int,16))
+#             fid = (aliases.get(fmod,fmod),_coerce(fobj[2:],int,16))
+#             rank = _coerce(rank, int)
+#             fid_factions = group_fid_factions[group]
+#             factions = fid_factions.get(aid)
+#             factiondict = dict(factions or [])
+#             factiondict.update({fid:rank})
+#             fid_factions[aid] = [(fid,rank) for fid,rank in factiondict.iteritems()]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports faction data to specified text file."""
+#         group_fid_factions,fid_eid = self.group_fid_factions, self.fid_eid
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","%s","%s","0x%06X","%s","%s","0x%06X","%s"\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Type'),_('Actor Eid'),_('Actor Mod'),_('Actor Object'),_('Faction Eid'),_('Faction Mod'),_('Faction Object'),_('Rank')), 'mbcs'))
+#         for group in sorted(group_fid_factions):
+#             fid_factions = group_fid_factions[group]
+#             for fid in sorted(fid_factions,key = lambda x: fid_eid.get(x)):
+#                 actorEid = fid_eid.get(fid,'Unknown')
+#                 for faction, rank in sorted(fid_factions[fid],key=lambda x: fid_eid.get(x[0])):
+#                     factionEid = fid_eid.get(faction,'Unknown')
+#                     out.write(rowFormat % (group,actorEid,fid[0].s,fid[1],factionEid,faction[0].s,faction[1],rank))
+#         out.close()
 #------------------------------------------------------------------------------
 class ActorLevels:
     """Package: Functions for manipulating actor levels."""
@@ -13002,7 +14937,7 @@ class ActorLevels:
                 fid,eid,offset,calcMin,calcMax = fields[:5]
                 source = GPath('Unknown')
                 fidObject = coerce(fid[4:], int, 16)
-                fid = (GPath('Oblivion.esm'), fidObject)
+                fid = (GPath('Fallout3.esm'), fidObject)
                 eid = coerce(eid, str)
                 offset = coerce(offset, int)
                 calcMin = coerce(calcMin, int)
@@ -13011,7 +14946,7 @@ class ActorLevels:
                 if len(fields) < 7 or fields[3][:2] != '0x': continue
                 source,eid,fidMod,fidObject,offset,calcMin,calcMax = fields[:7]
                 source = coerce(source, str)
-                if source.lower() in ('none', 'oblivion.esm'): continue
+                if source.lower() in ('none', 'fallout3.esm'): continue
                 source = GPath(source)
                 eid = coerce(eid, str)
                 fidMod = GPath(coerce(fidMod, str))
@@ -13036,9 +14971,9 @@ class ActorLevels:
         out = textPath.open('w')
         out.write(Encode(headFormat % (_('Source Mod'),_('Actor Eid'),_('Actor Mod'),_('Actor Object'),_('Offset'),_('CalcMin'),_('CalcMax'),_('Old IsPCLevelOffset'),_('Old Offset'),_('Old CalcMin'),_('Old CalcMax')),'mbcs'))
         #Sorted based on mod, then editor ID
-        obId_levels = mod_id_levels[GPath('Oblivion.esm')]
+        obId_levels = mod_id_levels[GPath('Fallout3.esm')]
         for mod in sorted(mod_id_levels):
-            if mod.s.lower() == 'oblivion.esm': continue
+            if mod.s.lower() == 'fallout3.esm': continue
             id_levels = mod_id_levels[mod]
             for id in sorted(id_levels,key=lambda k: (k[0].s,id_levels[k][0])):
                 eid, isOffset, offset, calcMin, calcMax = id_levels[id]
@@ -13054,121 +14989,121 @@ class ActorLevels:
                         out.write(blankExtendedRow)
         out.close()
 
-class CBash_ActorLevels:
-    """Package: Functions for manipulating actor levels."""
-    def __init__(self,aliases=None):
-        """Initialize."""
-        self.mod_fid_levels = {} #--levels = mod_id_levels[mod][longid]
-        self.aliases = aliases or {}
-        self.gotLevels = set()
-
-    def readFromMod(self,modInfo):
-        """Imports actor level data from the specified mod and its masters."""
-        mod_fid_levels, gotLevels = self.mod_fid_levels, self.gotLevels
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod('Oblivion.esm', Flags=0x00000068)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
-        Current.load()
-
-        for modFile in Current.LoadOrderMods:
-            modName = modFile.GName
-            if modName in gotLevels: continue
-            fid_levels = mod_fid_levels.setdefault(modName, {})
-            for record in modFile.NPC_:
-                fid_levels[record.fid] = (record.eid, record.IsPCLevelOffset and 1 or 0, record.level, record.calcMin, record.calcMax)
-                record.UnloadRecord()
-            gotLevels.add(modName)
-        del Current
-
-    def writeToMod(self,modInfo):
-        """Exports actor levels to specified mod."""
-        mod_fid_levels = self.mod_fid_levels
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ActorLevels:writeToMod"
-            print error[0]
-            return
-
-        changed = 0
-        fid_levels = mod_fid_levels.get(modFile.GName,mod_fid_levels.get(GPath('Unknown'),None))
-        if fid_levels:
-            for record in modFile.NPC_:
-                fid = record.fid
-                if fid not in fid_levels: continue
-                eid, isOffset, level, calcMin, calcMax = fid_levels[fid]
-                if((record.level, record.calcMin, record.calcMax) != (level, calcMin, calcMax)):
-                    (record.level, record.calcMin, record.calcMax) = (level, calcMin, calcMax)
-                    changed += 1
-        #--Done
-        if changed: modFile.save()
-        del Current
-        return changed
-
-    def readFromText(self,textPath):
-        """Imports NPC level data from specified text file."""
-        mod_fid_levels = self.mod_fid_levels
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if fields[0][:2] == '0x': #old format
-                fid,eid,offset,calcMin,calcMax = fields[:5]
-                source = GPath('Unknown')
-                fidObject = _coerce(fid[4:], int, 16)
-                fid = (GPath('Oblivion.esm'), fidObject)
-                eid = _coerce(eid, str, AllowNone=True)
-                offset = _coerce(offset, int)
-                calcMin = _coerce(calcMin, int)
-                calcMax = _coerce(calcMax, int)
-            else:
-                if len(fields) < 7 or fields[3][:2] != '0x': continue
-                source,eid,fidMod,fidObject,offset,calcMin,calcMax = fields[:7]
-                source = _coerce(source, str)
-                if source.lower() in ('none', 'oblivion.esm'): continue
-                source = GPath(source)
-                eid = _coerce(eid, str, AllowNone=True)
-                fidMod = GPath(_coerce(fidMod, str))
-                if fidMod.s.lower() == 'none': continue
-                fidObject = _coerce(fidObject[2:], int, 16)
-                if fidObject is None: continue
-                fid = (aliases.get(fidMod,fidMod),fidObject)
-                offset = _coerce(offset, int)
-                calcMin = _coerce(calcMin, int)
-                calcMax = _coerce(calcMax, int)
-            fid_levels = mod_fid_levels.setdefault(source, {})
-            fid_levels[fid] = (eid, 1, offset, calcMin, calcMax)
-        ins.close()
-
-    def writeToText(self,textPath):
-        """Export NPC level data to specified text file."""
-        mod_fid_levels = self.mod_fid_levels
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","%s","0x%06X","%d","%d","%d"'
-        extendedRowFormat = ',"%d","%d","%d","%d"\n'
-        blankExtendedRow = ',,,,\n'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Source Mod'),_('Actor Eid'),_('Actor Mod'),_('Actor Object'),_('Offset'),_('CalcMin'),_('CalcMax'),_('Old IsPCLevelOffset'),_('Old Offset'),_('Old CalcMin'),_('Old CalcMax')),'mbcs'))
-        #Sorted based on mod, then editor ID
-        obfid_levels = mod_fid_levels[GPath('Oblivion.esm')]
-        for mod in sorted(mod_fid_levels):
-            if mod.s.lower() == 'oblivion.esm': continue
-            fid_levels = mod_fid_levels[mod]
-            for fid in sorted(fid_levels,key=lambda k: (k[0].s,fid_levels[k][0])):
-                eid, isOffset, offset, calcMin, calcMax = fid_levels[fid]
-                if isOffset:
-                    source = mod.s
-                    fidMod, fidObject = fid[0].s,fid[1]
-                    out.write(rowFormat % (source, eid, fidMod, fidObject, offset, calcMin, calcMax))
-                    oldLevels = obfid_levels.get(fid,None)
-                    if oldLevels:
-                        oldEid, wasOffset, oldOffset, oldCalcMin, oldCalcMax = oldLevels
-                        out.write(extendedRowFormat % (wasOffset, oldOffset, oldCalcMin, oldCalcMax))
-                    else:
-                        out.write(blankExtendedRow)
-        out.close()
+# class CBash_ActorLevels:
+#     """Package: Functions for manipulating actor levels."""
+#     def __init__(self,aliases=None):
+#         """Initialize."""
+#         self.mod_fid_levels = {} #--levels = mod_id_levels[mod][longid]
+#         self.aliases = aliases or {}
+#         self.gotLevels = set()
+
+#     def readFromMod(self,modInfo):
+#         """Imports actor level data from the specified mod and its masters."""
+#         mod_fid_levels, gotLevels = self.mod_fid_levels, self.gotLevels
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod('Oblivion.esm', Flags=0x00000068)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
+#         Current.load()
+
+#         for modFile in Current.LoadOrderMods:
+#             modName = modFile.GName
+#             if modName in gotLevels: continue
+#             fid_levels = mod_fid_levels.setdefault(modName, {})
+#             for record in modFile.NPC_:
+#                 fid_levels[record.fid] = (record.eid, record.IsPCLevelOffset and 1 or 0, record.level, record.calcMin, record.calcMax)
+#                 record.UnloadRecord()
+#             gotLevels.add(modName)
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports actor levels to specified mod."""
+#         mod_fid_levels = self.mod_fid_levels
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ActorLevels:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = 0
+#         fid_levels = mod_fid_levels.get(modFile.GName,mod_fid_levels.get(GPath('Unknown'),None))
+#         if fid_levels:
+#             for record in modFile.NPC_:
+#                 fid = record.fid
+#                 if fid not in fid_levels: continue
+#                 eid, isOffset, level, calcMin, calcMax = fid_levels[fid]
+#                 if((record.level, record.calcMin, record.calcMax) != (level, calcMin, calcMax)):
+#                     (record.level, record.calcMin, record.calcMax) = (level, calcMin, calcMax)
+#                     changed += 1
+#         #--Done
+#         if changed: modFile.save()
+#         del Current
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports NPC level data from specified text file."""
+#         mod_fid_levels = self.mod_fid_levels
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if fields[0][:2] == '0x': #old format
+#                 fid,eid,offset,calcMin,calcMax = fields[:5]
+#                 source = GPath('Unknown')
+#                 fidObject = _coerce(fid[4:], int, 16)
+#                 fid = (GPath('Oblivion.esm'), fidObject)
+#                 eid = _coerce(eid, str, AllowNone=True)
+#                 offset = _coerce(offset, int)
+#                 calcMin = _coerce(calcMin, int)
+#                 calcMax = _coerce(calcMax, int)
+#             else:
+#                 if len(fields) < 7 or fields[3][:2] != '0x': continue
+#                 source,eid,fidMod,fidObject,offset,calcMin,calcMax = fields[:7]
+#                 source = _coerce(source, str)
+#                 if source.lower() in ('none', 'oblivion.esm'): continue
+#                 source = GPath(source)
+#                 eid = _coerce(eid, str, AllowNone=True)
+#                 fidMod = GPath(_coerce(fidMod, str))
+#                 if fidMod.s.lower() == 'none': continue
+#                 fidObject = _coerce(fidObject[2:], int, 16)
+#                 if fidObject is None: continue
+#                 fid = (aliases.get(fidMod,fidMod),fidObject)
+#                 offset = _coerce(offset, int)
+#                 calcMin = _coerce(calcMin, int)
+#                 calcMax = _coerce(calcMax, int)
+#             fid_levels = mod_fid_levels.setdefault(source, {})
+#             fid_levels[fid] = (eid, 1, offset, calcMin, calcMax)
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Export NPC level data to specified text file."""
+#         mod_fid_levels = self.mod_fid_levels
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","%s","%s","0x%06X","%d","%d","%d"'
+#         extendedRowFormat = ',"%d","%d","%d","%d"\n'
+#         blankExtendedRow = ',,,,\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Source Mod'),_('Actor Eid'),_('Actor Mod'),_('Actor Object'),_('Offset'),_('CalcMin'),_('CalcMax'),_('Old IsPCLevelOffset'),_('Old Offset'),_('Old CalcMin'),_('Old CalcMax')),'mbcs'))
+#         #Sorted based on mod, then editor ID
+#         obfid_levels = mod_fid_levels[GPath('Oblivion.esm')]
+#         for mod in sorted(mod_fid_levels):
+#             if mod.s.lower() == 'oblivion.esm': continue
+#             fid_levels = mod_fid_levels[mod]
+#             for fid in sorted(fid_levels,key=lambda k: (k[0].s,fid_levels[k][0])):
+#                 eid, isOffset, offset, calcMin, calcMax = fid_levels[fid]
+#                 if isOffset:
+#                     source = mod.s
+#                     fidMod, fidObject = fid[0].s,fid[1]
+#                     out.write(rowFormat % (source, eid, fidMod, fidObject, offset, calcMin, calcMax))
+#                     oldLevels = obfid_levels.get(fid,None)
+#                     if oldLevels:
+#                         oldEid, wasOffset, oldOffset, oldCalcMin, oldCalcMax = oldLevels
+#                         out.write(extendedRowFormat % (wasOffset, oldOffset, oldCalcMin, oldCalcMax))
+#                     else:
+#                         out.write(blankExtendedRow)
+#         out.close()
 
 #------------------------------------------------------------------------------
 class EditorIds:
@@ -13304,211 +15239,212 @@ class EditorIds:
             for id in sorted(id_eid,key = lambda a: id_eid[a]):
                 out.write(rowFormat % (type,id[0].s,id[1],id_eid[id]))
         out.close()
-class CBash_EditorIds:
-    """Editor ids for records, with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,types=None,aliases=None):
+# class CBash_EditorIds:
+#     """Editor ids for records, with functions for importing/exporting from/to mod/text file."""
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.group_fid_eid = {} #--eid = group_fid_eid[group][longid]
+#         self.old_new = {}
+#         if types:
+#             self.groups = set(types)
+#         else:
+#             self.groups = aggregateTypes
+#         self.aliases = aliases or {}
+
+#     def readFromMod(self,modInfo):
+#         """Imports eids from specified mod."""
+#         group_fid_eid,groups = self.group_fid_eid,self.groups
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_EditorIds:readFromMod"
+#             print error[0]
+#             return
+
+#         for group in groups:
+#             fid_eid = group_fid_eid.setdefault(group[:4], {})
+#             for record in getattr(modFile, group):
+#                 eid = record.eid
+#                 if eid: fid_eid[record.fid] = eid
+#                 record.UnloadRecord()
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports eids to specified mod."""
+#         group_fid_eid = self.group_fid_eid
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_EditorIds:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = []
+#         for group,block in modFile.aggregates.iteritems():
+#             fid_eid = group_fid_eid.get(group[:4],None)
+#             if not fid_eid: continue
+#             for record in block:
+#                 fid = record.fid
+#                 newEid = fid_eid.get(fid)
+#                 oldEid = record.eid
+#                 if newEid and newEid != oldEid:
+#                     record.eid = newEid
+#                     if record.eid == newEid: #Can silently fail if a record keyed by editorID (GMST,MGEF) already has the value
+#                         changed.append((oldEid,newEid))
+#         #--Update scripts
+#         old_new = dict(self.old_new)
+#         old_new.update(dict([(oldEid.lower(),newEid) for oldEid,newEid in changed]))
+#         changed.extend(self.changeScripts(modFile,old_new))
+#         #--Done
+#         if changed: modFile.save()
+#         return changed
+
+#     def changeScripts(self,modFile,old_new):
+#         """Changes scripts in modfile according to changed."""
+#         changed = []
+#         if not old_new: return changed
+#         reWord = re.compile('\w+')
+#         def subWord(match):
+#             word = match.group(0)
+#             newWord = old_new.get(word.lower())
+#             if not newWord:
+#                 return word
+#             else:
+#                 return newWord
+#         #--Scripts
+#         for script in sorted(modFile.SCPT,key=attrgetter('eid')):
+#             if not script.scriptText: continue
+#             newText = reWord.sub(subWord,script.scriptText)
+#             if newText != script.scriptText:
+#                 script.scriptText = newText
+#                 changed.append((_("Script"),script.eid))
+#         #--Quest Scripts
+#         for quest in sorted(modFile.QUST,key=attrgetter('eid')):
+#             questChanged = False
+#             for stage in quest.stages:
+#                 for entry in stage.entries:
+#                     oldScript = entry.scriptText
+#                     if not oldScript: continue
+#                     newScript = reWord.sub(subWord,oldScript)
+#                     if newScript != oldScript:
+#                         entry.scriptText = newScript
+#                         questChanged = True
+#             if questChanged:
+#                 changed.append((_("Quest"),quest.eid))
+#         #--Done
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports eids from specified text file."""
+#         group_fid_eid = self.group_fid_eid
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         reNewEid = re.compile('^[a-zA-Z][a-zA-Z0-9]+$')
+#         for fields in ins:
+#             if len(fields) < 4 or fields[2][:2] != '0x': continue
+#             group,mod,objectIndex,eid = fields[:4]
+#             group = _coerce(group,str)[:4]
+#             if group not in validTypes: continue
+#             mod = GPath(_coerce(mod,str))
+#             longid = (aliases.get(mod,mod),_coerce(objectIndex[2:],int,16))
+#             eid = _coerce(eid,str, AllowNone=True)
+#             if not reNewEid.match(eid):
+#                 continue
+#             fid_eid = group_fid_eid.setdefault(group, {})
+#             fid_eid[longid] = eid
+#             #--Explicit old to new def? (Used for script updating.)
+#             if len(fields) > 4:
+#                 self.old_new[_coerce(fields[4], str).lower()] = eid
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports eids to specified text file."""
+#         group_fid_eid = self.group_fid_eid
+#         headFormat = '"%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","%s","0x%06X","%s"\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id')),'mbcs'))
+#         for group in sorted(group_fid_eid):
+#             fid_eid = group_fid_eid[group]
+#             for fid in sorted(fid_eid,key = lambda a: fid_eid[a]):
+#                 out.write(rowFormat % (group,fid[0].s,fid[1],fid_eid[fid]))
+#         out.close()
+#------------------------------------------------------------------------------
+class FactionRelations:
+    """Faction relations."""
+    def __init__(self,aliases=None):
         """Initialize."""
-        self.group_fid_eid = {} #--eid = group_fid_eid[group][longid]
-        self.old_new = {}
-        if types:
-            self.groups = set(types)
-        else:
-            self.groups = aggregateTypes
+        self.id_relations = {} #--(otherLongid,otherDisp,groupCombatReaction) = id_relation[longid]
+        self.id_eid = {} #--For all factions.
         self.aliases = aliases or {}
+        self.gotFactions = set()
+
+    def readFactionEids(self,modInfo):
+        """Extracts faction editor ids from modInfo and its masters."""
+        loadFactory= LoadFactory(False,MreFact)
+        for modName in (modInfo.header.masters + [modInfo.name]):
+            if modName in self.gotFactions: continue
+            modFile = ModFile(modInfos[modName],loadFactory)
+            modFile.load(True)
+            mapper = modFile.getLongMapper()
+            for record in modFile.FACT.getActiveRecords():
+                self.id_eid[mapper(record.fid)] = record.eid
+            self.gotFactions.add(modName)
 
     def readFromMod(self,modInfo):
-        """Imports eids from specified mod."""
-        group_fid_eid,groups = self.group_fid_eid,self.groups
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_EditorIds:readFromMod"
-            print error[0]
-            return
+        """Imports faction relations from specified mod."""
+        self.readFactionEids(modInfo)
+        loadFactory= LoadFactory(False,MreFact)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        modFile.convertToLongFids(('FACT',))
+        for record in modFile.FACT.getActiveRecords():
+            #--Following is a bit messy. If already have relations for a given mod,
+            #  want to do an in-place update. Otherwise do an append.
+            relations = self.id_relations.get(record.fid)
+            if relations == None:
+                relations = self.id_relations[record.fid] = []
+            other_index = dict((y[0],x) for x,y in enumerate(relations))
+            for relation in record.relations:
+                other,disp,groupCombatReaction = relation.faction,relation.mod,relation.groupCombatReaction
+                if other in other_index:
+                    relations[other_index[other]] = (other,disp,groupCombatReaction)
+                else:
+                    relations.append((other,disp,groupCombatReaction))
 
-        for group in groups:
-            fid_eid = group_fid_eid.setdefault(group[:4], {})
-            for record in getattr(modFile, group):
-                eid = record.eid
-                if eid: fid_eid[record.fid] = eid
-                record.UnloadRecord()
-        del Current
-
-    def writeToMod(self,modInfo):
-        """Exports eids to specified mod."""
-        group_fid_eid = self.group_fid_eid
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_EditorIds:writeToMod"
-            print error[0]
-            return
-
-        changed = []
-        for group,block in modFile.aggregates.iteritems():
-            fid_eid = group_fid_eid.get(group[:4],None)
-            if not fid_eid: continue
-            for record in block:
-                fid = record.fid
-                newEid = fid_eid.get(fid)
-                oldEid = record.eid
-                if newEid and newEid != oldEid:
-                    record.eid = newEid
-                    if record.eid == newEid: #Can silently fail if a record keyed by editorID (GMST,MGEF) already has the value
-                        changed.append((oldEid,newEid))
-        #--Update scripts
-        old_new = dict(self.old_new)
-        old_new.update(dict([(oldEid.lower(),newEid) for oldEid,newEid in changed]))
-        changed.extend(self.changeScripts(modFile,old_new))
-        #--Done
-        if changed: modFile.save()
-        return changed
-
-    def changeScripts(self,modFile,old_new):
-        """Changes scripts in modfile according to changed."""
-        changed = []
-        if not old_new: return changed
-        reWord = re.compile('\w+')
-        def subWord(match):
-            word = match.group(0)
-            newWord = old_new.get(word.lower())
-            if not newWord:
-                return word
-            else:
-                return newWord
-        #--Scripts
-        for script in sorted(modFile.SCPT,key=attrgetter('eid')):
-            if not script.scriptText: continue
-            newText = reWord.sub(subWord,script.scriptText)
-            if newText != script.scriptText:
-                script.scriptText = newText
-                changed.append((_("Script"),script.eid))
-        #--Quest Scripts
-        for quest in sorted(modFile.QUST,key=attrgetter('eid')):
-            questChanged = False
-            for stage in quest.stages:
-                for entry in stage.entries:
-                    oldScript = entry.scriptText
-                    if not oldScript: continue
-                    newScript = reWord.sub(subWord,oldScript)
-                    if newScript != oldScript:
-                        entry.scriptText = newScript
-                        questChanged = True
-            if questChanged:
-                changed.append((_("Quest"),quest.eid))
-        #--Done
-        return changed
-
-    def readFromText(self,textPath):
-        """Imports eids from specified text file."""
-        group_fid_eid = self.group_fid_eid
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        reNewEid = re.compile('^[a-zA-Z][a-zA-Z0-9]+$')
-        for fields in ins:
-            if len(fields) < 4 or fields[2][:2] != '0x': continue
-            group,mod,objectIndex,eid = fields[:4]
-            group = _coerce(group,str)[:4]
-            if group not in validTypes: continue
-            mod = GPath(_coerce(mod,str))
-            longid = (aliases.get(mod,mod),_coerce(objectIndex[2:],int,16))
-            eid = _coerce(eid,str, AllowNone=True)
-            if not reNewEid.match(eid):
-                continue
-            fid_eid = group_fid_eid.setdefault(group, {})
-            fid_eid[longid] = eid
-            #--Explicit old to new def? (Used for script updating.)
-            if len(fields) > 4:
-                self.old_new[_coerce(fields[4], str).lower()] = eid
-        ins.close()
-
-    def writeToText(self,textPath):
-        """Exports eids to specified text file."""
-        group_fid_eid = self.group_fid_eid
-        headFormat = '"%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","0x%06X","%s"\n'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id')),'mbcs'))
-        for group in sorted(group_fid_eid):
-            fid_eid = group_fid_eid[group]
-            for fid in sorted(fid_eid,key = lambda a: fid_eid[a]):
-                out.write(rowFormat % (group,fid[0].s,fid[1],fid_eid[fid]))
-        out.close()
-#------------------------------------------------------------------------------
-class FactionRelations:
-    """Faction relations."""
-    def __init__(self,aliases=None):
-        """Initialize."""
-        self.id_relations = {} #--(otherLongid,otherDisp) = id_relation[longid]
-        self.id_eid = {} #--For all factions.
-        self.aliases = aliases or {}
-        self.gotFactions = set()
-
-    def readFactionEids(self,modInfo):
-        """Extracts faction editor ids from modInfo and its masters."""
-        loadFactory= LoadFactory(False,MreFact)
-        for modName in (modInfo.header.masters + [modInfo.name]):
-            if modName in self.gotFactions: continue
-            modFile = ModFile(modInfos[modName],loadFactory)
-            modFile.load(True)
-            mapper = modFile.getLongMapper()
-            for record in modFile.FACT.getActiveRecords():
-                self.id_eid[mapper(record.fid)] = record.eid
-            self.gotFactions.add(modName)
-
-    def readFromMod(self,modInfo):
-        """Imports faction relations from specified mod."""
-        self.readFactionEids(modInfo)
-        loadFactory= LoadFactory(False,MreFact)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        modFile.convertToLongFids(('FACT',))
-        for record in modFile.FACT.getActiveRecords():
-            #--Following is a bit messy. If already have relations for a given mod,
-            #  want to do an in-place update. Otherwise do an append.
-            relations = self.id_relations.get(record.fid)
-            if relations == None:
-                relations = self.id_relations[record.fid] = []
-            other_index = dict((y[0],x) for x,y in enumerate(relations))
-            for relation in record.relations:
-                other,disp = relation.faction,relation.mod
-                if other in other_index:
-                    relations[other_index[other]] = (other,disp)
-                else:
-                    relations.append((other,disp))
-
-    def readFromText(self,textPath):
-        """Imports faction relations from specified text file."""
-        id_relations,id_eid = self.id_relations, self.id_eid
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 7 or fields[2][:2] != '0x': continue
-            med,mmod,mobj,oed,omod,oobj,disp = fields[:9]
-            mmod = _coerce(mmod, str)
-            omod = _coerce(omod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj[2:],int,16))
-            oid = (GPath(aliases.get(omod,omod)),_coerce(oobj[2:],int,16))
-            disp = _coerce(disp, int)
-            relations = id_relations.get(mid)
-            if relations is None:
-                relations = id_relations[mid] = []
-            for index,entry in enumerate(relations):
-                if entry[0] == oid:
-                    relations[index] = (oid,disp)
-                    break
-            else:
-                relations.append((oid,disp))
-        ins.close()
+    def readFromText(self,textPath):
+        """Imports faction relations from specified text file."""
+        id_relations,id_eid = self.id_relations, self.id_eid
+        aliases = self.aliases
+        ins = bolt.CsvReader(textPath)
+        for fields in ins:
+            if len(fields) < 8 or fields[2][:2] != '0x': continue
+            med,mmod,mobj,oed,omod,oobj,disp,groupCombatReaction = fields[:8]
+            mmod = _coerce(mmod, str)
+            omod = _coerce(omod, str)
+            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj[2:],int,16))
+            oid = (GPath(aliases.get(omod,omod)),_coerce(oobj[2:],int,16))
+            disp = _coerce(disp, int)
+            relations = id_relations.get(mid)
+            if relations is None:
+                relations = id_relations[mid] = []
+            for index,entry in enumerate(relations):
+                if entry[0] == oid:
+                    relations[index] = (oid,disp,groupCombatReaction)
+                    break
+            else:
+                relations.append((oid,disp,groupCombatReaction))
+        ins.close()
 
     def writeToMod(self,modInfo):
         """Exports faction relations to specified mod."""
+        raise NotImplementedError
         id_relations,id_eid = self.id_relations, self.id_eid
         loadFactory= LoadFactory(True,MreFact)
         modFile = ModFile(modInfo,loadFactory)
@@ -13543,126 +15479,126 @@ class FactionRelations:
     def writeToText(self,textPath):
         """Exports faction relations to specified text file."""
         id_relations,id_eid = self.id_relations, self.id_eid
-        headFormat = '%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","0x%06X","%s","%s","0x%06X","%s"\n'
+        headFormat = '%s","%s","%s","%s","%s","%s","%s","%s"\n'
+        rowFormat = '"%s","%s","0x%06X","%s","%s","0x%06X","%s","%s"\n'
         out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Main Eid'),_('Main Mod'),_('Main Object'),_('Other Eid'),_('Other Mod'),_('Other Object'),_('Disp')),'mbcs'))
+        out.write(Encode(headFormat % (_('Main Eid'),_('Main Mod'),_('Main Object'),_('Other Eid'),_('Other Mod'),_('Other Object'),_('Disp'),_('GroupCombatReaction')),'mbcs'))
         for main in sorted(id_relations,key = lambda x: id_eid.get(x)):
             mainEid = id_eid.get(main,'Unknown')
-            for other, disp in sorted(id_relations[main],key=lambda x: id_eid.get(x[0])):
+            for other,disp,groupCombatReaction in sorted(id_relations[main],key=lambda x: id_eid.get(x[0])):
                 otherEid = id_eid.get(other,'Unknown')
-                out.write(rowFormat % (mainEid,main[0].s,main[1],otherEid,other[0].s,other[1],disp))
+                out.write(rowFormat % (mainEid,main[0].s,main[1],otherEid,other[0].s,other[1],disp,groupCombatReaction))
         out.close()
 
-class CBash_FactionRelations:
-    """Faction relations."""
-    def __init__(self,aliases=None):
-        """Initialize."""
-        self.fid_faction_mod = {}
-        self.fid_eid = {} #--For all factions.
-        self.aliases = aliases or {}
-        self.gotFactions = set()
-
-    def readFromMod(self,modInfo):
-        """Imports faction relations from specified mod."""
-        fid_faction_mod,fid_eid,gotFactions = self.fid_faction_mod,self.fid_eid,self.gotFactions
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
-        Current.load()
-        try:
-            importFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_FactionRelations:readFromMod"
-            print error[0]
-            return
-
-        for modFile in Current.LoadOrderMods:
-            modName = modFile.GName
-            if modName in gotFactions: continue
-            if modFile == importFile:
-                for record in modFile.FACT:
-                    fid = record.fid
-                    fid_eid[fid] = record.eid
-                    relations = record.relations_list
-                    if relations:
-                        faction_mod = fid_faction_mod.setdefault(fid,{})
-                        faction_mod.update(relations)
-                    record.UnloadRecord()
-            else:
-                for record in modFile.FACT:
-                    fid_eid[record.fid] = record.eid
-                    record.UnloadRecord()
-            gotFactions.add(modName)
-        del Current
-
-    def readFromText(self,textPath):
-        """Imports faction relations from specified text file."""
-        fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 7 or fields[2][:2] != '0x': continue
-            med,mmod,mobj,oed,omod,oobj,disp = fields[:9]
-            mmod = _coerce(mmod, str)
-            omod = _coerce(omod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj[2:],int,16))
-            oid = (GPath(aliases.get(omod,omod)),_coerce(oobj[2:],int,16))
-            disp = _coerce(disp, int)
-            faction_mod = fid_faction_mod.setdefault(mid,{})
-            faction_mod[oid] = disp
-        ins.close()
-
-    def writeToMod(self,modInfo):
-        """Exports faction relations to specified mod."""
-        fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_FactionRelations:writeToMod"
-            print error[0]
-            return
-
-        changed = 0
-        for record in modFile.FACT:
-            fid = record.fid
-            if fid not in fid_faction_mod: continue
-            newRelations = set([(faction, mod) for faction, mod in fid_faction_mod[fid].iteritems()])
-            curRelations = set(record.relations_list)
-            changes = newRelations - curRelations
-            if not changes: continue
-            for faction,mod in changes:
-                for entry in record.relations:
-                    if entry.faction == faction:
-                        entry.mod = mod
-                        break
-                else:
-                    entry = record.create_relation()
-                    entry.faction = faction
-                    entry.mod = mod
-            changed += 1
-        #--Done
-        if changed: modFile.save()
-        del Current
-        return changed
-
-    def writeToText(self,textPath):
-        """Exports faction relations to specified text file."""
-        fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","0x%06X","%s","%s","0x%06X","%s"\n'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Main Eid'),_('Main Mod'),_('Main Object'),_('Other Eid'),_('Other Mod'),_('Other Object'),_('Disp')),'mbcs'))
-        for main in sorted(fid_faction_mod,key = lambda x: fid_eid.get(x)):
-            mainEid = fid_eid.get(main,'Unknown')
-            faction_mod = fid_faction_mod[main]
-            for other, disp in sorted(faction_mod.items(),key=lambda x: fid_eid.get(x[0])):
-                otherEid = fid_eid.get(other,'Unknown')
-                out.write(rowFormat % (mainEid,main[0].s,main[1],otherEid,other[0].s,other[1],disp))
-        out.close()
+# class CBash_FactionRelations:
+#     """Faction relations."""
+#     def __init__(self,aliases=None):
+#         """Initialize."""
+#         self.fid_faction_mod = {}
+#         self.fid_eid = {} #--For all factions.
+#         self.aliases = aliases or {}
+#         self.gotFactions = set()
+
+#     def readFromMod(self,modInfo):
+#         """Imports faction relations from specified mod."""
+#         fid_faction_mod,fid_eid,gotFactions = self.fid_faction_mod,self.fid_eid,self.gotFactions
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000068)
+#         Current.load()
+#         try:
+#             importFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_FactionRelations:readFromMod"
+#             print error[0]
+#             return
+
+#         for modFile in Current.LoadOrderMods:
+#             modName = modFile.GName
+#             if modName in gotFactions: continue
+#             if modFile == importFile:
+#                 for record in modFile.FACT:
+#                     fid = record.fid
+#                     fid_eid[fid] = record.eid
+#                     relations = record.relations_list
+#                     if relations:
+#                         faction_mod = fid_faction_mod.setdefault(fid,{})
+#                         faction_mod.update(relations)
+#                     record.UnloadRecord()
+#             else:
+#                 for record in modFile.FACT:
+#                     fid_eid[record.fid] = record.eid
+#                     record.UnloadRecord()
+#             gotFactions.add(modName)
+#         del Current
+
+#     def readFromText(self,textPath):
+#         """Imports faction relations from specified text file."""
+#         fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 7 or fields[2][:2] != '0x': continue
+#             med,mmod,mobj,oed,omod,oobj,disp = fields[:9]
+#             mmod = _coerce(mmod, str)
+#             omod = _coerce(omod, str)
+#             mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj[2:],int,16))
+#             oid = (GPath(aliases.get(omod,omod)),_coerce(oobj[2:],int,16))
+#             disp = _coerce(disp, int)
+#             faction_mod = fid_faction_mod.setdefault(mid,{})
+#             faction_mod[oid] = disp
+#         ins.close()
+
+#     def writeToMod(self,modInfo):
+#         """Exports faction relations to specified mod."""
+#         fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_FactionRelations:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = 0
+#         for record in modFile.FACT:
+#             fid = record.fid
+#             if fid not in fid_faction_mod: continue
+#             newRelations = set([(faction, mod) for faction, mod in fid_faction_mod[fid].iteritems()])
+#             curRelations = set(record.relations_list)
+#             changes = newRelations - curRelations
+#             if not changes: continue
+#             for faction,mod in changes:
+#                 for entry in record.relations:
+#                     if entry.faction == faction:
+#                         entry.mod = mod
+#                         break
+#                 else:
+#                     entry = record.create_relation()
+#                     entry.faction = faction
+#                     entry.mod = mod
+#             changed += 1
+#         #--Done
+#         if changed: modFile.save()
+#         del Current
+#         return changed
+
+#     def writeToText(self,textPath):
+#         """Exports faction relations to specified text file."""
+#         fid_faction_mod,fid_eid = self.fid_faction_mod, self.fid_eid
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","%s","0x%06X","%s","%s","0x%06X","%s"\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Main Eid'),_('Main Mod'),_('Main Object'),_('Other Eid'),_('Other Mod'),_('Other Object'),_('Disp')),'mbcs'))
+#         for main in sorted(fid_faction_mod,key = lambda x: fid_eid.get(x)):
+#             mainEid = fid_eid.get(main,'Unknown')
+#             faction_mod = fid_faction_mod[main]
+#             for other, disp in sorted(faction_mod.items(),key=lambda x: fid_eid.get(x[0])):
+#                 otherEid = fid_eid.get(other,'Unknown')
+#                 out.write(rowFormat % (mainEid,main[0].s,main[1],otherEid,other[0].s,other[1],disp))
+#         out.close()
 #------------------------------------------------------------------------------
 class FidReplacer:
     """Replaces one set of fids with another."""
@@ -13737,85 +15673,89 @@ class FidReplacer:
         entries.sort(key=itemgetter(1))
         return '\n'.join(['%3d %s >> %s' % entry for entry in entries])
 
-class CBash_FidReplacer:
-    """Replaces one set of fids with another."""
-
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.old_new = {} #--Maps old fid to new fid
-        self.old_eid = {} #--Maps old fid to old editor id
-        self.new_eid = {} #--Maps new fid to new editor id
-
-    def readFromText(self,textPath):
-        """Reads replacement data from specified text file."""
-        old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        pack,unpack = struct.pack,struct.unpack
-        for fields in ins:
-            if len(fields) < 7 or fields[2][:2] != '0x' or fields[6][:2] != '0x': continue
-            oldMod,oldObj,oldEid,newEid,newMod,newObj = fields[1:7]
-            oldMod = _coerce(oldMod, str)
-            oldEid = _coerce(oldEid, str)
-            newEid = _coerce(newEid, str, AllowNone=True)
-            newMod = _coerce(newMod, str, AllowNone=True)
-            oldMod,newMod = map(GPath,(oldMod,newMod))
-            oldId = (GPath(aliases.get(oldMod,oldMod)),_coerce(oldObj,int,16))
-            newId = (GPath(aliases.get(newMod,newMod)),_coerce(newObj,int,16))
-            old_new[oldId] = newId
-            old_eid[oldId] = oldEid
-            new_eid[newId] = newEid
-        ins.close()
-
-    def updateMod(self, modInfo,changeBase=False):
-        """Updates specified mod file."""
-        old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
-        #Filter the fid replacements to only include existing mods
-        existing = modInfos.keys()
-        old_new = dict((oldId, newId) for oldId, newId in old_new.iteritems() if oldId[0] in existing and newId[0] in existing)
-        if not old_new: return False
-        old_count = {}
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        for newId in set(old_new.values()):
-            Current.addMod(modInfos[newId[0]].getPath().stail, Flags=0x00000068)
-        Current.addMod(modInfo.getPath().stail, Flags=0x00000078)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_FidReplacer:updateMod"
-            print error[0]
-            return
-
-        for oldId, newId in old_new.iteritems():
-            count = modFile.UpdateReferences(oldId,newId) #returns -1 on error
-            if count > 0: old_count[oldId] = count
-
-        #--Done
-        if not sum(old_count.values()): return False
-        modFile.save()
-        entries = [(count,old_eid[oldId],new_eid[old_new[oldId]]) for oldId,count in old_count.iteritems()]
-        entries.sort(key=itemgetter(1))
-        return '\n'.join(['%3d %s >> %s' % entry for entry in entries])
+# class CBash_FidReplacer:
+#     """Replaces one set of fids with another."""
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.old_new = {} #--Maps old fid to new fid
+#         self.old_eid = {} #--Maps old fid to old editor id
+#         self.new_eid = {} #--Maps new fid to new editor id
+
+#     def readFromText(self,textPath):
+#         """Reads replacement data from specified text file."""
+#         old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         pack,unpack = struct.pack,struct.unpack
+#         for fields in ins:
+#             if len(fields) < 7 or fields[2][:2] != '0x' or fields[6][:2] != '0x': continue
+#             oldMod,oldObj,oldEid,newEid,newMod,newObj = fields[1:7]
+#             oldMod = _coerce(oldMod, str)
+#             oldEid = _coerce(oldEid, str)
+#             newEid = _coerce(newEid, str, AllowNone=True)
+#             newMod = _coerce(newMod, str, AllowNone=True)
+#             oldMod,newMod = map(GPath,(oldMod,newMod))
+#             oldId = (GPath(aliases.get(oldMod,oldMod)),_coerce(oldObj,int,16))
+#             newId = (GPath(aliases.get(newMod,newMod)),_coerce(newObj,int,16))
+#             old_new[oldId] = newId
+#             old_eid[oldId] = oldEid
+#             new_eid[newId] = newEid
+#         ins.close()
+
+#     def updateMod(self, modInfo,changeBase=False):
+#         """Updates specified mod file."""
+#         old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
+#         #Filter the fid replacements to only include existing mods
+#         existing = modInfos.keys()
+#         old_new = dict((oldId, newId) for oldId, newId in old_new.iteritems() if oldId[0] in existing and newId[0] in existing)
+#         if not old_new: return False
+#         old_count = {}
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         for newId in set(old_new.values()):
+#             Current.addMod(modInfos[newId[0]].getPath().stail, Flags=0x00000068)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x00000078)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_FidReplacer:updateMod"
+#             print error[0]
+#             return
+
+#         for oldId, newId in old_new.iteritems():
+#             count = modFile.UpdateReferences(oldId,newId) #returns -1 on error
+#             if count > 0: old_count[oldId] = count
+
+#         #--Done
+#         if not sum(old_count.values()): return False
+#         modFile.save()
+#         entries = [(count,old_eid[oldId],new_eid[old_new[oldId]]) for oldId,count in old_count.iteritems()]
+#         entries.sort(key=itemgetter(1))
+#         return '\n'.join(['%3d %s >> %s' % entry for entry in entries])
 
 #------------------------------------------------------------------------------
 class FullNames:
     """Names for records, with functions for importing/exporting from/to mod/text file."""
     defaultTypes = set((
-        'ALCH', 'AMMO', 'APPA', 'ARMO', 'BOOK', 'BSGN', 'CLAS', 'CLOT', 'CONT', 'CREA', 'DOOR',
-        'EYES', 'FACT', 'FLOR', 'HAIR','INGR', 'KEYM', 'LIGH', 'MISC', 'NPC_', 'RACE', 'SGST',
-        'SLGM', 'SPEL','WEAP',))
+        'ALCH', 'AMMO', 'APPA', 'ARMO', 'BOOK', 'CLAS', 'CLOT', 'CONT', 'CREA', 'DOOR',
+        'EYES', 'FACT', 'FLOR', 'HAIR', 'INGR', 'KEYM', 'LIGH', 'MISC', 'NOTE', 'NPC_',
+        'RACE', 'SPEL', 'TERM', 'WEAP', 'ACTI', 'TACT'))
+    hasShortNameTypes = set((
+        'AMMO', 'AVIF', ))
 
     def __init__(self,types=None,aliases=None):
         """Initialize."""
         self.type_id_name = {} #--(eid,name) = type_id_name[type][longid]
+        self.type_id_sname = {} #--(eid,sname) = type_id_sname[type][longid]
         self.types = types or FullNames.defaultTypes
         self.aliases = aliases or {}
 
     def readFromMod(self,modInfo):
         """Imports type_id_name from specified mod."""
         type_id_name,types = self.type_id_name, self.types
+        type_id_sname = self.type_id_sname
         classes = [MreRecord.type_class[x] for x in self.types]
         loadFactory= LoadFactory(False,*classes)
         modFile = ModFile(modInfo,loadFactory)
@@ -13825,16 +15765,23 @@ class FullNames:
             typeBlock = modFile.tops.get(type,None)
             if not typeBlock: continue
             if type not in type_id_name: type_id_name[type] = {}
+            if type not in type_id_sname: type_id_sname[type] = {}
             id_name = type_id_name[type]
+            id_sname = type_id_sname[type]
             for record in typeBlock.getActiveRecords():
                 longid = mapper(record.fid)
                 full = record.full or (type != 'LIGH' and 'NO NAME')
                 if record.eid and full:
                     id_name[longid] = (record.eid,full)
+                if(hasattr(record, 'shortName')):
+                    sname = record.shortName
+                    if record.eid and sname:
+                        id_sname[longid] = (record.eid,sname)
 
     def writeToMod(self,modInfo):
         """Exports type_id_name to specified mod."""
         type_id_name,types = self.type_id_name,self.types
+        type_id_sname = self.type_id_sname
         classes = [MreRecord.type_class[x] for x in self.types]
         loadFactory= LoadFactory(True,*classes)
         modFile = ModFile(modInfo,loadFactory)
@@ -13843,16 +15790,24 @@ class FullNames:
         changed = {}
         for type in types:
             id_name = type_id_name.get(type,None)
+            id_sname = type_id_sname.get(type,None)
             typeBlock = modFile.tops.get(type,None)
             if not id_name or not typeBlock: continue
             for record in typeBlock.records:
                 longid = mapper(record.fid)
                 full = record.full
+                sname = record.shortName if (hasattr(record, 'shortName')) else None
                 eid,newFull = id_name.get(longid,(0,0))
+                eid2,newSname = id_sname.get(longid,(0,0))
                 if newFull and newFull not in (full,'NO NAME'):
                     record.full = newFull
                     record.setChanged()
                     changed[eid] = (full,newFull)
+                if newSname and newSname not in (sname,'NO NAME'):
+                    record.shortName = newSname
+                    record.setChanged()
+                    if not changed.has_key(eid):
+                        changed[eid] = (sname,newSname)
         if changed: modFile.safeSave()
         return changed
 
@@ -13860,12 +15815,14 @@ class FullNames:
         """Imports type_id_name from specified text file."""
         textPath = GPath(textPath)
         type_id_name = self.type_id_name
+        type_id_sname = self.type_id_sname
         aliases = self.aliases
         ins = bolt.CsvReader(textPath)
         for fields in ins:
             if len(fields) < 5 or fields[2][:2] != '0x': continue
             group,mod,objectIndex,eid,full = fields[:5]
             group = _coerce(group, str)
+            sname = fields[5] if type in self.hasShortNameTypes else None
             mod = GPath(_coerce(mod, str))
             longid = (aliases.get(mod,mod),_coerce(objectIndex[2:],int,16))
             eid = _coerce(eid, str, AllowNone=True)
@@ -13874,5295 +15831,5381 @@ class FullNames:
                 type_id_name[group][longid] = (eid,full)
             else:
                 type_id_name[group] = {longid:(eid,full)}
+            if group in type_id_sname:
+                type_id_sname[group][longid] = (eid,sname)
+            else:
+                type_id_sname[group] = {longid:(eid,sname)}
         ins.close()
 
     def writeToText(self,textPath):
         """Exports type_id_name to specified text file."""
         textPath = GPath(textPath)
         type_id_name = self.type_id_name
-        headFormat = '"%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","0x%06X","%s","%s"\n'
+        type_id_sname = self.type_id_sname
         out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name')), 'mbcs'))
         for type in sorted(type_id_name):
+            if type in self.hasShortNameTypes:
+                headFormat = '"%s","%s","%s","%s","%s","%s"\n'
+                rowFormat = '"%s","%s","0x%06X","%s","%s","%s"\n'
+                out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name'),_('Short Name')), 'mbcs'))
+            else:
+                headFormat = '"%s","%s","%s","%s","%s"\n'
+                rowFormat = '"%s","%s","0x%06X","%s","%s"\n'
+                out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name')), 'mbcs'))
             id_name = type_id_name[type]
+            id_sname = type_id_sname.get(type, {})
             longids = id_name.keys()
             longids.sort(key=lambda a: id_name[a][0])
             longids.sort(key=itemgetter(0))
             for longid in longids:
                 eid,name = id_name[longid]
-                out.write(rowFormat % (type,Encode(longid[0].s,'mbcs'),longid[1],eid,name.replace('"', '""')))
+                if type in self.hasShortNameTypes:
+                    eid2,sname = id_sname.get(longid,(eid,''))
+                    out.write(rowFormat % (type,Encode(longid[0].s,'mbcs'),longid[1],eid,name.replace('"', '""'),sname.replace('"', '""')))
+                else:
+                    out.write(rowFormat % (type,Encode(longid[0].s,'mbcs'),longid[1],eid,name.replace('"', '""')))
         out.close()
 
-class CBash_FullNames:
-    """Names for records, with functions for importing/exporting from/to mod/text file."""
-    defaultTypes = set(["CLAS","FACT","HAIR","EYES","RACE","MGEF","ENCH","SPEL","BSGN",
-                        "ACTI","APPA","ARMO","BOOK","CLOT","CONT","DOOR","INGR","LIGH",
-                        "MISC","FLOR","FURN","WEAP","AMMO","NPC_","CREA","SLGM","KEYM",
-                        "ALCH","SGST","WRLD","CELLS","DIAL","QUST"])
-
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.group_fid_name = {} #--(eid,name) = group_fid_name[group][longid]
-        self.types = types or CBash_FullNames.defaultTypes
-        self.aliases = aliases or {}
+# class CBash_FullNames:
+#     """Names for records, with functions for importing/exporting from/to mod/text file."""
+#     defaultTypes = set((
+#         'ALCH', 'AMMO', 'APPA', 'ARMO', 'BOOK', 'CLAS', 'CLOT', 'CONT', 'CREA', 'DOOR',
+#         'EYES', 'FACT', 'FLOR', 'HAIR', 'INGR', 'KEYM', 'LIGH', 'MISC', 'NOTE', 'NPC_',
+#         'RACE', 'SPEL', 'TERM', 'WEAP', 'ACTI', 'TACT',
+#         'CMNY', 'CCRD', 'IMOD', 'REPU', 'RCPE', 'RCCT', 'CHIP', 'CSNO'))
+#     hasShortNameTypes = set((
+#         'AMMO', 'AVIF', ))
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.group_fid_name = {} #--(eid,name) = group_fid_name[group][longid]
+#         self.types = types or CBash_FullNames.defaultTypes
+#         self.aliases = aliases or {}
+
+#     def readFromMod(self,modInfo):
+#         """Imports type_id_name from specified mod."""
+#         group_fid_name = self.group_fid_name
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_FullNames:readFromMod"
+#             print error[0]
+#             return
+
+#         for group in self.types:
+#             fid_name = group_fid_name.setdefault(group[:4],{})
+#             for record in getattr(modFile,group):
+#                 if(hasattr(record, 'full')):
+#                     full = record.full or (type != 'LIGH' and 'NO NAME')
+#                     eid = record.eid
+#                     if eid and full:
+#                         fid_name[record.fid] = (eid,full)
+#                 record.UnloadRecord()
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports type_id_name to specified mod."""
+#         group_fid_name = self.group_fid_name
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_FullNames:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = {}
+#         for type in self.types:
+#             fid_name = group_fid_name.get(type,None)
+#             if not fid_name: continue
+#             for record in getattr(modFile,type):
+#                 fid = record.fid
+#                 full = record.full
+#                 eid,newFull = fid_name.get(fid,(0,0))
+#                 if newFull and newFull not in (full,'NO NAME'):
+#                     record.full = newFull
+#                     changed[eid] = (full,newFull)
+#         if changed: modFile.save()
+#         del Current
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports type_id_name from specified text file."""
+#         textPath = GPath(textPath)
+#         group_fid_name = self.group_fid_name
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 5 or fields[2][:2] != '0x': continue
+#             group,mod,objectIndex,eid,full = fields[:5]
+#             group = _coerce(group, str)
+#             mod = GPath(_coerce(mod, str))
+#             longid = (aliases.get(mod,mod),_coerce(objectIndex[2:],int,16))
+#             eid = _coerce(eid, str, AllowNone=True)
+#             full = _coerce(full, str, AllowNone=True)
+#             group_fid_name.setdefault(group, {})[longid] = (eid,full)
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports type_id_name to specified text file."""
+#         textPath = GPath(textPath)
+#         group_fid_name = self.group_fid_name
+#         headFormat = '"%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","%s","0x%06X","%s","%s"\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name')), 'mbcs'))
+#         for group in sorted(group_fid_name):
+#             fid_name = group_fid_name[group]
+#             longids = fid_name.keys()
+#             longids.sort(key=lambda a: fid_name[a][0])
+#             longids.sort(key=itemgetter(0))
+#             for longid in longids:
+#                 eid,name = fid_name[longid]
+#                 out.write(rowFormat % (group,Encode(longid[0].s,'mbcs'),longid[1],eid,name.replace('"', '""')))
+#         out.close()
+
+#------------------------------------------------------------------------------
+# class CBash_MapMarkers:
+#     """Map marker references, with functions for importing/exporting from/to mod/text file."""
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.fid_markerdata = {}
+#         self.aliases = aliases or {}
+#         self.markerFid = (GPath('Oblivion.esm'), 0x000010)
+#         self.attrs = ['eid','markerName','markerType','IsVisible','IsCanTravelTo','posX','posY','posZ','rotX','rotY','rotZ']
+#         self.markerTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'NONE',
+#             1 : 'Camp',
+#             2 : 'Cave',
+#             3 : 'City',
+#             4 : 'Elven Ruin',
+#             5 : 'Fort Ruin',
+#             6 : 'Mine',
+#             7 : 'Landmark',
+#             8 : 'Tavern',
+#             9 : 'Settlement',
+#             10 : 'Daedric Shrine',
+#             11 : 'Oblivion Gate',
+#             12 : '?',
+#             13 : 'Ayleid Well',
+#             14 : 'Wayshrine',
+#             15 : 'Magical Stone',
+#             16 : 'Spire',
+#             17 : 'Obelisk of Order',
+#             18 : 'House',
+#             19 : 'Player marker (flag)',
+#             20 : 'Player marker (Q flag)',
+#             21 : 'Player marker (i flag)',
+#             22 : 'Player marker (? flag)',
+#             23 : 'Harbor/dock',
+#             24 : 'Stable',
+#             25 : 'Castle',
+#             26 : 'Farm',
+#             27 : 'Chapel',
+#             28 : 'Merchant',
+#             29 : 'Ayleid Step (old Ayleid ruin icon)',}
+#         self.markerTypeName_Number = dict([(y.lower(),x) for x,y in self.markerTypeNumber_Name.iteritems() if x is not None])
+
+#     def readFromMod(self,modInfo):
+#         """Imports type_id_name from specified mod."""
+#         fid_markerdata,markerFid,attrs = self.fid_markerdata,self.markerFid,self.attrs
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_MapMarkers:readFromMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.REFRS:
+#             if record.base == markerFid:
+#                 fid_markerdata[record.fid] = [getattr(record, attr) for attr in attrs]
+#             record.UnloadRecord()
+
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Imports type_id_name to specified mod."""
+#         fid_markerdata,markerFid,attrs = self.fid_markerdata,self.markerFid,self.attrs
+#         changed = []
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_MapMarkers:writeToMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.REFRS:
+#             fid = record.fid
+#             if not fid in fid_markerdata: continue
+#             if record.base == markerFid:
+#                 oldValues = [getattr(record, attr) for attr in attrs]
+#                 newValues = fid_markerdata[fid]
+#                 if oldValues != newValues:
+#                     changed.append(oldValues[0]) #eid
+#                     for attr, value in zip(attrs, newValues):
+#                         setattr(record, attr, value)
+
+#         if changed: modFile.save()
+#         del Current
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports type_id_name from specified text file."""
+#         fid_markerdata,aliases,markerTypeName_Number = self.fid_markerdata,self.aliases,self.markerTypeName_Number
+#         ins = bolt.CsvReader(GPath(textPath))
+#         for fields in ins:
+#             if len(fields) < 13 or fields[1][:2] != '0x': continue
+#             mod,objectIndex,eid,markerName,_markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ = fields[:13]
+#             mod = GPath(_coerce(mod, str))
+#             longid = (aliases.get(mod,mod),_coerce(objectIndex, int, 16))
+#             eid = _coerce(eid, str, AllowNone=True)
+#             markerName = _coerce(markerName, str, AllowNone=True)
+#             markerType = _coerce(_markerType, int)
+#             if markerType is None: #coercion failed
+#                 markerType = markerTypeName_Number.get(_markerType.lower(), 0)
+#             IsVisible = _coerce(IsVisible, bool)
+#             IsCanTravelTo = _coerce(IsCanTravelTo, bool)
+#             posX = _coerce(posX, float)
+#             posY = _coerce(posY, float)
+#             posZ = _coerce(posZ, float)
+#             rotX = _coerce(rotX, float)
+#             rotY = _coerce(rotY, float)
+#             rotZ = _coerce(rotZ, float)
+#             fid_markerdata[longid] = [eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports markers to specified text file."""
+#         fid_markerdata,markerTypeNumber_Name = self.fid_markerdata,self.markerTypeNumber_Name
+#         textPath = GPath(textPath)
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","0x%06X","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name'),_('Type'),_('IsVisible'),_('IsCanTravelTo'),_('posX'),_('posY'),_('posZ'),_('rotX'),_('rotY'),_('rotZ')),'mbcs'))
+#         longids = fid_markerdata.keys()
+#         longids.sort(key=lambda a: fid_markerdata[a][0])
+#         longids.sort(key=itemgetter(0))
+#         for longid in longids:
+#             eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ = fid_markerdata[longid]
+#             markerType = markerTypeNumber_Name.get(markerType,markerType)
+#             out.write(rowFormat % (longid[0].s,longid[1],eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ))
+#         out.close()
+
+#------------------------------------------------------------------------------
+# class CBash_CellBlockInfo:
+#     """Map marker references, with functions for importing/exporting from/to mod/text file."""
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.celldata = {}
+#         self.aliases = aliases or {}
+
+#     def readFromMod(self,modInfo):
+#         """Imports type_id_name from specified mod."""
+#         celldata = self.celldata
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_CellBlockInfo:readFromMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.CELLS:
+#             celldata[record.eid] = record.bsb
+#             record.UnloadRecord()
+
+#         del Current
+
+#     def writeToText(self,textPath):
+#         """Exports markers to specified text file."""
+#         celldata = self.celldata
+#         textPath = GPath(textPath)
+#         headFormat = '"%s","%s","%s",\n'
+#         rowFormat  = '"%s","%s","%s",\n'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Editor Id'),_('Block'),_('Sub-Block')),'mbcs'))
+#         eids = celldata.keys()
+#         eids.sort()
+#         for eid in eids:
+#             block, subblock = celldata[eid]
+#             out.write(rowFormat % (eid, block, subblock))
+#         out.close()
+
+#------------------------------------------------------------------------------
+# class SigilStoneDetails:
+#     """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.fid_stats = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.recipientTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'Self',
+#             1 : 'Touch',
+#             2 : 'Target',}
+#         self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+#         self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+#         self.actorValueNumber_Name[None] = 'NONE'
+#         self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         fid_stats = self.fid_stats
+#         loadFactory= LoadFactory(False,MreSgst)
+#         modFile = ModFile(modInfo,loadFactory)
+#         modFile.load(True)
+#         modFile.convertToLongFids(['SGST'])
+#         for record in modFile.SGST.getActiveRecords():
+#             effects = []
+#             for effect in record.effects:
+#                 effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+#                 if effect.scriptEffect:
+#                     effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
+#                                        effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+#                 else: effectlist.append([])
+#                 effects.append(effectlist)
+#             fid_stats[record.fid] = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, record.script, record.uses, record.value, round(record.weight,6), effects]
+
+#     def writeToMod(self,modInfo):
+#         """Writes stats to specified mod."""
+#         fid_stats = self.fid_stats
+#         loadFactory= LoadFactory(True,MreSgst)
+#         modFile = ModFile(modInfo,loadFactory)
+#         modFile.load(True)
+#         mapper = modFile.getLongMapper()
+#         shortMapper = modFile.getShortMapper()
+#         changed = [] #eids
+#         for record in modFile.SGST.getActiveRecords():
+#             newStats = fid_stats.get(mapper(record.fid), None)
+#             if not newStats: continue
+#             effects = []
+#             for effect in record.effects:
+#                 effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+#                 if effect.scriptEffect:
+#                     effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
+#                                        effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+#                 else: effectlist.append([])
+#                 effects.append(effectlist)
+#             oldStats = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, mapper(record.script), record.uses, record.value, round(record.weight,6), effects]
+#             if oldStats != newStats:
+#                 changed.append(oldStats[0]) #eid
+#                 record.eid, record.full, record.model.modPath, record.model.modb, record.iconPath, script, record.uses, record.value, record.weight, effects = newStats
+#                 record.script = shortMapper(script)
+#                 record.effects = []
+#                 for effect in effects:
+#                     neweffect = record.getDefault('effects')
+#                     neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
+#                     if len(scripteffect):
+#                         scriptEffect = record.getDefault('effects.scriptEffect')
+#                         script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile, scriptEffect.full = scripteffect
+#                         scriptEffect.script = shortMapper(script)
+#                         neweffect.scriptEffect = scriptEffect
+#                     record.effects.append(neweffect)
+#                 record.setChanged()
+#         if changed: modFile.safeSave()
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports stats from specified text file."""
+#         fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 12 or fields[1][:2] != '0x': continue
+#             mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,uses,value,weight = fields[:12]
+#             mmod = _coerce(mmod, str)
+#             mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+#             smod = _coerce(smod, str, AllowNone=True)
+#             if smod is None: sid = None
+#             else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
+#             eid = _coerce(eid, str, AllowNone=True)
+#             full = _coerce(full, str, AllowNone=True)
+#             modPath = _coerce(modPath, str, AllowNone=True)
+#             modb = _coerce(modb, float)
+#             iconPath = _coerce(iconPath, str, AllowNone=True)
+#             uses = _coerce(uses, int)
+#             value = _coerce(value, int)
+#             weight = _coerce(weight, float)
+#             effects = []
+#             _effects = fields[12:]
+#             while len(_effects) >= 13:
+#                 _effect, _effects = _effects[1:13], _effects[13:]
+#                 name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+#                 name = _coerce(name, str, AllowNone=True)
+#                 magnitude = _coerce(magnitude, int, AllowNone=True)
+#                 area = _coerce(area, int, AllowNone=True)
+#                 duration = _coerce(duration, int, AllowNone=True)
+#                 range = _coerce(range, str, AllowNone=True)
+#                 if range:
+#                     range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+#                 actorvalue = _coerce(actorvalue, str, AllowNone=True)
+#                 if actorvalue:
+#                     actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+#                 if None in (name,magnitude,area,duration,range,actorvalue):
+#                     continue
+#                 effect = [name,magnitude,area,duration,range,actorvalue]
+#                 semod = _coerce(semod, str, AllowNone=True)
+#                 seobj = _coerce(seobj, int, 16, AllowNone=True)
+#                 seschool = _coerce(seschool, int, AllowNone=True)
+#                 sevisual = _coerce(sevisual, int, AllowNone=True)
+#                 seflags = _coerce(seflags, int, AllowNone=True)
+#                 sename = _coerce(sename, str, AllowNone=True)
+#                 if None in (semod,seobj,seschool,sevisual,seflags,sename):
+#                     effect.append([])
+#                 else:
+#                     sefid = (GPath(aliases.get(semod,semod)),seobj)
+#                     effect.append([sefid, seschool, sevisual,seflags, sename])
+#                 effects.append(effect)
+#             fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, uses, value, weight, effects]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports stats to specified text file."""
+#         fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%d","%f"'
+#         altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%d","%f"'
+#         effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+#         scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
+#         noscriptEffectFiller = ',"None","None","None","None","None","None"'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+#                                 _('Name'),_('Model Path'),_('Bound Radius'),
+#                                 _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
+#                                 _('Uses'),_('Value'),_('Weight'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
+#                                 ),'mbcs'))
+#         for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
+#             eid,name,modpath,modb,iconpath,scriptfid,uses,value,weight,effects = fid_stats[fid]
+#             scriptfid = scriptfid or (GPath('None'), None)
+#             try:
+#                 output = rowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
+#             except TypeError:
+#                 output = altrowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
+#             for effect in effects:
+#                 efname,magnitude,area,duration,range,actorvalue = effect[:-1]
+#                 range = recipientTypeNumber_Name.get(range,range)
+#                 actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+#                 scripteffect = effect[-1]
+#                 output += effectFormat % (efname,magnitude,area,duration,range,actorvalue)
+#                 if len(scripteffect):
+#                     longid,seschool,sevisual,seflags,sename = scripteffect
+#                     if sevisual == '\x00\x00\x00\x00':
+#                         sevisual = ''
+#                     output += scriptEffectFormat % (longid[0].s,longid[1],seschool,sevisual,seflags,sename)
+#                 else:
+#                     output += noscriptEffectFiller
+#             output += '\n'
+#             out.write(output)
+#         out.close()
+# class CBash_SigilStoneDetails:
+#     """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.fid_stats = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.recipientTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'Self',
+#             1 : 'Touch',
+#             2 : 'Target',}
+#         self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+#         self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+#         self.actorValueNumber_Name[None] = 'NONE'
+#         self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         fid_stats = self.fid_stats
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_SigilStoneDetails:readFromMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.SGST:
+#             fid_stats[record.fid] = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, record.effects_list]
+
+#     def writeToMod(self,modInfo):
+#         """Writes stats to specified mod."""
+#         fid_stats = self.fid_stats
+#         changed = []
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_SigilStoneDetails:writeToMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.SGST:
+#             newStats = fid_stats.get(record.fid, None)
+#             if not newStats: continue
+#             oldStats = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, record.effects_list]
+#             if oldStats != newStats:
+#                 changed.append(oldStats[0]) #eid
+#                 record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, effects = newStats
+#                 record.effects_list = effects
+#         if changed: modFile.save()
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports stats from specified text file."""
+#         fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 12 or fields[1][:2] != '0x': continue
+#             mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,uses,value,weight = fields[:12]
+#             mmod = _coerce(mmod, str)
+#             mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+#             smod = _coerce(smod, str, AllowNone=True)
+#             if smod is None: sid = None
+#             else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
+#             eid = _coerce(eid, str, AllowNone=True)
+#             full = _coerce(full, str, AllowNone=True)
+#             modPath = _coerce(modPath, str, AllowNone=True)
+#             modb = _coerce(modb, float)
+#             iconPath = _coerce(iconPath, str, AllowNone=True)
+#             uses = _coerce(uses, int)
+#             value = _coerce(value, int)
+#             weight = _coerce(weight, float)
+#             effects = []
+#             _effects = fields[12:]
+#             while len(_effects) >= 13:
+#                 _effect, _effects = _effects[1:13], _effects[13:]
+#                 name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+#                 name = _coerce(name, str, AllowNone=True)
+#                 name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
+#                 magnitude = _coerce(magnitude, int, AllowNone=True)
+#                 area = _coerce(area, int, AllowNone=True)
+#                 duration = _coerce(duration, int, AllowNone=True)
+#                 range = _coerce(range, str, AllowNone=True)
+#                 if range:
+#                     range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+#                 actorvalue = _coerce(actorvalue, str, AllowNone=True)
+#                 if actorvalue:
+#                     actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+#                 if None in (name,magnitude,area,duration,range,actorvalue):
+#                     continue
+#                 effect = [name,magnitude,area,duration,range,actorvalue]
+#                 semod = _coerce(semod, str, AllowNone=True)
+#                 seobj = _coerce(seobj, int, 16, AllowNone=True)
+#                 seschool = _coerce(seschool, int, AllowNone=True)
+#                 sevisual = _coerce(sevisual, int, AllowNone=True)
+#                 seflags = _coerce(seflags, int, AllowNone=True)
+#                 sename = _coerce(sename, str, AllowNone=True)
+#                 if None in (semod,seobj,seschool,sevisual,seflags,sename):
+#                     effect.extend([None,None,None,None,None])
+#                 else:
+#                     sefid = (GPath(aliases.get(semod,semod)),seobj)
+#                     effect.extend([sefid, seschool, sevisual,seflags, sename])
+#                 effects.append(tuple(effect))
+#             fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, uses, value, weight, effects]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports stats to specified text file."""
+#         fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%d","%f"'
+#         altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%d","%f"'
+#         effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+#         scriptEffectFormat = ',"%s","0x%06X","%d","%d","%d","%s"'
+#         noscriptEffectFiller = ',"None","None","None","None","None","None"'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+#                                 _('Name'),_('Model Path'),_('Bound Radius'),
+#                                 _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
+#                                 _('Uses'),_('Value'),_('Weight'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
+#                                 ),'mbcs'))
+#         for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
+#             eid,name,modpath,modb,iconpath,scriptfid,uses,value,weight,effects = fid_stats[fid]
+#             scriptfid = scriptfid or (GPath('None'), None)
+#             try:
+#                 output = rowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
+#             except TypeError:
+#                 output = altrowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
+#             for effect in effects:
+#                 efname,magnitude,area,duration,range,actorvalue = effect[:6]
+#                 efname = c_ulong(efname)
+#                 efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
+#                 range = recipientTypeNumber_Name.get(range,range)
+#                 actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+#                 scripteffect = effect[6:]
+#                 output += effectFormat % (efname,magnitude,area,duration,range,actorvalue)
+#                 if None not in scripteffect:
+#                     output += scriptEffectFormat % tuple(scripteffect)
+#                 else:
+#                     output += noscriptEffectFiller
+#             output += '\n'
+#             out.write(output)
+#         out.close()
+#------------------------------------------------------------------------------
+class ItemStats:
+    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
+    class_attrs = {
+        'ALCH':('eid', 'weight', 'value'),
+        'AMMO':('eid', 'speed',  'value', 'clipRounds'),
+        'ARMO':('eid', 'weight', 'value', 'health', 'ar'),
+        'ARMA':('eid', 'weight', 'value', 'health', 'ar'),
+        'BOOK':('eid', 'weight', 'value'),
+        'INGR':('eid', 'weight', 'value'),
+        'KEYM':('eid', 'weight', 'value'),
+        'LIGH':('eid', 'weight', 'value', 'duration'),
+        'MISC':('eid', 'weight', 'value'),
+        'WEAP':('eid', 'weight', 'value', 'health', 'damage','clipsize',
+                'animationMultiplier','reach','ammoUse','minSpread','spread','sightFov','baseVatsToHitChance','projectileCount',
+                'minRange','maxRange','animationAttackMultiplier','fireRate','overrideActionPoint','rumbleLeftMotorStrength',
+                'rumbleRightMotorStrength','rumbleDuration','overrideDamageToWeaponMult','attackShotsPerSec',
+                'reloadTime','jamTime','aimArc','rambleWavelangth','limbDmgMult','sightUsage',
+                'semiAutomaticFireDelayMin','semiAutomaticFireDelayMax','criticalDamage','criticalMultiplier'),
+        }
 
-    def readFromMod(self,modInfo):
-        """Imports type_id_name from specified mod."""
-        group_fid_name = self.group_fid_name
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_FullNames:readFromMod"
-            print error[0]
-            return
+    @staticmethod
+    def sstr(value):
+        return _coerce(value, str, AllowNone=True)
 
-        for group in self.types:
-            fid_name = group_fid_name.setdefault(group[:4],{})
-            for record in getattr(modFile,group):
-                if(hasattr(record, 'full')):
-                    full = record.full or (type != 'LIGH' and 'NO NAME')
-                    eid = record.eid
-                    if eid and full:
-                        fid_name[record.fid] = (eid,full)
-                record.UnloadRecord()
-        del Current
+    @staticmethod
+    def sfloat(value):
+        return _coerce(value, float, AllowNone=True)
 
-    def writeToMod(self,modInfo):
-        """Exports type_id_name to specified mod."""
-        group_fid_name = self.group_fid_name
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_FullNames:writeToMod"
-            print error[0]
-            return
+    @staticmethod
+    def sint(value):
+        return _coerce(value, int, AllowNone=True)
 
-        changed = {}
-        for type in self.types:
-            fid_name = group_fid_name.get(type,None)
-            if not fid_name: continue
-            for record in getattr(modFile,type):
-                fid = record.fid
-                full = record.full
-                eid,newFull = fid_name.get(fid,(0,0))
-                if newFull and newFull not in (full,'NO NAME'):
-                    record.full = newFull
-                    changed[eid] = (full,newFull)
-        if changed: modFile.save()
-        del Current
+    @staticmethod
+    def snoneint(value):
+        x = _coerce(value, int, AllowNone=True)
+        if x == 0: return None
+        return x
+
+    def __init__(self,types=None,aliases=None):
+        """Initialize."""
+        self.class_fid_attr_value = {}
+        self.aliases = aliases or {} #--For aliasing mod names
+        self.attr_type = {'eid':self.sstr,
+                          'weight':self.sfloat,
+                          'value':self.sint,
+                          'damage':self.sint,
+                          'speed':self.sfloat,
+                          'enchantPoints':self.snoneint,
+                          'health':self.sint,
+                          'strength':self.sint,
+                          'duration':self.sint,
+                          'quality':self.sfloat,
+                          'uses':self.sint,
+                          'reach':self.sfloat,
+                          'clipRounds':self.sint,
+                          'projPerShot':self.sint,
+                          'ar':self.sint,
+                          'dt':self.sfloat,
+                          'clipsize':self.sint,
+                          'animationMultiplier':self.sfloat,
+                          'reach':self.sfloat,
+                          'ammoUse':self.sint,
+                          'minSpread':self.sfloat,
+                          'spread':self.sfloat,
+                          'sightFov':self.sfloat,
+                          'baseVatsToHitChance':self.sint,
+                          'projectileCount':self.sint,
+                          'minRange':self.sfloat,
+                          'maxRange':self.sfloat,
+                          'animationAttackMultiplier':self.sfloat,
+                          'fireRate':self.sfloat,
+                          'overrideActionPoint':self.sfloat,
+                          'rumbleLeftMotorStrength':self.sfloat,
+                          'rumbleRightMotorStrength':self.sfloat,
+                          'rumbleDuration':self.sfloat,
+                          'overrideDamageToWeaponMult':self.sfloat,
+                          'attackShotsPerSec':self.sfloat,
+                          'reloadTime':self.sfloat,
+                          'jamTime':self.sfloat,
+                          'aimArc':self.sfloat,
+                          'rambleWavelangth':self.sfloat,
+                          'limbDmgMult':self.sfloat,
+                          'sightUsage':self.sfloat,
+                          'semiAutomaticFireDelayMin':self.sfloat,
+                          'semiAutomaticFireDelayMax':self.sfloat,
+                          'strengthReq':self.sint,
+                          'regenRate':self.sfloat,
+                          'killImpulse':self.sfloat,
+                          'impulseDist':self.sfloat,
+                          'skillReq':self.sint,
+                          'criticalDamage':self.sint,
+                          'criticalMultiplier':self.sfloat,
+                          'vatsSkill':self.sfloat,
+                          'vatsDamMult':self.sfloat,
+                          'vatsAp':self.sfloat,}
+
+        for group in self.class_attrs:
+            self.class_fid_attr_value[group] = {}
+
+    def readFromMod(self,modInfo):
+        """Reads stats from specified mod."""
+        class_fid_attr_value = self.class_fid_attr_value
+        loadFactory= LoadFactory(False,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        mapper = modFile.getLongMapper()
+        for group, attrs in self.class_attrs.iteritems():
+            for record in getattr(modFile,group).getActiveRecords():
+                class_fid_attr_value[group].setdefault(mapper(record.fid), {}).update(zip(attrs,map(record.__getattribute__,attrs)))
+
+    def writeToMod(self,modInfo):
+        """Writes stats to specified mod."""
+        class_fid_attr_value = self.class_fid_attr_value
+        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        mapper = modFile.getLongMapper()
+        changed = {} #--changed[modName] = numChanged
+        for group, fid_attr_value in class_fid_attr_value.iteritems():
+            attrs = self.class_attrs[group]
+            for record in getattr(modFile,group).getActiveRecords():
+                longid = mapper(record.fid)
+                itemStats = fid_attr_value.get(longid,None)
+                if not itemStats: continue
+                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
+                if oldValues != itemStats:
+                    for attr, value in itemStats.iteritems():
+                        setattr(record,attr,value)
+                    record.setChanged()
+                    changed[longid[0]] = 1 + changed.get(longid[0],0)
+        if changed: modFile.safeSave()
         return changed
 
     def readFromText(self,textPath):
-        """Imports type_id_name from specified text file."""
-        textPath = GPath(textPath)
-        group_fid_name = self.group_fid_name
+        """Reads stats from specified text file."""
+        class_fid_attr_value = self.class_fid_attr_value
         aliases = self.aliases
         ins = bolt.CsvReader(textPath)
+        attr_type = self.attr_type
         for fields in ins:
-            if len(fields) < 5 or fields[2][:2] != '0x': continue
-            group,mod,objectIndex,eid,full = fields[:5]
-            group = _coerce(group, str)
-            mod = GPath(_coerce(mod, str))
-            longid = (aliases.get(mod,mod),_coerce(objectIndex[2:],int,16))
-            eid = _coerce(eid, str, AllowNone=True)
-            full = _coerce(full, str, AllowNone=True)
-            group_fid_name.setdefault(group, {})[longid] = (eid,full)
+            if len(fields) < 3 or fields[2][:2] != '0x': continue
+            group,modName,objectStr = fields[0:3]
+            modName = GPath(_coerce(modName,str))
+            longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
+            attrs = self.class_attrs[group]
+            attr_value = {}
+            for attr, value in zip(attrs, fields[3:3+len(attrs)]):
+                attr_value[attr] = attr_type[attr](value)
+            class_fid_attr_value[group].setdefault(longid, {}).update(attr_value)
         ins.close()
 
     def writeToText(self,textPath):
-        """Exports type_id_name to specified text file."""
-        textPath = GPath(textPath)
-        group_fid_name = self.group_fid_name
-        headFormat = '"%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","%s","0x%06X","%s","%s"\n'
+        """Writes stats to specified text file."""
+        class_fid_attr_value = self.class_fid_attr_value
         out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name')), 'mbcs'))
-        for group in sorted(group_fid_name):
-            fid_name = group_fid_name[group]
-            longids = fid_name.keys()
-            longids.sort(key=lambda a: fid_name[a][0])
+        def getSortedIds(fid_attr_value):
+            longids = fid_attr_value.keys()
+            longids.sort(key=lambda a: fid_attr_value[a]['eid'])
             longids.sort(key=itemgetter(0))
-            for longid in longids:
-                eid,name = fid_name[longid]
-                out.write(rowFormat % (group,Encode(longid[0].s,'mbcs'),longid[1],eid,name.replace('"', '""')))
+            return longids
+        def write(out, attrs, values):
+            attr_type = self.attr_type
+            csvFormat = ''
+            sstr = self.sstr
+            sint = self.sint
+            snoneint = self.snoneint
+            sfloat = self.sfloat
+            for index, attr in enumerate(attrs):
+                stype = attr_type[attr]
+                values[index] = stype(values[index]) #sanitize output
+                if values[index] is None: csvFormat += ',"{0[%d]}"' % index
+                elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
+                elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
+                elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
+            csvFormat = csvFormat[1:] #--Chop leading comma
+            out.write(csvFormat.format(values) + '\n')
+        for group,header in (
+            #--Alch
+            ('ALCH',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+            #Ammo
+            ('AMMO',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Speed'),_('Value'),_('Clip Rounds'))) + '"\n')),
+            #--Armor
+            ('ARMO',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
+            #--Armor Addon
+            ('ARMA',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
+            #Books
+            ('BOOK',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+            #Ingredients
+            ('INGR',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+            #--Keys
+            ('KEYM',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+            #Lights
+            ('LIGH',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
+            #--Misc
+            ('MISC',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+            #--Weapons
+            ('WEAP',
+                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),_('Clip Size'),
+                _('Animation Multiplier'), _('Reach'), _('Ammo Use'), _('Min Spread'), _('Spread'), _('Sight Fov'), _('Base VATS To-Hit Chance'), _('Projectile Count'),
+                _('Min Range'), _('Max Range'), _('Animation Attack Multiplier'), _('Fire Rate'), _('Override - Action Point'), _('Rumble - Left Motor Strength'),
+                _('rRmble - Right Motor Strength'), _('Rumble - Duration'), _('Override - Damage To Weapon Mult'), _('Attack Shots/Sec'),
+                _('Reload Time'), _('Jam Time'), _('Aim Arc'), _('Ramble - Wavelangth'), _('Limb Dmg Mult'), _('Sight Usage'),
+                _('Semi-Automatic Fire Delay Min'), _('Semi-Automatic Fire Delay Max'),
+                _('Critical Damage'), _('Crit % Mult'))) + '"\n')),
+            ):
+            fid_attr_value = class_fid_attr_value[group]
+            if not fid_attr_value: continue
+            attrs = self.class_attrs[group]
+            out.write(Encode(header,'mbcs'))
+            for longid in getSortedIds(fid_attr_value):
+                out.write('"%s","%s","0x%06X",' % (group,Encode(longid[0].s,'mbcs'),longid[1]))
+                attr_value = fid_attr_value[longid]
+                write(out, attrs, map(attr_value.get, attrs))
         out.close()
 
+# class CBash_ItemStats:
+#     """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
+#     class_attrs = {
+#         'ALCH':('eid', 'weight', 'value'),
+#         'AMMO':('eid', 'weight', 'value', 'damage', 'speed', 'enchantPoints'),
+#         'APPA':('eid', 'weight', 'value', 'quality'),
+#         'ARMO':('eid', 'weight', 'value', 'health', 'strength'),
+#         'BOOK':('eid', 'weight', 'value', 'enchantPoints'),
+#         'CLOT':('eid', 'weight', 'value', 'enchantPoints'),
+#         'INGR':('eid', 'weight', 'value'),
+#         'KEYM':('eid', 'weight', 'value'),
+#         'LIGH':('eid', 'weight', 'value', 'duration'),
+#         'MISC':('eid', 'weight', 'value'),
+#         'SGST':('eid', 'weight', 'value', 'uses'),
+#         'SLGM':('eid', 'weight', 'value'),
+#         'WEAP':('eid', 'weight', 'value', 'health', 'damage', 'speed', 'reach', 'enchantPoints'),
+#         }
+
+#     @staticmethod
+#     def sstr(value):
+#         return _coerce(value, str, AllowNone=True)
+
+#     @staticmethod
+#     def sfloat(value):
+#         return _coerce(value, float, AllowNone=True)
+
+#     @staticmethod
+#     def sint(value):
+#         return _coerce(value, int, AllowNone=True)
+
+#     @staticmethod
+#     def snoneint(value):
+#         x = _coerce(value, int, AllowNone=True)
+#         if x == 0: return None
+#         return x
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.class_fid_attr_value = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.attr_type = {'eid':self.sstr,
+#                           'weight':self.sfloat,
+#                           'value':self.sint,
+#                           'damage':self.sint,
+#                           'speed':self.sfloat,
+#                           'enchantPoints':self.snoneint,
+#                           'health':self.sint,
+#                           'strength':self.sint,
+#                           'duration':self.sint,
+#                           'quality':self.sfloat,
+#                           'uses':self.sint,
+#                           'reach':self.sfloat,}
+
+#         for group in self.class_attrs:
+#             self.class_fid_attr_value[group] = {}
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ItemStats:readFromMod"
+#             print error[0]
+#             return
+
+#         for group, attrs in self.class_attrs.iteritems():
+#             for record in getattr(modFile,group):
+#                 class_fid_attr_value[group].setdefault(record.fid, {}).update(zip(attrs,map(record.__getattribute__,attrs)))
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports type_id_name to specified mod."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ItemStats:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = {} #--changed[modName] = numChanged
+#         for group, fid_attr_value in class_fid_attr_value.iteritems():
+#             attrs = self.class_attrs[group]
+#             for fid, attr_value in fid_attr_value.iteritems():
+#                 record = modFile.LookupRecord(fid)
+#                 if record and record._Type == group:
+#                     oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
+#                     if oldValues != attr_value:
+#                         for attr, value in attr_value.iteritems():
+#                             setattr(record,attr,value)
+#                         changed[fid[0]] = 1 + changed.get(fid[0],0)
+#         if changed: modFile.save()
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Reads stats from specified text file."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         aliases = self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         attr_type = self.attr_type
+#         for fields in ins:
+#             if len(fields) < 3 or fields[2][:2] != '0x': continue
+#             group,modName,objectStr = fields[0:3]
+#             modName = GPath(_coerce(modName,str))
+#             longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
+#             attrs = self.class_attrs[group]
+#             attr_value = {}
+#             for attr, value in zip(attrs, fields[3:3+len(attrs)]):
+#                 attr_value[attr] = attr_type[attr](value)
+#             class_fid_attr_value[group].setdefault(longid, {}).update(attr_value)
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Writes stats to specified text file."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         out = textPath.open('w')
+#         def getSortedIds(fid_attr_value):
+#             longids = fid_attr_value.keys()
+#             longids.sort(key=lambda a: fid_attr_value[a]['eid'])
+#             longids.sort(key=itemgetter(0))
+#             return longids
+#         def write(out, attrs, values):
+#             attr_type = self.attr_type
+#             csvFormat = ''
+#             sstr = self.sstr
+#             sint = self.sint
+#             snoneint = self.snoneint
+#             sfloat = self.sfloat
+#             for index, attr in enumerate(attrs):
+#                 stype = attr_type[attr]
+#                 values[index] = stype(values[index]) #sanitize output
+#                 if values[index] is None: csvFormat += ',"{0[%d]}"' % index
+#                 elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
+#                 elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
+#                 elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
+#             csvFormat = csvFormat[1:] #--Chop leading comma
+#             out.write(csvFormat.format(values) + '\n')
+#         for group,header in (
+#             #--Alch
+#             ('ALCH',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Ammo
+#             ('AMMO',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'))) + '"\n')),
+#             #--Apparatus
+#             ('APPA',
+#                 ('"' + '","'.join((_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Quality'))) + '"\n')),
+#             #--Armor
+#             ('ARMO',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
+#             #Books
+#             ('BOOK',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
+#             #Clothing
+#             ('CLOT',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
+#             #Ingredients
+#             ('INGR',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #--Keys
+#             ('KEYM',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Lights
+#             ('LIGH',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
+#             #--Misc
+#             ('MISC',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Sigilstones
+#             ('SGST',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Uses'))) + '"\n')),
+#             #Soulgems
+#             ('SLGM',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #--Weapons
+#             ('WEAP',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),
+#                 _('Speed'),_('Reach'),_('EPoints'))) + '"\n')),
+#             ):
+#             fid_attr_value = class_fid_attr_value[group]
+#             if not fid_attr_value: continue
+#             attrs = self.class_attrs[group]
+#             out.write(Encode(header,'mbcs'))
+#             for longid in getSortedIds(fid_attr_value):
+#                 out.write('"%s","%s","0x%06X",' % (group,Encode(longid[0].s,'mbcs'),longid[1]))
+#                 attr_value = fid_attr_value[longid]
+#                 write(out, attrs, map(attr_value.get, attrs))
+#         out.close()
 #------------------------------------------------------------------------------
-class CBash_MapMarkers:
-    """Map marker references, with functions for importing/exporting from/to mod/text file."""
+class ItemPrices:
+    """Function for importing/exporting from/to mod/text file only the value, name and eid of records."""
 
     def __init__(self,types=None,aliases=None):
         """Initialize."""
-        self.fid_markerdata = {}
-        self.aliases = aliases or {}
-        self.markerFid = (GPath('Oblivion.esm'), 0x000010)
-        self.attrs = ['eid','markerName','markerType','IsVisible','IsCanTravelTo','posX','posY','posZ','rotX','rotY','rotZ']
-        self.markerTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'NONE',
-            1 : 'Camp',
-            2 : 'Cave',
-            3 : 'City',
-            4 : 'Elven Ruin',
-            5 : 'Fort Ruin',
-            6 : 'Mine',
-            7 : 'Landmark',
-            8 : 'Tavern',
-            9 : 'Settlement',
-            10 : 'Daedric Shrine',
-            11 : 'Oblivion Gate',
-            12 : '?',
-            13 : 'Ayleid Well',
-            14 : 'Wayshrine',
-            15 : 'Magical Stone',
-            16 : 'Spire',
-            17 : 'Obelisk of Order',
-            18 : 'House',
-            19 : 'Player marker (flag)',
-            20 : 'Player marker (Q flag)',
-            21 : 'Player marker (i flag)',
-            22 : 'Player marker (? flag)',
-            23 : 'Harbor/dock',
-            24 : 'Stable',
-            25 : 'Castle',
-            26 : 'Farm',
-            27 : 'Chapel',
-            28 : 'Merchant',
-            29 : 'Ayleid Step (old Ayleid ruin icon)',}
-        self.markerTypeName_Number = dict([(y.lower(),x) for x,y in self.markerTypeNumber_Name.iteritems() if x is not None])
+        self.class_fid_stats = {'ALCH':{},'AMMO':{},'ARMO':{},'ARMA':{},'BOOK':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'WEAP':{}}
+        self.attrs = ('value', 'eid', 'full')
+        self.aliases = aliases or {} #--For aliasing mod names
 
     def readFromMod(self,modInfo):
-        """Imports type_id_name from specified mod."""
-        fid_markerdata,markerFid,attrs = self.fid_markerdata,self.markerFid,self.attrs
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_MapMarkers:readFromMod"
-            print error[0]
-            return
-
-        for record in modFile.REFRS:
-            if record.base == markerFid:
-                fid_markerdata[record.fid] = [getattr(record, attr) for attr in attrs]
-            record.UnloadRecord()
-
-        del Current
+        """Reads data from specified mod."""
+        class_fid_stats, attrs = self.class_fid_stats, self.attrs
+        loadFactory= LoadFactory(False,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        mapper = modFile.getLongMapper()
+        attrs = self.attrs
+        for group, fid_stats in class_fid_stats.iteritems():
+            for record in getattr(modFile,group).getActiveRecords():
+                fid_stats[mapper(record.fid)] = map(record.__getattribute__,attrs)
 
     def writeToMod(self,modInfo):
-        """Imports type_id_name to specified mod."""
-        fid_markerdata,markerFid,attrs = self.fid_markerdata,self.markerFid,self.attrs
-        changed = []
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_MapMarkers:writeToMod"
-            print error[0]
-            return
+        """Writes stats to specified mod."""
+        class_fid_stats, attrs = self.class_fid_stats, self.attrs
+        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        mapper = modFile.getLongMapper()
 
-        for record in modFile.REFRS:
-            fid = record.fid
-            if not fid in fid_markerdata: continue
-            if record.base == markerFid:
-                oldValues = [getattr(record, attr) for attr in attrs]
-                newValues = fid_markerdata[fid]
-                if oldValues != newValues:
-                    changed.append(oldValues[0]) #eid
-                    for attr, value in zip(attrs, newValues):
-                        setattr(record, attr, value)
-
-        if changed: modFile.save()
-        del Current
+        changed = {} #--changed[modName] = numChanged
+        for group, fid_stats in class_fid_stats.iteritems():
+            for record in getattr(modFile,group).getActiveRecords():
+                longid = mapper(record.fid)
+                stats = fid_stats.get(longid,None)
+                if not stats: continue
+                value = stats[0]
+                if record.value != value:
+                    record.value = value
+                    changed[longid[0]] = changed.get(longid[0],0) + 1
+                    record.setChanged()
+        if changed: modFile.safeSave()
         return changed
 
+
     def readFromText(self,textPath):
-        """Imports type_id_name from specified text file."""
-        fid_markerdata,aliases,markerTypeName_Number = self.fid_markerdata,self.aliases,self.markerTypeName_Number
-        ins = bolt.CsvReader(GPath(textPath))
+        """Reads stats from specified text file."""
+        class_fid_stats, aliases = self.class_fid_stats, self.aliases
+        ins = bolt.CsvReader(textPath)
         for fields in ins:
-            if len(fields) < 13 or fields[1][:2] != '0x': continue
-            mod,objectIndex,eid,markerName,_markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ = fields[:13]
-            mod = GPath(_coerce(mod, str))
-            longid = (aliases.get(mod,mod),_coerce(objectIndex, int, 16))
+            if len(fields) < 6 or not fields[1].startswith('0x'): continue
+            mmod,mobj,value,eid,name,group = fields[:6]
+            mmod = GPath(_coerce(mmod, str))
+            longid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj, int, 16))
+            value = _coerce(value, int)
             eid = _coerce(eid, str, AllowNone=True)
-            markerName = _coerce(markerName, str, AllowNone=True)
-            markerType = _coerce(_markerType, int)
-            if markerType is None: #coercion failed
-                markerType = markerTypeName_Number.get(_markerType.lower(), 0)
-            IsVisible = _coerce(IsVisible, bool)
-            IsCanTravelTo = _coerce(IsCanTravelTo, bool)
-            posX = _coerce(posX, float)
-            posY = _coerce(posY, float)
-            posZ = _coerce(posZ, float)
-            rotX = _coerce(rotX, float)
-            rotY = _coerce(rotY, float)
-            rotZ = _coerce(rotZ, float)
-            fid_markerdata[longid] = [eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ]
+            name = _coerce(name, str, AllowNone=True)
+            group = _coerce(group, str)
+            class_fid_stats[group][longid] = [value,eid,name]
         ins.close()
 
     def writeToText(self,textPath):
-        """Exports markers to specified text file."""
-        fid_markerdata,markerTypeNumber_Name = self.fid_markerdata,self.markerTypeNumber_Name
-        textPath = GPath(textPath)
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","0x%06X","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+        """Writes stats to specified text file."""
+        class_fid_stats, attrs = self.class_fid_stats, self.attrs
         out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),_('Name'),_('Type'),_('IsVisible'),_('IsCanTravelTo'),_('posX'),_('posY'),_('posZ'),_('rotX'),_('rotY'),_('rotZ')),'mbcs'))
-        longids = fid_markerdata.keys()
-        longids.sort(key=lambda a: fid_markerdata[a][0])
-        longids.sort(key=itemgetter(0))
-        for longid in longids:
-            eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ = fid_markerdata[longid]
-            markerType = markerTypeNumber_Name.get(markerType,markerType)
-            out.write(rowFormat % (longid[0].s,longid[1],eid,markerName,markerType,IsVisible,IsCanTravelTo,posX,posY,posZ,rotX,rotY,rotZ))
+        def getSortedIds(stats):
+            longids = stats.keys()
+            longids.sort(key=lambda a: stats[a][0])
+            longids.sort(key=itemgetter(0))
+            return longids
+        format,header = bolt.csvFormat('iss'),('"' + '","'.join((_('Mod Name'),_('ObjectIndex'), _('Value'),_('Editor Id'),_('Name'),_('Type'))) + '"\n')
+        for group, fid_stats in sorted(class_fid_stats.iteritems()):
+            if not fid_stats: continue
+            out.write(Encode(header,'mbcs'))
+            for fid in sorted(fid_stats,key=lambda x: (fid_stats[x][1],fid_stats[x][0])):
+                out.write(Encode('"%s","0x%06X",' % (fid[0].s,fid[1]),'mbcs'))
+                out.write(format % tuple(fid_stats[fid]) + ',%s\n' % group)
         out.close()
-
+# class CBash_ItemPrices:
+#     """Function for importing/exporting from/to mod/text file only the value, name and eid of records."""
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.class_fid_stats = {'ALCH':{},'AMMO':{},'APPA':{},'ARMO':{},'BOOK':{},'CLOT':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'SGST':{},'SLGM':{},'WEAP':{}}
+#         self.attrs = ('value', 'eid', 'full')
+#         self.aliases = aliases or {} #--For aliasing mod names
+
+#     def readFromMod(self,modInfo):
+#         """Reads data from specified mod."""
+#         class_fid_stats, attrs = self.class_fid_stats, self.attrs
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ItemPrices:readFromMod"
+#             print error[0]
+#             return
+
+#         for group, fid_stats in class_fid_stats.iteritems():
+#             for record in getattr(modFile,group):
+#                 fid_stats[record.fid] = map(record.__getattribute__,attrs)
+#                 record.UnloadRecord()
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Writes stats to specified mod."""
+#         class_fid_stats, attrs = self.class_fid_stats, self.attrs
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ItemPrices:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = {} #--changed[modName] = numChanged
+#         for group, fid_stats in class_fid_stats.iteritems():
+#             for fid, stats in fid_stats.iteritems():
+#                 record = modFile.LookupRecord(fid)
+#                 if record and record._Type == group:
+#                     value = stats[0]
+#                     if record.value != value:
+#                         record.value = value
+#                         changed[fid[0]] = changed.get(fid[0],0) + 1
+#         if changed: modFile.save()
+#         del Current
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Reads stats from specified text file."""
+#         class_fid_stats, aliases = self.class_fid_stats, self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 6 or not fields[1].startswith('0x'): continue
+#             mmod,mobj,value,eid,name,group = fields[:6]
+#             mmod = GPath(_coerce(mmod, str))
+#             longid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj, int, 16))
+#             value = _coerce(value, int)
+#             eid = _coerce(eid, str, AllowNone=True)
+#             name = _coerce(name, str, AllowNone=True)
+#             group = _coerce(group, str)
+#             class_fid_stats[group][longid] = [value,eid,name]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Writes stats to specified text file."""
+#         class_fid_stats, attrs = self.class_fid_stats, self.attrs
+#         out = textPath.open('w')
+#         def getSortedIds(stats):
+#             longids = stats.keys()
+#             longids.sort(key=lambda a: stats[a][0])
+#             longids.sort(key=itemgetter(0))
+#             return longids
+#         format,header = bolt.csvFormat('iss'),('"' + '","'.join((_('Mod Name'),_('ObjectIndex'), _('Value'),_('Editor Id'),_('Name'),_('Type'))) + '"\n')
+#         for group, fid_stats in sorted(class_fid_stats.iteritems()):
+#             if not fid_stats: continue
+#             out.write(Encode(header,'mbcs'))
+#             for fid in sorted(fid_stats,key=lambda x: (fid_stats[x][1],fid_stats[x][0])):
+#                 out.write(Encode('"%s","0x%06X",' % (fid[0].s,fid[1]),'mbcs'))
+#                 out.write(format % tuple(fid_stats[fid]) + ',%s\n' % group)
+#         out.close()
 #------------------------------------------------------------------------------
-class CBash_CellBlockInfo:
-    """Map marker references, with functions for importing/exporting from/to mod/text file."""
+class CompleteItemData:
+    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
 
     def __init__(self,types=None,aliases=None):
         """Initialize."""
-        self.celldata = {}
-        self.aliases = aliases or {}
-
-    def readFromMod(self,modInfo):
-        """Imports type_id_name from specified mod."""
-        celldata = self.celldata
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_CellBlockInfo:readFromMod"
-            print error[0]
-            return
-
-        for record in modFile.CELLS:
-            celldata[record.eid] = record.bsb
-            record.UnloadRecord()
-            
-        del Current
-
-    def writeToText(self,textPath):
-        """Exports markers to specified text file."""
-        celldata = self.celldata
-        textPath = GPath(textPath)
-        headFormat = '"%s","%s","%s",\n'
-        rowFormat  = '"%s","%s","%s",\n'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Editor Id'),_('Block'),_('Sub-Block')),'mbcs'))
-        eids = celldata.keys()
-        eids.sort()
-        for eid in eids:
-            block, subblock = celldata[eid]
-            out.write(rowFormat % (eid, block, subblock))
-        out.close()
-
-#------------------------------------------------------------------------------
-class SigilStoneDetails:
-    """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.fid_stats = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+        self.type_stats = {'ALCH':{},'AMMO':{},'ARMO':{},'ARMA':{},'BOOK':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'WEAP':{}}
+        self.type_attrs = {
+            'ALCH':('eid', 'full', 'weight', 'value', 'largeIconPath', 'smallIconPath'),
+            'AMMO':('eid', 'full', 'speed',  'value', 'clipRounds', 'largeIconPath', 'smallIconPath'),
+            'ARMO':('eid', 'full', 'weight', 'value', 'health', 'ar', 'maleLargeIconPath', 'maleSmallIconPath', 'femaleLargeIconPath', 'femaleSmallIconPath'),
+            'ARMA':('eid', 'full', 'weight', 'value', 'health', 'ar', 'maleLargeIconPath', 'maleSmallIconPath', 'femaleLargeIconPath', 'femaleSmallIconPath'),
+            'BOOK':('eid', 'full', 'weight', 'value', 'largeIconPath', 'smallIconPath'),
+            'INGR':('eid', 'full', 'weight', 'value', 'iconPath'),
+            'KEYM':('eid', 'full', 'weight', 'value', 'largeIconPath', 'smallIconPath'),
+            'LIGH':('eid', 'full', 'weight', 'value', 'duration','iconPath'),
+            'MISC':('eid', 'full', 'weight', 'value', 'largeIconPath', 'smallIconPath'),
+            'WEAP':('eid', 'full', 'weight', 'value', 'health', 'damage','clipsize',
+                    'animationMultiplier','reach','ammoUse','minSpread','spread','sightFov','baseVatsToHitChance','projectileCount',
+                    'minRange','maxRange','animationAttackMultiplier','fireRate','overrideActionPoint','rumbleLeftMotorStrength',
+                    'rumbleRightMotorStrength','rumbleDuration','overrideDamageToWeaponMult','attackShotsPerSec',
+                    'reloadTime','jamTime','aimArc','rambleWavelangth','limbDmgMult','sightUsage',
+                    'semiAutomaticFireDelayMin','semiAutomaticFireDelayMax','criticalDamage','criticalMultiplier',
+                    'largeIconPath', 'smallIconPath'),
+            }
+        self.aliases = aliases or {} #--For aliasing mod fulls
 
     def readFromMod(self,modInfo):
         """Reads stats from specified mod."""
-        fid_stats = self.fid_stats
-        loadFactory= LoadFactory(False,MreSgst)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        modFile.convertToLongFids(['SGST'])
-        for record in modFile.SGST.getActiveRecords():
-            effects = []
-            for effect in record.effects:
-                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                if effect.scriptEffect:
-                    effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
-                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                else: effectlist.append([])
-                effects.append(effectlist)
-            fid_stats[record.fid] = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, record.script, record.uses, record.value, round(record.weight,6), effects]
+        ###Remove from Bash after CBash integrated
+        if not CBash: #very lame though
+            self.model = {}
+            self.Mmodel = {}
+            self.Fmodel = {}
+            self.MGndmodel = {}
+            self.FGndmodel = {}
+            self.ShellCasingmodel = {}
+            self.Scopemodel = {}
+            self.Gndmodel = {}
+            loadFactory= LoadFactory(False,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
+            modFile = ModFile(modInfo,loadFactory)
+            modFile.load(True)
+            mapper = modFile.getLongMapper()
+            for type in self.type_stats:
+                stats, attrs = self.type_stats[type], self.type_attrs[type]
+                for record in getattr(modFile,type).getActiveRecords():
+                    longid = mapper(record.fid)
+                    recordGetAttr = record.__getattribute__
+                    stats[longid] = tuple(recordGetAttr(attr) for attr in attrs)
+                    if type in ['ALCH','AMMO','BOOK','INGR','KEYM','LIGH','MISC']:
+                        if record.model:
+                            self.model[longid] = record.model.modPath
+                    elif type in ['WEAP',]:
+                        if record.model:
+                            self.model[longid] = record.model.modPath
+                        if record.shellCasingModel:
+                            self.ShellCasingmodel[longid] = record.shellCasingModel.modPath
+                        if record.scopeModel:
+                            self.Scopemodel[longid] = record.scopeModel.modPath
+                        if record.worldModel:
+                            self.Gndmodel[longid] = record.worldModel.modPath
+                    elif type in ['ARMO','ARMA']:
+                        if record.maleBody:
+                            self.Mmodel[longid] = record.maleBody.modPath
+                        if record.maleWorld:
+                            self.MGndmodel[longid] = record.maleWorld.modPath
+                        if record.femaleBody:
+                            self.Fmodel[longid] = record.femaleBody.modPath
+                        if record.femaleWorld:
+                            self.FGndmodel[longid] = record.femaleWorld.modPath
+        else:
+            Current = ObCollection(ModsPath=dirs['mods'].s)
+            Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+            Current.load()
+            try:
+                modFile = Current.LookupModFile(modInfo.getPath().stail)
+            except KeyError, error:
+                print "CompleteItemData:readFromMod"
+                print error[0]
+                return
+
+            for type,stats in self.type_stats.iteritems():
+                if type in ['KEYM',]:
+                    for record in getattr(modFile,type):
+                        longid = record.fid
+                        stats[longid] = record.Export()
+                if type not in ['ALCH',]: continue
+                attrs = self.type_attrs[type]
+                for record in getattr(modFile,type):
+                    longid = record.fid
+                    stats[longid] = tuple(getattr(record,attr) for attr in attrs)
 
     def writeToMod(self,modInfo):
         """Writes stats to specified mod."""
-        fid_stats = self.fid_stats
-        loadFactory= LoadFactory(True,MreSgst)
+        ###Remove from Bash after CBash integrated
+##        if(CBash == None):
+        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreArmo,MreArma,MreBook,MreIngr,MreKeym,MreLigh,MreMisc,MreWeap)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
         mapper = modFile.getLongMapper()
-        shortMapper = modFile.getShortMapper()
-        changed = [] #eids
-        for record in modFile.SGST.getActiveRecords():
-            newStats = fid_stats.get(mapper(record.fid), None)
-            if not newStats: continue
-            effects = []
-            for effect in record.effects:
-                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                if effect.scriptEffect:
-                    effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
-                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                else: effectlist.append([])
-                effects.append(effectlist)
-            oldStats = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, mapper(record.script), record.uses, record.value, round(record.weight,6), effects]
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                record.eid, record.full, record.model.modPath, record.model.modb, record.iconPath, script, record.uses, record.value, record.weight, effects = newStats
-                record.script = shortMapper(script)
-                record.effects = []
-                for effect in effects:
-                    neweffect = record.getDefault('effects')
-                    neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
-                    if len(scripteffect):
-                        scriptEffect = record.getDefault('effects.scriptEffect')
-                        script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile, scriptEffect.full = scripteffect
-                        scriptEffect.script = shortMapper(script)
-                        neweffect.scriptEffect = scriptEffect
-                    record.effects.append(neweffect)
+        changed = {} #--changed[modName] = numChanged
+        for type in self.type_stats:
+            stats, attrs = self.type_stats[type], self.type_attrs[type]
+            for record in getattr(modFile,type).getActiveRecords():
+                longid = mapper(record.fid)
+                itemStats = stats.get(longid,None)
+                if not itemStats: continue
+                map(record.__setattr__,attrs,itemStats)
                 record.setChanged()
+                changed[longid[0]] = 1 + changed.get(longid[0],0)
         if changed: modFile.safeSave()
         return changed
+##        else:
+##            Current = ObCollection(ModsPath=dirs['mods'].s)
+##            modFile = Current.addMod(modInfo.getPath().stail)
+##            Current.minimalLoad(LoadMasters=False)
+##
+##            changed = {} #--changed[modName] = numChanged
+##            for type,stats in self.type_stats.iteritems():
+##                attrs = self.type_attrs[type]
+##                for record in getattr(modFile,type):
+##                    longid = record.fid
+##                    itemStats = stats.get(longid,None)
+##                    if not itemStats: continue
+##                    for attr,stat in attrs,itemStats:
+##                        if(stat != "NONE"):
+##                            setattr(record,attr,stat)
+##                    changed[longid[0]] = 1 + changed.get(longid[0],0)
+##            if changed: modFile.save()
+##            return changed
 
     def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
+        """Reads stats from specified text file."""
+        alch, ammo, armor, armoraddon, books, ingredients, keys, lights, misc, weapons = [self.type_stats[type] for type in ('ALCH','AMMO','ARMO','ARMA','BOOK','INGR','KEYM','LIGH','MISC','WEAP')]
+        aliases = self.aliases
         ins = bolt.CsvReader(textPath)
+        pack,unpack = struct.pack,struct.unpack
+        sfloat = lambda a: unpack('f',pack('f',float(a)))[0] #--Force standard precision
         for fields in ins:
-            if len(fields) < 12 or fields[1][:2] != '0x': continue
-            mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,uses,value,weight = fields[:12]
-            mmod = _coerce(mmod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-            smod = _coerce(smod, str, AllowNone=True)
-            if smod is None: sid = None
-            else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
-            eid = _coerce(eid, str, AllowNone=True)
-            full = _coerce(full, str, AllowNone=True)
-            modPath = _coerce(modPath, str, AllowNone=True)
-            modb = _coerce(modb, float)
-            iconPath = _coerce(iconPath, str, AllowNone=True)
-            uses = _coerce(uses, int)
-            value = _coerce(value, int)
-            weight = _coerce(weight, float)
-            effects = []
-            _effects = fields[12:]
-            while len(_effects) >= 13:
-                _effect, _effects = _effects[1:13], _effects[13:]
-                name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                name = _coerce(name, str, AllowNone=True)
-                magnitude = _coerce(magnitude, int, AllowNone=True)
-                area = _coerce(area, int, AllowNone=True)
-                duration = _coerce(duration, int, AllowNone=True)
-                range = _coerce(range, str, AllowNone=True)
-                if range:
-                    range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                if actorvalue:
-                    actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                if None in (name,magnitude,area,duration,range,actorvalue):
-                    continue
-                effect = [name,magnitude,area,duration,range,actorvalue]
-                semod = _coerce(semod, str, AllowNone=True)
-                seobj = _coerce(seobj, int, 16, AllowNone=True)
-                seschool = _coerce(seschool, int, AllowNone=True)
-                sevisual = _coerce(sevisual, int, AllowNone=True)
-                seflags = _coerce(seflags, int, AllowNone=True)
-                sename = _coerce(sename, str, AllowNone=True)
-                if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                    effect.append([])
-                else:
-                    sefid = (GPath(aliases.get(semod,semod)),seobj)
-                    effect.append([sefid, seschool, sevisual,seflags, sename])
-                effects.append(effect)
-            fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, uses, value, weight, effects]
+            if len(fields) < 3 or fields[2][:2] != '0x': continue
+            type,modName,objectStr,eid = fields[0:4]
+            modName = GPath(modName)
+            longid = (GPath(aliases.get(modName,modName)),int(objectStr[2:],16))
+            if type == 'ALCH':
+                alch[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value)
+                    zip((str,sfloat,int,str,str),fields[4:9]))
+            elif type == 'AMMO':
+                ammo[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(speed, value, clipRounds)
+                    zip((str,sfloat,int,int,str,str),fields[4:10]))
+            elif type == 'ARMO':
+                armor[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value, health, ar)
+                    zip((str,sfloat,int,int,int,str,str,str,str),fields[4:13]))
+            elif type == 'ARMA':
+                armoraddon[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value, health, ar)
+                    zip((str,sfloat,int,int,int,str,str,str,str),fields[4:13]))
+            elif type == 'BOOK':
+                books[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value)
+                    zip((str,sfloat,int,str,str),fields[4:9]))
+            elif type == 'INGR':
+                ingredients[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value)
+                    zip((str,sfloat,int,str),fields[4:8]))
+            elif type == 'KEYM':
+                keys[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value)
+                    zip((str,sfloat,int,str,str),fields[4:9]))
+            elif type == 'LIGH':
+                lights[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value, duration)
+                    zip((str,sfloat,int,int,str),fields[4:9]))
+            elif type == 'MISC':
+                misc[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value)
+                    zip((str,sfloat,int,str,str),fields[4:9]))
+            elif type == 'WEAP':
+                weapons[longid] = (eid,) + tuple(func(field) for func,field in
+                    #--(weight, value, health, damage, clipsize,
+                    #-- animationMultiplier, reach, ammoUse, minSpread, spread, sightFov, baseVatsToHitChance, projectileCount,
+                    #-- minRange, maxRange, animationAttackMultiplier, fireRate, overrideActionPoint, rumbleLeftMotorStrength,
+                    #-- rumbleRightMotorStrength, rumbleDuration, overrideDamageToWeaponMult, attackShotsPerSec,
+                    #-- reloadTime, jamTime, aimArc, rambleWavelangth, limbDmgMult, sightUsage,
+                    #-- semiAutomaticFireDelayMin, semiAutomaticFireDelayMax, criticalDamage, criticalMultiplier)
+                    zip((str,sfloat,int,int,int,int,
+                         sfloat,sfloat,int,sfloat,sfloat,sfloat,int,int,
+                         sfloat,sfloat,sfloat,sfloat,sfloat,sfloat,
+                         sfloat,sfloat,sfloat,sfloat,
+                         sfloat,sfloat,sfloat,sfloat,sfloat,sfloat,
+                         sfloat,sfloat,int,sfloat,str,str),fields[4:40]))
         ins.close()
 
     def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%d","%f"'
-        altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%d","%f"'
-        effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-        scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
-        noscriptEffectFiller = ',"None","None","None","None","None","None"'
+        """Writes stats to specified text file."""
         out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                                _('Name'),_('Model Path'),_('Bound Radius'),
-                                _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
-                                _('Uses'),_('Value'),_('Weight'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
-                                ),'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
-            eid,name,modpath,modb,iconpath,scriptfid,uses,value,weight,effects = fid_stats[fid]
-            scriptfid = scriptfid or (GPath('None'), None)
-            try:
-                output = rowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
-            except TypeError:
-                output = altrowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
-            for effect in effects:
-                efname,magnitude,area,duration,range,actorvalue = effect[:-1]
-                range = recipientTypeNumber_Name.get(range,range)
-                actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                scripteffect = effect[-1]
-                output += effectFormat % (efname,magnitude,area,duration,range,actorvalue)
-                if len(scripteffect):
-                    longid,seschool,sevisual,seflags,sename = scripteffect
-                    if sevisual == '\x00\x00\x00\x00':
-                        sevisual = ''
-                    output += scriptEffectFormat % (longid[0].s,longid[1],seschool,sevisual,seflags,sename)
-                else:
-                    output += noscriptEffectFiller
-            output += '\n'
-            out.write(output)
-        out.close()
-class CBash_SigilStoneDetails:
-    """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.fid_stats = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
-
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        fid_stats = self.fid_stats
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_SigilStoneDetails:readFromMod"
-            print error[0]
-            return
-
-        for record in modFile.SGST:
-            fid_stats[record.fid] = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, record.effects_list]
-
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        fid_stats = self.fid_stats
-        changed = []
-
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_SigilStoneDetails:writeToMod"
-            print error[0]
-            return
-
-        for record in modFile.SGST:
-            newStats = fid_stats.get(record.fid, None)
-            if not newStats: continue
-            oldStats = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, record.effects_list]
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.uses, record.value, record.weight, effects = newStats
-                record.effects_list = effects
-        if changed: modFile.save()
-        return changed
-
-    def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 12 or fields[1][:2] != '0x': continue
-            mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,uses,value,weight = fields[:12]
-            mmod = _coerce(mmod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-            smod = _coerce(smod, str, AllowNone=True)
-            if smod is None: sid = None
-            else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
-            eid = _coerce(eid, str, AllowNone=True)
-            full = _coerce(full, str, AllowNone=True)
-            modPath = _coerce(modPath, str, AllowNone=True)
-            modb = _coerce(modb, float)
-            iconPath = _coerce(iconPath, str, AllowNone=True)
-            uses = _coerce(uses, int)
-            value = _coerce(value, int)
-            weight = _coerce(weight, float)
-            effects = []
-            _effects = fields[12:]
-            while len(_effects) >= 13:
-                _effect, _effects = _effects[1:13], _effects[13:]
-                name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                name = _coerce(name, str, AllowNone=True)
-                name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
-                magnitude = _coerce(magnitude, int, AllowNone=True)
-                area = _coerce(area, int, AllowNone=True)
-                duration = _coerce(duration, int, AllowNone=True)
-                range = _coerce(range, str, AllowNone=True)
-                if range:
-                    range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                if actorvalue:
-                    actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                if None in (name,magnitude,area,duration,range,actorvalue):
-                    continue
-                effect = [name,magnitude,area,duration,range,actorvalue]
-                semod = _coerce(semod, str, AllowNone=True)
-                seobj = _coerce(seobj, int, 16, AllowNone=True)
-                seschool = _coerce(seschool, int, AllowNone=True)
-                sevisual = _coerce(sevisual, int, AllowNone=True)
-                seflags = _coerce(seflags, int, AllowNone=True)
-                sename = _coerce(sename, str, AllowNone=True)
-                if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                    effect.extend([None,None,None,None,None])
-                else:
-                    sefid = (GPath(aliases.get(semod,semod)),seobj)
-                    effect.extend([sefid, seschool, sevisual,seflags, sename])
-                effects.append(tuple(effect))
-            fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, uses, value, weight, effects]
-        ins.close()
+        def getSortedIds(stats):
+            longids = stats.keys()
+            longids.sort(key=lambda a: stats[a][0])
+            longids.sort(key=itemgetter(0))
+            return longids
+        if not CBash:
+            for type,format,header in (
+                #--Alch
+                ('ALCH', bolt.csvFormat('ssfisss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Large Icon Path'),_('Small Icon Path'),_('Model'))) + '"\n')),
+                #Ammo
+                ('AMMO', bolt.csvFormat('ssfiisss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Speed'),_('Value'),_('Clip Rounds'),_('Large Icon Path'),_('Small Icon Path'),_('Model'))) + '"\n')),
+                #--Armor
+                ('ARMO', bolt.csvFormat('ssfiiissssssss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('AR'),
+                    _('Male Large Icon Path'),_('Male Small Icon Path'),_('Female Large Icon Path'),_('Female Small Icon Path'),
+                    _('Male Model Path'),_('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
+                #--Armor Addon
+                ('ARMA', bolt.csvFormat('ssfiiissssssss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('AR'),
+                    _('Male Large Icon Path'),_('Male Small Icon Path'),_('Female Large Icon Path'),_('Female Small Icon Path'),
+                    _('Male Model Path'),_('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
+                #Books
+                ('BOOK', bolt.csvFormat('ssfisss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Large Icon Path'),_('Small Icon Path'),_('Model'))) + '"\n')),
+                #Ingredients
+                ('INGR', bolt.csvFormat('ssfiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
+                #--Keys
+                ('KEYM', bolt.csvFormat('ssfisss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Large Icon Path'),_('Small Icon Path'),_('Model'))) + '"\n')),
+                #Lights
+                ('LIGH', bolt.csvFormat('ssfiiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Duration'),_('Icon Path'),_('Model'))) + '"\n')),
+                #--Misc
+                ('MISC', bolt.csvFormat('ssfisss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Large Icon Path'),_('Small Icon Path'),_('Model'))) + '"\n')),
+                #--Weapons
+                ('WEAP', bolt.csvFormat('ssfiiiiffifffiiffffffffffffffffffifssssss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('Damage'),_('Clip Size'),
+                    _('Animation Multiplier'), _('Reach'), _('Ammo Use'), _('Min Spread'), _('Spread'), _('Sight Fov'), _('Base VATS To-Hit Chance'), _('Projectile Count'),
+                    _('Min Range'), _('Max Range'), _('Animation Attack Multiplier'), _('Fire Rate'), _('Override - Action Point'), _('Rumble - Left Motor Strength'),
+                    _('rRmble - Right Motor Strength'), _('Rumble - Duration'), _('Override - Damage To Weapon Mult'), _('Attack Shots/Sec'),
+                    _('Reload Time'), _('Jam Time'), _('Aim Arc'), _('Ramble - Wavelangth'), _('Limb Dmg Mult'), _('Sight Usage'),
+                    _('Semi-Automatic Fire Delay Min'), _('Semi-Automatic Fire Delay Max'),
+                    _('Critical Damage'), _('Crit % Mult'),
+                    _('Large Icon Path'),_('Small Icon Path'),_('Model'),_('Shell Casing Model'),_('Scope Model'),_('World Model'))) + '"\n')),
+                ):
+                stats = self.type_stats[type]
+                if not stats: continue
+                out.write('\n'+header)
+                for longid in getSortedIds(stats):
+                    out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
+                    tempstats = list(stats[longid])
+                    if type == 'ARMO' or type == 'ARMA':
+                        tempstats.append(self.Mmodel.get(longid, 'NONE'))
+                        tempstats.append(self.Fmodel.get(longid, 'NONE'))
+                        tempstats.append(self.MGndmodel.get(longid, 'NONE'))
+                        tempstats.append(self.FGndmodel.get(longid, 'NONE'))
+                    elif type == 'WEAP':
+                        tempstats.append(self.model.get(longid, 'NONE'))
+                        tempstats.append(self.ShellCasingmodel.get(longid, 'NONE'))
+                        tempstats.append(self.Scopemodel.get(longid, 'NONE'))
+                        tempstats.append(self.Gndmodel.get(longid, 'NONE'))
+                    else:
+                        tempstats.append(self.model.get(longid, 'NONE'))
+                    finalstats = tuple(tempstats)
+                    out.write(format % finalstats)
+        else:
+            for type,format,header in (
+                ('ALCH', bolt.csvFormat('ssfissssss')+'\n', #--Potions
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),
+                    _('modPath'),_('IsFood'),_('IsNoAutoCalc'),_('Script'),_('Effects'))) + '"\n')),
+                ('AMMO', bolt.csvFormat('ssfiifisssss')+'\n', #--Ammo
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Damage'),_('Speed')
+                    ,_('Enchant Points'),_('Icon Path'),_('Model'),_('Script'),_('Enchantment'),_('Normal Weapon'))) + '"\n')),
+                #--Apparatus
+                ('APPA', bolt.csvFormat('ssfifss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Quantity'),_('Icon Path'),_('Model'))) + '"\n')),
+                #--Armor
+                ('ARMO', bolt.csvFormat('ssfiiissssss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),
+                    _('AR'),_('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
+                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
+                #Books
+                ('BOOK', bolt.csvFormat('ssfiiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
+                #Clothing
+                ('CLOT', bolt.csvFormat('ssfiissssss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),
+                    _('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
+                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
+                #Ingredients
+                ('INGR', bolt.csvFormat('ssfiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
+                ('KEYM', bolt.csvFormat('sssssssss')+'\n',     #--Keys
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Value'),_('Weight'),_('Model'),_('Icon'),_('Script'),_('MODB'),_('MODT_P'))) + '"\n')),
 
-    def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%d","%f"'
-        altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%d","%f"'
-        effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-        scriptEffectFormat = ',"%s","0x%06X","%d","%d","%d","%s"'
-        noscriptEffectFiller = ',"None","None","None","None","None","None"'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                                _('Name'),_('Model Path'),_('Bound Radius'),
-                                _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
-                                _('Uses'),_('Value'),_('Weight'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
-                                ),'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
-            eid,name,modpath,modb,iconpath,scriptfid,uses,value,weight,effects = fid_stats[fid]
-            scriptfid = scriptfid or (GPath('None'), None)
-            try:
-                output = rowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
-            except TypeError:
-                output = altrowFormat % (fid[0].s,fid[1],eid,name,modpath,modb,iconpath,scriptfid[0].s,scriptfid[1],uses,value,weight)
-            for effect in effects:
-                efname,magnitude,area,duration,range,actorvalue = effect[:6]
-                efname = c_ulong(efname)
-                efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
-                range = recipientTypeNumber_Name.get(range,range)
-                actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                scripteffect = effect[6:]
-                output += effectFormat % (efname,magnitude,area,duration,range,actorvalue)
-                if None not in scripteffect:
-                    output += scriptEffectFormat % tuple(scripteffect)
+                #Lights
+                ('LIGH', bolt.csvFormat('ssfiiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Duration'),_('Icon Path'),_('Model'))) + '"\n')),
+                #--Misc
+                ('MISC', bolt.csvFormat('ssfiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
+                #Sigilstones
+                ('SGST', bolt.csvFormat('ssfiiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Uses'),_('Icon Path'),_('Model'))) + '"\n')),
+                #Soulgems
+                ('SLGM', bolt.csvFormat('ssfiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
+                #--Weapons
+                ('WEAP', bolt.csvFormat('ssfiiiffiss')+'\n',
+                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('Damage'),
+                    _('Speed'),_('Reach'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
+                ):
+                stats = self.type_stats[type]
+                if not stats: continue
+                out.write('\n'+header)
+                if type != 'KEYM':
+                    for longid in getSortedIds(stats):
+                        out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
+                        out.write(format % stats[longid])
                 else:
-                    output += noscriptEffectFiller
-            output += '\n'
-            out.write(output)
+                    format = bolt.csvFormat('sssssssss')
+                    for longid in getSortedIds(stats):
+                        out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
+                        out.write(format % stats[longid])
+                        out.write('\n')
         out.close()
-#------------------------------------------------------------------------------
-class ItemStats:
-    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
-    class_attrs = {
-        'ALCH':('eid', 'weight', 'value'),
-        'AMMO':('eid', 'weight', 'value', 'damage', 'speed', 'enchantPoints'),
-        'APPA':('eid', 'weight', 'value', 'quality'),
-        'ARMO':('eid', 'weight', 'value', 'health', 'strength'),
-        'BOOK':('eid', 'weight', 'value', 'enchantPoints'),
-        'CLOT':('eid', 'weight', 'value', 'enchantPoints'),
-        'INGR':('eid', 'weight', 'value'),
-        'KEYM':('eid', 'weight', 'value'),
-        'LIGH':('eid', 'weight', 'value', 'duration'),
-        'MISC':('eid', 'weight', 'value'),
-        'SGST':('eid', 'weight', 'value', 'uses'),
-        'SLGM':('eid', 'weight', 'value'),
-        'WEAP':('eid', 'weight', 'value', 'health', 'damage', 'speed', 'reach', 'enchantPoints'),
-        }
 
-    @staticmethod
-    def sstr(value):
-        return _coerce(value, str, AllowNone=True)
-
-    @staticmethod
-    def sfloat(value):
-        return _coerce(value, float, AllowNone=True)
-
-    @staticmethod
-    def sint(value):
-        return _coerce(value, int, AllowNone=True)
-
-    @staticmethod
-    def snoneint(value):
-        x = _coerce(value, int, AllowNone=True)
-        if x == 0: return None
-        return x
+# class CBash_CompleteItemData:
+#     """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
+#     @staticmethod
+#     def sstr(value):
+#         return _coerce(value, str, AllowNone=True)
+
+#     @staticmethod
+#     def sfloat(value):
+#         return _coerce(value, float, AllowNone=True)
+
+#     @staticmethod
+#     def sint(value):
+#         return _coerce(value, int, AllowNone=True)
+
+#     @staticmethod
+#     def snoneint(value):
+#         x = _coerce(value, int, AllowNone=True)
+#         if x == 0: return None
+#         return x
+
+#     @staticmethod
+#     def sbool(value):
+#         return _coerce(value, bool)
+
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.class_fid_values = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.recipientTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'Self',
+#             1 : 'Touch',
+#             2 : 'Target',}
+#         self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+#         self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+#         self.actorValueNumber_Name[None] = 'NONE'
+#         self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         class_fid_values = self.class_fid_values
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_CompleteItemData:readFromMod"
+#             print error[0]
+#             return
+
+#         for group in pickupables:
+#             for record in getattr(modFile,group):
+#                 values = ExtractExportList(record)
+#                 print values
+#                 print
+#                 print
+#                 class_fid_values.setdefault(group,{})[record.fid] = values
+#                 break
+#         del Current
+
+#     def writeToMod(self,modInfo):
+#         """Exports type_id_name to specified mod."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_CompleteItemData:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = {} #--changed[modName] = numChanged
+#         for group, fid_attr_value in class_fid_attr_value.iteritems():
+#             attrs = self.class_attrs[group]
+#             for fid, attr_value in fid_attr_value.iteritems():
+#                 record = modFile.LookupRecord(fid)
+#                 if record and record._Type == group:
+#                     oldValues = map(record.__getattribute__,attrs)
+#                     if oldValues != attr_value:
+#                         map(record.__setattr__,attrs, attr_value)
+#                         changed[fid[0]] = 1 + changed.get(fid[0],0)
+#         if changed: modFile.save()
+#         return changed
+
+#     def readEffectsFromText(self, fields):
+#         effects = []
+#         _effects = fields[12:]
+#         while len(_effects) >= 13:
+#             _effect, _effects = _effects[1:13], _effects[13:]
+#             name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+#             name = _coerce(name, str, AllowNone=True)
+#             name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
+#             magnitude = _coerce(magnitude, int, AllowNone=True)
+#             area = _coerce(area, int, AllowNone=True)
+#             duration = _coerce(duration, int, AllowNone=True)
+#             range = _coerce(range, str, AllowNone=True)
+#             if range:
+#                 range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+#             actorvalue = _coerce(actorvalue, str, AllowNone=True)
+#             if actorvalue:
+#                 actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+#             if None in (name,magnitude,area,duration,range,actorvalue):
+#                 continue
+#             effect = [name,magnitude,area,duration,range,actorvalue]
+#             semod = _coerce(semod, str, AllowNone=True)
+#             seobj = _coerce(seobj, int, 16, AllowNone=True)
+#             seschool = _coerce(seschool, int, AllowNone=True)
+#             sevisual = _coerce(sevisual, int, AllowNone=True)
+#             seflags = _coerce(seflags, int, AllowNone=True)
+#             sename = _coerce(sename, str, AllowNone=True)
+#             if None in (semod,seobj,seschool,sevisual,seflags,sename):
+#                 effect.extend([None,None,None,None,None])
+#             else:
+#                 sefid = (GPath(aliases.get(semod,semod)),seobj)
+#                 effect.extend([sefid, seschool, sevisual,seflags, sename])
+#             effects.append(tuple(effect))
+#         return effects
+
+#     def readSGSTFromText(self, fields):
+#         aliases = self.aliases
+#         eid,full,weight,value,uses,iconPath,modPath,modb,smod,sobj = fields[:10]
+#         fields = fields[:10]
+#         smod = _coerce(smod, str, AllowNone=True)
+#         if smod is None: sid = None
+#         else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
+#         eid = _coerce(eid, str, AllowNone=True)
+#         full = _coerce(full, str, AllowNone=True)
+#         modPath = _coerce(modPath, str, AllowNone=True)
+#         modb = _coerce(modb, float)
+#         iconPath = _coerce(iconPath, str, AllowNone=True)
+#         uses = _coerce(uses, int)
+#         value = _coerce(value, int)
+#         weight = _coerce(weight, float)
+#         effects = readEffectsFromText(fields)
+#         return [eid, full, weight, value, uses, iconPath, modPath, modb, sid, effects]
+
+#     def readFromText(self,textPath):
+#         """Reads stats from specified text file."""
+#         class_fid_attr_value, aliases = self.class_fid_attr_value, self.aliases
+#         ins = bolt.CsvReader(textPath)
+#         attr_type = self.attr_type
+#         for fields in ins:
+#             if len(fields) < 3 or fields[2][:2] != '0x': continue
+#             group,modName,objectStr = fields[:3]
+#             fields = fields[3:]
+#             modName = GPath(_coerce(modName,str))
+#             longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
+#             attrs = self.class_attrs[group]
+#             if group == 'ALCH':
+#                 pass
+#             elif group == 'AMMO':
+#                 pass
+#             elif group == 'SGST':
+#                 class_fid_attr_value[group][longid] = readSGSTFields(fields)
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         return
+#         """Writes stats to specified text file."""
+#         class_fid_attr_value = self.class_fid_attr_value
+#         out = textPath.open('w')
+#         def getSortedIds(fid_attr_value):
+#             longids = fid_attr_value.keys()
+#             longids.sort(key=lambda a: fid_attr_value[a]['eid'])
+#             longids.sort(key=itemgetter(0))
+#             return longids
+#         def write(out, attrs, values):
+#             attr_type = self.attr_type
+#             csvFormat = ''
+#             sstr = self.sstr
+#             sint = self.sint
+#             snoneint = self.snoneint
+#             sfloat = self.sfloat
+#             for index, attr in enumerate(attrs):
+#                 stype = attr_type[attr]
+#                 values[index] = stype(values[index]) #sanitize output
+#                 if values[index] is None: csvFormat += ',"{0[%d]}"' % index
+#                 elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
+#                 elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
+#                 elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
+#             csvFormat = csvFormat[1:] #--Chop leading comma
+#             out.write(csvFormat.format(values) + '\n')
+#         for group,header in (
+#             #--Alch
+#             ('ALCH',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Ammo
+#             ('AMMO',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'))) + '"\n')),
+#             #--Apparatus
+#             ('APPA',
+#                 ('"' + '","'.join((_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Quality'))) + '"\n')),
+#             #--Armor
+#             ('ARMO',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
+#             #Books
+#             ('BOOK',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
+#             #Clothing
+#             ('CLOT',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
+#             #Ingredients
+#             ('INGR',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #--Keys
+#             ('KEYM',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Lights
+#             ('LIGH',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
+#             #--Misc
+#             ('MISC',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #Sigilstones
+#             ('SGST',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Uses'))) + '"\n')),
+#             #Soulgems
+#             ('SLGM',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
+#             #--Weapons
+#             ('WEAP',
+#                 ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
+#                 _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),
+#                 _('Speed'),_('Reach'),_('EPoints'))) + '"\n')),
+#             ):
+#             fid_attr_value = class_fid_attr_value[group]
+#             if not fid_attr_value: continue
+#             attrs = self.class_attrs[group]
+#             out.write(header)
+#             for longid in getSortedIds(fid_attr_value):
+#                 out.write('"%s","%s","0x%06X",' % (group,longid[0].s,longid[1]))
+#                 attr_value = fid_attr_value[longid]
+#                 write(out, attrs, map(attr_value.get, attrs))
+#         out.close()
 
+#------------------------------------------------------------------------------
+class ScriptText:
+    """import & export functions for script text."""
     def __init__(self,types=None,aliases=None):
         """Initialize."""
-        self.class_fid_attr_value = {}
+        self.eid_data = {}
         self.aliases = aliases or {} #--For aliasing mod names
-        self.attr_type = {'eid':self.sstr,
-                          'weight':self.sfloat,
-                          'value':self.sint,
-                          'damage':self.sint,
-                          'speed':self.sfloat,
-                          'enchantPoints':self.snoneint,
-                          'health':self.sint,
-                          'strength':self.sint,
-                          'duration':self.sint,
-                          'quality':self.sfloat,
-                          'uses':self.sint,
-                          'reach':self.sfloat,}
-
-        for group in self.class_attrs:
-            self.class_fid_attr_value[group] = {}
 
-    def readFromMod(self,modInfo):
+    def readFromMod(self, modInfo, file):
         """Reads stats from specified mod."""
-        class_fid_attr_value = self.class_fid_attr_value
-        loadFactory= LoadFactory(False,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
+        eid_data = self.eid_data
+        loadFactory= LoadFactory(False,MreScpt)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
         mapper = modFile.getLongMapper()
-        for group, attrs in self.class_attrs.iteritems():
-            for record in getattr(modFile,group).getActiveRecords():
-                class_fid_attr_value[group].setdefault(mapper(record.fid), {}).update(zip(attrs,map(record.__getattribute__,attrs)))
 
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        class_fid_attr_value = self.class_fid_attr_value
-        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
-        modFile = ModFile(modInfo,loadFactory)
+        with balt.Progress(_("Export Scripts")) as progress:
+            records = modFile.SCPT.getActiveRecords()
+            y = len(records)
+            z = 0
+            for record in records:
+                z += 1
+                progress((0.5/y*z),_("Reading scripts in %s.")%(file))
+                eid_data[record.eid] = (record.scriptText, mapper(record.fid))
+
+    def writeToMod(self, modInfo, makeNew=False):
+        """Writes scripts to specified mod."""
+        eid_data = self.eid_data
+        changed = []
+        added = []
+        loadFactory = LoadFactory(True,MreScpt)
+        modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
-        mapper = modFile.getLongMapper()
-        changed = {} #--changed[modName] = numChanged
-        for group, fid_attr_value in class_fid_attr_value.iteritems():
-            attrs = self.class_attrs[group]
-            for record in getattr(modFile,group).getActiveRecords():
-                longid = mapper(record.fid)
-                itemStats = fid_attr_value.get(longid,None)
-                if not itemStats: continue
-                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
-                if oldValues != itemStats:
-                    for attr, value in itemStats.iteritems():
-                        setattr(record,attr,value)
+
+        for record in modFile.SCPT.getActiveRecords():
+            eid = record.eid
+            data = eid_data.get(eid,None)
+            if data is not None:
+                newText, longid = data
+                oldText = record.scriptText
+                if oldText.lower() != newText.lower():
+                    record.scriptText = newText
                     record.setChanged()
-                    changed[longid[0]] = 1 + changed.get(longid[0],0)
-        if changed: modFile.safeSave()
-        return changed
+                    changed.append(eid)
+                del eid_data[eid]
+        if makeNew and eid_data:
+            tes4 = modFile.tes4
+            for eid, data in eid_data.iteritems():
+                newText, longid = data
+                scriptFid = genFid(len(tes4.masters),tes4.getNextObject())
+                newScript = MreScpt(('SCPT',0,0x40000,scriptFid,0))
+                newScript.eid = eid
+                newScript.scriptText = newText
+                newScript.setChanged()
+                modFile.SCPT.records.append(newScript)
+                added.append(eid)
+        if changed or added: modFile.safeSave()
+        return (changed, added)
 
-    def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        class_fid_attr_value = self.class_fid_attr_value
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        attr_type = self.attr_type
-        for fields in ins:
-            if len(fields) < 3 or fields[2][:2] != '0x': continue
-            group,modName,objectStr = fields[0:3]
-            modName = GPath(_coerce(modName,str))
-            longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
-            attrs = self.class_attrs[group]
-            attr_value = {}
-            for attr, value in zip(attrs, fields[3:3+len(attrs)]):
-                attr_value[attr] = attr_type[attr](value)
-            class_fid_attr_value[group].setdefault(longid, {}).update(attr_value)
-        ins.close()
+    def readFromText(self,textPath,modInfo):
+        """Reads scripts from files in specified mods' directory in bashed patches folder."""
+        eid_data, aliases = self.eid_data, self.aliases
+        with balt.Progress(_("Import Scripts")) as progress:
+            for root, dirs, files in os.walk(textPath):
+                y = len(files)
+                z = 0
+                for name in files:
+                    z += 1
+                    nPath = GPath(name)
+                    if(nPath.cext != inisettings['ScriptFileExt']):
+                        progress(((1/y)*z),_("Skipping file %s.") % (name))
+                        continue
+                    progress(((1/y)*z),_("Reading file %s.") % (name))
+                    ## Python 2.6+ syntax disabled for Python 2.5 compatibility
+                    ## with open(os.path.join(root, name),"r") as text:
+                    try:
+                        text = open(os.path.join(root, name),"r")
+                        lines = text.readlines()
+                    finally:
+                        text.close()
+                    try:
+                        modName,FormID,eid = lines[0][1:-1],lines[1][1:-1],lines[2][1:-1]
+                    except:
+                        deprint("%s has malformed script header lines - was skipped" % name)
+                        continue
+                    scriptText = ''.join(lines[3:]).replace('\n','\r\n') #because the cs reads\writes EOLs in \r\n format.
+                    eid_data[eid] = (scriptText, FormID)
+        if eid_data: return True
+        return False
 
-    def writeToText(self,textPath):
+    def writeToText(self,textPath,skip,folder,deprefix,esp):
         """Writes stats to specified text file."""
-        class_fid_attr_value = self.class_fid_attr_value
-        out = textPath.open('w')
-        def getSortedIds(fid_attr_value):
-            longids = fid_attr_value.keys()
-            longids.sort(key=lambda a: fid_attr_value[a]['eid'])
-            longids.sort(key=itemgetter(0))
-            return longids
-        def write(out, attrs, values):
-            attr_type = self.attr_type
-            csvFormat = ''
-            sstr = self.sstr
-            sint = self.sint
-            snoneint = self.snoneint
-            sfloat = self.sfloat
-            for index, attr in enumerate(attrs):
-                stype = attr_type[attr]
-                values[index] = stype(values[index]) #sanitize output
-                if values[index] is None: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
-                elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
-            csvFormat = csvFormat[1:] #--Chop leading comma
-            out.write(csvFormat.format(values) + '\n')
-        for group,header in (
-            #--Alch
-            ('ALCH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Ammo
-            ('AMMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'))) + '"\n')),
-            #--Apparatus
-            ('APPA',
-                ('"' + '","'.join((_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Quality'))) + '"\n')),
-            #--Armor
-            ('ARMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
-            #Books
-            ('BOOK',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Clothing
-            ('CLOT',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Ingredients
-            ('INGR',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Keys
-            ('KEYM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Lights
-            ('LIGH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
-            #--Misc
-            ('MISC',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Sigilstones
-            ('SGST',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Uses'))) + '"\n')),
-            #Soulgems
-            ('SLGM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Weapons
-            ('WEAP',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),
-                _('Speed'),_('Reach'),_('EPoints'))) + '"\n')),
-            ):
-            fid_attr_value = class_fid_attr_value[group]
-            if not fid_attr_value: continue
-            attrs = self.class_attrs[group]
-            out.write(Encode(header,'mbcs'))
-            for longid in getSortedIds(fid_attr_value):
-                out.write('"%s","%s","0x%06X",' % (group,Encode(longid[0].s,'mbcs'),longid[1]))
-                attr_value = fid_attr_value[longid]
-                write(out, attrs, map(attr_value.get, attrs))
-        out.close()
+        eid_data = self.eid_data
+        x = len(skip)
+        exportedScripts = []
+        y = len(eid_data)
+        z = 0
+        num = 0
+        r = len(deprefix)
+        with balt.Progress(_("Export Scripts")) as progress:
+            for eid in sorted(eid_data, key=lambda b: (b, eid_data[b][1])):
+                text, longid = eid_data[eid]
+                z += 1
+                progress((0.5+0.5/y*z),_("Exporting script %s.") % (eid))
+                if x == 0 or skip.lower() != eid[:x].lower():
+                    fileName = eid
+                    if r >= 1 and deprefix == fileName[:r]:
+                        fileName = fileName[r:]
+                    num += 1
+                    outpath = dirs['patches'].join(folder).join(fileName+inisettings['ScriptFileExt'])
+                    with outpath.open('wb') as out:
+                        formid = '0x%06X' %(longid[1])
+                        out.write(';'+Encode(longid[0].s,'mbcs')+'\r\n;'+formid+'\r\n;'+eid+'\r\n'+text)
+                    exportedScripts.append(eid)
+        return (_('Exported %d scripts from %s:\n') % (num,esp)+'\n'.join(exportedScripts))
 
-class CBash_ItemStats:
-    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
-    class_attrs = {
-        'ALCH':('eid', 'weight', 'value'),
-        'AMMO':('eid', 'weight', 'value', 'damage', 'speed', 'enchantPoints'),
-        'APPA':('eid', 'weight', 'value', 'quality'),
-        'ARMO':('eid', 'weight', 'value', 'health', 'strength'),
-        'BOOK':('eid', 'weight', 'value', 'enchantPoints'),
-        'CLOT':('eid', 'weight', 'value', 'enchantPoints'),
-        'INGR':('eid', 'weight', 'value'),
-        'KEYM':('eid', 'weight', 'value'),
-        'LIGH':('eid', 'weight', 'value', 'duration'),
-        'MISC':('eid', 'weight', 'value'),
-        'SGST':('eid', 'weight', 'value', 'uses'),
-        'SLGM':('eid', 'weight', 'value'),
-        'WEAP':('eid', 'weight', 'value', 'health', 'damage', 'speed', 'reach', 'enchantPoints'),
-        }
+# class CBash_ScriptText:
+#     """import & export functions for script text."""
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.eid_data = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+
+#     def readFromMod(self, modInfo, file):
+#         """Reads stats from specified mod."""
+#         eid_data = self.eid_data
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ScriptText:readFromMod"
+#             print error[0]
+#             return
+
+#         progress = balt.Progress(_("Export Scripts"))
+#         try:
+#             records = modFile.SCPT
+#             y = len(records)
+#             z = 0
+#             for record in records:
+#                 z += 1
+#                 progress((0.5/y*z),_("Reading scripts in %s.") % (file))
+#                 eid_data[record.eid] = (record.scriptText, record.fid)
+#                 record.UnloadRecord()
+#         finally: #just to ensure the progress bar gets destroyed
+#             progress = progress.Destroy()
+#             del Current
+
+#     def writeToMod(self, modInfo, makeNew=False):
+#         """Writes scripts to specified mod."""
+#         eid_data = self.eid_data
+#         changed = []
+#         added = []
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_ScriptText:writeToMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.SCPT:
+#             eid = record.eid
+#             data = eid_data.get(eid,None)
+#             if data is not None:
+#                 newText, longid = data
+#                 oldText = record.scriptText
+#                 if oldText != newText:
+#                     record.scriptText = newText
+#                     changed.append(eid)
+#                 del eid_data[eid]
+#         if makeNew and eid_data:
+#             for eid, data in eid_data.iteritems():
+#                 newText, longid = data
+#                 newScript = modFile.create_SCPT()
+#                 if newScript is not None:
+#                     newScript.eid = eid
+#                     newScript.scriptText = newText
+#                     added.append(eid)
+#         if changed or added: modFile.save()
+#         del Current
+#         return (changed, added)
+
+#     def readFromText(self,textPath,modInfo):
+#         """Reads scripts from files in specified mods' directory in bashed patches folder."""
+#         eid_data, aliases = self.eid_data, self.aliases
+#         with balt.Progress(_("Import Scripts")) as progress:
+#             for root, dirs, files in os.walk(textPath):
+#                 y = len(files)
+#                 z = 0
+#                 for name in files:
+#                     z += 1
+#                     nPath = GPath(name)
+#                     if(nPath.cext != inisettings['ScriptFileExt']):
+#                         progress(((1/y)*z),_("Skipping file %s.") % (name))
+#                         continue
+#                     progress(((1/y)*z),_("Reading file %s.") % (name))
+#                     ## Python 2.6+ syntax disabled for Python 2.5 compatibility
+#                     ## with open(os.path.join(root, name),"r") as text:
+#                     try:
+#                         text = open(os.path.join(root, name),"r")
+#                         lines = text.readlines()
+#                     finally:
+#                         text.close()
+#                     modName,FormID,eid = lines[0][1:-1],lines[1][1:-1],lines[2][1:-1]
+#                     scriptText = ''.join(lines[3:]).replace('\n','\r\n') #because the cs writes it in \r\n format.
+#                     eid_data[ISTRING(eid)] = (ISTRING(scriptText), FormID) #script text is case insensitive
+#         if eid_data: return True
+#         return False
+
+#     def writeToText(self,textPath,skip,folder,deprefix,esp):
+#         """Writes stats to specified text file."""
+#         eid_data = self.eid_data
+#         x = len(skip)
+#         exportedScripts = []
+#         y = len(eid_data)
+#         z = 0
+#         num = 0
+#         r = len(deprefix)
+#         with balt.Progress(_("Export Scripts")) as progress:
+#             for eid in sorted(eid_data, key=lambda b: (b, eid_data[b][1])):
+#                 text, longid = eid_data[eid]
+#                 z += 1
+#                 progress((0.5+0.5/y*z),_("Exporting script %s.") % (eid))
+#                 if x == 0 or skip.lower() != eid[:x].lower():
+#                     fileName = eid
+#                     if r >= 1 and deprefix == fileName[:r]:
+#                         fileName = fileName[r:]
+#                     num += 1
+#                     outpath = dirs['patches'].join(folder).join(fileName+inisettings['ScriptFileExt'])
+#                     with outpath.open('wb') as out:
+#                         formid = '0x%06X' %(longid[1])
+#                         try:
+#                             out.write(';'+Encode(longid[0].s,'mbcs')+'\r\n;'+formid+'\r\n;'+eid+'\r\n'+text)
+#                         except UnicodeDecodeError:
+#                             try:
+#                                 out.write((';'.decode('cp1252')+longid[0].s.decode('cp1252')+'\r\n;'.decode('cp1252')+formid.decode('cp1252')+'\r\n;'.decode('cp1252')+eid.decode('cp1252')+'\r\n'+text.decode('cp1252')).encode('cp1252'))
+#                             except UnicodeDecodeError, err:
+#                                 print err
+#                                 print outpath
+#                                 print ';',longid[0].s,'\r\n;',formid,'\r\n;',eid,'\r\n',text
+#                             except UnicodeEncodeError, err:
+#                                 print err
+#                                 print outpath
+#                                 print ';',longid[0].s,'\r\n;',formid,'\r\n;',eid,'\r\n',text
+#                     exportedScripts.append(eid)
+#         return (_('Exported %d scripts from %s:\n') % (num,esp)+'\n'.join(exportedScripts))
 
-    @staticmethod
-    def sstr(value):
-        return _coerce(value, str, AllowNone=True)
+#------------------------------------------------------------------------------
+class SpellRecords:
+    """Statistics for spells, with functions for importing/exporting from/to mod/text file."""
 
-    @staticmethod
-    def sfloat(value):
-        return _coerce(value, float, AllowNone=True)
+    def __init__(self,types=None,aliases=None,detailed=False):
+        """Initialize."""
+        self.fid_stats = {}
+        self.attrs = ('eid', 'full', 'cost', 'level', 'spellType')
+        self.detailed = detailed
+        if detailed:
+            self.attrs = self.attrs + ('flags.noAutoCalc', 'flags.startSpell', 'flags.immuneToSilence',
+                                       'flags.ignoreLOS', 'flags.scriptEffectAlwaysApplies',
+                                       'flags.disallowAbsorbReflect',
+                                       'flags.touchExplodesWOTarget') #, 'effects_list' is special cased
+        self.spellTypeNumber_Name = {None : 'NONE',
+                                     0 : 'Spell',
+                                     1 : 'Disease',
+                                     2 : 'Power',
+                                     3 : 'LesserPower',
+                                     4 : 'Ability',
+                                     5 : 'Poison',}
+        self.spellTypeName_Number = dict([(y.lower(),x) for x,y in self.spellTypeNumber_Name.iteritems() if x is not None])
 
-    @staticmethod
-    def sint(value):
-        return _coerce(value, int, AllowNone=True)
+        self.levelTypeNumber_Name = {None : 'NONE',
+                                     0 : 'Novice',
+                                     1 : 'Apprentice',
+                                     2 : 'Journeyman',
+                                     3 : 'Expert',
+                                     4 : 'Master',}
+        self.levelTypeName_Number = dict([(y.lower(),x) for x,y in self.levelTypeNumber_Name.iteritems() if x is not None])
 
-    @staticmethod
-    def snoneint(value):
-        x = _coerce(value, int, AllowNone=True)
-        if x == 0: return None
-        return x
+        self.recipientTypeNumber_Name = {
+            None : 'NONE',
+            0 : 'Self',
+            1 : 'Touch',
+            2 : 'Target',}
+        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
 
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.class_fid_attr_value = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.attr_type = {'eid':self.sstr,
-                          'weight':self.sfloat,
-                          'value':self.sint,
-                          'damage':self.sint,
-                          'speed':self.sfloat,
-                          'enchantPoints':self.snoneint,
-                          'health':self.sint,
-                          'strength':self.sint,
-                          'duration':self.sint,
-                          'quality':self.sfloat,
-                          'uses':self.sint,
-                          'reach':self.sfloat,}
-
-        for group in self.class_attrs:
-            self.class_fid_attr_value[group] = {}
-
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        class_fid_attr_value = self.class_fid_attr_value
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ItemStats:readFromMod"
-            print error[0]
-            return
-
-        for group, attrs in self.class_attrs.iteritems():
-            for record in getattr(modFile,group):
-                class_fid_attr_value[group].setdefault(record.fid, {}).update(zip(attrs,map(record.__getattribute__,attrs)))
-        del Current
-
-    def writeToMod(self,modInfo):
-        """Exports type_id_name to specified mod."""
-        class_fid_attr_value = self.class_fid_attr_value
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ItemStats:writeToMod"
-            print error[0]
-            return
-
-        changed = {} #--changed[modName] = numChanged
-        for group, fid_attr_value in class_fid_attr_value.iteritems():
-            attrs = self.class_attrs[group]
-            for fid, attr_value in fid_attr_value.iteritems():
-                record = modFile.LookupRecord(fid)
-                if record and record._Type == group:
-                    oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
-                    if oldValues != attr_value:
-                        for attr, value in attr_value.iteritems():
-                            setattr(record,attr,value)
-                        changed[fid[0]] = 1 + changed.get(fid[0],0)
-        if changed: modFile.save()
-        return changed
-
-    def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        class_fid_attr_value = self.class_fid_attr_value
-        aliases = self.aliases
-        ins = bolt.CsvReader(textPath)
-        attr_type = self.attr_type
-        for fields in ins:
-            if len(fields) < 3 or fields[2][:2] != '0x': continue
-            group,modName,objectStr = fields[0:3]
-            modName = GPath(_coerce(modName,str))
-            longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
-            attrs = self.class_attrs[group]
-            attr_value = {}
-            for attr, value in zip(attrs, fields[3:3+len(attrs)]):
-                attr_value[attr] = attr_type[attr](value)
-            class_fid_attr_value[group].setdefault(longid, {}).update(attr_value)
-        ins.close()
-
-    def writeToText(self,textPath):
-        """Writes stats to specified text file."""
-        class_fid_attr_value = self.class_fid_attr_value
-        out = textPath.open('w')
-        def getSortedIds(fid_attr_value):
-            longids = fid_attr_value.keys()
-            longids.sort(key=lambda a: fid_attr_value[a]['eid'])
-            longids.sort(key=itemgetter(0))
-            return longids
-        def write(out, attrs, values):
-            attr_type = self.attr_type
-            csvFormat = ''
-            sstr = self.sstr
-            sint = self.sint
-            snoneint = self.snoneint
-            sfloat = self.sfloat
-            for index, attr in enumerate(attrs):
-                stype = attr_type[attr]
-                values[index] = stype(values[index]) #sanitize output
-                if values[index] is None: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
-                elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
-            csvFormat = csvFormat[1:] #--Chop leading comma
-            out.write(csvFormat.format(values) + '\n')
-        for group,header in (
-            #--Alch
-            ('ALCH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Ammo
-            ('AMMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'))) + '"\n')),
-            #--Apparatus
-            ('APPA',
-                ('"' + '","'.join((_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Quality'))) + '"\n')),
-            #--Armor
-            ('ARMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
-            #Books
-            ('BOOK',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Clothing
-            ('CLOT',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Ingredients
-            ('INGR',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Keys
-            ('KEYM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Lights
-            ('LIGH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
-            #--Misc
-            ('MISC',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Sigilstones
-            ('SGST',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Uses'))) + '"\n')),
-            #Soulgems
-            ('SLGM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Weapons
-            ('WEAP',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),
-                _('Speed'),_('Reach'),_('EPoints'))) + '"\n')),
-            ):
-            fid_attr_value = class_fid_attr_value[group]
-            if not fid_attr_value: continue
-            attrs = self.class_attrs[group]
-            out.write(Encode(header,'mbcs'))
-            for longid in getSortedIds(fid_attr_value):
-                out.write('"%s","%s","0x%06X",' % (group,Encode(longid[0].s,'mbcs'),longid[1]))
-                attr_value = fid_attr_value[longid]
-                write(out, attrs, map(attr_value.get, attrs))
-        out.close()
-#------------------------------------------------------------------------------
-class ItemPrices:
-    """Function for importing/exporting from/to mod/text file only the value, name and eid of records."""
+        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+        self.actorValueNumber_Name[None] = 'NONE'
+        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
 
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.class_fid_stats = {'ALCH':{},'AMMO':{},'APPA':{},'ARMO':{},'BOOK':{},'CLOT':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'SGST':{},'SLGM':{},'WEAP':{}}
-        self.attrs = ('value', 'eid', 'full')
         self.aliases = aliases or {} #--For aliasing mod names
 
     def readFromMod(self,modInfo):
-        """Reads data from specified mod."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
-        loadFactory = LoadFactory(False,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
+        """Reads stats from specified mod."""
+        fid_stats, attrs = self.fid_stats, self.attrs
+        detailed = self.detailed
+        loadFactory= LoadFactory(False,MreSpel)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
-        mapper = modFile.getLongMapper()
-        attrs = self.attrs
-        for group, fid_stats in class_fid_stats.iteritems():
-            for record in getattr(modFile,group).getActiveRecords():
-                fid_stats[mapper(record.fid)] = map(record.__getattribute__,attrs)
+        modFile.convertToLongFids(['SPEL'])
+        for record in modFile.SPEL.getActiveRecords():
+            fid_stats[record.fid] = [getattr_deep(record, attr) for attr in attrs]
+            if detailed:
+                effects = []
+                for effect in record.effects:
+                    effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+                    if effect.scriptEffect:
+                        effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
+                                           effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+                    else: effectlist.append([])
+                    effects.append(effectlist)
+                fid_stats[record.fid].append(effects)
 
     def writeToMod(self,modInfo):
         """Writes stats to specified mod."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
-        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
+        fid_stats, attrs = self.fid_stats, self.attrs
+        detailed = self.detailed
+        loadFactory= LoadFactory(True,MreSpel)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
         mapper = modFile.getLongMapper()
+        shortMapper = modFile.getShortMapper()
 
-        changed = {} #--changed[modName] = numChanged
-        for group, fid_stats in class_fid_stats.iteritems():
-            for record in getattr(modFile,group).getActiveRecords():
-                longid = mapper(record.fid)
-                stats = fid_stats.get(longid,None)
-                if not stats: continue
-                value = stats[0]
-                if record.value != value:
-                    record.value = value
-                    changed[longid[0]] = changed.get(longid[0],0) + 1
-                    record.setChanged()
+        changed = [] #eids
+        for record in modFile.SPEL.getActiveRecords():
+            newStats = fid_stats.get(mapper(record.fid), None)
+            if not newStats: continue
+            oldStats = [getattr_deep(record, attr) for attr in attrs]
+            if detailed:
+                effects = []
+                for effect in record.effects:
+                    effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+                    if effect.scriptEffect:
+                        effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
+                                           effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+                    else: effectlist.append([])
+                    effects.append(effectlist)
+                oldStats.append(effects)
+            if oldStats != newStats:
+                changed.append(oldStats[0]) #eid
+                for attr, value in zip(attrs, newStats):
+                    setattr_deep(record, attr, value)
+                if detailed and len(newStats) > len(attrs):
+                    effects = newStats[-1]
+                    record.effects = []
+                    for effect in effects:
+                        neweffect = record.getDefault('effects')
+                        neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
+                        if len(scripteffect):
+                            scriptEffect = record.getDefault('effects.scriptEffect')
+                            script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile, scriptEffect.full = scripteffect
+                            scriptEffect.script = shortMapper(script)
+                            neweffect.scriptEffect = scriptEffect
+                        record.effects.append(neweffect)
+                record.setChanged()
         if changed: modFile.safeSave()
         return changed
 
-
     def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        class_fid_stats, aliases = self.class_fid_stats, self.aliases
+        """Imports stats from specified text file."""
+        detailed,aliases,spellTypeName_Number,levelTypeName_Number = self.detailed,self.aliases,self.spellTypeName_Number,self.levelTypeName_Number
+        fid_stats,recipientTypeName_Number,actorValueName_Number = self.fid_stats,self.recipientTypeName_Number,self.actorValueName_Number
         ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 6 or not fields[1].startswith('0x'): continue
-            mmod,mobj,value,eid,name,group = fields[:6]
-            mmod = GPath(_coerce(mmod, str))
-            longid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj, int, 16))
-            value = _coerce(value, int)
-            eid = _coerce(eid, str, AllowNone=True)
-            name = _coerce(name, str, AllowNone=True)
-            group = _coerce(group, str)
-            class_fid_stats[group][longid] = [value,eid,name]
-        ins.close()
-
-    def writeToText(self,textPath):
-        """Writes stats to specified text file."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
-        out = textPath.open('w')
-        def getSortedIds(stats):
-            longids = stats.keys()
-            longids.sort(key=lambda a: stats[a][0])
-            longids.sort(key=itemgetter(0))
-            return longids
-        format,header = bolt.csvFormat('iss'),('"' + '","'.join((_('Mod Name'),_('ObjectIndex'), _('Value'),_('Editor Id'),_('Name'),_('Type'))) + '"\n')
-        for group, fid_stats in sorted(class_fid_stats.iteritems()):
-            if not fid_stats: continue
-            out.write(Encode(header,'mbcs'))
-            for fid in sorted(fid_stats,key=lambda x: (fid_stats[x][1],fid_stats[x][0])):
-                out.write(Encode('"%s","0x%06X",' % (fid[0].s,fid[1]),'mbcs'))
-                out.write(format % tuple(fid_stats[fid]) + ',%s\n' % group)
-        out.close()
-class CBash_ItemPrices:
-    """Function for importing/exporting from/to mod/text file only the value, name and eid of records."""
-
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.class_fid_stats = {'ALCH':{},'AMMO':{},'APPA':{},'ARMO':{},'BOOK':{},'CLOT':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'SGST':{},'SLGM':{},'WEAP':{}}
-        self.attrs = ('value', 'eid', 'full')
-        self.aliases = aliases or {} #--For aliasing mod names
-
-    def readFromMod(self,modInfo):
-        """Reads data from specified mod."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ItemPrices:readFromMod"
-            print error[0]
-            return
-
-        for group, fid_stats in class_fid_stats.iteritems():
-            for record in getattr(modFile,group):
-                fid_stats[record.fid] = map(record.__getattribute__,attrs)
-                record.UnloadRecord()
-        del Current
-
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
         try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ItemPrices:writeToMod"
-            print error[0]
-            return
-
-        changed = {} #--changed[modName] = numChanged
-        for group, fid_stats in class_fid_stats.iteritems():
-            for fid, stats in fid_stats.iteritems():
-                record = modFile.LookupRecord(fid)
-                if record and record._Type == group:
-                    value = stats[0]
-                    if record.value != value:
-                        record.value = value
-                        changed[fid[0]] = changed.get(fid[0],0) + 1
-        if changed: modFile.save()
-        del Current
-        return changed
+            for fields in ins:
+                if len(fields) < 8 or fields[2][:2] != '0x': continue
+                group,mmod,mobj,eid,full,cost,levelType,spellType = fields[:8]
+                fields = fields[8:]
+                group = _coerce(group, str)
+                if group.lower() != 'spel': continue
+                mmod = _coerce(mmod, str)
+                mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+                eid = _coerce(eid, str, AllowNone=True)
+                full = _coerce(full, str, AllowNone=True)
+                cost = _coerce(cost, int)
+                levelType = _coerce(levelType, str)
+                levelType = levelTypeName_Number.get(levelType.lower(),_coerce(levelType,int) or 0)
+                spellType = _coerce(spellType, str)
+                spellType = spellTypeName_Number.get(spellType.lower(),_coerce(spellType,int) or 0)
+                if not detailed or len(fields) < 7:
+                    fid_stats[mid] = [eid,full,cost,levelType,spellType]
+                    continue
+                mc,ss,its,aeil,saa,daar,tewt = fields[:7]
+                fields = fields[7:]
+                mc = _coerce(mc, bool)
+                ss = _coerce(ss, bool)
+                its = _coerce(its, bool)
+                aeil = _coerce(aeil, bool)
+                saa = _coerce(saa, bool)
+                daar = _coerce(daar, bool)
+                tewt = _coerce(tewt, bool)
 
-    def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        class_fid_stats, aliases = self.class_fid_stats, self.aliases
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 6 or not fields[1].startswith('0x'): continue
-            mmod,mobj,value,eid,name,group = fields[:6]
-            mmod = GPath(_coerce(mmod, str))
-            longid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj, int, 16))
-            value = _coerce(value, int)
-            eid = _coerce(eid, str, AllowNone=True)
-            name = _coerce(name, str, AllowNone=True)
-            group = _coerce(group, str)
-            class_fid_stats[group][longid] = [value,eid,name]
-        ins.close()
+                effects = []
+                _effects = fields
+                while len(_effects) >= 13:
+                    _effect, _effects = _effects[1:13], _effects[13:]
+                    name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+                    name = _coerce(name, str, AllowNone=True)
+                    magnitude = _coerce(magnitude, int, AllowNone=True)
+                    area = _coerce(area, int, AllowNone=True)
+                    duration = _coerce(duration, int, AllowNone=True)
+                    range = _coerce(range, str, AllowNone=True)
+                    if range:
+                        range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+                    actorvalue = _coerce(actorvalue, str, AllowNone=True)
+                    if actorvalue:
+                        actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+                    if None in (name,magnitude,area,duration,range,actorvalue):
+                        continue
+                    effect = [name,magnitude,area,duration,range,actorvalue]
+                    semod = _coerce(semod, str, AllowNone=True)
+                    seobj = _coerce(seobj, int, 16, AllowNone=True)
+                    seschool = _coerce(seschool, int, AllowNone=True)
+                    sevisual = _coerce(sevisual, str, AllowNone=True)
+                    seflags = _coerce(seflags, bool, AllowNone=True)
+                    sename = _coerce(sename, str, AllowNone=True)
+                    if None in (semod,seobj,seschool,sevisual,seflags,sename):
+                        effect.append([])
+                    else:
+                        if sevisual.strip() == '':
+                            sevisual = '\x00\x00\x00\x00'
+                        sefid = (GPath(aliases.get(semod,semod)),seobj)
+                        effect.append([sefid, seschool, sevisual,seflags, sename])
+                    effects.append(effect)
+                fid_stats[mid] = [eid, full, cost, levelType, spellType, mc, ss, its, aeil, saa, daar, tewt, effects]
+        finally:
+            ins.close()
 
     def writeToText(self,textPath):
-        """Writes stats to specified text file."""
-        class_fid_stats, attrs = self.class_fid_stats, self.attrs
+        """Exports stats to specified text file."""
+        detailed,fid_stats,spellTypeNumber_Name,levelTypeNumber_Name = self.detailed,self.fid_stats,self.spellTypeNumber_Name,self.levelTypeNumber_Name
+        recipientTypeNumber_Name,actorValueNumber_Name = self.recipientTypeNumber_Name,self.actorValueNumber_Name
+        header = (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+                  _('Name'),_('Cost'),_('Level Type'),_('Spell Type'))
+        rowFormat = '"%s","%s","0x%06X","%s","%s","%d","%s","%s"'
+        if detailed:
+            header = header + (_('Manual Cost'),_('Start Spell'),_('Immune To Silence'),_('Area Effect Ignores LOS'),
+                               _('Script Always Applies'),_('Disallow Absorb and Reflect'),_('Touch Explodes Without Target'),
+                               _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+                               _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+                               _('Additional Effects (Same format)'))
+            rowFormat = rowFormat + ',"%s","%s","%s","%s","%s","%s","%s"'
+            effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+            scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
+            noscriptEffectFiller = ',"None","None","None","None","None","None"'
+        headFormat = '"%s",' * len(header)
+        headFormat = headFormat[:-1] + '\n' #chop trailing comma
+
         out = textPath.open('w')
-        def getSortedIds(stats):
-            longids = stats.keys()
-            longids.sort(key=lambda a: stats[a][0])
-            longids.sort(key=itemgetter(0))
-            return longids
-        format,header = bolt.csvFormat('iss'),('"' + '","'.join((_('Mod Name'),_('ObjectIndex'), _('Value'),_('Editor Id'),_('Name'),_('Type'))) + '"\n')
-        for group, fid_stats in sorted(class_fid_stats.iteritems()):
-            if not fid_stats: continue
-            out.write(Encode(header,'mbcs'))
-            for fid in sorted(fid_stats,key=lambda x: (fid_stats[x][1],fid_stats[x][0])):
-                out.write(Encode('"%s","0x%06X",' % (fid[0].s,fid[1]),'mbcs'))
-                out.write(format % tuple(fid_stats[fid]) + ',%s\n' % group)
+        out.write(Encode(headFormat % header,'mbcs'))
+        for fid in sorted(fid_stats,key = lambda x: (fid_stats[x][0],x[0])):
+            if detailed:
+                eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt,effects = fid_stats[fid]
+                levelType = levelTypeNumber_Name.get(levelType,levelType)
+                spellType = spellTypeNumber_Name.get(spellType,spellType)
+                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt)
+                for effect in effects:
+                    efname,magnitude,area,duration,range,actorvalue = effect[:-1]
+                    range = recipientTypeNumber_Name.get(range,range)
+                    actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+                    scripteffect = effect[-1]
+                    output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
+                    if len(scripteffect):
+                        longid,seschool,sevisual,seflags,sename = scripteffect
+                        if sevisual == '\x00\x00\x00\x00':
+                            sevisual = ''
+                        output += scriptEffectFormat % (Encode(longid[0].s,'mbcs'),longid[1],seschool,sevisual,seflags,sename)
+                    else:
+                        output += noscriptEffectFiller
+            else:
+                eid,name,cost,levelType,spellType = fid_stats[fid]
+                levelType = levelTypeNumber_Name.get(levelType,levelType)
+                spellType = spellTypeNumber_Name.get(spellType,spellType)
+                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType)
+            output += '\n'
+            out.write(output)
         out.close()
-#------------------------------------------------------------------------------
-class CompleteItemData:
-    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
 
+# class CBash_SpellRecords:
+#     """Statistics for spells, with functions for importing/exporting from/to mod/text file."""
+
+#     def __init__(self,types=None,aliases=None,detailed=False):
+#         """Initialize."""
+#         self.fid_stats = {}
+#         self.attrs = ('eid', 'full', 'cost', 'levelType', 'spellType')
+#         self.detailed = detailed
+#         if detailed:
+#             self.attrs = self.attrs + ('IsManualCost', 'IsStartSpell', 'IsSilenceImmune',
+#                                        'IsAreaEffectIgnoresLOS', 'IsScriptAlwaysApplies',
+#                                        'IsDisallowAbsorbReflect',
+#                                        'IsTouchExplodesWOTarget', 'effects_list')
+#         self.spellTypeNumber_Name = {None : 'NONE',
+#                                      0 : 'Spell',
+#                                      1 : 'Disease',
+#                                      2 : 'Power',
+#                                      3 : 'LesserPower',
+#                                      4 : 'Ability',
+#                                      5 : 'Poison',}
+#         self.spellTypeName_Number = dict([(y.lower(),x) for x,y in self.spellTypeNumber_Name.iteritems() if x is not None])
+
+#         self.levelTypeNumber_Name = {None : 'NONE',
+#                                      0 : 'Novice',
+#                                      1 : 'Apprentice',
+#                                      2 : 'Journeyman',
+#                                      3 : 'Expert',
+#                                      4 : 'Master',}
+#         self.levelTypeName_Number = dict([(y.lower(),x) for x,y in self.levelTypeNumber_Name.iteritems() if x is not None])
+
+#         self.recipientTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'Self',
+#             1 : 'Touch',
+#             2 : 'Target',}
+#         self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+
+#         self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+#         self.actorValueNumber_Name[None] = 'NONE'
+#         self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+
+#         self.aliases = aliases or {} #--For aliasing mod names
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         fid_stats, attrs = self.fid_stats, self.attrs
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_SpellRecords:readFromMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.SPEL:
+#             fid_stats[record.fid] = map(record.__getattribute__, attrs)
+#             record.UnloadRecord()
+
+#     def writeToMod(self,modInfo):
+#         """Writes stats to specified mod."""
+#         fid_stats, attrs = self.fid_stats, self.attrs
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_SpellRecords:writeToMod"
+#             print error[0]
+#             return
+
+#         changed = []
+#         for record in modFile.SPEL:
+#             newStats = fid_stats.get(record.fid, None)
+#             if not newStats: continue
+#             oldStats = map(record.__getattribute__,attrs)
+#             if oldStats != newStats:
+#                 changed.append(oldStats[0]) #eid
+#                 map(record.__setattr__,attrs,newStats)
+
+#         #--Done
+#         if changed: modFile.save()
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports stats from specified text file."""
+#         detailed,aliases,spellTypeName_Number,levelTypeName_Number = self.detailed,self.aliases,self.spellTypeName_Number,self.levelTypeName_Number
+#         fid_stats,recipientTypeName_Number,actorValueName_Number = self.fid_stats,self.recipientTypeName_Number,self.actorValueName_Number
+#         ins = bolt.CsvReader(textPath)
+#         try:
+#             for fields in ins:
+#                 if len(fields) < 8 or fields[2][:2] != '0x': continue
+#                 group,mmod,mobj,eid,full,cost,levelType,spellType = fields[:8]
+#                 fields = fields[8:]
+#                 group = _coerce(group, str)
+#                 if group.lower() != 'spel': continue
+#                 mmod = _coerce(mmod, str)
+#                 mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+#                 eid = _coerce(eid, str, AllowNone=True)
+#                 full = _coerce(full, str, AllowNone=True)
+#                 cost = _coerce(cost, int)
+#                 levelType = _coerce(levelType, str)
+#                 levelType = levelTypeName_Number.get(levelType.lower(),_coerce(levelType,int) or 0)
+#                 spellType = _coerce(spellType, str)
+#                 spellType = spellTypeName_Number.get(spellType.lower(),_coerce(spellType,int) or 0)
+#                 if not detailed or len(fields) < 7:
+#                     fid_stats[mid] = [eid,full,cost,levelType,spellType]
+#                     continue
+#                 mc,ss,its,aeil,saa,daar,tewt = fields[:7]
+#                 fields = fields[7:]
+#                 mc = _coerce(mc, bool)
+#                 ss = _coerce(ss, bool)
+#                 its = _coerce(its, bool)
+#                 aeil = _coerce(aeil, bool)
+#                 saa = _coerce(saa, bool)
+#                 daar = _coerce(daar, bool)
+#                 tewt = _coerce(tewt, bool)
+
+#                 effects = []
+#                 _effects = fields
+#                 while len(_effects) >= 13:
+#                     _effect, _effects = _effects[1:13], _effects[13:]
+#                     name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+#                     name = _coerce(name, str, AllowNone=True)
+#                     if name is not None:
+#                         name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
+#                     magnitude = _coerce(magnitude, int, AllowNone=True)
+#                     area = _coerce(area, int, AllowNone=True)
+#                     duration = _coerce(duration, int, AllowNone=True)
+#                     range = _coerce(range, str, AllowNone=True)
+#                     if range:
+#                         range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+#                     actorvalue = _coerce(actorvalue, str, AllowNone=True)
+#                     if actorvalue:
+#                         actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+#                     if None in (name,magnitude,area,duration,range,actorvalue):
+#                         continue
+#                     effect = [name,magnitude,area,duration,range,actorvalue]
+#                     semod = _coerce(semod, str, AllowNone=True)
+#                     seobj = _coerce(seobj, int, 16, AllowNone=True)
+#                     seschool = _coerce(seschool, int, AllowNone=True)
+#                     sevisual = _coerce(sevisual, str, AllowNone=True)
+#                     seflags = _coerce(seflags, bool, AllowNone=True)
+#                     sename = _coerce(sename, str, AllowNone=True)
+#                     if None in (semod,seobj,seschool,sevisual,seflags,sename):
+#                         effect.extend([None,None,None,None,None])
+#                     else:
+#                         sevisual = cast(sevisual, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
+#                         sefid = (GPath(aliases.get(semod,semod)),seobj)
+#                         effect.extend([sefid, seschool, sevisual,seflags, sename])
+#                     effects.append(tuple(effect))
+#                 fid_stats[mid] = [eid, full, cost, levelType, spellType, mc, ss, its, aeil, saa, daar, tewt, effects]
+#         finally:
+#             ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports stats to specified text file."""
+#         detailed,fid_stats,spellTypeNumber_Name,levelTypeNumber_Name = self.detailed,self.fid_stats,self.spellTypeNumber_Name,self.levelTypeNumber_Name
+#         recipientTypeNumber_Name,actorValueNumber_Name = self.recipientTypeNumber_Name,self.actorValueNumber_Name
+#         header = (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+#                   _('Name'),_('Cost'),_('Level Type'),_('Spell Type'))
+#         rowFormat = '"%s","%s","0x%06X","%s","%s","%d","%s","%s"'
+#         if detailed:
+#             header = header + (_('Manual Cost'),_('Start Spell'),_('Immune To Silence'),_('Area Effect Ignores LOS'),
+#                                _('Script Always Applies'),_('Disallow Absorb and Reflect'),_('Touch Explodes Without Target'),
+#                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+#                                _('Additional Effects (Same format)'))
+#             rowFormat = rowFormat + ',"%s","%s","%s","%s","%s","%s","%s"'
+#             effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+#             scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
+#             noscriptEffectFiller = ',"None","None","None","None","None","None"'
+#         headFormat = '"%s",' * len(header)
+#         headFormat = headFormat[:-1] + '\n' #chop trailing comma
+
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % header,'mbcs'))
+#         for fid in sorted(fid_stats,key = lambda x: (fid_stats[x][0],x[0])):
+#             if detailed:
+#                 eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt,effects = fid_stats[fid]
+#                 levelType = levelTypeNumber_Name.get(levelType,levelType)
+#                 spellType = spellTypeNumber_Name.get(spellType,spellType)
+#                 output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt)
+#                 for effect in effects:
+#                     efname,magnitude,area,duration,range,actorvalue = effect[:6]
+#                     efname = c_ulong(efname)
+#                     efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
+#                     range = recipientTypeNumber_Name.get(range,range)
+#                     actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+#                     output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
+#                     longid,seschool,sevisual,seflags,sename = effect[6:]
+#                     if None not in (longid,seschool,sevisual,seflags,sename):
+#                         sevisual = c_ulong(sevisual)
+#                         sevisual = cast(byref(sevisual), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
+#                         output += scriptEffectFormat % (Encode(longid[0].s,'mbcs'),longid[1],seschool,sevisual,seflags,sename)
+#                     else:
+#                         output += noscriptEffectFiller
+#             else:
+#                 eid,name,cost,levelType,spellType = fid_stats[fid]
+#                 levelType = levelTypeNumber_Name.get(levelType,levelType)
+#                 spellType = spellTypeNumber_Name.get(spellType,spellType)
+#                 output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType)
+#             output += '\n'
+#             out.write(output)
+#         out.close()
+#------------------------------------------------------------------------------
+class IngredientDetails:
+    """Details on Ingredients, with functions for importing/exporting from/to mod/text file."""
     def __init__(self,types=None,aliases=None):
         """Initialize."""
-        self.type_stats = {'ALCH':{},'AMMO':{},'APPA':{},'ARMO':{},'BOOK':{},'CLOT':{},'INGR':{},'KEYM':{},'LIGH':{},'MISC':{},'SGST':{},'SLGM':{},'WEAP':{}}
-        self.type_attrs = {
-            'ALCH':('eid', 'full', 'weight', 'value', 'iconPath', 'model','IsFood','IsNoAutoCalc','script','effects'), #TODO: proper effects export
-            'AMMO':('eid', 'full', 'weight', 'value', 'damage', 'speed', 'enchantPoints', 'iconPath','model','script','enchantment','IsNormal'),
-            'APPA':('eid', 'full', 'weight', 'value', 'quality', 'iconPath'),
-            'ARMO':('eid', 'full', 'weight', 'value', 'health', 'strength', 'maleIconPath', 'femaleIconPath'),
-            'BOOK':('eid', 'full', 'weight', 'value', 'enchantPoints', 'iconPath'),
-            'CLOT':('eid', 'full', 'weight', 'value', 'enchantPoints', 'maleIconPath', 'femaleIconPath'),
-            'INGR':('eid', 'full', 'weight', 'value', 'iconPath'),
-            'KEYM':('eid', 'full', 'weight', 'value', 'iconPath'),
-            'LIGH':('eid', 'full', 'weight', 'value', 'duration', 'iconPath'),
-            'MISC':('eid', 'full', 'weight', 'value', 'iconPath'),
-            'SGST':('eid', 'full', 'weight', 'value', 'uses', 'iconPath'),
-            'SLGM':('eid', 'full', 'weight', 'value', 'iconPath'),
-            'WEAP':('eid', 'full', 'weight', 'value', 'health', 'damage', 'speed', 'reach', 'enchantPoints', 'iconPath'),
-            }
-        self.aliases = aliases or {} #--For aliasing mod fulls
+        self.fid_stats = {}
+        self.aliases = aliases or {} #--For aliasing mod names
+        self.recipientTypeNumber_Name = {
+            None : 'NONE',
+            0 : 'Self',
+            1 : 'Touch',
+            2 : 'Target',}
+        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+        self.actorValueNumber_Name[None] = 'NONE'
+        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
 
     def readFromMod(self,modInfo):
         """Reads stats from specified mod."""
-        ###Remove from Bash after CBash integrated
-        if not CBash: #very lame though
-            self.model = {}
-            self.Mmodel = {}
-            self.Fmodel = {}
-            self.MGndmodel = {}
-            self.FGndmodel = {}
-            loadFactory= LoadFactory(False,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
-            modFile = ModFile(modInfo,loadFactory)
-            modFile.load(True)
-            mapper = modFile.getLongMapper()
-            for type in self.type_stats:
-                stats, attrs = self.type_stats[type], self.type_attrs[type]
-                for record in getattr(modFile,type).getActiveRecords():
-                    longid = mapper(record.fid)
-                    recordGetAttr = record.__getattribute__
-                    stats[longid] = tuple(recordGetAttr(attr) for attr in attrs)
-                    if type in ['ALCH','AMMO','APPA','BOOK','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']:
-                        if record.model:
-                            self.model[longid] = record.model.modPath
-                    elif type in ['CLOT','ARMO']:
-                        if record.maleBody:
-                            self.Mmodel[longid] = record.maleBody.modPath
-                        if record.maleWorld:
-                            self.MGndmodel[longid] = record.maleWorld.modPath
-                        if record.femaleBody:
-                            self.Fmodel[longid] = record.femaleBody.modPath
-                        if record.femaleWorld:
-                            self.FGndmodel[longid] = record.femaleWorld.modPath
-        else:
-            Current = ObCollection(ModsPath=dirs['mods'].s)
-            Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-            Current.load()
-            try:
-                modFile = Current.LookupModFile(modInfo.getPath().stail)
-            except KeyError, error:
-                print "CompleteItemData:readFromMod"
-                print error[0]
-                return
-
-            for type,stats in self.type_stats.iteritems():
-                if type in ['KEYM',]:
-                    for record in getattr(modFile,type):
-                        longid = record.fid
-                        stats[longid] = record.Export()
-                if type not in ['ALCH',]: continue
-                attrs = self.type_attrs[type]
-                for record in getattr(modFile,type):
-                    longid = record.fid
-                    stats[longid] = tuple(getattr(record,attr) for attr in attrs)
+        fid_stats = self.fid_stats
+        loadFactory= LoadFactory(False,MreIngr)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        modFile.convertToLongFids(['INGR'])
+        for record in modFile.INGR.getActiveRecords():
+            effects = []
+            for effect in record.effects:
+                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+                if effect.scriptEffect:
+                    effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
+                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+                else: effectlist.append([])
+                effects.append(effectlist)
+            fid_stats[record.fid] = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, record.script, record.value, round(record.weight,6), effects]
 
     def writeToMod(self,modInfo):
         """Writes stats to specified mod."""
-        ###Remove from Bash after CBash integrated
-##        if(CBash == None):
-        loadFactory= LoadFactory(True,MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreClot,MreIngr,MreKeym,MreLigh,MreMisc,MreSgst,MreSlgm,MreWeap)
+        fid_stats = self.fid_stats
+        loadFactory = LoadFactory(True,MreIngr)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
         mapper = modFile.getLongMapper()
-        changed = {} #--changed[modName] = numChanged
-        for type in self.type_stats:
-            stats, attrs = self.type_stats[type], self.type_attrs[type]
-            for record in getattr(modFile,type).getActiveRecords():
-                longid = mapper(record.fid)
-                itemStats = stats.get(longid,None)
-                if not itemStats: continue
-                map(record.__setattr__,attrs,itemStats)
-                record.setChanged()
-                changed[longid[0]] = 1 + changed.get(longid[0],0)
-        if changed: modFile.safeSave()
+        shortMapper = modFile.getShortMapper()
+        changed = [] #eids
+        for record in modFile.INGR.getActiveRecords():
+            newStats = fid_stats.get(mapper(record.fid), None)
+            if not newStats: continue
+            effects = []
+            for effect in record.effects:
+                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
+                if effect.scriptEffect:
+                    effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
+                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
+                else: effectlist.append([])
+                effects.append(effectlist)
+            oldStats = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, mapper(record.script), record.value, round(record.weight,6), effects]
+            if oldStats != newStats:
+                changed.append(oldStats[0]) #eid
+                record.eid, record.full, record.model.modPath, record.model.modb, record.iconPath, script, record.value, record.weight, effects = newStats
+                record.script = shortMapper(script)
+                record.effects = []
+                for effect in effects:
+                    neweffect = record.getDefault('effects')
+                    neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
+                    if len(scripteffect):
+                        scriptEffect = record.getDefault('effects.scriptEffect')
+                        script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile.hostile, scriptEffect.full = scripteffect
+                        scriptEffect.script = shortMapper(script)
+                        neweffect.scriptEffect = scriptEffect
+                    record.effects.append(neweffect)
+                record.setChanged()
+        if changed: modFile.safeSave()
         return changed
-##        else:
-##            Current = ObCollection(ModsPath=dirs['mods'].s)
-##            modFile = Current.addMod(modInfo.getPath().stail)
-##            Current.minimalLoad(LoadMasters=False)
-##
-##            changed = {} #--changed[modName] = numChanged
-##            for type,stats in self.type_stats.iteritems():
-##                attrs = self.type_attrs[type]
-##                for record in getattr(modFile,type):
-##                    longid = record.fid
-##                    itemStats = stats.get(longid,None)
-##                    if not itemStats: continue
-##                    for attr,stat in attrs,itemStats:
-##                        if(stat != "NONE"):
-##                            setattr(record,attr,stat)
-##                    changed[longid[0]] = 1 + changed.get(longid[0],0)
-##            if changed: modFile.save()
-##            return changed
 
     def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        alch, ammo, appa, armor, books, clothing, ingredients, keys, lights, misc, sigilstones, soulgems, weapons = [self.type_stats[type] for type in ('ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP')]
-        aliases = self.aliases
+        """Imports stats from specified text file."""
+        fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
         ins = bolt.CsvReader(textPath)
-        pack,unpack = struct.pack,struct.unpack
-        sfloat = lambda a: unpack('f',pack('f',float(a)))[0] #--Force standard precision
         for fields in ins:
-            if len(fields) < 3 or fields[2][:2] != '0x': continue
-            type,modName,objectStr,eid = fields[0:4]
-            modName = GPath(modName)
-            longid = (GPath(aliases.get(modName,modName)),int(objectStr[2:],16))
-            if type == 'ALCH':
-                alch[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value)
-                    zip((str,sfloat,int,str),fields[4:8]))
-            elif type == 'AMMO':
-                ammo[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, damage, speed, enchantPoints)
-                    zip((str,sfloat,int,int,sfloat,int,str),fields[4:11]))
-            elif type == 'APPA':
-                appa[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight,value,quantity)
-                    zip((str,sfloat,int,sfloat,str),fields[4:9]))
-            elif type == 'ARMO':
-                armor[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, health, strength)
-                    zip((str,sfloat,int,int,int,str,str),fields[4:10]))
-            elif type == 'BOOK':
-               books[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, echantPoints)
-                    zip((str,sfloat,int,int,str),fields[4:9]))
-            elif type == 'CLOT':
-                clothing[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, echantPoints)
-                    zip((str,sfloat,int,int,str,str),fields[4:10]))
-            elif type == 'INGR':
-                ingredients[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value)
-                    zip((str,sfloat,int,str),fields[4:8]))
-            elif type == 'KEYM':
-                keys[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value)
-                    zip((str,sfloat,int,str),fields[4:8]))
-            elif type == 'LIGH':
-               lights[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, duration)
-                    zip((str,sfloat,int,int,str),fields[4:9]))
-            elif type == 'MISC':
-                misc[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value)
-                    zip((str,sfloat,int,str),fields[4:8]))
-            elif type == 'SGST':
-               sigilstones[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, uses)
-                    zip((str,sfloat,int,int,str),fields[4:9]))
-            elif type == 'SLGM':
-                soulgems[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value)
-                    zip((str,sfloat,int,str),fields[4:8]))
-            elif type == 'WEAP':
-                weapons[longid] = (eid,) + tuple(func(field) for func,field in
-                    #--(weight, value, health, damage, speed, reach, epoints)
-                    zip((str,sfloat,int,int,int,sfloat,sfloat,int,str),fields[4:13]))
+            if len(fields) < 11 or fields[1][:2] != '0x': continue
+            mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,value,weight = fields[:11]
+            mmod = _coerce(mmod, str)
+            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+            smod = _coerce(smod, str, AllowNone=True)
+            if smod is None: sid = None
+            else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
+            eid = _coerce(eid, str, AllowNone=True)
+            full = _coerce(full, str, AllowNone=True)
+            modPath = _coerce(modPath, str, AllowNone=True)
+            modb = _coerce(modb, float)
+            iconPath = _coerce(iconPath, str, AllowNone=True)
+            value = _coerce(value, int)
+            weight = _coerce(weight, float)
+            effects = []
+            _effects = fields[11:]
+            while len(_effects) >= 13:
+                _effect, _effects = _effects[1:13], _effects[13:]
+                name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+                name = _coerce(name, str, AllowNone=True)
+                magnitude = _coerce(magnitude, int, AllowNone=True)
+                area = _coerce(area, int, AllowNone=True)
+                duration = _coerce(duration, int, AllowNone=True)
+                range = _coerce(range, str, AllowNone=True)
+                if range:
+                    range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+                actorvalue = _coerce(actorvalue, str, AllowNone=True)
+                if actorvalue:
+                    actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+                if None in (name,magnitude,area,duration,range,actorvalue):
+                    continue
+                effect = [name,magnitude,area,duration,range,actorvalue]
+                semod = _coerce(semod, str, AllowNone=True)
+                seobj = _coerce(seobj, int, 16, AllowNone=True)
+                seschool = _coerce(seschool, int, AllowNone=True)
+                sevisual = _coerce(sevisual, int, AllowNone=True)
+                seflags = _coerce(seflags, int, AllowNone=True)
+                sename = _coerce(sename, str, AllowNone=True)
+                if None in (semod,seobj,seschool,sevisual,seflags,sename):
+                    effect.append([])
+                else:
+                    sefid = (GPath(aliases.get(semod,semod)),seobj)
+                    effect.append([sefid, seschool, sevisual,seflags, sename])
+                effects.append(effect)
+            fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, value, weight, effects]
         ins.close()
 
     def writeToText(self,textPath):
-        """Writes stats to specified text file."""
+        """Exports stats to specified text file."""
+        fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
+        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+        rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%f"'
+        altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%f"'
+        effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+        scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
+        noscriptEffectFiller = ',"None","None","None","None","None","None"'
         out = textPath.open('w')
-        def getSortedIds(stats):
-            longids = stats.keys()
-            longids.sort(key=lambda a: stats[a][0])
-            longids.sort(key=itemgetter(0))
-            return longids
-        if not CBash:
-            for type,format,header in (
-                #--Alch
-                ('ALCH', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Ammo
-                ('AMMO', bolt.csvFormat('ssfiifiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Apparatus
-                ('APPA', bolt.csvFormat('ssfifss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Quantity'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Armor
-                ('ARMO', bolt.csvFormat('ssfiiissssss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),
-                    _('AR'),_('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
-                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
-                #Books
-                ('BOOK', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Clothing
-                ('CLOT', bolt.csvFormat('ssfiissssss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),
-                    _('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
-                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
-                #Ingredients
-                ('INGR', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Keys
-                ('KEYM', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Lights
-                ('LIGH', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Duration'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Misc
-                ('MISC', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Sigilstones
-                ('SGST', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Uses'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Soulgems
-                ('SLGM', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Weapons
-                ('WEAP', bolt.csvFormat('ssfiiiffiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('Damage'),
-                    _('Speed'),_('Reach'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
-                ):
-                stats = self.type_stats[type]
-                if not stats: continue
-                out.write('\n'+header)
-                for longid in getSortedIds(stats):
-                    out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
-                    tempstats = list(stats[longid])
-                    if type == 'ARMO' or type == 'CLOT':
-                        tempstats.append(self.Mmodel.get(longid, 'NONE'))
-                        tempstats.append(self.Fmodel.get(longid, 'NONE'))
-                        tempstats.append(self.MGndmodel.get(longid, 'NONE'))
-                        tempstats.append(self.FGndmodel.get(longid, 'NONE'))
-                    else:
-                        tempstats.append(self.model.get(longid, 'NONE'))
-                    finalstats = tuple(tempstats)
-                    out.write(format % finalstats)
-        else:
-            for type,format,header in (
-                ('ALCH', bolt.csvFormat('ssfissssss')+'\n', #--Potions
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),
-                    _('modPath'),_('IsFood'),_('IsNoAutoCalc'),_('Script'),_('Effects'))) + '"\n')),
-                ('AMMO', bolt.csvFormat('ssfiifisssss')+'\n', #--Ammo
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Damage'),_('Speed')
-                    ,_('Enchant Points'),_('Icon Path'),_('Model'),_('Script'),_('Enchantment'),_('Normal Weapon'))) + '"\n')),
-                #--Apparatus
-                ('APPA', bolt.csvFormat('ssfifss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Quantity'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Armor
-                ('ARMO', bolt.csvFormat('ssfiiissssss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),
-                    _('AR'),_('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
-                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
-                #Books
-                ('BOOK', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Clothing
-                ('CLOT', bolt.csvFormat('ssfiissssss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('EPoints'),
-                    _('Male Icon Path'),_('Female Icon Path'),_('Male Model Path'),
-                    _('Female Model Path'),_('Male World Model Path'),_('Female World Model Path'))) + '"\n')),
-                #Ingredients
-                ('INGR', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                ('KEYM', bolt.csvFormat('sssssssss')+'\n',     #--Keys
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Value'),_('Weight'),_('Model'),_('Icon'),_('Script'),_('MODB'),_('MODT_P'))) + '"\n')),
-
-                #Lights
-                ('LIGH', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Duration'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Misc
-                ('MISC', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Sigilstones
-                ('SGST', bolt.csvFormat('ssfiiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Uses'),_('Icon Path'),_('Model'))) + '"\n')),
-                #Soulgems
-                ('SLGM', bolt.csvFormat('ssfiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Icon Path'),_('Model'))) + '"\n')),
-                #--Weapons
-                ('WEAP', bolt.csvFormat('ssfiiiffiss')+'\n',
-                    ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                    _('Editor Id'),_('Name'),_('Weight'),_('Value'),_('Health'),_('Damage'),
-                    _('Speed'),_('Reach'),_('EPoints'),_('Icon Path'),_('Model'))) + '"\n')),
-                ):
-                stats = self.type_stats[type]
-                if not stats: continue
-                out.write('\n'+header)
-                if type != 'KEYM':
-                    for longid in getSortedIds(stats):
-                        out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
-                        out.write(format % stats[longid])
+        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+                                _('Name'),_('Model Path'),_('Bound Radius'),
+                                _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
+                                _('Value'),_('Weight'),
+                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
+                                ),'mbcs'))
+        for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
+            eid,name,modpath,modb,iconpath,scriptfid,value,weight,effects = fid_stats[fid]
+            scriptfid = scriptfid or (GPath('None'), None)
+            try:
+                output = rowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
+            except TypeError:
+                output = altrowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
+            for effect in effects:
+                efname,magnitude,area,duration,range,actorvalue = effect[:-1]
+                range = recipientTypeNumber_Name.get(range,range)
+                actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+                scripteffect = effect[-1]
+                output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
+                if len(scripteffect):
+                    longid,seschool,sevisual,seflags,sename = scripteffect
+                    if sevisual == '\x00\x00\x00\x00':
+                        sevisual = ''
+                    output += scriptEffectFormat % (longid[0].s,longid[1],seschool,sevisual,seflags,sename)
                 else:
-                    format = bolt.csvFormat('sssssssss')
-                    for longid in getSortedIds(stats):
-                        out.write('"%s","%s","0x%06X",' % (type,longid[0].s,longid[1]))
-                        out.write(format % stats[longid])
-                        out.write('\n')
+                    output += noscriptEffectFiller
+            output += '\n'
+            out.write(output)
         out.close()
+# class CBash_IngredientDetails:
+#     """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
+#     def __init__(self,types=None,aliases=None):
+#         """Initialize."""
+#         self.fid_stats = {}
+#         self.aliases = aliases or {} #--For aliasing mod names
+#         self.recipientTypeNumber_Name = {
+#             None : 'NONE',
+#             0 : 'Self',
+#             1 : 'Touch',
+#             2 : 'Target',}
+#         self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+#         self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
+#         self.actorValueNumber_Name[None] = 'NONE'
+#         self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+
+#     def readFromMod(self,modInfo):
+#         """Reads stats from specified mod."""
+#         fid_stats = self.fid_stats
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_IngredientDetails:readFromMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.INGR:
+#             fid_stats[record.fid] = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, record.effects_list]
+
+#     def writeToMod(self,modInfo):
+#         """Writes stats to specified mod."""
+#         fid_stats = self.fid_stats
+#         changed = []
+
+#         Current = ObCollection(ModsPath=dirs['mods'].s)
+#         Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
+#         Current.load()
+#         try:
+#             modFile = Current.LookupModFile(modInfo.getPath().stail)
+#         except KeyError, error:
+#             print "CBash_IngredientDetails:writeToMod"
+#             print error[0]
+#             return
+
+#         for record in modFile.INGR:
+#             newStats = fid_stats.get(record.fid, None)
+#             if not newStats: continue
+#             oldStats = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, record.effects_list]
+#             if oldStats != newStats:
+#                 changed.append(oldStats[0]) #eid
+#                 record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, effects = newStats
+#                 record.effects_list = effects
+#         if changed: modFile.save()
+#         return changed
+
+#     def readFromText(self,textPath):
+#         """Imports stats from specified text file."""
+#         fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 11 or fields[1][:2] != '0x': continue
+#             mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,value,weight = fields[:11]
+#             mmod = _coerce(mmod, str)
+#             mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
+#             smod = _coerce(smod, str, AllowNone=True)
+#             if smod is None: sid = None
+#             else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
+#             eid = _coerce(eid, str, AllowNone=True)
+#             full = _coerce(full, str, AllowNone=True)
+#             modPath = _coerce(modPath, str, AllowNone=True)
+#             modb = _coerce(modb, float)
+#             iconPath = _coerce(iconPath, str, AllowNone=True)
+#             value = _coerce(value, int)
+#             weight = _coerce(weight, float)
+#             effects = []
+#             _effects = fields[12:]
+#             while len(_effects) >= 13:
+#                 _effect, _effects = _effects[1:13], _effects[13:]
+#                 name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
+#                 name = _coerce(name, str, AllowNone=True)
+#                 name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
+#                 magnitude = _coerce(magnitude, int, AllowNone=True)
+#                 area = _coerce(area, int, AllowNone=True)
+#                 duration = _coerce(duration, int, AllowNone=True)
+#                 range = _coerce(range, str, AllowNone=True)
+#                 if range:
+#                     range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
+#                 actorvalue = _coerce(actorvalue, str, AllowNone=True)
+#                 if actorvalue:
+#                     actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
+#                 if None in (name,magnitude,area,duration,range,actorvalue):
+#                     continue
+#                 effect = [name,magnitude,area,duration,range,actorvalue]
+#                 semod = _coerce(semod, str, AllowNone=True)
+#                 seobj = _coerce(seobj, int, 16, AllowNone=True)
+#                 seschool = _coerce(seschool, int, AllowNone=True)
+#                 sevisual = _coerce(sevisual, int, AllowNone=True)
+#                 seflags = _coerce(seflags, int, AllowNone=True)
+#                 sename = _coerce(sename, str, AllowNone=True)
+#                 if None in (semod,seobj,seschool,sevisual,seflags,sename):
+#                     effect.extend([None,None,None,None,None])
+#                 else:
+#                     sefid = (GPath(aliases.get(semod,semod)),seobj)
+#                     effect.extend([sefid, seschool, sevisual,seflags, sename])
+#                 effects.append(tuple(effect))
+#             fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, value, weight, effects]
+#         ins.close()
+
+#     def writeToText(self,textPath):
+#         """Exports stats to specified text file."""
+#         fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
+#         headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
+#         rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%f"'
+#         altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%f"'
+#         effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
+#         scriptEffectFormat = ',"%s","0x%06X","%d","%d","%d","%s"'
+#         noscriptEffectFiller = ',"None","None","None","None","None","None"'
+#         out = textPath.open('w')
+#         out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
+#                                 _('Name'),_('Model Path'),_('Bound Radius'),
+#                                 _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
+#                                 _('Value'),_('Weight'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
+#                                 _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
+#                                 _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
+#                                 ),'mbcs'))
+#         for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
+#             eid,name,modpath,modb,iconpath,scriptfid,value,weight,effects = fid_stats[fid]
+#             scriptfid = scriptfid or (GPath('None'), None)
+#             try:
+#                 output = rowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
+#             except TypeError:
+#                 output = altrowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
+#             for effect in effects:
+#                 efname,magnitude,area,duration,range,actorvalue = effect[:6]
+#                 efname = c_ulong(efname)
+#                 efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
+#                 range = recipientTypeNumber_Name.get(range,range)
+#                 actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
+#                 scripteffect = effect[6:]
+#                 output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
+#                 if None not in scripteffect:
+#                     output += scriptEffectFormat % tuple(scripteffect)
+#                 else:
+#                     output += noscriptEffectFiller
+#             output += '\n'
+#             out.write(output)
+#         out.close()
+#------------------------------------------------------------------------------
+class ModDetails:
+    """Details data for a mods file. Similar to TesCS Details view."""
+    def __init__(self,modInfo=None,progress=None):
+        """Initialize."""
+        self.group_records = {} #--group_records[group] = [(fid0,eid0),(fid1,eid1),...]
 
-class CBash_CompleteItemData:
-    """Statistics for armor and weapons, with functions for importing/exporting from/to mod/text file."""
-    @staticmethod
-    def sstr(value):
-        return _coerce(value, str, AllowNone=True)
-
-    @staticmethod
-    def sfloat(value):
-        return _coerce(value, float, AllowNone=True)
-
-    @staticmethod
-    def sint(value):
-        return _coerce(value, int, AllowNone=True)
-
-    @staticmethod
-    def snoneint(value):
-        x = _coerce(value, int, AllowNone=True)
-        if x == 0: return None
-        return x
+    def readFromMod(self,modInfo,progress=None):
+        """Extracts details from mod file."""
+        def getRecordReader(ins,flags,size):
+            """Decompress record data as needed."""
+            if not MreRecord._flags1(flags).compressed:
+                return (ins,ins.tell()+size)
+            else:
+                import zlib
+                sizeCheck, = struct.unpack('I',ins.read(4))
+                decomp = zlib.decompress(ins.read(size-4))
+                if len(decomp) != sizeCheck:
+                    raise ModError(self.inName,
+                        _('Mis-sized compressed data. Expected %d, got %d.') % (size,len(decomp)))
+                reader = ModReader(modInfo.name,cStringIO.StringIO(decomp))
+                return (reader,sizeCheck)
+        progress = progress or bolt.Progress()
+        group_records = self.group_records = {}
+        records = group_records['TES4'] = []
+        ins = ModReader(modInfo.name,modInfo.getPath().open('rb'))
+        while not ins.atEnd():
+            (type,size,str0,fid,uint2,uint3) = ins.unpackRecHeader()
+            if type == 'GRUP':
+                progress(1.0*ins.tell()/modInfo.size,_("Scanning: ")+str0)
+                records = group_records.setdefault(str0,[])
+                if str0 in ('CELL','WRLD','DIAL'):
+                    ins.seek(size-recHeaderSize,1)
+            elif type != 'GRUP':
+                eid = ''
+                nextRecord = ins.tell() + size
+                recs,endRecs = getRecordReader(ins,str0,size)
+                while recs.tell() < endRecs:
+                    (type,size) = recs.unpackSubHeader()
+                    if type == 'EDID':
+                        eid = recs.readString(size)
+                        break
+                    recs.seek(size,1)
+                records.append((fid,eid))
+                ins.seek(nextRecord)
+        ins.close()
+        del group_records['TES4']
 
+#------------------------------------------------------------------------------
+class ModGroups:
+    """Groups for mods with functions for importing/exporting from/to text file."""
     @staticmethod
-    def sbool(value):
-        return _coerce(value, bool)
+    def filter(mods):
+        """Returns non-group header mods."""
+        return [x for x in mods if not reGroupHeader.match(x.s)]
 
-    def __init__(self,types=None,aliases=None):
+    def __init__(self):
         """Initialize."""
-        self.class_fid_values = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
-
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        class_fid_values = self.class_fid_values
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_CompleteItemData:readFromMod"
-            print error[0]
-            return
-
-        for group in pickupables:
-            for record in getattr(modFile,group):
-                values = ExtractExportList(record)
-                print values
-                print
-                print
-                class_fid_values.setdefault(group,{})[record.fid] = values
-                break
-        del Current
+        self.mod_group = {}
 
-    def writeToMod(self,modInfo):
-        """Exports type_id_name to specified mod."""
-        class_fid_attr_value = self.class_fid_attr_value
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_CompleteItemData:writeToMod"
-            print error[0]
-            return
+    def readFromModInfos(self,mods=None):
+        """Imports mods/groups from modInfos."""
+        column = modInfos.table.getColumn('group')
+        mods = ModGroups.filter(mods or column.keys())
+        groups = tuple(column.get(x) for x in mods)
+        self.mod_group.update((x,y) for x,y in zip(mods,groups) if y)
 
-        changed = {} #--changed[modName] = numChanged
-        for group, fid_attr_value in class_fid_attr_value.iteritems():
-            attrs = self.class_attrs[group]
-            for fid, attr_value in fid_attr_value.iteritems():
-                record = modFile.LookupRecord(fid)
-                if record and record._Type == group:
-                    oldValues = map(record.__getattribute__,attrs)
-                    if oldValues != attr_value:
-                        map(record.__setattr__,attrs, attr_value)
-                        changed[fid[0]] = 1 + changed.get(fid[0],0)
-        if changed: modFile.save()
+    def writeToModInfos(self,mods=None):
+        """Exports mod groups to modInfos."""
+        mods = ModGroups.filter(mods or modInfos.table.data.keys())
+        mod_group = self.mod_group
+        column = modInfos.table.getColumn('group')
+        changed = 0
+        for mod in mods:
+            if mod in mod_group and column.get(mod) != mod_group[mod]:
+                column[mod] = mod_group[mod]
+                changed += 1
         return changed
 
-    def readEffectsFromText(self, fields):
-        effects = []
-        _effects = fields[12:]
-        while len(_effects) >= 13:
-            _effect, _effects = _effects[1:13], _effects[13:]
-            name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-            name = _coerce(name, str, AllowNone=True)
-            name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
-            magnitude = _coerce(magnitude, int, AllowNone=True)
-            area = _coerce(area, int, AllowNone=True)
-            duration = _coerce(duration, int, AllowNone=True)
-            range = _coerce(range, str, AllowNone=True)
-            if range:
-                range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-            actorvalue = _coerce(actorvalue, str, AllowNone=True)
-            if actorvalue:
-                actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-            if None in (name,magnitude,area,duration,range,actorvalue):
-                continue
-            effect = [name,magnitude,area,duration,range,actorvalue]
-            semod = _coerce(semod, str, AllowNone=True)
-            seobj = _coerce(seobj, int, 16, AllowNone=True)
-            seschool = _coerce(seschool, int, AllowNone=True)
-            sevisual = _coerce(sevisual, int, AllowNone=True)
-            seflags = _coerce(seflags, int, AllowNone=True)
-            sename = _coerce(sename, str, AllowNone=True)
-            if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                effect.extend([None,None,None,None,None])
-            else:
-                sefid = (GPath(aliases.get(semod,semod)),seobj)
-                effect.extend([sefid, seschool, sevisual,seflags, sename])
-            effects.append(tuple(effect))
-        return effects
-
-    def readSGSTFromText(self, fields):
-        aliases = self.aliases
-        eid,full,weight,value,uses,iconPath,modPath,modb,smod,sobj = fields[:10]
-        fields = fields[:10]
-        smod = _coerce(smod, str, AllowNone=True)
-        if smod is None: sid = None
-        else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
-        eid = _coerce(eid, str, AllowNone=True)
-        full = _coerce(full, str, AllowNone=True)
-        modPath = _coerce(modPath, str, AllowNone=True)
-        modb = _coerce(modb, float)
-        iconPath = _coerce(iconPath, str, AllowNone=True)
-        uses = _coerce(uses, int)
-        value = _coerce(value, int)
-        weight = _coerce(weight, float)
-        effects = readEffectsFromText(fields)
-        return [eid, full, weight, value, uses, iconPath, modPath, modb, sid, effects]
-
     def readFromText(self,textPath):
-        """Reads stats from specified text file."""
-        class_fid_attr_value, aliases = self.class_fid_attr_value, self.aliases
+        """Imports mod groups from specified text file."""
+        textPath = GPath(textPath)
+        mod_group = self.mod_group
         ins = bolt.CsvReader(textPath)
-        attr_type = self.attr_type
         for fields in ins:
-            if len(fields) < 3 or fields[2][:2] != '0x': continue
-            group,modName,objectStr = fields[:3]
-            fields = fields[3:]
-            modName = GPath(_coerce(modName,str))
-            longid = (GPath(aliases.get(modName,modName)),_coerce(objectStr,int,16))
-            attrs = self.class_attrs[group]
-            if group == 'ALCH':
-                pass
-            elif group == 'AMMO':
-                pass
-            elif group == 'SGST':
-                class_fid_attr_value[group][longid] = readSGSTFields(fields)
+            if len(fields) >= 2 and reModExt.search(fields[0]):
+               mod,group = fields[:2]
+               mod_group[GPath(mod)] = group
         ins.close()
 
     def writeToText(self,textPath):
-        return
-        """Writes stats to specified text file."""
-        class_fid_attr_value = self.class_fid_attr_value
+        """Exports eids to specified text file."""
+        textPath = GPath(textPath)
+        mod_group = self.mod_group
+        rowFormat = '"%s","%s"\n'
         out = textPath.open('w')
-        def getSortedIds(fid_attr_value):
-            longids = fid_attr_value.keys()
-            longids.sort(key=lambda a: fid_attr_value[a]['eid'])
-            longids.sort(key=itemgetter(0))
-            return longids
-        def write(out, attrs, values):
-            attr_type = self.attr_type
-            csvFormat = ''
-            sstr = self.sstr
-            sint = self.sint
-            snoneint = self.snoneint
-            sfloat = self.sfloat
-            for index, attr in enumerate(attrs):
-                stype = attr_type[attr]
-                values[index] = stype(values[index]) #sanitize output
-                if values[index] is None: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sstr: csvFormat += ',"{0[%d]}"' % index
-                elif stype is sint or stype is snoneint: csvFormat += ',"{0[%d]:d}"' % index
-                elif stype is sfloat: csvFormat += ',"{0[%d]:f}"' % index
-            csvFormat = csvFormat[1:] #--Chop leading comma
-            out.write(csvFormat.format(values) + '\n')
-        for group,header in (
-            #--Alch
-            ('ALCH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Ammo
-            ('AMMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Damage'),_('Speed'),_('EPoints'))) + '"\n')),
-            #--Apparatus
-            ('APPA',
-                ('"' + '","'.join((_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Quality'))) + '"\n')),
-            #--Armor
-            ('ARMO',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('AR'))) + '"\n')),
-            #Books
-            ('BOOK',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Clothing
-            ('CLOT',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('EPoints'))) + '"\n')),
-            #Ingredients
-            ('INGR',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Keys
-            ('KEYM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Lights
-            ('LIGH',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Duration'))) + '"\n')),
-            #--Misc
-            ('MISC',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #Sigilstones
-            ('SGST',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Uses'))) + '"\n')),
-            #Soulgems
-            ('SLGM',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'))) + '"\n')),
-            #--Weapons
-            ('WEAP',
-                ('"' + '","'.join((_('Type'),_('Mod Name'),_('ObjectIndex'),
-                _('Editor Id'),_('Weight'),_('Value'),_('Health'),_('Damage'),
-                _('Speed'),_('Reach'),_('EPoints'))) + '"\n')),
-            ):
-            fid_attr_value = class_fid_attr_value[group]
-            if not fid_attr_value: continue
-            attrs = self.class_attrs[group]
-            out.write(header)
-            for longid in getSortedIds(fid_attr_value):
-                out.write('"%s","%s","0x%06X",' % (group,longid[0].s,longid[1]))
-                attr_value = fid_attr_value[longid]
-                write(out, attrs, map(attr_value.get, attrs))
+        out.write(Encode(rowFormat % (_("Mod"),_("Group")),'mbcs'))
+        for mod in sorted(mod_group):
+            out.write(rowFormat % (mod.s,mod_group[mod]))
         out.close()
 
 #------------------------------------------------------------------------------
-class ScriptText:
-    """import & export functions for script text."""
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.eid_data = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-
-    def readFromMod(self, modInfo, file):
-        """Reads stats from specified mod."""
-        eid_data = self.eid_data
-        loadFactory= LoadFactory(False,MreScpt)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        mapper = modFile.getLongMapper()
+class PCFaces:
+    """Package: Objects and functions for working with face data."""
+    flags = Flags(0L,Flags.getNames('name','race','gender','hair','eye','iclass','stats','factions','modifiers','spells'))
 
-        with balt.Progress(_("Export Scripts")) as progress:
-            records = modFile.SCPT.getActiveRecords()
-            y = len(records)
-            z = 0
-            for record in records:
-                z += 1
-                progress((0.5/y*z),_("Reading scripts in %s.")%(file))
-                eid_data[record.eid] = (record.scriptText, mapper(record.fid))
+    class PCFace(object):
+        """Represents a face."""
+        __slots__ = ('masters','eid','pcName','race','gender','eye','hair',
+            'hairLength','hairRed','hairBlue','hairGreen','unused3','fggs_p','fgga_p','fgts_p','level','attributes',
+            'skills','health','unused2','baseSpell','fatigue','iclass','factions','modifiers','spells')
+        def __init__(self):
+            self.masters = []
+            self.eid = self.pcName = 'generic'
+            self.fggs_p = self.fgts_p = '\x00'*4*50
+            self.fgga_p = '\x00'*4*30
+            self.unused2 = null2
+            self.health = self.unused3 = self.baseSpell = self.fatigue = self.level = 0
+            self.skills = self.attributes = self.iclass = None
+            self.factions = []
+            self.modifiers = []
+            self.spells = []
 
-    def writeToMod(self, modInfo, makeNew=False):
-        """Writes scripts to specified mod."""
-        eid_data = self.eid_data
-        changed = []
-        added = []
-        loadFactory = LoadFactory(True,MreScpt)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
+        def getGenderName(self):
+            return self.gender and 'Female' or 'Male'
 
-        for record in modFile.SCPT.getActiveRecords():
-            eid = record.eid
-            data = eid_data.get(eid,None)
-            if data is not None:
-                newText, longid = data
-                oldText = record.scriptText
-                if oldText.lower() != newText.lower():
-                    record.scriptText = newText
-                    record.setChanged()
-                    changed.append(eid)
-                del eid_data[eid]
-        if makeNew and eid_data:
-            tes4 = modFile.tes4
-            for eid, data in eid_data.iteritems():
-                newText, longid = data
-                scriptFid = genFid(len(tes4.masters),tes4.getNextObject())
-                newScript = MreScpt(('SCPT',0,0x40000,scriptFid,0))
-                newScript.eid = eid
-                newScript.scriptText = newText
-                newScript.setChanged()
-                modFile.SCPT.records.append(newScript)
-                added.append(eid)
-        if changed or added: modFile.safeSave()
-        return (changed, added)
+        def getRaceName(self):
+            return bush.raceNames.get(self.race,_('Unknown'))
 
-    def readFromText(self,textPath,modInfo):
-        """Reads scripts from files in specified mods' directory in bashed patches folder."""
-        eid_data, aliases = self.eid_data, self.aliases
-        with balt.Progress(_("Import Scripts")) as progress:
-            for root, dirs, files in os.walk(textPath):
-                y = len(files)
-                z = 0
-                for name in files:
-                    z += 1
-                    nPath = GPath(name)
-                    if(nPath.cext != inisettings['ScriptFileExt']):
-                        progress(((1/y)*z),_("Skipping file %s.") % (name))
-                        continue
-                    progress(((1/y)*z),_("Reading file %s.") % (name))
-                    ## Python 2.6+ syntax disabled for Python 2.5 compatibility
-                    ## with open(os.path.join(root, name),"r") as text:
-                    try:
-                        text = open(os.path.join(root, name),"r")
-                        lines = text.readlines()
-                    finally:
-                        text.close()
-                    try:
-                        modName,FormID,eid = lines[0][1:-1],lines[1][1:-1],lines[2][1:-1]
-                    except:
-                        deprint("%s has malformed script header lines - was skipped" % name)
-                        continue
-                    scriptText = ''.join(lines[3:]).replace('\n','\r\n') #because the cs reads\writes EOLs in \r\n format.
-                    eid_data[eid] = (scriptText, FormID)
-        if eid_data: return True
-        return False
+        def convertRace(self,fromRace,toRace):
+            """Converts face from one race to another while preserving structure, etc."""
+            for attr,num in (('fggs_p',50),('fgga_p',30),('fgts_p',50)):
+                format = `num`+'f'
+                sValues = list(struct.unpack(format,getattr(self,attr)))
+                fValues = list(struct.unpack(format,getattr(fromRace,attr)))
+                tValues = list(struct.unpack(format,getattr(toRace,attr)))
+                for index,(sValue,fValue,tValue) in enumerate(zip(sValues,fValues,tValues)):
+                    sValues[index] = sValue + fValue - tValue
+                setattr(self,attr,struct.pack(format,*sValues))
 
-    def writeToText(self,textPath,skip,folder,deprefix,esp):
-        """Writes stats to specified text file."""
-        eid_data = self.eid_data
-        x = len(skip)
-        exportedScripts = []
-        y = len(eid_data)
-        z = 0
-        num = 0
-        r = len(deprefix)
-        with balt.Progress(_("Export Scripts")) as progress:
-            for eid in sorted(eid_data, key=lambda b: (b, eid_data[b][1])):
-                text, longid = eid_data[eid]
-                z += 1
-                progress((0.5+0.5/y*z),_("Exporting script %s.") % (eid))
-                if x == 0 or skip.lower() != eid[:x].lower():
-                    fileName = eid
-                    if r >= 1 and deprefix == fileName[:r]:
-                        fileName = fileName[r:]
-                    num += 1
-                    outpath = dirs['patches'].join(folder).join(fileName+inisettings['ScriptFileExt'])
-                    with outpath.open('wb') as out:
-                        formid = '0x%06X' %(longid[1])
-                        out.write(';'+Encode(longid[0].s,'mbcs')+'\r\n;'+formid+'\r\n;'+eid+'\r\n'+text)
-                    exportedScripts.append(eid)
-        return (_('Exported %d scripts from %s:\n') % (num,esp)+'\n'.join(exportedScripts))
+    # SAVES -------------------------------------------------------------------
+    @staticmethod
+    def save_getNamePos(saveName,data,pcName):
+        """Safely finds position of name within save ACHR data."""
+        namePos = data.find(pcName)
+        if namePos == -1:
+            raise SaveFileError(saveName,_('Failed to find pcName in PC ACHR record.'))
+        namePos2 = data.find(pcName,namePos+1)
+        if namePos2 != -1:
+            raise SaveFileError(saveName,_(
+                'Uncertain about position of face data, probably because '
+                'player character name is too short. Try renaming player '
+                'character in save game.'))
+        return namePos
 
-class CBash_ScriptText:
-    """import & export functions for script text."""
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.eid_data = {}
-        self.aliases = aliases or {} #--For aliasing mod names
+    # Save Get ----------------------------------------------------------------
+    @staticmethod
+    def save_getFace(saveFile):
+        """DEPRECATED. Same as save_getPlayerFace(saveFile)."""
+        return PCFaces.save_getPlayerFace(saveFile)
 
-    def readFromMod(self, modInfo, file):
-        """Reads stats from specified mod."""
-        eid_data = self.eid_data
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ScriptText:readFromMod"
-            print error[0]
-            return
+    @staticmethod
+    def save_getFaces(saveFile):
+        """Returns player and created faces from a save file or saveInfo."""
+        if isinstance(saveFile,SaveInfo):
+            saveInfo = saveFile
+            saveFile = SaveFile(saveInfo)
+            saveFile.load()
+        faces = PCFaces.save_getCreatedFaces(saveFile)
+        playerFace = PCFaces.save_getPlayerFace(saveFile)
+        faces[7] = playerFace
+        return faces
 
-        progress = balt.Progress(_("Export Scripts"))
-        try:
-            records = modFile.SCPT
-            y = len(records)
-            z = 0
-            for record in records:
-                z += 1
-                progress((0.5/y*z),_("Reading scripts in %s.") % (file))
-                eid_data[record.eid] = (record.scriptText, record.fid)
-                record.UnloadRecord()
-        finally: #just to ensure the progress bar gets destroyed
-            progress = progress.Destroy()
-            del Current
+    @staticmethod
+    def save_getCreatedFace(saveFile,targetid):
+        """Gets a particular created face."""
+        return PCFaces.save_getCreatedFaces(saveFile,targetid).get(targetid)
 
-    def writeToMod(self, modInfo, makeNew=False):
-        """Writes scripts to specified mod."""
-        eid_data = self.eid_data
-        changed = []
-        added = []
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_ScriptText:writeToMod"
-            print error[0]
-            return
+    @staticmethod
+    def save_getCreatedFaces(saveFile,targetid=None):
+        """Returns created faces from savefile. If fid is supplied, will only
+        return created face with that fid.
+        Note: Created NPCs do NOT use irefs!"""
+        targetid = bolt.intArg(targetid)
+        if isinstance(saveFile,SaveInfo):
+            saveInfo = saveFile
+            saveFile = SaveFile(saveInfo)
+            saveFile.load()
+        faces = {}
+        for record in saveFile.created:
+            if record.recType != 'NPC_': continue
+            #--Created NPC record
+            if targetid and record.fid != targetid: continue
+            npc = record.getTypeCopy()
+            face = faces[npc.fid] = PCFaces.PCFace()
+            face.masters = saveFile.masters
+            for attr in ('eid','race','eye','hair','hairLength',
+                         'hairRed','hairBlue','hairGreen','unused3',
+                         'fggs_p','fgga_p','fgts_p','level','skills',
+                         'health','unused2','baseSpell', 'fatigue',
+                         'attributes','iclass'):
+                setattr(face,attr,getattr(npc,attr))
+            face.gender = (0,1)[npc.flags.female]
+            face.pcName = npc.full
+            #--Changed NPC Record
+            PCFaces.save_getChangedNpc(saveFile,record.fid,face)
+        return faces
 
-        for record in modFile.SCPT:
-            eid = record.eid
-            data = eid_data.get(eid,None)
-            if data is not None:
-                newText, longid = data
-                oldText = record.scriptText
-                if oldText != newText:
-                    record.scriptText = newText
-                    changed.append(eid)
-                del eid_data[eid]
-        if makeNew and eid_data:
-            for eid, data in eid_data.iteritems():
-                newText, longid = data
-                newScript = modFile.create_SCPT()
-                if newScript is not None:
-                    newScript.eid = eid
-                    newScript.scriptText = newText
-                    added.append(eid)
-        if changed or added: modFile.save()
-        del Current
-        return (changed, added)
-
-    def readFromText(self,textPath,modInfo):
-        """Reads scripts from files in specified mods' directory in bashed patches folder."""
-        eid_data, aliases = self.eid_data, self.aliases
-        with balt.Progress(_("Import Scripts")) as progress:
-            for root, dirs, files in os.walk(textPath):
-                y = len(files)
-                z = 0
-                for name in files:
-                    z += 1
-                    nPath = GPath(name)
-                    if(nPath.cext != inisettings['ScriptFileExt']):
-                        progress(((1/y)*z),_("Skipping file %s.") % (name))
-                        continue
-                    progress(((1/y)*z),_("Reading file %s.") % (name))
-                    ## Python 2.6+ syntax disabled for Python 2.5 compatibility
-                    ## with open(os.path.join(root, name),"r") as text:
-                    try:
-                        text = open(os.path.join(root, name),"r")
-                        lines = text.readlines()
-                    finally:
-                        text.close()
-                    modName,FormID,eid = lines[0][1:-1],lines[1][1:-1],lines[2][1:-1]
-                    scriptText = ''.join(lines[3:]).replace('\n','\r\n') #because the cs writes it in \r\n format.
-                    eid_data[ISTRING(eid)] = (ISTRING(scriptText), FormID) #script text is case insensitive
-        if eid_data: return True
-        return False
-
-    def writeToText(self,textPath,skip,folder,deprefix,esp):
-        """Writes stats to specified text file."""
-        eid_data = self.eid_data
-        x = len(skip)
-        exportedScripts = []
-        y = len(eid_data)
-        z = 0
-        num = 0
-        r = len(deprefix)
-        with balt.Progress(_("Export Scripts")) as progress:
-            for eid in sorted(eid_data, key=lambda b: (b, eid_data[b][1])):
-                text, longid = eid_data[eid]
-                z += 1
-                progress((0.5+0.5/y*z),_("Exporting script %s.") % (eid))
-                if x == 0 or skip.lower() != eid[:x].lower():
-                    fileName = eid
-                    if r >= 1 and deprefix == fileName[:r]:
-                        fileName = fileName[r:]
-                    num += 1
-                    outpath = dirs['patches'].join(folder).join(fileName+inisettings['ScriptFileExt'])
-                    with outpath.open('wb') as out:
-                        formid = '0x%06X' %(longid[1])
-                        try:
-                            out.write(';'+Encode(longid[0].s,'mbcs')+'\r\n;'+formid+'\r\n;'+eid+'\r\n'+text)
-                        except UnicodeDecodeError:
-                            try:
-                                out.write((';'.decode('cp1252')+longid[0].s.decode('cp1252')+'\r\n;'.decode('cp1252')+formid.decode('cp1252')+'\r\n;'.decode('cp1252')+eid.decode('cp1252')+'\r\n'+text.decode('cp1252')).encode('cp1252'))
-                            except UnicodeDecodeError, err:
-                                print err
-                                print outpath
-                                print ';',longid[0].s,'\r\n;',formid,'\r\n;',eid,'\r\n',text
-                            except UnicodeEncodeError, err:
-                                print err
-                                print outpath
-                                print ';',longid[0].s,'\r\n;',formid,'\r\n;',eid,'\r\n',text
-                    exportedScripts.append(eid)
-        return (_('Exported %d scripts from %s:\n') % (num,esp)+'\n'.join(exportedScripts))
+    @staticmethod
+    def save_getChangedNpc(saveFile,fid,face=None):
+        """Update face with data from npc change record."""
+        face = face or PCFaces.PCFace()
+        changeRecord = saveFile.getRecord(fid)
+        if not changeRecord:
+            return face
+        fid,recType,recFlags,version,data = changeRecord
+        npc = SreNPC(recFlags,data)
+        if npc.acbs:
+            face.gender = npc.acbs.flags.female
+            face.level = npc.acbs.level
+            face.baseSpell = npc.acbs.baseSpell
+            face.fatigue = npc.acbs.fatigue
+        for attr in ('attributes','skills','health','unused2'):
+            value = getattr(npc,attr)
+            if value != None:
+                setattr(face,attr,value)
+        #--Iref >> fid
+        getFid = saveFile.getFid
+        face.spells = [getFid(x) for x in (npc.spells or [])]
+        face.factions = [(getFid(x),y) for x,y in (npc.factions or [])]
+        face.modifiers = (npc.modifiers or [])[:]
+        #delist('npc.spells:',[strFid(x) for x in face.spells])
+        #delist('npc.factions:',face.factions)
+        #delist('npc.modifiers:',face.modifiers)
+        return face
 
-#------------------------------------------------------------------------------
-class SpellRecords:
-    """Statistics for spells, with functions for importing/exporting from/to mod/text file."""
+    @staticmethod
+    def save_getPlayerFace(saveFile):
+        """Extract player face from save file."""
+        if isinstance(saveFile,SaveInfo):
+            saveInfo = saveFile
+            saveFile = SaveFile(saveInfo)
+            saveFile.load()
+        face = PCFaces.PCFace()
+        face.pcName = saveFile.pcName
+        face.masters = saveFile.masters
+        #--Player ACHR
+        record = saveFile.getRecord(0x14)
+        data = record[-1]
+        namePos = PCFaces.save_getNamePos(saveFile.fileInfo.name,data,saveFile.pcName)
+        (face.fggs_p, face.fgga_p, face.fgts_p, face.race, face.hair, face.eye,
+            face.hairLength, face.hairRed, face.hairBlue, face.hairGreen, face.unused3, face.gender) = struct.unpack(
+            '=200s120s200s3If3BsB',data[namePos-542:namePos-1])
+        classPos = namePos+len(saveFile.pcName)+1
+        face.iclass, = struct.unpack('I',data[classPos:classPos+4])
+        #--Iref >> fid
+        getFid = saveFile.getFid
+        face.race = getFid(face.race)
+        face.hair = getFid(face.hair)
+        face.eye = getFid(face.eye)
+        face.iclass = getFid(face.iclass)
+        #--Changed NPC Record
+        PCFaces.save_getChangedNpc(saveFile,7,face)
+        #--Done
+        return face
 
-    def __init__(self,types=None,aliases=None,detailed=False):
-        """Initialize."""
-        self.fid_stats = {}
-        self.attrs = ('eid', 'full', 'cost', 'level', 'spellType')
-        self.detailed = detailed
-        if detailed:
-            self.attrs = self.attrs + ('flags.noAutoCalc', 'flags.startSpell', 'flags.immuneToSilence',
-                                       'flags.ignoreLOS', 'flags.scriptEffectAlwaysApplies',
-                                       'flags.disallowAbsorbReflect',
-                                       'flags.touchExplodesWOTarget') #, 'effects_list' is special cased
-        self.spellTypeNumber_Name = {None : 'NONE',
-                                     0 : 'Spell',
-                                     1 : 'Disease',
-                                     2 : 'Power',
-                                     3 : 'LesserPower',
-                                     4 : 'Ability',
-                                     5 : 'Poison',}
-        self.spellTypeName_Number = dict([(y.lower(),x) for x,y in self.spellTypeNumber_Name.iteritems() if x is not None])
+    # Save Set ----------------------------------------------------------------
+    @staticmethod
+    def save_setFace(saveInfo,face,flags=0L):
+        """DEPRECATED. Write a pcFace to a save file."""
+        saveFile = SaveFile(saveInfo)
+        saveFile.load()
+        PCFaces.save_setPlayerFace(saveFile,face,flags)
+        saveFile.safeSave()
 
-        self.levelTypeNumber_Name = {None : 'NONE',
-                                     0 : 'Novice',
-                                     1 : 'Apprentice',
-                                     2 : 'Journeyman',
-                                     3 : 'Expert',
-                                     4 : 'Master',}
-        self.levelTypeName_Number = dict([(y.lower(),x) for x,y in self.levelTypeNumber_Name.iteritems() if x is not None])
+    @staticmethod
+    def save_setCreatedFace(saveFile,targetid,face):
+        """Sets created face in savefile to specified face.
+        Note: Created NPCs do NOT use irefs!"""
+        targetid = bolt.intArg(targetid)
+        #--Find record
+        for index,record in enumerate(saveFile.created):
+            if record.fid == targetid:
+                npc = record.getTypeCopy()
+                saveFile.created[index] = npc
+                break
+        else:
+            raise StateError("Record %08X not found in %s." % (targetid,saveFile.fileInfo.name.s))
+        if npc.recType != 'NPC_':
+            raise StateError("Record %08X in %s is not an NPC." % (targetid,saveFile.fileInfo.name.s))
+        #--Update masters
+        for fid in (face.race, face.eye, face.hair):
+            if not fid: continue
+            maxMaster = len(face.masters)-1
+            mod = getModIndex(fid)
+            master = face.masters[min(mod,maxMaster)]
+            if master not in saveFile.masters:
+                saveFile.masters.append(master)
+        masterMap = MasterMap(face.masters,saveFile.masters)
+        #--Set face
+        npc.full = face.pcName
+        npc.flags.female = (face.gender & 0x1)
+        npc.setRace(masterMap(face.race,0x00907)) #--Default to Imperial
+        npc.eye = masterMap(face.eye,None)
+        npc.hair = masterMap(face.hair,None)
+        npc.hairLength = face.hairLength
+        npc.hairRed = face.hairRed
+        npc.hairBlue = face.hairBlue
+        npc.hairGreen = face.hairGreen
+        npc.unused3 = face.unused3
+        npc.fggs_p = face.fggs_p
+        npc.fgga_p = face.fgga_p
+        npc.fgts_p = face.fgts_p
+        #--Stats: Skip Level, baseSpell, fatigue and factions since they're discarded by game engine.
+        if face.skills: npc.skills = face.skills
+        if face.health:
+            npc.health = face.health
+            npc.unused2 = face.unused2
+        if face.attributes: npc.attributes = face.attributes
+        if face.iclass: npc.iclass = face.iclass
+        npc.setChanged()
+        npc.getSize()
 
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+        #--Change record?
+        changeRecord = saveFile.getRecord(npc.fid)
+        if changeRecord == None: return
+        fid,recType,recFlags,version,data = changeRecord
+        npc = SreNPC(recFlags,data)
+        if not npc.acbs: npc.acbs = npc.getDefault('acbs')
+        npc.acbs.flags.female = face.gender
+        npc.acbs.level = face.level
+        npc.acbs.baseSpell = face.baseSpell
+        npc.acbs.fatigue = face.fatigue
+        npc.modifiers = face.modifiers[:]
+        #--Fid conversion
+        getIref = saveFile.getIref
+        npc.spells = [getIref(x) for x in face.spells]
+        npc.factions = [(getIref(x),y) for x,y in face.factions]
 
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+        #--Done
+        saveFile.setRecord(npc.getTuple(fid,version))
 
-        self.aliases = aliases or {} #--For aliasing mod names
+    @staticmethod
+    def save_setPlayerFace(saveFile,face,flags=0L,morphFacts=None):
+        """Write a pcFace to a save file."""
+        flags = PCFaces.flags(flags)
+        #--Update masters
+        for fid in (face.race, face.eye, face.hair, face.iclass):
+            if not fid: continue
+            maxMaster = len(face.masters)-1
+            mod = getModIndex(fid)
+            master = face.masters[min(mod,maxMaster)]
+            if master not in saveFile.masters:
+                saveFile.masters.append(master)
+        masterMap = MasterMap(face.masters,saveFile.masters)
 
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        fid_stats, attrs = self.fid_stats, self.attrs
-        detailed = self.detailed
-        loadFactory= LoadFactory(False,MreSpel)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        modFile.convertToLongFids(['SPEL'])
-        for record in modFile.SPEL.getActiveRecords():
-            fid_stats[record.fid] = [getattr_deep(record, attr) for attr in attrs]
-            if detailed:
-                effects = []
-                for effect in record.effects:
-                    effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                    if effect.scriptEffect:
-                        effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
-                                           effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                    else: effectlist.append([])
-                    effects.append(effectlist)
-                fid_stats[record.fid].append(effects)
+        #--Player ACHR
+        #--Buffer for modified record data
+        buff = cStringIO.StringIO()
+        def buffPack(format,*args):
+            buff.write(struct.pack(format,*args))
+        def buffPackRef(oldFid,doPack=True):
+            newFid = oldFid and masterMap(oldFid,None)
+            if newFid and doPack:
+                newRef = saveFile.getIref(newFid)
+                buff.write(struct.pack('I',newRef))
+            else:
+                buff.seek(4,1)
+        oldRecord = saveFile.getRecord(0x14)
+        oldData = oldRecord[-1]
+        namePos = PCFaces.save_getNamePos(saveFile.fileInfo.name,oldData,saveFile.pcName)
+        buff.write(oldData)
+        #--Modify buffer with face data.
+        buff.seek(namePos-542)
+        buffPack('=200s120s200s',face.fggs_p, face.fgga_p, face.fgts_p)
+        #--Race?
+        buffPackRef(face.race,flags.race)
+        #--Hair, Eyes?
+        buffPackRef(face.hair,flags.hair)
+        buffPackRef(face.eye,flags.eye)
+        if flags.hair:
+            buffPack('=f3Bs',face.hairLength,face.hairRed,face.hairBlue,face.hairGreen,face.unused3)
+        else:
+            buff.seek(8,1)
+        #--Gender?
+        if flags.gender:
+            buffPack('B',face.gender)
+        else:
+            buff.seek(1,1)
+        #--Name?
+        if flags.name:
+            postName = buff.getvalue()[buff.tell()+len(saveFile.pcName)+2:]
+            buffPack('B',len(face.pcName)+1)
+            buff.write(face.pcName+'\x00')
+            buff.write(postName)
+            buff.seek(-len(postName),1)
+            saveFile.pcName = face.pcName
+        else:
+            buff.seek(len(saveFile.pcName)+2,1)
+        #--Class?
+        if flags.iclass and face.iclass:
+            pos = buff.tell()
+            newClass = masterMap(face.iclass)
+            oldClass = saveFile.fids[struct.unpack('I',buff.read(4))[0]]
+            customClass = saveFile.getIref(0x22843)
+            if customClass not in (newClass,oldClass):
+                buff.seek(pos)
+                buffPackRef(newClass)
 
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        fid_stats, attrs = self.fid_stats, self.attrs
-        detailed = self.detailed
-        loadFactory= LoadFactory(True,MreSpel)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        mapper = modFile.getLongMapper()
-        shortMapper = modFile.getShortMapper()
+        newData = buff.getvalue()
+        saveFile.setRecord(oldRecord[:-1]+(newData,))
 
-        changed = [] #eids
-        for record in modFile.SPEL.getActiveRecords():
-            newStats = fid_stats.get(mapper(record.fid), None)
-            if not newStats: continue
-            oldStats = [getattr_deep(record, attr) for attr in attrs]
-            if detailed:
-                effects = []
-                for effect in record.effects:
-                    effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                    if effect.scriptEffect:
-                        effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
-                                           effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                    else: effectlist.append([])
-                    effects.append(effectlist)
-                oldStats.append(effects)
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                for attr, value in zip(attrs, newStats):
-                    setattr_deep(record, attr, value)
-                if detailed and len(newStats) > len(attrs):
-                    effects = newStats[-1]
-                    record.effects = []
-                    for effect in effects:
-                        neweffect = record.getDefault('effects')
-                        neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
-                        if len(scripteffect):
-                            scriptEffect = record.getDefault('effects.scriptEffect')
-                            script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile, scriptEffect.full = scripteffect
-                            scriptEffect.script = shortMapper(script)
-                            neweffect.scriptEffect = scriptEffect
-                        record.effects.append(neweffect)
-                record.setChanged()
-        if changed: modFile.safeSave()
-        return changed
+        #--Player NPC
+        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
+        npc = SreNPC(recFlags,data)
+        #--Gender
+        if flags.gender and npc.acbs:
+            npc.acbs.flags.female = face.gender
+        #--Stats
+        if flags.stats and npc.acbs:
+            npc.acbs.level = face.level
+            npc.acbs.baseSpell = face.baseSpell
+            npc.acbs.fatigue = face.fatigue
+            npc.attributes = face.attributes
+            npc.skills = face.skills
+            npc.health = face.health
+            npc.unused2 = face.unused2
+        #--Factions: Faction assignment doesn't work. (Probably stored in achr.)
+        #--Modifiers, Spells, Name
+        if flags.modifiers: npc.modifiers = face.modifiers[:]
+        if flags.spells:
+            #delist('Set PC Spells:',face.spells)
+            npc.spells = [saveFile.getIref(x) for x in face.spells]
+        npc.full = None
+        saveFile.setRecord(npc.getTuple(fid,version))
+        #--Save
+        buff.close()
 
-    def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        detailed,aliases,spellTypeName_Number,levelTypeName_Number = self.detailed,self.aliases,self.spellTypeName_Number,self.levelTypeName_Number
-        fid_stats,recipientTypeName_Number,actorValueName_Number = self.fid_stats,self.recipientTypeName_Number,self.actorValueName_Number
-        ins = bolt.CsvReader(textPath)
-        try:
-            for fields in ins:
-                if len(fields) < 8 or fields[2][:2] != '0x': continue
-                group,mmod,mobj,eid,full,cost,levelType,spellType = fields[:8]
-                fields = fields[8:]
-                group = _coerce(group, str)
-                if group.lower() != 'spel': continue
-                mmod = _coerce(mmod, str)
-                mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-                eid = _coerce(eid, str, AllowNone=True)
-                full = _coerce(full, str, AllowNone=True)
-                cost = _coerce(cost, int)
-                levelType = _coerce(levelType, str)
-                levelType = levelTypeName_Number.get(levelType.lower(),_coerce(levelType,int) or 0)
-                spellType = _coerce(spellType, str)
-                spellType = spellTypeName_Number.get(spellType.lower(),_coerce(spellType,int) or 0)
-                if not detailed or len(fields) < 7:
-                    fid_stats[mid] = [eid,full,cost,levelType,spellType]
-                    continue
-                mc,ss,its,aeil,saa,daar,tewt = fields[:7]
-                fields = fields[7:]
-                mc = _coerce(mc, bool)
-                ss = _coerce(ss, bool)
-                its = _coerce(its, bool)
-                aeil = _coerce(aeil, bool)
-                saa = _coerce(saa, bool)
-                daar = _coerce(daar, bool)
-                tewt = _coerce(tewt, bool)
+    # Save Misc ----------------------------------------------------------------
+    @staticmethod
+    def save_repairHair(saveInfo):
+        """Repairs hair if it has been zeroed. (Which happens if hair came from a
+        cosmetic mod that has since been removed.) Returns True if repaired, False
+        if no repair was necessary."""
+        saveFile = SaveFile(saveInfo)
+        saveFile.load()
+        record = saveFile.getRecord(0x14)
+        data = record[-1]
+        namePos = PCFaces.save_getNamePos(saveInfo.name,data,saveFile.pcName)
+        raceRef,hairRef = struct.unpack('2I',data[namePos-22:namePos-14])
+        if hairRef != 0: return False
+        raceForm = raceRef and saveFile.fids[raceRef]
+        gender, = struct.unpack('B',data[namePos-2])
+        if gender:
+            hairForm = bush.raceHairFemale.get(raceForm,0x1da83)
+        else:
+            hairForm = bush.raceHairMale.get(raceForm,0x90475)
+        hairRef = saveFile.getIref(hairForm)
+        data = data[:namePos-18]+struct.pack('I',hairRef)+data[namePos-14:]
+        saveFile.setRecord(record[:-1]+(data,))
+        saveFile.safeSave()
+        return True
 
-                effects = []
-                _effects = fields
-                while len(_effects) >= 13:
-                    _effect, _effects = _effects[1:13], _effects[13:]
-                    name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                    name = _coerce(name, str, AllowNone=True)
-                    magnitude = _coerce(magnitude, int, AllowNone=True)
-                    area = _coerce(area, int, AllowNone=True)
-                    duration = _coerce(duration, int, AllowNone=True)
-                    range = _coerce(range, str, AllowNone=True)
-                    if range:
-                        range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                    actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                    if actorvalue:
-                        actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                    if None in (name,magnitude,area,duration,range,actorvalue):
-                        continue
-                    effect = [name,magnitude,area,duration,range,actorvalue]
-                    semod = _coerce(semod, str, AllowNone=True)
-                    seobj = _coerce(seobj, int, 16, AllowNone=True)
-                    seschool = _coerce(seschool, int, AllowNone=True)
-                    sevisual = _coerce(sevisual, str, AllowNone=True)
-                    seflags = _coerce(seflags, bool, AllowNone=True)
-                    sename = _coerce(sename, str, AllowNone=True)
-                    if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                        effect.append([])
-                    else:
-                        if sevisual.strip() == '':
-                            sevisual = '\x00\x00\x00\x00'
-                        sefid = (GPath(aliases.get(semod,semod)),seobj)
-                        effect.append([sefid, seschool, sevisual,seflags, sename])
-                    effects.append(effect)
-                fid_stats[mid] = [eid, full, cost, levelType, spellType, mc, ss, its, aeil, saa, daar, tewt, effects]
-        finally:
-            ins.close()
+    # MODS --------------------------------------------------------------------
+    @staticmethod
+    def mod_getFaces(modInfo):
+        """Returns an array of PCFaces from a mod file."""
+        #--Mod File
+        loadFactory = LoadFactory(False,MreNpc)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        faces = {}
+        for npc in modFile.NPC_.getActiveRecords():
+            face = PCFaces.PCFace()
+            face.masters = modFile.tes4.masters + [modInfo.name]
+            for field in ('eid','race','eye','hair','hairLength',
+                          'hairRed','hairBlue','hairGreen','unused3',
+                          'fggs_p','fgga_p','fgts_p','level','skills',
+                          'health','unused2','baseSpell',
+                          'fatigue','attributes','iclass'):
+                setattr(face,field,getattr(npc,field))
+            face.gender = npc.flags.female
+            face.pcName = npc.full
+            faces[face.eid] = face
+            #print face.pcName, face.race, face.hair, face.eye, face.hairLength, face.hairRed, face.hairBlue, face.hairGreen, face.unused3
+        return faces
 
-    def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        detailed,fid_stats,spellTypeNumber_Name,levelTypeNumber_Name = self.detailed,self.fid_stats,self.spellTypeNumber_Name,self.levelTypeNumber_Name
-        recipientTypeNumber_Name,actorValueNumber_Name = self.recipientTypeNumber_Name,self.actorValueNumber_Name
-        header = (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                  _('Name'),_('Cost'),_('Level Type'),_('Spell Type'))
-        rowFormat = '"%s","%s","0x%06X","%s","%s","%d","%s","%s"'
-        if detailed:
-            header = header + (_('Manual Cost'),_('Start Spell'),_('Immune To Silence'),_('Area Effect Ignores LOS'),
-                               _('Script Always Applies'),_('Disallow Absorb and Reflect'),_('Touch Explodes Without Target'),
-                               _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                               _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                               _('Additional Effects (Same format)'))
-            rowFormat = rowFormat + ',"%s","%s","%s","%s","%s","%s","%s"'
-            effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-            scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
-            noscriptEffectFiller = ',"None","None","None","None","None","None"'
-        headFormat = '"%s",' * len(header)
-        headFormat = headFormat[:-1] + '\n' #chop trailing comma
+    @staticmethod
+    def mod_getRaceFaces(modInfo):
+        """Returns an array of Race Faces from a mod file."""
+        loadFactory = LoadFactory(False,MreRace)
+        modFile = ModFile(modInfo,loadFactory)
+        modFile.load(True)
+        faces = {}
+        for race in modFile.RACE.getActiveRecords():
+            face = PCFaces.PCFace()
+            face.masters = []
+            for field in ('eid','fggs_p','fgga_p','fgts_p'):
+                setattr(face,field,getattr(race,field))
+            faces[face.eid] = face
+        return faces
 
-        out = textPath.open('w')
-        out.write(Encode(headFormat % header,'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: (fid_stats[x][0],x[0])):
-            if detailed:
-                eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt,effects = fid_stats[fid]
-                levelType = levelTypeNumber_Name.get(levelType,levelType)
-                spellType = spellTypeNumber_Name.get(spellType,spellType)
-                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt)
-                for effect in effects:
-                    efname,magnitude,area,duration,range,actorvalue = effect[:-1]
-                    range = recipientTypeNumber_Name.get(range,range)
-                    actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                    scripteffect = effect[-1]
-                    output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
-                    if len(scripteffect):
-                        longid,seschool,sevisual,seflags,sename = scripteffect
-                        if sevisual == '\x00\x00\x00\x00':
-                            sevisual = ''
-                        output += scriptEffectFormat % (Encode(longid[0].s,'mbcs'),longid[1],seschool,sevisual,seflags,sename)
+    @staticmethod
+    def mod_addFace(modInfo,face):
+        """Writes a pcFace to a mod file."""
+        #--Mod File
+        loadFactory = LoadFactory(True,MreNpc)
+        modFile = ModFile(modInfo,loadFactory)
+        if modInfo.getPath().exists():
+            modFile.load(True)
+        #--Tes4
+        tes4 = modFile.tes4
+        if not tes4.author:
+            tes4.author = '[wb]'
+        if not tes4.description:
+            tes4.description = Encode(_('Face dump from save game.'),'mbcs')
+        if modInfos.masterName not in tes4.masters:
+            tes4.masters.append(modInfos.masterName)
+        masterMap = MasterMap(face.masters,tes4.masters+[modInfo.name])
+        #--Eid
+        npcEids = set([record.eid for record in modFile.NPC_.records])
+        eidForm = ''.join(("sg", bush.raceShortNames.get(face.race,'Unk'),
+            (face.gender and 'a' or 'u'), re.sub(r'\W','',face.pcName),'%02d'))
+        count,eid = 0, eidForm % 0
+        while eid in npcEids:
+            count += 1
+            eid = eidForm % count
+        #--NPC
+        npcid = genFid(len(tes4.masters),tes4.getNextObject())
+        npc = MreNpc(('NPC_',0,0x40000,npcid,0))
+        npc.eid = eid
+        npc.full = face.pcName
+        npc.flags.female = face.gender
+        npc.iclass = masterMap(face.iclass,0x237a8) #--Default to Acrobat
+        npc.setRace(masterMap(face.race,0x00907)) #--Default to Imperial
+        npc.eye = masterMap(face.eye,None)
+        npc.hair = masterMap(face.hair,None)
+        npc.hairLength = face.hairLength
+        npc.hairRed = face.hairRed
+        npc.hairBlue = face.hairBlue
+        npc.hairGreen = face.hairGreen
+        npc.unused3 = face.unused3
+        npc.fggs_p = face.fggs_p
+        npc.fgga_p = face.fgga_p
+        npc.fgts_p = face.fgts_p
+        #--Stats
+        npc.level = face.level
+        npc.baseSpell = face.baseSpell
+        npc.fatigue = face.fatigue
+        if face.skills: npc.skills = face.skills
+        if face.health:
+            npc.health = face.health
+            npc.unused2 = face.unused2
+        if face.attributes: npc.attributes = face.attributes
+        npc.setChanged()
+        modFile.NPC_.records.append(npc)
+        #--Save
+        modFile.safeSave()
+        return npc
+
+#------------------------------------------------------------------------------
+class CleanMod:
+    """Fixes cells to avoid nvidia fog problem."""
+    def __init__(self,modInfo):
+        self.modInfo = modInfo
+        self.fixedCells = set()
+
+    def clean(self,progress):
+        """Duplicates file, then walks through and edits file as necessary."""
+        progress.setFull(self.modInfo.size)
+        fixedCells = self.fixedCells
+        fixedCells.clear()
+        #--File stream
+        path = self.modInfo.getPath()
+        #--Scan/Edit
+        ins = ModReader(self.modInfo.name,path.open('rb'))
+        out = path.temp.open('wb')
+        def copy(size,back=False):
+            buff = ins.read(size)
+            out.write(buff)
+        def copyPrev(size):
+            ins.seek(-size,1)
+            buff = ins.read(size)
+            out.write(buff)
+        while not ins.atEnd():
+            progress(ins.tell())
+            (type,size,str0,fid,uint2,uint3) = ins.unpackRecHeader()
+            copyPrev(recHeaderSize)
+            if type == 'GRUP':
+                if fid != 0: #--Ignore sub-groups
+                    pass
+                elif str0 not in ('CELL','WRLD'):
+                    copy(size-recHeaderSize)
+            #--Handle cells
+            elif type == 'CELL':
+                nextRecord = ins.tell() + size
+                while ins.tell() < nextRecord:
+                    (type,size) = ins.unpackSubHeader()
+                    copyPrev(6)
+                    if type != 'XCLL':
+                        copy(size)
                     else:
-                        output += noscriptEffectFiller
+                        if size == 40: # for Fallout3/NV
+                            color,near,far,rotXY,rotZ,fade,clip,power = ins.unpack('=12s2f2l3f',size,'CELL.XCLL')
+                        else:
+                            color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',size,'CELL.XCLL')
+                        if not (near or far or clip):
+                            near = 0.0001
+                            fixedCells.add(fid)
+                        if size == 40: # for Fallout3/NV
+                            out.write(struct.pack('=12s2f2l3f',color,near,far,rotXY,rotZ,fade,clip,power))
+                        else:
+                            out.write(struct.pack('=12s2f2l2f',color,near,far,rotXY,rotZ,fade,clip))
+            #--Non-Cells
             else:
-                eid,name,cost,levelType,spellType = fid_stats[fid]
-                levelType = levelTypeNumber_Name.get(levelType,levelType)
-                spellType = spellTypeNumber_Name.get(spellType,spellType)
-                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType)
-            output += '\n'
-            out.write(output)
+                copy(size)
+        #--Done
+        ins.close()
         out.close()
+        if fixedCells:
+            self.modInfo.makeBackup()
+            path.untemp()
+            self.modInfo.setmtime()
+        else:
+            path.temp.remove()
 
-class CBash_SpellRecords:
-    """Statistics for spells, with functions for importing/exporting from/to mod/text file."""
-
-    def __init__(self,types=None,aliases=None,detailed=False):
-        """Initialize."""
-        self.fid_stats = {}
-        self.attrs = ('eid', 'full', 'cost', 'levelType', 'spellType')
-        self.detailed = detailed
-        if detailed:
-            self.attrs = self.attrs + ('IsManualCost', 'IsStartSpell', 'IsSilenceImmune',
-                                       'IsAreaEffectIgnoresLOS', 'IsScriptAlwaysApplies',
-                                       'IsDisallowAbsorbReflect',
-                                       'IsTouchExplodesWOTarget', 'effects_list')
-        self.spellTypeNumber_Name = {None : 'NONE',
-                                     0 : 'Spell',
-                                     1 : 'Disease',
-                                     2 : 'Power',
-                                     3 : 'LesserPower',
-                                     4 : 'Ability',
-                                     5 : 'Poison',}
-        self.spellTypeName_Number = dict([(y.lower(),x) for x,y in self.spellTypeNumber_Name.iteritems() if x is not None])
+#------------------------------------------------------------------------------
+class ModCleaner:
+    """Class for cleaning ITM and UDR edits from mods.
+       ITM detection requires CBash to work."""
+    UDR     = 0x01  # Deleted references
+    ITM     = 0x02  # Identical to master records
+    FOG     = 0x04  # Nvidia Fog Fix
+    ALL = UDR|ITM|FOG
 
-        self.levelTypeNumber_Name = {None : 'NONE',
-                                     0 : 'Novice',
-                                     1 : 'Apprentice',
-                                     2 : 'Journeyman',
-                                     3 : 'Expert',
-                                     4 : 'Master',}
-        self.levelTypeName_Number = dict([(y.lower(),x) for x,y in self.levelTypeNumber_Name.iteritems() if x is not None])
+    def __init__(self,modInfo):
+        self.modInfo = modInfo
+        self.itm = set()    # Fids for Identical To Master records
+        self.udr = set()    # Fids for Deleted Reference records
+        self.fog = set()    # Fids for Cells needing the Nvidia Fog Fix
 
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
+    def scan(self,what=ALL,progress=bolt.Progress()):
+        """Scan this mod for dirty edits.
+           return (UDR,ITM,FogFix)"""
+        udr,itm,fog = ModCleaner.scan_Many([self.modInfo],what,progress)[0]
+        if what & ModCleaner.UDR:
+            self.udr = udr
+        if what & ModCleaner.ITM:
+            self.itm = itm
+        if what & ModCleaner.FOG:
+            self.fog = fog
+        return (udr,itm,fog)
 
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+    @staticmethod
+    def scan_Many(modInfos,what=ALL,progress=bolt.Progress()):
+        """Scan multiple mods for dirty edits"""
+        if len(modInfos) == 0: return []
+        if not settings['bash.CBashEnabled']:
+            return ModCleaner._scan_Python(modInfos,what,progress)
+        else:
+            return ModCleaner._scan_CBash(modInfos,what,progress)
 
-        self.aliases = aliases or {} #--For aliasing mod names
+    def clean(self,what=UDR|FOG,progress=bolt.Progress(),reScan=False):
+        """reScan:
+             True: perform scans before cleaning
+             False: only perform scans if itm/udr is empty
+             """
+        ModCleaner.clean_Many([self],what,progress,reScan)
 
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        fid_stats, attrs = self.fid_stats, self.attrs
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_SpellRecords:readFromMod"
-            print error[0]
-            return
+    @staticmethod
+    def clean_Many(cleaners,what,progress=bolt.Progress(),reScan=False):
+        """Accepts either a list of ModInfo's or a list of ModCleaner's"""
+        if isinstance(cleaners[0],ModInfos):
+            reScan = True
+            cleaners = [ModCleaner(x) for x in cleaners]
+        if not settings['bash.CBashEnabled']:
+            ModCleaner._clean_Python(cleaners,what,progress)
+        else:
+            #--CBash
+            #--Scan?
+            if reScan:
+                ret = ModCleaner._scan_CBash([x.modInfo for x in cleaners],what,progress)
+                for i,cleaner in enumerate(cleaners):
+                    udr,itm,fog = ret[i]
+                    if what & ModCleaner.UDR:
+                        cleaner.udr = udr
+                    if what & ModCleaner.ITM:
+                        cleaner.itm = itm
+                    if what & ModCleaner.FOG:
+                        cleaner.fog = fog
+            #--Clean
+            ModCleaner._clean_CBash(cleaners,what,progress)
 
-        for record in modFile.SPEL:
-            fid_stats[record.fid] = map(record.__getattribute__, attrs)
-            record.UnloadRecord()
-
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        fid_stats, attrs = self.fid_stats, self.attrs
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_SpellRecords:writeToMod"
-            print error[0]
-            return
-
-        changed = []
-        for record in modFile.SPEL:
-            newStats = fid_stats.get(record.fid, None)
-            if not newStats: continue
-            oldStats = map(record.__getattribute__,attrs)
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                map(record.__setattr__,attrs,newStats)
-
-        #--Done
-        if changed: modFile.save()
-        return changed
-
-    def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        detailed,aliases,spellTypeName_Number,levelTypeName_Number = self.detailed,self.aliases,self.spellTypeName_Number,self.levelTypeName_Number
-        fid_stats,recipientTypeName_Number,actorValueName_Number = self.fid_stats,self.recipientTypeName_Number,self.actorValueName_Number
-        ins = bolt.CsvReader(textPath)
-        try:
-            for fields in ins:
-                if len(fields) < 8 or fields[2][:2] != '0x': continue
-                group,mmod,mobj,eid,full,cost,levelType,spellType = fields[:8]
-                fields = fields[8:]
-                group = _coerce(group, str)
-                if group.lower() != 'spel': continue
-                mmod = _coerce(mmod, str)
-                mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-                eid = _coerce(eid, str, AllowNone=True)
-                full = _coerce(full, str, AllowNone=True)
-                cost = _coerce(cost, int)
-                levelType = _coerce(levelType, str)
-                levelType = levelTypeName_Number.get(levelType.lower(),_coerce(levelType,int) or 0)
-                spellType = _coerce(spellType, str)
-                spellType = spellTypeName_Number.get(spellType.lower(),_coerce(spellType,int) or 0)
-                if not detailed or len(fields) < 7:
-                    fid_stats[mid] = [eid,full,cost,levelType,spellType]
-                    continue
-                mc,ss,its,aeil,saa,daar,tewt = fields[:7]
-                fields = fields[7:]
-                mc = _coerce(mc, bool)
-                ss = _coerce(ss, bool)
-                its = _coerce(its, bool)
-                aeil = _coerce(aeil, bool)
-                saa = _coerce(saa, bool)
-                daar = _coerce(daar, bool)
-                tewt = _coerce(tewt, bool)
+    @staticmethod
+    def _loadCollection(mods):
+        # mods = list(ModInfo's) or list(ModCleaner's)
+        collection = ObCollection(ModsPath=dirs['mods'].s)
+        for mod in mods:
+            if isinstance(mod,ModCleaner):
+                modInfo = mod.modInfo
+            else:
+                modInfo = mod
+            if len(modInfo.masterNames) == 0: continue
+            path = modInfo.getPath()
+            collection.addMod(path.stail)
+        collection.load()
+        return collection
 
-                effects = []
-                _effects = fields
-                while len(_effects) >= 13:
-                    _effect, _effects = _effects[1:13], _effects[13:]
-                    name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                    name = _coerce(name, str, AllowNone=True)
-                    if name is not None:
-                        name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
-                    magnitude = _coerce(magnitude, int, AllowNone=True)
-                    area = _coerce(area, int, AllowNone=True)
-                    duration = _coerce(duration, int, AllowNone=True)
-                    range = _coerce(range, str, AllowNone=True)
-                    if range:
-                        range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                    actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                    if actorvalue:
-                        actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                    if None in (name,magnitude,area,duration,range,actorvalue):
-                        continue
-                    effect = [name,magnitude,area,duration,range,actorvalue]
-                    semod = _coerce(semod, str, AllowNone=True)
-                    seobj = _coerce(seobj, int, 16, AllowNone=True)
-                    seschool = _coerce(seschool, int, AllowNone=True)
-                    sevisual = _coerce(sevisual, str, AllowNone=True)
-                    seflags = _coerce(seflags, bool, AllowNone=True)
-                    sename = _coerce(sename, str, AllowNone=True)
-                    if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                        effect.extend([None,None,None,None,None])
-                    else:
-                        sevisual = cast(sevisual, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
-                        sefid = (GPath(aliases.get(semod,semod)),seobj)
-                        effect.extend([sefid, seschool, sevisual,seflags, sename])
-                    effects.append(tuple(effect))
-                fid_stats[mid] = [eid, full, cost, levelType, spellType, mc, ss, its, aeil, saa, daar, tewt, effects]
-        finally:
-            ins.close()
+    @staticmethod
+    def _scan_CBash(modInfos,what,progress):
+        """Scan multiple mods for problems"""
+        if what & ModCleaner.ALL:
+            # There are scans to do
+            doUDR = bool(what & ModCleaner.UDR)
+            doITM = bool(what & ModCleaner.ITM)
+            doFog = bool(what & ModCleaner.FOG)
+            if len(modInfos) > 1:
+                progress(0,_('Loading...')+'\n'+modInfos[0].name.s)
+            else:
+                progress(0,_('Loading...'))
+            #--Load
+            collection = ModCleaner._loadCollection(modInfos)
+            #--Scan
+            progress.setFull(max(len(modInfos),1))
+            ret = []
+            for i,modInfo in enumerate(modInfos):
+                progress(i,_('Scanning...') + '\n' + modInfo.name.s)
+                udr = set()
+                itm = set()
+                fog = set()
+                if len(modInfo.masterNames) > 0:
+                    path = modInfo.getPath()
+                    modFile = collection.LookupModFile(path.stail)
+                    blocks = modFile.aggregates
+                    subprogress1 = SubProgress(progress,i,i+1)
+                    subprogress1.setFull(max(len(blocks),1))
+                    for j,block in enumerate(blocks.values()):
+                        subprogress1(j)
+                        subprogress2 = SubProgress(subprogress1,j,j+1)
+                        subprogress2.setFull(max(len(block),1))
+                        for k,record in enumerate(block):
+                            subprogress2(k)
+                            fid = record.fid
+                            #--Scan UDR
+                            if doUDR and record._Type in ('ACRE','ACHR','REFR') and record.IsDeleted:
+                                udr.add(fid)
+                            #--Scan fog
+                            if doFog and record._Type == 'CELL':
+                                if not (record.fogNear or record.fogFar or record.fogClip):
+                                    fog.add(fid)
+                            #--Scan ITM
+                            if doITM:
+                                if not fid or fid[0] == modFile.GName: continue
+                                master = collection.LookupModFile(fid[0].stail)
+                                if not master: continue
+                                masterRecord = master.LookupRecord(fid)
+                                if not masterRecord: continue
+                                if record.IsIdenticalTo(masterRecord):
+                                    itm.add(fid)
+                ret.append((udr,itm,fog))
+            #--Unload
+            collection.Unload()
+            return ret
+        else:
+            return [(set(),set(),set()) for x in range(len(modInfos))]
 
-    def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        detailed,fid_stats,spellTypeNumber_Name,levelTypeNumber_Name = self.detailed,self.fid_stats,self.spellTypeNumber_Name,self.levelTypeNumber_Name
-        recipientTypeNumber_Name,actorValueNumber_Name = self.recipientTypeNumber_Name,self.actorValueNumber_Name
-        header = (_('Type'),_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                  _('Name'),_('Cost'),_('Level Type'),_('Spell Type'))
-        rowFormat = '"%s","%s","0x%06X","%s","%s","%d","%s","%s"'
-        if detailed:
-            header = header + (_('Manual Cost'),_('Start Spell'),_('Immune To Silence'),_('Area Effect Ignores LOS'),
-                               _('Script Always Applies'),_('Disallow Absorb and Reflect'),_('Touch Explodes Without Target'),
-                               _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                               _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                               _('Additional Effects (Same format)'))
-            rowFormat = rowFormat + ',"%s","%s","%s","%s","%s","%s","%s"'
-            effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-            scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
-            noscriptEffectFiller = ',"None","None","None","None","None","None"'
-        headFormat = '"%s",' * len(header)
-        headFormat = headFormat[:-1] + '\n' #chop trailing comma
+    @staticmethod
+    def _scan_Python(modInfos,what,progress):
+        if what & (ModCleaner.UDR|ModCleaner.FOG):
+            # Python can't do ITM scanning
+            doUDR = what & ModCleaner.UDR
+            doFog = what & ModCleaner.FOG
+            progress.setFull(max(len(modInfos),1))
+            ret = []
+            for i,modInfo in enumerate(modInfos):
+                progress(i,_('Scanning...') + '\n' + modInfo.name.s)
+                udr = set()
+                itm = set()
+                fog = set()
+                if len(modInfo.masterNames) > 0:
+                    subprogress = SubProgress(progress,i,i+1)
+                    subprogress.setFull(max(modInfo.size,1))
+                    #--File stream
+                    path = modInfo.getPath()
+                    #--Scan
+                    ins = ModReader(modInfo.name,path.open('rb'))
+                    while not ins.atEnd():
+                        subprogress(ins.tell())
+                        (type,size,flags,fid,uint2,uint3) = ins.unpackRecHeader()
+                        if type == 'GRUP':
+                            if fid != 0: #--Ignore sub-groups
+                                pass
+                            elif flags not in ('CELL','WRLD'):
+                                ins.read(size-recHeaderSize)
+                        else:
+                            if doUDR and flags & 0x20 and type in ('ACHR','ACRE','REFR'):
+                                udr.add(fid)
+                            if doFog and type == 'CELL':
+                                nextRecord = ins.tell() + size
+                                while ins.tell() < nextRecord:
+                                    (nextType,nextSize) = ins.unpackSubHeader()
+                                    if type != 'XCLL':
+                                        ins.read(nextSize)
+                                    else:
+                                        color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',nextSize,'CELL.XCLL')
+                                        if not (near or far or clip):
+                                            fog.add(fid)
+                            else:
+                                ins.read(size)
+                    #--Done
+                    ins.close()
+                ret.append((udr,itm,fog))
+            return ret
+        else:
+            return [(set(),set(),set()) for x in range(len(modInfos))]
 
-        out = textPath.open('w')
-        out.write(Encode(headFormat % header,'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: (fid_stats[x][0],x[0])):
-            if detailed:
-                eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt,effects = fid_stats[fid]
-                levelType = levelTypeNumber_Name.get(levelType,levelType)
-                spellType = spellTypeNumber_Name.get(spellType,spellType)
-                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType,mc,ss,its,aeil,saa,daar,tewt)
-                for effect in effects:
-                    efname,magnitude,area,duration,range,actorvalue = effect[:6]
-                    efname = c_ulong(efname)
-                    efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
-                    range = recipientTypeNumber_Name.get(range,range)
-                    actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                    output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
-                    longid,seschool,sevisual,seflags,sename = effect[6:]
-                    if None not in (longid,seschool,sevisual,seflags,sename):
-                        sevisual = c_ulong(sevisual)
-                        sevisual = cast(byref(sevisual), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
-                        output += scriptEffectFormat % (Encode(longid[0].s,'mbcs'),longid[1],seschool,sevisual,seflags,sename)
-                    else:
-                        output += noscriptEffectFiller
+    @staticmethod
+    def _clean_CBash(cleaners,what,progress):
+        if what & (ModCleaner.UDR|ModCleaner.FOG):
+            doUDR = what & ModCleaner.UDR
+            doFog = what & ModCleaner.FOG
+            progress.setFull(max(len(cleaners),1))
+            if len(cleaners) > 1:
+                progress(0,_('Loading...')+'\n'+cleaners[0].modInfo.name.s)
             else:
-                eid,name,cost,levelType,spellType = fid_stats[fid]
-                levelType = levelTypeNumber_Name.get(levelType,levelType)
-                spellType = spellTypeNumber_Name.get(spellType,spellType)
-                output = rowFormat % ('SPEL',Encode(fid[0].s,'mbcs'),fid[1],eid,name,cost,levelType,spellType)
-            output += '\n'
-            out.write(output)
-        out.close()
-#------------------------------------------------------------------------------
-class IngredientDetails:
-    """Details on Ingredients, with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,types=None,aliases=None):
-        """Initialize."""
-        self.fid_stats = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+                progress(0,_('Loading...'))
+            #--Load
+            collection = ModCleaner._loadCollection(cleaners)
+            #--Clean
+            for i,cleaner in enumerate(cleaners):
+                progress(i,_('Cleaning...') + '\n' + cleaner.modInfo.name.s)
+                path = cleaner.modInfo.getPath()
+                modFile = collection.LookupModFile(path.stail)
+                changed = False
+                #Only do UDR and Fog right now
+                total = sum([len(cleaner.udr)*doUDR,len(cleaner.fog)*doFog])
+                recordNum = 0
+                subprogress = SubProgress(progress,i,i+1)
+                subprogress.setFull(max(total,1))
+                if doUDR:
+                    for fid in cleaner.udr:
+                        subprogress(recordNum)
+                        recordNum += 1
+                        record = modFile.LookupRecord(fid)
+                        if record and record._Type in ('ACRE','ACHR','REFR') and record.IsDeleted:
+                            changed = True
+                            record.IsDeleted = False
+                            record.IsIgnored = True
+                if doFog:
+                    for fid in cleaner.fog:
+                        subprogress(recordNum)
+                        recordNum += 1
+                        record = modFile.LookupRecord(fid)
+                        if record and record._Type == 'CELL':
+                            if not (record.fogNear or record.fogFar or record.fogClip):
+                                record.fogNear = 0.0001
+                                changed = True
+                #--Save
+                if changed:
+                    try:
+                        modFile.save(False)
+                    except WindowsError, werr:
+                        if werr.winerror != 32: raise
+                        while balt.askYes(None,_('Bash encountered an error when saving %s.\n\nThe file is in use by another process such as TES4Edit.\nPlease close the other program that is accessing %s.\n\nTry again?') % (modPath.stail,modPath.stail),_('%s - Save Error') % modPath.stail):
+                            try:
+                                modFile.save(False)
+                            except WindowsError, werr:
+                                continue
+                            break
+                        else:
+                            raise
+            collection.Unload()
 
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        fid_stats = self.fid_stats
-        loadFactory= LoadFactory(False,MreIngr)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        modFile.convertToLongFids(['INGR'])
-        for record in modFile.INGR.getActiveRecords():
-            effects = []
-            for effect in record.effects:
-                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                if effect.scriptEffect:
-                    effectlist.append([effect.scriptEffect.script, effect.scriptEffect.school, effect.scriptEffect.visual,
-                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                else: effectlist.append([])
-                effects.append(effectlist)
-            fid_stats[record.fid] = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, record.script, record.value, round(record.weight,6), effects]
+    @staticmethod
+    def _clean_Python(cleaners,what,progress):
+        if what & (ModCleaner.UDR|ModCleaner.FOG):
+            doUDR = what & ModCleaner.UDR
+            doFog = what & ModCleaner.FOG
+            progress.setFull(max(len(cleaners),1))
+            #--Clean
+            for i,cleaner in enumerate(cleaners):
+                progress(i,_('Cleaning...')+'\n'+cleaner.modInfo.name.s)
+                subprogress = SubProgress(progress,i,i+1)
+                subprogress.setFull(max(cleaner.modInfo.size,1))
+                #--File stream
+                path = cleaner.modInfo.getPath()
+                #--Scan & clean
+                ins = ModReader(cleaner.modInfo.name,path.open('rb'))
+                out = path.temp.open('wb')
+                def copy(size):
+                    out.write(ins.read(size))
+                def copyPrev(size):
+                    ins.seek(-size,1)
+                    out.write(ins.read(size))
+                changed = False
+                while not ins.atEnd():
+                    subprogress(ins.tell())
+                    (type,size,flags,fid,uint2,uint3) = ins.unpackRecHeader()
+                    if type == 'GRUP':
+                        if fid != 0:
+                            pass
+                        elif flags not in ('CELL','WRLD'):
+                            copy(size-20)
+                    else:
+                        if doUDR and flags & 0x20 and type in ('ACHR','ACRE','REFR'):
+                            flags = (flags & ~0x20) | 0x1000
+                            out.seek(-20,1)
+                            out.write(struct.pack('=4s4I',type,size,flags,fid,uint2))
+                            change = True
+                        if doFog and type == 'CELL':
+                            nextRecord = ins.tell() + size
+                            while ins.tell() < nextRecord:
+                                subprogress(ins.tell())
+                                (nextType,nextSize) = ins.unpackSubHeader()
+                                copyPrev(6)
+                                if nextType != 'XCLL':
+                                    copy(nextSize)
+                                else:
+                                    color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',size,'CELL.XCLL')
+                                    if not (near or far or clip):
+                                        near = 0.0001
+                                        changed = True
+                                    out.write(struct.pack('=12s2f2l2f',color,near,far,rotXY,rotZ,fade,clip))
+                        else:
+                            copy(size)
+                #--Done
+                ins.close()
+                out.close()
+                #--Save
+                if changed:
+                    modInfo.makeBackup()
+                    try:
+                        path.untemp()
+                    except WindowsError, werr:
+                        if werr.winerror != 32: raise
+                        while balt.askYes(None,_('Bash encountered an error when saving %s.\n\nThe file is in use by another process such as TES4Edit.\nPlease close the other program that is accessing %s.\n\nTry again?') % (modPath.stail,modPath.stail),_('%s - Save Error') % modPath.stail):
+                            try:
+                                path.untemp()
+                            except WindowsError,werr:
+                                continue
+                            break
+                        else:
+                            raise
+                    modInfo.setmtime()
+                else:
+                    path.temp.remove()
 
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        fid_stats = self.fid_stats
-        loadFactory = LoadFactory(True,MreIngr)
+#------------------------------------------------------------------------------
+class SaveSpells:
+    """Player spells of a savegame."""
+
+    def __init__(self,saveInfo):
+        """Initialize."""
+        self.saveInfo = saveInfo
+        self.saveFile = None
+        self.allSpells = {} #--spells[(modName,objectIndex)] = (name,type)
+
+    def load(self,progress=None):
+        """Loads savegame and and extracts created spells from it and its masters."""
+        progress = progress or bolt.Progress()
+        saveFile = self.saveFile = SaveFile(self.saveInfo)
+        saveFile.load(SubProgress(progress,0,0.4))
+        progress = SubProgress(progress,0.4,1.0,len(saveFile.masters)+1)
+        #--Extract spells from masters
+        for index,master in enumerate(saveFile.masters):
+            progress(index,master.s)
+            if master in modInfos:
+                self.importMod(modInfos[master])
+        #--Extract created spells
+        allSpells = self.allSpells
+        saveName = self.saveInfo.name
+        progress(progress.full-1,saveName.s)
+        for record in saveFile.created:
+            if record.recType == 'SPEL':
+                allSpells[(saveName,getObjectIndex(record.fid))] = record.getTypeCopy()
+
+    def importMod(self,modInfo):
+        """Imports spell info from specified mod."""
+        #--Spell list already extracted?
+        if 'bash.spellList' in modInfo.extras:
+            self.allSpells.update(modInfo.extras['bash.spellList'])
+            return
+        #--Else extract spell list
+        loadFactory= LoadFactory(False,MreSpel)
         modFile = ModFile(modInfo,loadFactory)
         modFile.load(True)
-        mapper = modFile.getLongMapper()
-        shortMapper = modFile.getShortMapper()
-        changed = [] #eids
-        for record in modFile.INGR.getActiveRecords():
-            newStats = fid_stats.get(mapper(record.fid), None)
-            if not newStats: continue
-            effects = []
-            for effect in record.effects:
-                effectlist = [effect.name, effect.magnitude, effect.area, effect.duration, effect.recipient, effect.actorValue]
-                if effect.scriptEffect:
-                    effectlist.append([mapper(effect.scriptEffect.script), effect.scriptEffect.school, effect.scriptEffect.visual,
-                                       effect.scriptEffect.flags.hostile, effect.scriptEffect.full])
-                else: effectlist.append([])
-                effects.append(effectlist)
-            oldStats = [record.eid, record.full, record.model.modPath, round(record.model.modb,6), record.iconPath, mapper(record.script), record.value, round(record.weight,6), effects]
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                record.eid, record.full, record.model.modPath, record.model.modb, record.iconPath, script, record.value, record.weight, effects = newStats
-                record.script = shortMapper(script)
-                record.effects = []
-                for effect in effects:
-                    neweffect = record.getDefault('effects')
-                    neweffect.name, neweffect.magnitude, neweffect.area, neweffect.duration, neweffect.recipient, neweffect.actorValue, scripteffect = effect
-                    if len(scripteffect):
-                        scriptEffect = record.getDefault('effects.scriptEffect')
-                        script, scriptEffect.school, scriptEffect.visual, scriptEffect.flags.hostile.hostile, scriptEffect.full = scripteffect
-                        scriptEffect.script = shortMapper(script)
-                        neweffect.scriptEffect = scriptEffect
-                    record.effects.append(neweffect)
-                record.setChanged()
-        if changed: modFile.safeSave()
-        return changed
+        modFile.convertToLongFids(('SPEL',))
+        spells = modInfo.extras['bash.spellList'] = dict(
+            [(record.fid,record) for record in modFile.SPEL.getActiveRecords()])
+        self.allSpells.update(spells)
 
-    def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 11 or fields[1][:2] != '0x': continue
-            mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,value,weight = fields[:11]
-            mmod = _coerce(mmod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-            smod = _coerce(smod, str, AllowNone=True)
-            if smod is None: sid = None
-            else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
-            eid = _coerce(eid, str, AllowNone=True)
-            full = _coerce(full, str, AllowNone=True)
-            modPath = _coerce(modPath, str, AllowNone=True)
-            modb = _coerce(modb, float)
-            iconPath = _coerce(iconPath, str, AllowNone=True)
-            value = _coerce(value, int)
-            weight = _coerce(weight, float)
-            effects = []
-            _effects = fields[11:]
-            while len(_effects) >= 13:
-                _effect, _effects = _effects[1:13], _effects[13:]
-                name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                name = _coerce(name, str, AllowNone=True)
-                magnitude = _coerce(magnitude, int, AllowNone=True)
-                area = _coerce(area, int, AllowNone=True)
-                duration = _coerce(duration, int, AllowNone=True)
-                range = _coerce(range, str, AllowNone=True)
-                if range:
-                    range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                if actorvalue:
-                    actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                if None in (name,magnitude,area,duration,range,actorvalue):
-                    continue
-                effect = [name,magnitude,area,duration,range,actorvalue]
-                semod = _coerce(semod, str, AllowNone=True)
-                seobj = _coerce(seobj, int, 16, AllowNone=True)
-                seschool = _coerce(seschool, int, AllowNone=True)
-                sevisual = _coerce(sevisual, int, AllowNone=True)
-                seflags = _coerce(seflags, int, AllowNone=True)
-                sename = _coerce(sename, str, AllowNone=True)
-                if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                    effect.append([])
-                else:
-                    sefid = (GPath(aliases.get(semod,semod)),seobj)
-                    effect.append([sefid, seschool, sevisual,seflags, sename])
-                effects.append(effect)
-            fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, value, weight, effects]
-        ins.close()
+    def getPlayerSpells(self):
+        """Returns players spell list from savegame. (Returns ONLY spells. I.e., not abilities, etc.)"""
+        saveFile = self.saveFile
+        #--Get masters and npc spell fids
+        masters = saveFile.masters[:]
+        maxMasters = len(masters) - 1
+        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
+        npc = SreNPC(recFlags,data)
+        pcSpells = {} #--pcSpells[spellName] = iref
+        #--NPC doesn't have any spells?
+        if not npc.spells:
+            return pcSpells
+        #--Get spell names to match fids
+        for iref in npc.spells:
+            if (iref >> 24) == 255:
+                fid = iref
+            else:
+                fid = saveFile.fids[iref]
+            modIndex,objectIndex = getFormIndices(fid)
+            if modIndex == 255:
+                master = self.saveInfo.name
+            elif modIndex <= maxMasters:
+                master = masters[modIndex]
+            else: #--Bad fid?
+                continue
+            #--Get spell data
+            record = self.allSpells.get((master,objectIndex),None)
+            if record and record.full and record.spellType == 0 and fid != 0x136:
+                pcSpells[record.full] = (iref,record)
+        return pcSpells
 
-    def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%f"'
-        altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%f"'
-        effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-        scriptEffectFormat = ',"%s","0x%06X","%d","%s","%s","%s"'
-        noscriptEffectFiller = ',"None","None","None","None","None","None"'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                                _('Name'),_('Model Path'),_('Bound Radius'),
-                                _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
-                                _('Value'),_('Weight'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
-                                ),'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
-            eid,name,modpath,modb,iconpath,scriptfid,value,weight,effects = fid_stats[fid]
-            scriptfid = scriptfid or (GPath('None'), None)
-            try:
-                output = rowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
-            except TypeError:
-                output = altrowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
-            for effect in effects:
-                efname,magnitude,area,duration,range,actorvalue = effect[:-1]
-                range = recipientTypeNumber_Name.get(range,range)
-                actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                scripteffect = effect[-1]
-                output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
-                if len(scripteffect):
-                    longid,seschool,sevisual,seflags,sename = scripteffect
-                    if sevisual == '\x00\x00\x00\x00':
-                        sevisual = ''
-                    output += scriptEffectFormat % (longid[0].s,longid[1],seschool,sevisual,seflags,sename)
-                else:
-                    output += noscriptEffectFiller
-            output += '\n'
-            out.write(output)
-        out.close()
-class CBash_IngredientDetails:
-    """Details on SigilStones, with functions for importing/exporting from/to mod/text file."""
-    def __init__(self,types=None,aliases=None):
+    def removePlayerSpells(self,spellsToRemove):
+        """Removes specified spells from players spell list."""
+        (fid,recType,recFlags,version,data) = self.saveFile.getRecord(7)
+        npc = SreNPC(recFlags,data)
+        if npc.spells and spellsToRemove:
+            #--Remove spells and save
+            npc.spells = [iref for iref in npc.spells if iref not in spellsToRemove]
+            self.saveFile.setRecord(npc.getTuple(fid,version))
+            self.saveFile.safeSave()
+
+#------------------------------------------------------------------------------
+class SaveEnchantments:
+    """Player enchantments of a savegame."""
+
+    def __init__(self,saveInfo):
         """Initialize."""
-        self.fid_stats = {}
-        self.aliases = aliases or {} #--For aliasing mod names
-        self.recipientTypeNumber_Name = {
-            None : 'NONE',
-            0 : 'Self',
-            1 : 'Touch',
-            2 : 'Target',}
-        self.recipientTypeName_Number = dict([(y.lower(),x) for x,y in self.recipientTypeNumber_Name.iteritems() if x is not None])
-        self.actorValueNumber_Name = dict([(x, y) for x,y in enumerate(bush.actorValues)])
-        self.actorValueNumber_Name[None] = 'NONE'
-        self.actorValueName_Number = dict([(y.lower(),x) for x,y in self.actorValueNumber_Name.iteritems() if x is not None])
+        self.saveInfo = saveInfo
+        self.saveFile = None
+        self.createdEnchantments = []
 
-    def readFromMod(self,modInfo):
-        """Reads stats from specified mod."""
-        fid_stats = self.fid_stats
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000028)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_IngredientDetails:readFromMod"
-            print error[0]
-            return
+    def load(self,progress=None):
+        """Loads savegame and and extracts created enchantments from it."""
+        progress = progress or bolt.Progress()
+        saveFile = self.saveFile = SaveFile(self.saveInfo)
+        saveFile.load(SubProgress(progress,0,0.4))
+        #--Extract created enchantments
+        createdEnchantments = self.createdEnchantments
+        saveName = self.saveInfo.name
+        progress(progress.full-1,saveName.s)
+        for index,record in enumerate(saveFile.created):
+            if record.recType == 'ENCH':
+                record = record.getTypeCopy()
+                record.getSize() #--Since type copy makes it changed.
+                saveFile.created[index] = record
+                self.createdEnchantments.append((index,record))
 
-        for record in modFile.INGR:
-            fid_stats[record.fid] = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, record.effects_list]
+    def setCastWhenUsedEnchantmentNumberOfUses(self,uses):
+        """Sets Cast When Used Enchantment number of uses (via editing the enchat cost)."""
+        count = 0
+        for (index, record) in self.createdEnchantments:
+            if record.itemType in [1,2]:
+                if uses == 0:
+                    if record.enchantCost == 0: continue
+                    record.enchantCost = 0
+                else:
+                    if record.enchantCost == max(record.chargeAmount/uses,1): continue
+                    record.enchantCost = max(record.chargeAmount/uses,1)
+                record.setChanged()
+                record.getSize()
+                count += 1
+        self.saveFile.safeSave()
 
-    def writeToMod(self,modInfo):
-        """Writes stats to specified mod."""
-        fid_stats = self.fid_stats
-        changed = []
+class Save_NPCEdits:
+    """General editing of NPCs/player in savegame."""
 
-        Current = ObCollection(ModsPath=dirs['mods'].s)
-        Current.addMod(modInfo.getPath().stail, Flags=0x000000038)
-        Current.load()
-        try:
-            modFile = Current.LookupModFile(modInfo.getPath().stail)
-        except KeyError, error:
-            print "CBash_IngredientDetails:writeToMod"
-            print error[0]
-            return
+    def __init__(self,saveInfo):
+        """Initialize."""
+        self.saveInfo = saveInfo
+        self.saveFile = SaveFile(saveInfo)
 
-        for record in modFile.INGR:
-            newStats = fid_stats.get(record.fid, None)
-            if not newStats: continue
-            oldStats = [record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, record.effects_list]
-            if oldStats != newStats:
-                changed.append(oldStats[0]) #eid
-                record.eid, record.full, record.modPath, record.modb, record.iconPath, record.script, record.value, record.weight, effects = newStats
-                record.effects_list = effects
-        if changed: modFile.save()
-        return changed
+    def renamePlayer(self,newName):
+        """rename the player in  a save file."""
+        self.saveInfo.header.pcName = newName
+        saveFile = self.saveFile
+        saveFile.load()
+        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
+        npc = SreNPC(recFlags,data)
+        npc.full = Encode(newName,'mbcs')
+        saveFile.pcName = newName
+        saveFile.setRecord(npc.getTuple(fid,version))
+        saveFile.safeSave()
 
-    def readFromText(self,textPath):
-        """Imports stats from specified text file."""
-        fid_stats,aliases,recipientTypeName_Number,actorValueName_Number = self.fid_stats, self.aliases, self.recipientTypeName_Number, self.actorValueName_Number
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 11 or fields[1][:2] != '0x': continue
-            mmod,mobj,eid,full,modPath,modb,iconPath,smod,sobj,value,weight = fields[:11]
-            mmod = _coerce(mmod, str)
-            mid = (GPath(aliases.get(mmod,mmod)),_coerce(mobj,int,16))
-            smod = _coerce(smod, str, AllowNone=True)
-            if smod is None: sid = None
-            else: sid = (GPath(aliases.get(smod,smod)),_coerce(sobj,int,16))
-            eid = _coerce(eid, str, AllowNone=True)
-            full = _coerce(full, str, AllowNone=True)
-            modPath = _coerce(modPath, str, AllowNone=True)
-            modb = _coerce(modb, float)
-            iconPath = _coerce(iconPath, str, AllowNone=True)
-            value = _coerce(value, int)
-            weight = _coerce(weight, float)
-            effects = []
-            _effects = fields[12:]
-            while len(_effects) >= 13:
-                _effect, _effects = _effects[1:13], _effects[13:]
-                name,magnitude,area,duration,range,actorvalue,semod,seobj,seschool,sevisual,seflags,sename = tuple(_effect)
-                name = _coerce(name, str, AllowNone=True)
-                name = cast(name, POINTER(c_ulong)).contents.value #convert 4 char string to int (doesn't support obme)
-                magnitude = _coerce(magnitude, int, AllowNone=True)
-                area = _coerce(area, int, AllowNone=True)
-                duration = _coerce(duration, int, AllowNone=True)
-                range = _coerce(range, str, AllowNone=True)
-                if range:
-                    range = recipientTypeName_Number.get(range.lower(),_coerce(range,int))
-                actorvalue = _coerce(actorvalue, str, AllowNone=True)
-                if actorvalue:
-                    actorvalue = actorValueName_Number.get(actorvalue.lower(),_coerce(actorvalue,int))
-                if None in (name,magnitude,area,duration,range,actorvalue):
-                    continue
-                effect = [name,magnitude,area,duration,range,actorvalue]
-                semod = _coerce(semod, str, AllowNone=True)
-                seobj = _coerce(seobj, int, 16, AllowNone=True)
-                seschool = _coerce(seschool, int, AllowNone=True)
-                sevisual = _coerce(sevisual, int, AllowNone=True)
-                seflags = _coerce(seflags, int, AllowNone=True)
-                sename = _coerce(sename, str, AllowNone=True)
-                if None in (semod,seobj,seschool,sevisual,seflags,sename):
-                    effect.extend([None,None,None,None,None])
-                else:
-                    sefid = (GPath(aliases.get(semod,semod)),seobj)
-                    effect.extend([sefid, seschool, sevisual,seflags, sename])
-                effects.append(tuple(effect))
-            fid_stats[mid] = [eid, full, modPath, modb, iconPath, sid, value, weight, effects]
-        ins.close()
+# Patchers 1 ------------------------------------------------------------------
+#------------------------------------------------------------------------------
+class PatchFile(ModFile):
+    """Defines and executes patcher configuration."""
+    #--Class
+    mergeClasses = (
+        MreActi, MreAlch, MreAmmo, MreAnio, MreAppa, MreArmo, MreBook, MreBsgn, MreClas,
+        MreClot, MreCont, MreCrea, MreDoor, MreEfsh, MreEnch, MreEyes, MreFact, MreFlor, MreFurn,
+        MreGlob, MreGras, MreHair, MreIngr, MreKeym, MreLigh, MreLscr, MreLvlc, MreLvli,
+        MreLvsp, MreMgef, MreMisc, MreNpc,  MrePack, MreQust, MreRace, MreScpt, MreSgst,
+        MreSlgm, MreSoun, MreSpel, MreStat, MreTree, MreWatr, MreWeap, MreWthr,
+        MreClmt, MreCsty, MreIdle, MreLtex, MreRegn, MreSbsp, MreSkil,
+        MreTxst, MreMicn, MreFlst, MreLvln, MrePerk, MreExpl, MreIpct, MreIpds, MreProj,
+        MreDebr, MreImad, MreMstt, MreNote, MreTerm, MreAvif, MreEczn, MreBptd, MreVtyp,
+        MreMusc, MrePwat, MreAspc, MreHdpt, MreDobj, MreIdlm, MreArma, MreTact)
 
-    def writeToText(self,textPath):
-        """Exports stats to specified text file."""
-        fid_stats,recipientTypeNumber_Name,actorValueNumber_Name = self.fid_stats, self.recipientTypeNumber_Name, self.actorValueNumber_Name
-        headFormat = '"%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s","%s"\n'
-        rowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","0x%06X","%d","%f"'
-        altrowFormat = '"%s","0x%06X","%s","%s","%s","%f","%s","%s","%s","%d","%f"'
-        effectFormat = ',,"%s","%d","%d","%d","%s","%s"'
-        scriptEffectFormat = ',"%s","0x%06X","%d","%d","%d","%s"'
-        noscriptEffectFiller = ',"None","None","None","None","None","None"'
-        out = textPath.open('w')
-        out.write(Encode(headFormat % (_('Mod Name'),_('ObjectIndex'),_('Editor Id'),
-                                _('Name'),_('Model Path'),_('Bound Radius'),
-                                _('Icon Path'),_('Script Mod Name'),_('Script ObjectIndex'),
-                                _('Value'),_('Weight'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),
-                                _('Effect'),_('Name'),_('Magnitude'),_('Area'),_('Duration'),_('Range'),_('Actor Value'),
-                                _('SE Mod Name'),_('SE ObjectIndex'),_('SE school'),_('SE visual'),_('SE Is Hostile'),_('SE Name'),_('Additional Effects (Same format)')
-                                ),'mbcs'))
-        for fid in sorted(fid_stats,key = lambda x: fid_stats[x][0]):
-            eid,name,modpath,modb,iconpath,scriptfid,value,weight,effects = fid_stats[fid]
-            scriptfid = scriptfid or (GPath('None'), None)
-            try:
-                output = rowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
-            except TypeError:
-                output = altrowFormat % (Encode(fid[0].s,'mbcs'),fid[1],eid,name,modpath,modb,iconpath,Encode(scriptfid[0].s,'mbcs'),scriptfid[1],value,weight)
-            for effect in effects:
-                efname,magnitude,area,duration,range,actorvalue = effect[:6]
-                efname = c_ulong(efname)
-                efname = cast(byref(efname), POINTER(c_char * 4)).contents.value #convert int to 4 char string (doesn't support obme)
-                range = recipientTypeNumber_Name.get(range,range)
-                actorvalue = actorValueNumber_Name.get(actorvalue,actorvalue)
-                scripteffect = effect[6:]
-                output += effectFormat % (efname,magnitude,area,duration,range,Encode(actorvalue,'mbcs'))
-                if None not in scripteffect:
-                    output += scriptEffectFormat % tuple(scripteffect)
-                else:
-                    output += noscriptEffectFiller
-            output += '\n'
-            out.write(output)
-        out.close()
-#------------------------------------------------------------------------------
-class ModDetails:
-    """Details data for a mods file. Similar to TesCS Details view."""
-    def __init__(self,modInfo=None,progress=None):
-        """Initialize."""
-        self.group_records = {} #--group_records[group] = [(fid0,eid0),(fid1,eid1),...]
-
-    def readFromMod(self,modInfo,progress=None):
-        """Extracts details from mod file."""
-        def getRecordReader(ins,flags,size):
-            """Decompress record data as needed."""
-            if not MreRecord._flags1(flags).compressed:
-                return (ins,ins.tell()+size)
-            else:
-                import zlib
-                sizeCheck, = struct.unpack('I',ins.read(4))
-                decomp = zlib.decompress(ins.read(size-4))
-                if len(decomp) != sizeCheck:
-                    raise ModError(self.inName,
-                        _('Mis-sized compressed data. Expected %d, got %d.') % (size,len(decomp)))
-                reader = ModReader(modInfo.name,cStringIO.StringIO(decomp))
-                return (reader,sizeCheck)
-        progress = progress or bolt.Progress()
-        group_records = self.group_records = {}
-        records = group_records['TES4'] = []
-        ins = ModReader(modInfo.name,modInfo.getPath().open('rb'))
-        while not ins.atEnd():
-            (type,size,str0,fid,uint2) = ins.unpackRecHeader()
-            if type == 'GRUP':
-                progress(1.0*ins.tell()/modInfo.size,_("Scanning: ")+str0)
-                records = group_records.setdefault(str0,[])
-                if str0 in ('CELL','WRLD','DIAL'):
-                    ins.seek(size-20,1)
-            elif type != 'GRUP':
-                eid = ''
-                nextRecord = ins.tell() + size
-                recs,endRecs = getRecordReader(ins,str0,size)
-                while recs.tell() < endRecs:
-                    (type,size) = recs.unpackSubHeader()
-                    if type == 'EDID':
-                        eid = recs.readString(size)
-                        break
-                    recs.seek(size,1)
-                records.append((fid,eid))
-                ins.seek(nextRecord)
-        ins.close()
-        del group_records['TES4']
-
-#------------------------------------------------------------------------------
-class ModGroups:
-    """Groups for mods with functions for importing/exporting from/to text file."""
     @staticmethod
-    def filter(mods):
-        """Returns non-group header mods."""
-        return [x for x in mods if not reGroupHeader.match(x.s)]
-
-    def __init__(self):
-        """Initialize."""
-        self.mod_group = {}
-
-    def readFromModInfos(self,mods=None):
-        """Imports mods/groups from modInfos."""
-        column = modInfos.table.getColumn('group')
-        mods = ModGroups.filter(mods or column.keys())
-        groups = tuple(column.get(x) for x in mods)
-        self.mod_group.update((x,y) for x,y in zip(mods,groups) if y)
-
-    def writeToModInfos(self,mods=None):
-        """Exports mod groups to modInfos."""
-        mods = ModGroups.filter(mods or modInfos.table.data.keys())
-        mod_group = self.mod_group
-        column = modInfos.table.getColumn('group')
-        changed = 0
-        for mod in mods:
-            if mod in mod_group and column.get(mod) != mod_group[mod]:
-                column[mod] = mod_group[mod]
-                changed += 1
-        return changed
+    def modIsMergeable(modInfo,progress=None,verbose=True):
+        """Returns True or error message indicating whether specified mod is mergeable."""
+        reasons = ''
+        if reEsmExt.search(modInfo.name.s):
+            if not verbose: return False
+            reasons += _("\n.    Is esm.")
+        #--Bashed Patch
+        if modInfo.header.author == "BASHED PATCH":
+            if not verbose: return False
+            reasons += _("\n.    Is Bashed Patch.")
 
-    def readFromText(self,textPath):
-        """Imports mod groups from specified text file."""
-        textPath = GPath(textPath)
-        mod_group = self.mod_group
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) >= 2 and reModExt.search(fields[0]):
-               mod,group = fields[:2]
-               mod_group[GPath(mod)] = group
-        ins.close()
+        #--Bsa?
+        reBsa = re.compile(re.escape(modInfo.name.sroot)+'.*bsa$',re.I)
+        for file in modInfos.dir.list():
+            if reBsa.match(file.s):
+                if not verbose: return False
+                reasons += _("\n.    Has BSA archive.")
+                break
+        #-- Check to make sure NoMerge tag not in tags - if in tags don't show up as mergeable.
+        if 'NoMerge' in modInfos[GPath(modInfo.name.s)].getBashTags():
+            if not verbose: return False
+            reasons += _("\n.    Has 'NoMerge' tag.")
+        #--Load test
+        mergeTypes = set([recClass.classType for recClass in PatchFile.mergeClasses])
+        modFile = ModFile(modInfo,LoadFactory(False,*mergeTypes))
+        try:
+            modFile.load(True)
+        except ModError, error:
+            if not verbose: return False
+            reasons += '\n.    ' + Unicode(str(error))+'.'
+        #--Skipped over types?
+        if modFile.topsSkipped:
+            if not verbose: return False
+            reasons += (_("\n.    Unsupported types: ") + ', '.join(sorted(modFile.topsSkipped))+'.')
+        #--Empty mod
+        if not modFile.tops:
+            if not verbose: return False
+            reasons += _("\n.    Empty mod.")
+        #--New record
+        lenMasters = len(modFile.tes4.masters)
+        newblocks = []
+        for type,block in modFile.tops.iteritems():
+            for record in block.getActiveRecords():
+                if record.fid >> 24 >= lenMasters:
+                    if not verbose: return False
+                    newblocks.append(type)
+                    break
+        if newblocks: reasons += (_("\n.    New record(s) in block(s): ") + ', '.join(sorted(newblocks))+'.')
+        dependent = [curModInfo.name.s for curModInfo in modInfos.data.values() if curModInfo.header.author != "BASHED PATCH" if GPath(modInfo.name.s) in curModInfo.header.masters]
+        if dependent:
+            if not verbose: return False
+            reasons += (_("\n.    Is a master of mod(s): ") + ', '.join(sorted(dependent))+'.')
+        if reasons: return reasons
+        return True
 
-    def writeToText(self,textPath):
-        """Exports eids to specified text file."""
-        textPath = GPath(textPath)
-        mod_group = self.mod_group
-        rowFormat = '"%s","%s"\n'
-        out = textPath.open('w')
-        out.write(Encode(rowFormat % (_("Mod"),_("Group")),'mbcs'))
-        for mod in sorted(mod_group):
-            out.write(rowFormat % (mod.s,mod_group[mod]))
-        out.close()
+    #--Instance
+    def __init__(self,modInfo,patchers):
+        """Initialization."""
+        ModFile.__init__(self,modInfo,None)
+        self.tes4.author = 'BASHED PATCH'
+        self.tes4.masters = [modInfos.masterName]
+        self.longFids = True
+        #--New attrs
+        self.aliases = {} #--Aliases from one mod name to another. Used by text file patchers.
+        self.patchers = patchers
+        self.keepIds = set()
+        self.mergeIds = set()
+        self.loadErrorMods = []
+        self.worldOrphanMods = []
+        self.unFilteredMods = []
+        self.compiledAllMods = []
+        self.patcher_mod_skipcount = {}
+        #--Config
+        self.bodyTags = 'HAGPBFE' #--Default bodytags
+        self.weaponTags = 'BESMUTL' #--Default weaponTags
+        #--Mods
+        self.setMods([name for name in modInfos.ordered if modInfos[name].mtime < self.patchTime],[])
+        for patcher in self.patchers:
+            patcher.initPatchFile(self,self.loadMods)
 
-#------------------------------------------------------------------------------
-class PCFaces:
-    """Package: Objects and functions for working with face data."""
-    flags = Flags(0L,Flags.getNames('name','race','gender','hair','eye','iclass','stats','factions','modifiers','spells'))
+    def setMods(self,loadMods=None,mergeMods=None):
+        """Sets mod lists and sets."""
+        if loadMods != None: self.loadMods = loadMods
+        if mergeMods != None: self.mergeMods = mergeMods
+        self.loadSet = set(self.loadMods)
+        self.mergeSet = set(self.mergeMods)
+        self.allMods = modInfos.getOrdered(self.loadSet|self.mergeSet)
+        self.allSet = set(self.allMods)
 
-    class PCFace(object):
-        """Represents a face."""
-        __slots__ = ('masters','eid','pcName','race','gender','eye','hair',
-            'hairLength','hairRed','hairBlue','hairGreen','unused3','fggs_p','fgga_p','fgts_p','level','attributes',
-            'skills','health','unused2','baseSpell','fatigue','iclass','factions','modifiers','spells')
-        def __init__(self):
-            self.masters = []
-            self.eid = self.pcName = 'generic'
-            self.fggs_p = self.fgts_p = '\x00'*4*50
-            self.fgga_p = '\x00'*4*30
-            self.unused2 = null2
-            self.health = self.unused3 = self.baseSpell = self.fatigue = self.level = 0
-            self.skills = self.attributes = self.iclass = None
-            self.factions = []
-            self.modifiers = []
-            self.spells = []
+    def getKeeper(self):
+        """Returns a function to add fids to self.keepIds."""
+        def keep(fid):
+            self.keepIds.add(fid)
+            return fid
+        return keep
 
-        def getGenderName(self):
-            return self.gender and 'Female' or 'Male'
+    def initData(self,progress):
+        """Gives each patcher a chance to get its source data."""
+        if not len(self.patchers): return
+        progress = progress.setFull(len(self.patchers))
+        for index,patcher in enumerate(self.patchers):
+            progress(index,_("Preparing\n%s") % patcher.getName())
+            patcher.initData(SubProgress(progress,index))
+        progress(progress.full,_('Patchers prepared.'))
 
-        def getRaceName(self):
-            return bush.raceNames.get(self.race,_('Unknown'))
+    def initFactories(self,progress):
+        """Gets load factories."""
+        progress(0,_("Processing."))
+        def updateClasses(type_classes,newClasses):
+            if not newClasses: return
+            for item in newClasses:
+                if not isinstance(item,str):
+                    type_classes[item.classType] = item
+                elif item not in type_classes:
+                    type_classes[item] = item
+        readClasses = {}
+        writeClasses = {}
+        updateClasses(readClasses,(MreMgef,MreScpt)) #--Need info from magic effects.
+        updateClasses(writeClasses,(MreMgef,)) #--Need info from magic effects.
+        for patcher in self.patchers:
+            updateClasses(readClasses, patcher.getReadClasses())
+            updateClasses(writeClasses, patcher.getWriteClasses())
+        self.readFactory = LoadFactory(False,*readClasses.values())
+        self.loadFactory = LoadFactory(True,*writeClasses.values())
+        #--Merge Factory
+        self.mergeFactory = LoadFactory(False,*PatchFile.mergeClasses)
 
-        def convertRace(self,fromRace,toRace):
-            """Converts face from one race to another while preserving structure, etc."""
-            for attr,num in (('fggs_p',50),('fgga_p',30),('fgts_p',50)):
-                format = `num`+'f'
-                sValues = list(struct.unpack(format,getattr(self,attr)))
-                fValues = list(struct.unpack(format,getattr(fromRace,attr)))
-                tValues = list(struct.unpack(format,getattr(toRace,attr)))
-                for index,(sValue,fValue,tValue) in enumerate(zip(sValues,fValues,tValues)):
-                    sValues[index] = sValue + fValue - tValue
-                setattr(self,attr,struct.pack(format,*sValues))
+    def scanLoadMods(self,progress):
+        """Scans load+merge mods."""
+        if not len(self.loadMods): return
+        nullProgress = bolt.Progress()
+        progress = progress.setFull(len(self.allMods))
+        for index,modName in enumerate(self.allMods):
+            bashTags = modInfos[modName].getBashTags()
+            if modName in self.loadMods and 'Filter' in bashTags:
+                self.unFilteredMods.append(modName)
+            try:
+                loadFactory = (self.readFactory,self.mergeFactory)[modName in self.mergeSet]
+                progress(index,_("%s\nLoading...") % modName.s)
+                modInfo = modInfos[GPath(modName)]
+                modFile = ModFile(modInfo,loadFactory)
+                modFile.load(True,SubProgress(progress,index,index+0.5))
+            except ModError:
+                self.loadErrorMods.append(modName)
+                continue
+            try:
+                #--Error checks
+                if 'WRLD' in modFile.tops and modFile.WRLD.orphansSkipped:
+                    self.worldOrphanMods.append(modName)
+                if 'SCPT' in modFile.tops and modName != 'Fallout3.esm':
+                    gls = modFile.SCPT.getRecord(0x00025811)
+                    if gls and gls.compiledSize == 4 and gls.lastIndex == 0:
+                        self.compiledAllMods.append(modName)
+                pstate = index+0.5
+                isMerged = modName in self.mergeSet
+                doFilter = isMerged and 'Filter' in bashTags
+                #--iiMode is a hack to support Item Interchange. Actual key used is InventOnly.
+                iiMode = isMerged and bool(set(('InventOnly','IIM')) & bashTags)
+                if isMerged:
+                    progress(pstate,_("%s\nMerging...") % modName.s)
+                    self.mergeModFile(modFile,nullProgress,doFilter,iiMode)
+                else:
+                    progress(pstate,_("%s\nScanning...") % modName.s)
+                    self.scanModFile(modFile,nullProgress)
+                for patcher in sorted(self.patchers,key=attrgetter('scanOrder')):
+                    if iiMode and not patcher.iiMode: continue
+                    progress(pstate,_("%s\n%s") % (modName.s,patcher.name))
+                    patcher.scanModFile(modFile,nullProgress)
+                # Clip max version at {Fo3:0.94, FoNV:1.34}.  See explanation in the CBash version as to why.
+                self.tes4.version = min(max(modFile.tes4.version, self.tes4.version),1.34)
+            except bolt.CancelError:
+                raise
+            except:
+                print _("MERGE/SCAN ERROR:"),modName.s
+                raise
+        progress(progress.full,_('Load mods scanned.'))
 
-    # SAVES -------------------------------------------------------------------
-    @staticmethod
-    def save_getNamePos(saveName,data,pcName):
-        """Safely finds position of name within save ACHR data."""
-        namePos = data.find(pcName)
-        if namePos == -1:
-            raise SaveFileError(saveName,_('Failed to find pcName in PC ACHR record.'))
-        namePos2 = data.find(pcName,namePos+1)
-        if namePos2 != -1:
-            raise SaveFileError(saveName,_(
-                'Uncertain about position of face data, probably because '
-                'player character name is too short. Try renaming player '
-                'character in save game.'))
-        return namePos
+    def mergeModFile(self,modFile,progress,doFilter,iiMode):
+        """Copies contents of modFile into self."""
+        mergeIds = self.mergeIds
+        loadSet = self.loadSet
+        modFile.convertToLongFids()
+        badForm = (GPath("Fallout3.esm"),0xA31D) #--DarkPCB record
+        for blockType,block in modFile.tops.iteritems():
+            iiSkipMerge = iiMode and blockType not in ('LVLC','LVLI','LVSP','LVLN')
+            #--Make sure block type is also in read and write factories
+            if blockType not in self.loadFactory.recTypes:
+                recClass = self.mergeFactory.type_class[blockType]
+                self.readFactory.addClass(recClass)
+                self.loadFactory.addClass(recClass)
+            patchBlock = getattr(self,blockType)
+            if not isinstance(patchBlock,MobObjects):
+                raise BoltError(_("Merge unsupported for type: ")+blockType)
+            filtered = []
+            for record in block.getActiveRecords():
+                if record.fid == badForm: continue
+                #--Include this record?
+                if not doFilter or record.fid[0] in loadSet:
+                    filtered.append(record)
+                    if doFilter: record.mergeFilter(loadSet)
+                    if iiSkipMerge: continue
+                    record = record.getTypeCopy()
+                    patchBlock.setRecord(record)
+                    mergeIds.add(record.fid)
+            #--Filter records
+            block.records = filtered
+            block.indexRecords()
 
-    # Save Get ----------------------------------------------------------------
-    @staticmethod
-    def save_getFace(saveFile):
-        """DEPRECATED. Same as save_getPlayerFace(saveFile)."""
-        return PCFaces.save_getPlayerFace(saveFile)
+    def scanModFile(self,modFile,progress):
+        """Scans file and overwrites own records with modfile records."""
+        #--Keep all MGEFs
+        modFile.convertToLongFids('MGEF')
+        if 'MGEF' in modFile.tops:
+            for record in modFile.MGEF.getActiveRecords():
+                self.MGEF.setRecord(record.getTypeCopy())
+        #--Merger, override.
+        mergeIds = self.mergeIds
+        mapper = modFile.getLongMapper()
+        for blockType,block in self.tops.iteritems():
+            if blockType in modFile.tops:
+                block.updateRecords(modFile.tops[blockType],mapper,mergeIds)
 
-    @staticmethod
-    def save_getFaces(saveFile):
-        """Returns player and created faces from a save file or saveInfo."""
-        if isinstance(saveFile,SaveInfo):
-            saveInfo = saveFile
-            saveFile = SaveFile(saveInfo)
-            saveFile.load()
-        faces = PCFaces.save_getCreatedFaces(saveFile)
-        playerFace = PCFaces.save_getPlayerFace(saveFile)
-        faces[7] = playerFace
-        return faces
+    def buildPatch(self,log,progress):
+        """Completes merge process. Use this when finished using scanLoadMods."""
+        if not len(self.patchers): return
+        log.setHeader('= '+self.fileInfo.name.s+' '+'='*30+'#',True)
+        log("{{CONTENTS=1}}")
+        #--Load Mods and error mods
+        log.setHeader(_("= Overview"),True)
+        log.setHeader(_("=== Date/Time"))
+        log('* '+formatDate(time.time()))
+        log(_('* Elapsed Time: ') + 'TIMEPLACEHOLDER')
+        if self.patcher_mod_skipcount:
+            log.setHeader(_("=== Skipped Imports"))
+            log(_("The following import patchers skipped records because the imported record required a missing or non-active mod to work properly. If this was not intentional, rebuild the patch after either deactivating the imported mods listed below or activating the missing mod(s)."))
+            for patcher, mod_skipcount in self.patcher_mod_skipcount.iteritems():
+                log ('* %s skipped %d records:' % (str(patcher),sum(mod_skipcount.values())))
+                for mod, skipcount in mod_skipcount.iteritems():
+                    log ('  * The imported mod, %s, skipped %d records.' % (str(mod),skipcount))
+        if self.unFilteredMods:
+            log.setHeader(_("=== Unfiltered Mods"))
+            log(_("The following mods were active when the patch was built. For the mods to work properly, you should deactivate the mods and then rebuild the patch with the mods [[http://wrye.ufrealms.net/Wrye%20Bash.html#MergeFiltering|Merged]] in."))
+            for mod in self.unFilteredMods: log ('* '+mod.s)
+        if self.loadErrorMods:
+            log.setHeader(_("=== Load Error Mods"))
+            log(_("The following mods had load errors and were skipped while building the patch. Most likely this problem is due to a badly formatted mod. For more info, see [[http://www.uesp.net/wiki/Tes4Mod:Wrye_Bash/Bashed_Patch#Error_Messages|Bashed Patch: Error Messages]]."))
+            for mod in self.loadErrorMods: log ('* '+mod.s)
+        if self.worldOrphanMods:
+            log.setHeader(_("=== World Orphans"))
+            log(_("The following mods had orphaned world groups, which were skipped. This is not a major problem, but you might want to use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#RemoveWorldOrphans|Remove World Orphans]] command to repair the mods."))
+            for mod in self.worldOrphanMods: log ('* '+mod.s)
+        if self.compiledAllMods:
+            log.setHeader(_("=== Compiled All"))
+            log(_("The following mods have an empty compiled version of genericLoreScript. This is usually a sign that the mod author did a __compile all__ while editing scripts. This may interfere with the behavior of other mods that intentionally modify scripts from Fallout3.esm. (E.g. Cobl and Unofficial Fallout 3 Patch.) You can use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#DecompileAll|Decompile All]] command to repair the mods."))
+            for mod in self.compiledAllMods: log ('* '+mod.s)
+        log.setHeader(_("=== Active Mods"),True)
+        for name in self.allMods:
+            version = modInfos.getVersion(name)
+            if name in self.loadMods:
+                message = '* %02X ' % (self.loadMods.index(name),)
+            else:
+                message = '* ++ '
+            if version:
+                message += _('%s  [Version %s]') % (name.s,version)
+            else:
+                message += name.s
+            log(message)
+        #--Load Mods and error mods
+        if self.aliases:
+            log.setHeader(_("= Mod Aliases"))
+            for key,value in sorted(self.aliases.iteritems()):
+                log('* %s >> %s' % (key.s,value.s))
+        #--Patchers
+        self.keepIds |= self.mergeIds
+        subProgress = SubProgress(progress,0,0.9,len(self.patchers))
+        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('editOrder'))):
+            subProgress(index,_("Completing\n%s...") % (patcher.getName(),))
+            patcher.buildPatch(log,SubProgress(subProgress,index))
+        #--Trim records
+        progress(0.9,_("Completing\nTrimming records..."))
+        for block in self.tops.values():
+            block.keepRecords(self.keepIds)
+        progress(0.95,_("Completing\nConverting fids..."))
+        #--Convert masters to short fids
+        self.tes4.masters = self.getMastersUsed()
+        self.convertToShortFids()
+        progress(1.0,"Compiled.")
+        #--Description
+        numRecords = sum([x.getNumRecords(False) for x in self.tops.values()])
+        self.tes4.description = Encode(_("Updated: %s\n\nRecords Changed: %d") % (formatDate(time.time()),numRecords),'mbcs')
+
+class CBash_PatchFile(ObModFile):
+    """Defines and executes patcher configuration."""
 
+    #--Class
     @staticmethod
-    def save_getCreatedFace(saveFile,targetid):
-        """Gets a particular created face."""
-        return PCFaces.save_getCreatedFaces(saveFile,targetid).get(targetid)
+    def configIsCBash(patchConfigs):
+        for key in patchConfigs:
+            if 'CBash' in key:
+                return True
+        return False
 
     @staticmethod
-    def save_getCreatedFaces(saveFile,targetid=None):
-        """Returns created faces from savefile. If fid is supplied, will only
-        return created face with that fid.
-        Note: Created NPCs do NOT use irefs!"""
-        targetid = bolt.intArg(targetid)
-        if isinstance(saveFile,SaveInfo):
-            saveInfo = saveFile
-            saveFile = SaveFile(saveInfo)
-            saveFile.load()
-        faces = {}
-        for record in saveFile.created:
-            if record.recType != 'NPC_': continue
-            #--Created NPC record
-            if targetid and record.fid != targetid: continue
-            npc = record.getTypeCopy()
-            face = faces[npc.fid] = PCFaces.PCFace()
-            face.masters = saveFile.masters
-            for attr in ('eid','race','eye','hair','hairLength',
-                         'hairRed','hairBlue','hairGreen','unused3',
-                         'fggs_p','fgga_p','fgts_p','level','skills',
-                         'health','unused2','baseSpell', 'fatigue',
-                         'attributes','iclass'):
-                setattr(face,attr,getattr(npc,attr))
-            face.gender = (0,1)[npc.flags.female]
-            face.pcName = npc.full
-            #--Changed NPC Record
-            PCFaces.save_getChangedNpc(saveFile,record.fid,face)
-        return faces
+    def modIsMergeableNoLoad(modInfo,verbose=False):
+        reasons = ''
+        if reEsmExt.search(modInfo.name.s):
+            if not verbose: return False
+            reasons += _("\n.    Is esm.")
+        #--Bashed Patch
+        if modInfo.header.author == "BASHED PATCH":
+            if not verbose: return False
+            reasons += _("\n.    Is Bashed Patch.")
+        #--Bsa?
+        reBsa = re.compile(re.escape(modInfo.name.sroot)+'.*bsa$',re.I)
+        for file in modInfos.dir.list():
+            if reBsa.match(file.s):
+                if not verbose: return False
+                reasons += _("\n.    Has BSA archive.")
+                break
+        #-- Check to make sure NoMerge tag not in tags - if in tags don't show up as mergeable.
+        tags = modInfos[modInfo.name].getBashTags()
+        if 'NoMerge' in tags:
+            if not verbose: return False
+            reasons += _("\n.    Has 'NoMerge' tag.")
+        if reasons: return reasons
+        return True
 
     @staticmethod
-    def save_getChangedNpc(saveFile,fid,face=None):
-        """Update face with data from npc change record."""
-        face = face or PCFaces.PCFace()
-        changeRecord = saveFile.getRecord(fid)
-        if not changeRecord:
-            return face
-        fid,recType,recFlags,version,data = changeRecord
-        npc = SreNPC(recFlags,data)
-        if npc.acbs:
-            face.gender = npc.acbs.flags.female
-            face.level = npc.acbs.level
-            face.baseSpell = npc.acbs.baseSpell
-            face.fatigue = npc.acbs.fatigue
-        for attr in ('attributes','skills','health','unused2'):
-            value = getattr(npc,attr)
-            if value != None:
-                setattr(face,attr,value)
-        #--Iref >> fid
-        getFid = saveFile.getFid
-        face.spells = [getFid(x) for x in (npc.spells or [])]
-        face.factions = [(getFid(x),y) for x,y in (npc.factions or [])]
-        face.modifiers = (npc.modifiers or [])[:]
-        #delist('npc.spells:',[strFid(x) for x in face.spells])
-        #delist('npc.factions:',face.factions)
-        #delist('npc.modifiers:',face.modifiers)
-        return face
-
-    @staticmethod
-    def save_getPlayerFace(saveFile):
-        """Extract player face from save file."""
-        if isinstance(saveFile,SaveInfo):
-            saveInfo = saveFile
-            saveFile = SaveFile(saveInfo)
-            saveFile.load()
-        face = PCFaces.PCFace()
-        face.pcName = saveFile.pcName
-        face.masters = saveFile.masters
-        #--Player ACHR
-        record = saveFile.getRecord(0x14)
-        data = record[-1]
-        namePos = PCFaces.save_getNamePos(saveFile.fileInfo.name,data,saveFile.pcName)
-        (face.fggs_p, face.fgga_p, face.fgts_p, face.race, face.hair, face.eye,
-            face.hairLength, face.hairRed, face.hairBlue, face.hairGreen, face.unused3, face.gender) = struct.unpack(
-            '=200s120s200s3If3BsB',data[namePos-542:namePos-1])
-        classPos = namePos+len(saveFile.pcName)+1
-        face.iclass, = struct.unpack('I',data[classPos:classPos+4])
-        #--Iref >> fid
-        getFid = saveFile.getFid
-        face.race = getFid(face.race)
-        face.hair = getFid(face.hair)
-        face.eye = getFid(face.eye)
-        face.iclass = getFid(face.iclass)
-        #--Changed NPC Record
-        PCFaces.save_getChangedNpc(saveFile,7,face)
-        #--Done
-        return face
-
-    # Save Set ----------------------------------------------------------------
-    @staticmethod
-    def save_setFace(saveInfo,face,flags=0L):
-        """DEPRECATED. Write a pcFace to a save file."""
-        saveFile = SaveFile(saveInfo)
-        saveFile.load()
-        PCFaces.save_setPlayerFace(saveFile,face,flags)
-        saveFile.safeSave()
+    def modIsMergeableLoad(modInfo,verbose=False,modFile=None):
+        allowMissingMasters = set(['Filter','IIM','InventOnly'])
+        tags = modInfos[modInfo.name].getBashTags()
+        reasons = ''
+        #--Load test
+        if modFile is None:
+            Current = ObCollection(ModsPath=dirs['mods'].s)
+            Current.addMod(modInfo.getPath().stail, Flags=0x00000128)
+            Current.load()
+            try:
+                modFile = Current.LookupModFile(modInfo.getPath().stail)
+            except KeyError, error:
+                print "modIsMergeableLoad"
+                print error[0]
+                return
+        missingMasters = []
+        nonActiveMasters = []
+        masters = modFile.TES4.masters
+        for master in masters:
+            master = GPath(master)
+            if not tags & allowMissingMasters:
+                if master not in modInfos:
+                    if not verbose: return False
+                    missingMasters.append(master.s)
+                elif not modInfos.isSelected(master):
+                    if not verbose: return False
+                    nonActiveMasters.append(master.s)
+        #--masters not present in mod list?
+        if len(missingMasters):
+            if not verbose: return False
+            reasons += (_("\n.    Masters missing: \n    * ") + '\n    * '.join(sorted(missingMasters)))
+        if len(nonActiveMasters):
+            if not verbose: return False
+            reasons += (_("\n.    Masters not active: \n    * ") + '\n    * '.join(sorted(nonActiveMasters)))
+        #--Empty mod
+        if modFile.IsEmpty():
+            if not verbose: return False
+            reasons += _("\n.    Empty mod.")
+        #--New record
+        else:
+            if not tags & allowMissingMasters:
+                newblocks = modFile.GetNewRecordTypes()
+                if newblocks:
+                    if not verbose: return False
+                    reasons += (_("\n.    New record(s) in block(s): ") + ', '.join(sorted(newblocks))+'.')
+        dependent = [curModInfo.name.s for curModInfo in modInfos.data.values() if curModInfo.header.author != "BASHED PATCH" and modInfo.name.s in curModInfo.header.masters and curModInfo.name not in modInfos.mergeable]
+        if dependent:
+            if not verbose: return False
+            reasons += (_("\n.    Is a master of non-mergeable mod(s): ") + ', '.join(sorted(dependent))+'.')
+        if reasons: return reasons
+        return True
 
     @staticmethod
-    def save_setCreatedFace(saveFile,targetid,face):
-        """Sets created face in savefile to specified face.
-        Note: Created NPCs do NOT use irefs!"""
-        targetid = bolt.intArg(targetid)
-        #--Find record
-        for index,record in enumerate(saveFile.created):
-            if record.fid == targetid:
-                npc = record.getTypeCopy()
-                saveFile.created[index] = npc
-                break
-        else:
-            raise StateError("Record %08X not found in %s." % (targetid,saveFile.fileInfo.name.s))
-        if npc.recType != 'NPC_':
-            raise StateError("Record %08X in %s is not an NPC." % (targetid,saveFile.fileInfo.name.s))
-        #--Update masters
-        for fid in (face.race, face.eye, face.hair):
-            if not fid: continue
-            maxMaster = len(face.masters)-1
-            mod = getModIndex(fid)
-            master = face.masters[min(mod,maxMaster)]
-            if master not in saveFile.masters:
-                saveFile.masters.append(master)
-        masterMap = MasterMap(face.masters,saveFile.masters)
-        #--Set face
-        npc.full = face.pcName
-        npc.flags.female = (face.gender & 0x1)
-        npc.setRace(masterMap(face.race,0x00907)) #--Default to Imperial
-        npc.eye = masterMap(face.eye,None)
-        npc.hair = masterMap(face.hair,None)
-        npc.hairLength = face.hairLength
-        npc.hairRed = face.hairRed
-        npc.hairBlue = face.hairBlue
-        npc.hairGreen = face.hairGreen
-        npc.unused3 = face.unused3
-        npc.fggs_p = face.fggs_p
-        npc.fgga_p = face.fgga_p
-        npc.fgts_p = face.fgts_p
-        #--Stats: Skip Level, baseSpell, fatigue and factions since they're discarded by game engine.
-        if face.skills: npc.skills = face.skills
-        if face.health:
-            npc.health = face.health
-            npc.unused2 = face.unused2
-        if face.attributes: npc.attributes = face.attributes
-        if face.iclass: npc.iclass = face.iclass
-        npc.setChanged()
-        npc.getSize()
+    def modIsMergeable(modInfo,progress=None,verbose=True,modFile=None):
+        """Returns True or error message indicating whether specified mod is mergeable."""
+        canmerge = CBash_PatchFile.modIsMergeableNoLoad(modInfo, verbose)
+        if not verbose:
+            if canmerge == True:
+                return CBash_PatchFile.modIsMergeableLoad(modInfo, verbose, modFile)
+            return False
+        loadreasons = CBash_PatchFile.modIsMergeableLoad(modInfo, verbose, modFile)
+        reasons = ''
+        if canmerge != True:
+            reasons = canmerge
+        if loadreasons != True:
+            reasons += loadreasons
+        if reasons: return reasons
+        return True
 
-        #--Change record?
-        changeRecord = saveFile.getRecord(npc.fid)
-        if changeRecord == None: return
-        fid,recType,recFlags,version,data = changeRecord
-        npc = SreNPC(recFlags,data)
-        if not npc.acbs: npc.acbs = npc.getDefault('acbs')
-        npc.acbs.flags.female = face.gender
-        npc.acbs.level = face.level
-        npc.acbs.baseSpell = face.baseSpell
-        npc.acbs.fatigue = face.fatigue
-        npc.modifiers = face.modifiers[:]
-        #--Fid conversion
-        getIref = saveFile.getIref
-        npc.spells = [getIref(x) for x in face.spells]
-        npc.factions = [(getIref(x),y) for x,y in face.factions]
+    #--Instance
+    def __init__(self, patchName, patchers):
+        """Initialization."""
+        self.patchName = patchName
+        #--New attrs
+        self.aliases = {} #--Aliases from one mod name to another. Used by text file patchers.
+        self.patchers = patchers
+        self.mergeIds = set()
+        self.loadErrorMods = []
+        self.worldOrphanMods = []
+        self.unFilteredMods = []
+        self.compiledAllMods = []
+        self.type_patchers = {}
+        self.indexMGEFs = False
+        self.mgef_school = bush.mgef_school.copy()
+        self.mgef_name = bush.mgef_name.copy()
+        self.hostileEffects = bush.hostileEffects.copy()
+        self.scanSet = set()
+        self.patcher_mod_skipcount = {}
+        #--Config
+        self.bodyTags = 'HAGPBFE' #--Default bodytags
+        self.weaponTags = 'BESMUTL' #--Default weaponTags
+        #--Mods
+        self.setMods([name for name in modInfos.ordered if modInfos[name].mtime < self.patchTime],[])
+        for patcher in self.patchers:
+            patcher.initPatchFile(self,self.loadMods)
 
-        #--Done
-        saveFile.setRecord(npc.getTuple(fid,version))
+    def setMods(self,loadMods=None,mergeMods=None):##,forceMergeMods=[]):
+        """Sets mod lists and sets."""
+        if loadMods != None: self.loadMods = loadMods
+        if mergeMods != None: self.mergeMods = mergeMods
+##        self.forceMergeSet = set(forceMergeMods)
+        self.loadSet = set(self.loadMods)
+        self.mergeSet = set(self.mergeMods)
+        self.allMods = modInfos.getOrdered(self.loadSet|self.mergeSet)##|self.forceMergeSet)
+        self.allSet = set(self.allMods)
 
-    @staticmethod
-    def save_setPlayerFace(saveFile,face,flags=0L,morphFacts=None):
-        """Write a pcFace to a save file."""
-        flags = PCFaces.flags(flags)
-        #--Update masters
-        for fid in (face.race, face.eye, face.hair, face.iclass):
-            if not fid: continue
-            maxMaster = len(face.masters)-1
-            mod = getModIndex(fid)
-            master = face.masters[min(mod,maxMaster)]
-            if master not in saveFile.masters:
-                saveFile.masters.append(master)
-        masterMap = MasterMap(face.masters,saveFile.masters)
+    def initData(self,progress):
+        """Gives each patcher a chance to get its source data."""
+        if not len(self.patchers): return
+        progress = progress.setFull(len(self.patchers))
+        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('scanOrder'))):
+            progress(index,_("Preparing\n%s") % patcher.getName())
+            patcher.initData(self.type_patchers,SubProgress(progress,index))
+        progress(progress.full,_('Patchers prepared.'))
 
-        #--Player ACHR
-        #--Buffer for modified record data
-        buff = cStringIO.StringIO()
-        def buffPack(format,*args):
-            buff.write(struct.pack(format,*args))
-        def buffPackRef(oldFid,doPack=True):
-            newFid = oldFid and masterMap(oldFid,None)
-            if newFid and doPack:
-                newRef = saveFile.getIref(newFid)
-                buff.write(struct.pack('I',newRef))
-            else:
-                buff.seek(4,1)
-        oldRecord = saveFile.getRecord(0x14)
-        oldData = oldRecord[-1]
-        namePos = PCFaces.save_getNamePos(saveFile.fileInfo.name,oldData,saveFile.pcName)
-        buff.write(oldData)
-        #--Modify buffer with face data.
-        buff.seek(namePos-542)
-        buffPack('=200s120s200s',face.fggs_p, face.fgga_p, face.fgts_p)
-        #--Race?
-        buffPackRef(face.race,flags.race)
-        #--Hair, Eyes?
-        buffPackRef(face.hair,flags.hair)
-        buffPackRef(face.eye,flags.eye)
-        if flags.hair:
-            buffPack('=f3Bs',face.hairLength,face.hairRed,face.hairBlue,face.hairGreen,face.unused3)
-        else:
-            buff.seek(8,1)
-        #--Gender?
-        if flags.gender:
-            buffPack('B',face.gender)
-        else:
-            buff.seek(1,1)
-        #--Name?
-        if flags.name:
-            postName = buff.getvalue()[buff.tell()+len(saveFile.pcName)+2:]
-            buffPack('B',len(face.pcName)+1)
-            buff.write(face.pcName+'\x00')
-            buff.write(postName)
-            buff.seek(-len(postName),1)
-            saveFile.pcName = face.pcName
-        else:
-            buff.seek(len(saveFile.pcName)+2,1)
-        #--Class?
-        if flags.iclass and face.iclass:
-            pos = buff.tell()
-            newClass = masterMap(face.iclass)
-            oldClass = saveFile.fids[struct.unpack('I',buff.read(4))[0]]
-            customClass = saveFile.getIref(0x22843)
-            if customClass not in (newClass,oldClass):
-                buff.seek(pos)
-                buffPackRef(newClass)
+    def mergeModFile(self,modFile,progress,doFilter,iiMode):
+        """Copies contents of modFile into self."""
+        """Note that GMST and MGEF records will get assigned new FormID's, due to the way
+           that CBash works.  This is ok, since these types of records are only
+           referenced via their EditorID's."""
+        mergeIds = self.mergeIds
+        loadSet = self.loadSet
+        parentsToLoad = set()
+        recordsToLoad = set()
+        badForm = (GPath("Fallout3.esm"),0xA31D) #--DarkPCB record
+        for blockType, block in modFile.aggregates.iteritems():
+            iiSkipMerge = iiMode and blockType not in ('LVLC','LVLI','LVSP','LVLN')
+            if iiSkipMerge: continue
+            #--Make sure block type is also in read and write factories
+            for record in block:
+                if record.fid == badForm: continue
+                #--Include this record?
+                if record.IsWinning():
+                    if doFilter:
+                        if not record.fid[0] in loadSet: continue
+                        record.mergeFilter(loadSet)
+                    parent = record.Parent
+                    if parent:
+                        parentFid = parent.fid
+                        if self.HasRecord(parentFid) == False:
+                            #Copy the parent over if it isn't in the patch
+                            parentsToLoad.add(parentFid)
+                    recordsToLoad.add(record)
 
-        newData = buff.getvalue()
-        saveFile.setRecord(oldRecord[:-1]+(newData,))
+        recordFids = set([x.fid for x in recordsToLoad])
+        otherParentsToLoad = parentsToLoad - recordFids # Parents to copy from the winning mod
+        parentsToLoad -= otherParentsToLoad             # Parents to copy from this mod
 
-        #--Player NPC
-        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
-        npc = SreNPC(recFlags,data)
-        #--Gender
-        if flags.gender and npc.acbs:
-            npc.acbs.flags.female = face.gender
-        #--Stats
-        if flags.stats and npc.acbs:
-            npc.acbs.level = face.level
-            npc.acbs.baseSpell = face.baseSpell
-            npc.acbs.fatigue = face.fatigue
-            npc.attributes = face.attributes
-            npc.skills = face.skills
-            npc.health = face.health
-            npc.unused2 = face.unused2
-        #--Factions: Faction assignment doesn't work. (Probably stored in achr.)
-        #--Modifiers, Spells, Name
-        if flags.modifiers: npc.modifiers = face.modifiers[:]
-        if flags.spells:
-            #delist('Set PC Spells:',face.spells)
-            npc.spells = [saveFile.getIref(x) for x in face.spells]
-        npc.full = None
-        saveFile.setRecord(npc.getTuple(fid,version))
-        #--Save
-        buff.close()
+        def isWorldCELL(record):
+            if record._Type == "CELL":
+                parent = record.Parent
+                if parent:
+                    if parent._Type == "WRLD":
+                        cell = parent.WorldCELL
+                        if cell and cell.fid == record.fid:
+                            return True
+            return False
 
-    # Save Misc ----------------------------------------------------------------
-    @staticmethod
-    def save_repairHair(saveInfo):
-        """Repairs hair if it has been zeroed. (Which happens if hair came from a
-        cosmetic mod that has since been removed.) Returns True if repaired, False
-        if no repair was necessary."""
-        saveFile = SaveFile(saveInfo)
-        saveFile.load()
-        record = saveFile.getRecord(0x14)
-        data = record[-1]
-        namePos = PCFaces.save_getNamePos(saveInfo.name,data,saveFile.pcName)
-        raceRef,hairRef = struct.unpack('2I',data[namePos-22:namePos-14])
-        if hairRef != 0: return False
-        raceForm = raceRef and saveFile.fids[raceRef]
-        gender, = struct.unpack('B',data[namePos-2])
-        if gender:
-            hairForm = bush.raceHairFemale.get(raceForm,0x1da83)
-        else:
-            hairForm = bush.raceHairMale.get(raceForm,0x90475)
-        hairRef = saveFile.getIref(hairForm)
-        data = data[:namePos-18]+struct.pack('I',hairRef)+data[namePos-14:]
-        saveFile.setRecord(record[:-1]+(data,))
-        saveFile.safeSave()
-        return True
+        # Load parent records from winning mods first
+        for parentFid in otherParentsToLoad:
+            parent = self.ObCollection.LookupRecords(parentFid)
+            if parent:
+                # Deal with WorldCELL's copy flags not being set properly
+                if isWorldCELL(parent[0]):
+                    parent[0].Parent.CopyAsOverride(self)
+                    parent[0].CopyAsOverride(self,4)
+                else:
+                    parent[0].CopyAsOverride(self)
+        # Load parent records from this mod
+        for parentFid in parentsToLoad:
+            parent = self.ObCollection.LookupRecords(parentFid,True)
+            if parent:
+                for p in parent:
+                    if p.GName == modFile.GName:
+                        if isWorldCELL(p):
+                            p.CopyAsOverride(self,4)
+                        else:
+                            p.CopyAsOverride(self)
+        # Load records from this mod
+        for record in recordsToLoad:
+            override = record.CopyAsOverride(self)
+            if override:
+                mergeIds.add(override.fid)
 
-    # MODS --------------------------------------------------------------------
-    @staticmethod
-    def mod_getFaces(modInfo):
-        """Returns an array of PCFaces from a mod file."""
-        #--Mod File
-        loadFactory = LoadFactory(False,MreNpc)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        faces = {}
-        for npc in modFile.NPC_.getActiveRecords():
-            face = PCFaces.PCFace()
-            face.masters = modFile.tes4.masters + [modInfo.name]
-            for field in ('eid','race','eye','hair','hairLength',
-                          'hairRed','hairBlue','hairGreen','unused3',
-                          'fggs_p','fgga_p','fgts_p','level','skills',
-                          'health','unused2','baseSpell',
-                          'fatigue','attributes','iclass'):
-                setattr(face,field,getattr(npc,field))
-            face.gender = npc.flags.female
-            face.pcName = npc.full
-            faces[face.eid] = face
-            #print face.pcName, face.race, face.hair, face.eye, face.hairLength, face.hairRed, face.hairBlue, face.hairGreen, face.unused3
-        return faces
+##    def forceMergeModFile(self,modFile,progress,doFilter,iiMode):
+##        """Copies contents of modFile into self; as new records in the patch not as overrides including new records so can be dangerous!."""
+##        badForm = (GPath("Oblivion.esm"),0xA31D) #--DarkPCB record
+##        print modFile
+##        for blockType, block in modFile.aggregates.iteritems():
+##            #--Make sure block type is also in read and write factories
+##            print blockType, block
+##            for record in block:
+##                if record.fid == badForm: continue
+##                #--Include this record?
+##                if hasattr(record, '_ParentID'):
+##                    if self.HasRecord(record._ParentID) is None:
+##                        #Copy the winning version of the parent over if it isn't in the patch
+##                        parent = self.ObCollection.LookupRecords(record._ParentID)
+##                        if parent:
+##                            if parent[0].GName == record.GName:
+##                                parent[0].CopyAsNew(self.patchFile)
+##                            else:
+##                                parent[0].CopyAsOverride(self.patchFile)
+##                new = record.CopyAsNew(self)
+##                print new
 
-    @staticmethod
-    def mod_getRaceFaces(modInfo):
-        """Returns an array of Race Faces from a mod file."""
-        loadFactory = LoadFactory(False,MreRace)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        faces = {}
-        for race in modFile.RACE.getActiveRecords():
-            face = PCFaces.PCFace()
-            face.masters = []
-            for field in ('eid','fggs_p','fgga_p','fgts_p'):
-                setattr(face,field,getattr(race,field))
-            faces[face.eid] = face
-        return faces
+    def buildPatch(self,progress):
+        """Scans load+merge mods."""
+        if not len(self.loadMods): return
+        iiModeSet = set(('InventOnly','IIM'))
+        levelLists = set(('LVLC','LVLI','LVSP','LVLN'))
+        nullProgress = bolt.Progress()
 
-    @staticmethod
-    def mod_addFace(modInfo,face):
-        """Writes a pcFace to a mod file."""
-        #--Mod File
-        loadFactory = LoadFactory(True,MreNpc)
-        modFile = ModFile(modInfo,loadFactory)
-        if modInfo.getPath().exists():
-            modFile.load(True)
-        #--Tes4
-        tes4 = modFile.tes4
-        if not tes4.author:
-            tes4.author = '[wb]'
-        if not tes4.description:
-            tes4.description = _('Face dump from save game.')
-        if modInfos.masterName not in tes4.masters:
-            tes4.masters.append(modInfos.masterName)
-        masterMap = MasterMap(face.masters,tes4.masters+[modInfo.name])
-        #--Eid
-        npcEids = set([record.eid for record in modFile.NPC_.records])
-        eidForm = ''.join(("sg", bush.raceShortNames.get(face.race,'Unk'),
-            (face.gender and 'a' or 'u'), re.sub(r'\W','',face.pcName),'%02d'))
-        count,eid = 0, eidForm % 0
-        while eid in npcEids:
-            count += 1
-            eid = eidForm % count
-        #--NPC
-        npcid = genFid(len(tes4.masters),tes4.getNextObject())
-        npc = MreNpc(('NPC_',0,0x40000,npcid,0))
-        npc.eid = eid
-        npc.full = face.pcName
-        npc.flags.female = face.gender
-        npc.iclass = masterMap(face.iclass,0x237a8) #--Default to Acrobat
-        npc.setRace(masterMap(face.race,0x00907)) #--Default to Imperial
-        npc.eye = masterMap(face.eye,None)
-        npc.hair = masterMap(face.hair,None)
-        npc.hairLength = face.hairLength
-        npc.hairRed = face.hairRed
-        npc.hairBlue = face.hairBlue
-        npc.hairGreen = face.hairGreen
-        npc.unused3 = face.unused3
-        npc.fggs_p = face.fggs_p
-        npc.fgga_p = face.fgga_p
-        npc.fgts_p = face.fgts_p
-        #--Stats
-        npc.level = face.level
-        npc.baseSpell = face.baseSpell
-        npc.fatigue = face.fatigue
-        if face.skills: npc.skills = face.skills
-        if face.health:
-            npc.health = face.health
-            npc.unused2 = face.unused2
-        if face.attributes: npc.attributes = face.attributes
-        npc.setChanged()
-        modFile.NPC_.records.append(npc)
-        #--Save
-        modFile.safeSave()
-        return npc
+        IIMSet = set([modName for modName in (self.allSet|self.scanSet) if bool(modInfos[modName].getBashTags() & iiModeSet)])
 
-#------------------------------------------------------------------------------
-class CleanMod:
-    """Fixes cells to avoid nvidia fog problem."""
-    def __init__(self,modInfo):
-        self.modInfo = modInfo
-        self.fixedCells = set()
+        self.ObCollection = ObCollection(ModsPath=dirs['mods'].s)
 
-    def clean(self,progress):
-        """Duplicates file, then walks through and edits file as necessary."""
-        progress.setFull(self.modInfo.size)
-        fixedCells = self.fixedCells
-        fixedCells.clear()
-        #--File stream
-        path = self.modInfo.getPath()
-        #--Scan/Edit
-        ins = ModReader(self.modInfo.name,path.open('rb'))
-        out = path.temp.open('wb')
-        def copy(size,back=False):
-            buff = ins.read(size)
-            out.write(buff)
-        def copyPrev(size):
-            ins.seek(-size,1)
-            buff = ins.read(size)
-            out.write(buff)
-        while not ins.atEnd():
-            progress(ins.tell())
-            (type,size,str0,fid,uint2) = ins.unpackRecHeader()
-            copyPrev(20)
-            if type == 'GRUP':
-                if fid != 0: #--Ignore sub-groups
-                    pass
-                elif str0 not in ('CELL','WRLD'):
-                    copy(size-20)
-            #--Handle cells
-            elif type == 'CELL':
-                nextRecord = ins.tell() + size
-                while ins.tell() < nextRecord:
-                    (type,size) = ins.unpackSubHeader()
-                    copyPrev(6)
-                    if type != 'XCLL':
-                        copy(size)
-                    else:
-                        color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',size,'CELL.XCLL')
-                        if not (near or far or clip):
-                            near = 0.0001
-                            fixedCells.add(fid)
-                        out.write(struct.pack('=12s2f2l2f',color,near,far,rotXY,rotZ,fade,clip))
-            #--Non-Cells
-            else:
-                copy(size)
-        #--Done
-        ins.close()
-        out.close()
-        if fixedCells:
-            self.modInfo.makeBackup()
-            path.untemp()
-            self.modInfo.setmtime()
-        else:
-            path.temp.remove()
+        #add order reordered
+        #mods can't be added more than once, and a mod could be in both the loadSet and mergeSet or loadSet and scanSet
+        #if it was added as a normal mod first, it isn't flagged correctly when later added as a merge mod
+        #if it was added as a scan mod first, it isn't flagged correctly when later added as a normal mod
+        for name in self.mergeSet:
+            if modInfos[name].mtime < self.patchTime:
+                self.ObCollection.addMergeMod(modInfos[name].getPath().stail)
+        for name in self.loadSet:
+            if modInfos[name].mtime < self.patchTime:
+                self.ObCollection.addMod(modInfos[name].getPath().stail)
+        for name in self.scanSet:
+            if modInfos[name].mtime < self.patchTime:
+                self.ObCollection.addScanMod(modInfos[name].getPath().stail)
+##        for name in self.forceMergeSet:
+##            if modInfos[name].mtime < self.patchTime:
+##                self.ObCollection.addMergeMod(modInfos[name].getPath().stail)
+        self.patchName.temp.remove()
+        self.ObCollection.addMod(self.patchName.temp.s, IgnoreExisting=True)
+        self.ObCollection.load()
+        try:
+            patchFile = self.patchFile = self.ObCollection.LookupModFile(self.patchName.temp.s)
+        except KeyError, error:
+            print "buildPatch"
+            print error[0]
+            return
+        if self.ObCollection.LookupModFileLoadOrder(self.patchName.temp.s) == 0:
+            print _("Please copy this entire message and report it on the current official thread at "
+                    "http://forums.bethsoft.com/index.php?/forum/25-mods/.\n Also with:\n1. Your OS:"
+                    "\n2. Your installed MS Visual C++ redistributable versions:\n3. Your system RAM "
+                    "amount:\n4. How much memory Python.exe\pythonw.exe or Wrye Bash.exe is using\n5."
+                    " and finally... if restarting Wrye Bash and trying again and building the CBash "
+                    "Bashed Patch right away works fine\n")
+            print ObCollection.Debug_DumpModFiles()
+            raise StateError()
+        ObModFile.__init__(self, patchFile._CollectionID, patchFile._ModID)
 
-#------------------------------------------------------------------------------
-class ModCleaner:
-    """Class for cleaning ITM and UDR edits from mods.
-       ITM detection requires CBash to work."""
-    UDR     = 0x01  # Deleted references
-    ITM     = 0x02  # Identical to master records
-    FOG     = 0x04  # Nvidia Fog Fix
-    ALL = UDR|ITM|FOG
+        self.TES4.author = 'BASHED PATCH'
 
-    def __init__(self,modInfo):
-        self.modInfo = modInfo
-        self.itm = set()    # Fids for Identical To Master records
-        self.udr = set()    # Fids for Deleted Reference records
-        self.fog = set()    # Fids for Cells needing the Nvidia Fog Fix
+        #With this indexing, MGEFs may be looped through twice if another patcher also looks through MGEFs
+        #It's inefficient, but it really shouldn't be a problem since there are so few MGEFs.
+        if self.indexMGEFs:
+            mgefId_hostile = {}
+            self.mgef_school.clear()
+            self.mgef_name.clear()
+            for modName in self.allMods:
+                try:
+                    modFile = self.ObCollection.LookupModFile(modName.s)
+                except KeyError, error:
+                    print "indexMGEFs"
+                    print error[0]
+                    continue
+                for record in modFile.MGEF:
+                    full = record.full
+                    eid = record.eid
+                    if (full and eid):
+                        mgefId = cast(eid, POINTER(c_ulong)).contents.value if record.recordVersion is None else record.mgefCode
+                        self.mgef_school[mgefId] = record.school
+                        self.mgef_name[mgefId] = full
+                        mgefId_hostile[mgefId] = record.IsHostile
+                    record.UnloadRecord()
+            self.hostileEffects = set([mgefId for mgefId, hostile in mgefId_hostile.iteritems() if hostile])
+        self.completeMods = modInfos.getOrdered(self.allSet|self.scanSet)
+        type_patchers = self.type_patchers
+        numFinishers = 0
+        for type, patchers in type_patchers.iteritems():
+            if len([patcher.finishPatch for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'finishPatch')]):
+                numFinishers += 1
 
-    def scan(self,what=ALL,progress=bolt.Progress()):
-        """Scan this mod for dirty edits.
-           return (UDR,ITM,FogFix)"""
-        udr,itm,fog = ModCleaner.scan_Many([self.modInfo],what,progress)[0]
-        if what & ModCleaner.UDR:
-            self.udr = udr
-        if what & ModCleaner.ITM:
-            self.itm = itm
-        if what & ModCleaner.FOG:
-            self.fog = fog
-        return (udr,itm,fog)
+        progress = progress.setFull(len(self.completeMods) + max(numFinishers,1))
+        maxVersion = 0
+        for index,modName in enumerate(self.completeMods):
+            if modName == self.patchName: continue
+            modInfo = modInfos[modName]
+            bashTags = modInfo.getBashTags()
+            isScanned = modName in self.scanSet and modName not in self.loadSet and modName not in self.mergeSet
+            if modName in self.loadMods and 'Filter' in bashTags:
+                self.unFilteredMods.append(modName)
+            isMerged = modName in self.mergeSet
+##            isForceMerged = modName in self.forceMergeSet
+            doFilter = isMerged and 'Filter' in bashTags
+            #--iiMode is a hack to support Item Interchange. Actual key used is InventOnly.
+            iiMode = isMerged and bool(iiModeSet & bashTags)
+            try:
+                modFile = self.ObCollection.LookupModFile(modInfo.getPath().stail)
+            except KeyError, error:
+                print "completeMods"
+                print error[0]
+                continue
+            modGName = modFile.GName
+            #--Error checks
+            gls = modFile.LookupRecord(0x00025811)
+            if gls and gls.compiledSize == 4 and gls.lastIndex == 0 and modName != GPath('Fallout3.esm'):
+                self.compiledAllMods.append(modName)
+            pstate = 0
+            subProgress = SubProgress(progress,index)
+            subProgress.setFull(max(len(type_patchers),1))
+            for type, patchers in type_patchers.iteritems():
+                iiFilter = IIMSet and not (iiMode or type in levelLists)
+                #Filter the used patchers as needed
+                if iiMode:
+                    applyPatchers = [patcher.apply for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'apply') and patcher.iiMode if not patcher.applyRequiresChecked or (modGName in patcher.srcs)]
+                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') and patcher.iiMode if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
+                elif isScanned:
+                    applyPatchers = [] #Scanned mods should never be copied directly into the bashed patch.
+                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') and patcher.allowUnloaded if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
+                else:
+                    applyPatchers = [patcher.apply for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'apply') if not patcher.applyRequiresChecked or (modGName in patcher.srcs)]
+                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
 
-    @staticmethod
-    def scan_Many(modInfos,what=ALL,progress=bolt.Progress()):
-        """Scan multiple mods for dirty edits"""
-        if len(modInfos) == 0: return []
-        if not settings['bash.CBashEnabled']:
-            return ModCleaner._scan_Python(modInfos,what,progress)
-        else:
-            return ModCleaner._scan_CBash(modInfos,what,progress)
+                #See if all the patchers were filtered out
+                if not (applyPatchers or scanPatchers): continue
+                subProgress(pstate,_("Patching...\n%s::%s") % (modFile.ModName,type))
+                pstate += 1
+                for record in getattr(modFile, type):
+                    #If conflicts is > 0, it will include all conflicts, even the record that called it
+                    #(i.e. len(conflicts) will never equal 1)
+                    #The winning record is at position 0, and the last record is the one most overridden
+                    if doFilter:
+                        if not record.fid[0] in self.loadSet: continue
+                        record.mergeFilter(self.loadSet)
 
-    def clean(self,what=UDR|FOG,progress=bolt.Progress(),reScan=False):
-        """reScan:
-             True: perform scans before cleaning
-             False: only perform scans if itm/udr is empty
-             """
-        ModCleaner.clean_Many([self],what,progress,reScan)
+                    if iiFilter:
+                        #InventOnly/IIM tags are a pain. They don't fit the normal patch model.
+                        #They're basically a mixture of scanned and merged.
+                        #This effectively hides all non-level list records from the other patchers
+                        conflicts = [conflict for conflict in record.Conflicts() if conflict.GName not in IIMSet]
+                        isWinning = (len(conflicts) < 2 or conflicts[0].ModName == record.ModName)
+                    else:
+                        #Prevents scanned records from being scanned twice if the scanned record loads later than the real winning record
+                        # (once when the real winning record is applied, and once when the scanned record is later encountered)
+                        if isScanned and record.IsWinning(True): #Not the most optimized, but works well enough
+                            continue #doesn't work if the record's been copied into the patch...needs work
+                        isWinning = record.IsWinning()
 
-    @staticmethod
-    def clean_Many(cleaners,what,progress=bolt.Progress(),reScan=False):
-        """Accepts either a list of ModInfo's or a list of ModCleaner's"""
-        if isinstance(cleaners[0],ModInfos):
-            reScan = True
-            cleaners = [ModCleaner(x) for x in cleaners]
-        if not settings['bash.CBashEnabled']:
-            ModCleaner._clean_Python(cleaners,what,progress)
-        else:
-            #--CBash
-            #--Scan?
-            if reScan:
-                ret = ModCleaner._scan_CBash([x.modInfo for x in cleaners],what,progress)
-                for i,cleaner in enumerate(cleaners):
-                    udr,itm,fog = ret[i]
-                    if what & ModCleaner.UDR:
-                        cleaner.udr = udr
-                    if what & ModCleaner.ITM:
-                        cleaner.itm = itm
-                    if what & ModCleaner.FOG:
-                        cleaner.fog = fog
-            #--Clean
-            ModCleaner._clean_CBash(cleaners,what,progress)
+                    if isWinning:
+                        curPatchers = applyPatchers
+                    else:
+                        curPatchers = scanPatchers
+                    for patcher in curPatchers:
+                        patcher(modFile, record, bashTags)
+                    record.UnloadRecord()
+            if isMerged:
+                progress(index,_("%s\nMerging...") % modFile.ModName)
+                self.mergeModFile(modFile,nullProgress,doFilter,iiMode)
+##            if isForceMerged:
+##                progress(index,_("%s\nMerging...") % modFile.ModName)
+##                self.forceMergeModFile(modFile,nullProgress,doFilter,iiMode)
+            maxVersion = max(modFile.TES4.version, maxVersion)
+        # Force 1.0 as max TES4 version for now, as we don't expext any new esp format changes,
+        # and if they do come about, we can always change this.  Plus this will solve issues where
+        # Mod files mistakenly get have the header version set > 1.0
+        self.TES4.version = min(maxVersion,1.0)
+        #Finish the patch
+        modFile = self
+        progress(len(self.completeMods))
+        subProgress = SubProgress(progress,len(self.completeMods))
+        subProgress.setFull(max(numFinishers,1))
+        pstate = 0
+        for type, patchers in type_patchers.iteritems():
+            finishPatchers = [patcher.finishPatch for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'finishPatch')]
+            if finishPatchers:
+                subProgress(pstate,_("Final Patching...\n%s::%s") % (modFile.ModName,type))
+                pstate += 1
+                for patcher in finishPatchers:
+                    patcher(self, subProgress)
+        #--Fix UDR's
+        ## Skip this for now, since we aren't restoring any relevant data, just swapping flags (aka, use TES4Edit instead)
+        ##progress(0,_('Cleaning...'))
+        ##records = self.ACRES + self.ACHRS + self.REFRS
+        ##progress.setFull(max(len(records),1))
+        ##for i,record in enumerate(records):
+        ##    progress(i)
+        ##    if record.IsDeleted:
+        ##        record.IsDeleted = False
+        ##        record.IsIgnored = True
+        #--Done
+        progress(progress.full,_('Patchers applied.'))
+        self.ScanCollection = None
 
-    @staticmethod
-    def _loadCollection(mods):
-        # mods = list(ModInfo's) or list(ModCleaner's)
-        collection = ObCollection(ModsPath=dirs['mods'].s)
-        for mod in mods:
-            if isinstance(mod,ModCleaner):
-                modInfo = mod.modInfo
-            else:
-                modInfo = mod
-            if len(modInfo.masterNames) == 0: continue
-            path = modInfo.getPath()
-            collection.addMod(path.stail)
-        collection.load()
-        return collection
+    def buildPatchLog(self,patchName,log,progress):
+        """Completes merge process. Use this when finished using buildPatch."""
+        if not len(self.patchers): return
+        log.setHeader('= '+patchName.s+' '+'='*30+'#',True)
+        log("{{CONTENTS=1}}")
+        #--Load Mods and error mods
+        log.setHeader(_("= Overview"),True)
+        log.setHeader(_("=== Date/Time"))
+        log('* '+formatDate(time.time()))
+        log(_('* Elapsed Time: ') + 'TIMEPLACEHOLDER')
+        if self.patcher_mod_skipcount:
+            log.setHeader(_("=== Skipped Imports"))
+            log(_("The following import patchers skipped records because the imported record required a missing or non-active mod to work properly. If this was not intentional, rebuild the patch after either deactivating the imported mods listed below or activating the missing mod(s)."))
+            for patcher, mod_skipcount in self.patcher_mod_skipcount.iteritems():
+                log ('* %s skipped %d records:' % (str(patcher),sum(mod_skipcount.values())))
+                for mod, skipcount in mod_skipcount.iteritems():
+                    log ('  * The imported mod, %s, skipped %d records.' % (str(mod),skipcount))
 
-    @staticmethod
-    def _scan_CBash(modInfos,what,progress):
-        """Scan multiple mods for problems"""
-        if what & ModCleaner.ALL:
-            # There are scans to do
-            doUDR = bool(what & ModCleaner.UDR)
-            doITM = bool(what & ModCleaner.ITM)
-            doFog = bool(what & ModCleaner.FOG)
-            if len(modInfos) > 1:
-                progress(0,_('Loading...')+'\n'+modInfos[0].name.s)
+        if self.unFilteredMods:
+            log.setHeader(_("=== Unfiltered Mods"))
+            log(_("The following mods were active when the patch was built. For the mods to work properly, you should deactivate the mods and then rebuild the patch with the mods [[http://wrye.ufrealms.net/Wrye%20Bash.html#MergeFiltering|Merged]] in."))
+            for mod in self.unFilteredMods: log ('* '+mod.s)
+        if self.loadErrorMods:
+            log.setHeader(_("=== Load Error Mods"))
+            log(_("The following mods had load errors and were skipped while building the patch. Most likely this problem is due to a badly formatted mod. For more info, see [[http://www.uesp.net/wiki/Tes4Mod:Wrye_Bash/Bashed_Patch#Error_Messages|Bashed Patch: Error Messages]]."))
+            for mod in self.loadErrorMods: log ('* '+mod.s)
+        if self.worldOrphanMods:
+            log.setHeader(_("=== World Orphans"))
+            log(_("The following mods had orphaned world groups, which were skipped. This is not a major problem, but you might want to use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#RemoveWorldOrphans|Remove World Orphans]] command to repair the mods."))
+            for mod in self.worldOrphanMods: log ('* '+mod.s)
+        if self.compiledAllMods:
+            log.setHeader(_("=== Compiled All"))
+            log(_("The following mods have an empty compiled version of genericLoreScript. This is usually a sign that the mod author did a __compile all__ while editing scripts. This may interfere with the behavior of other mods that intentionally modify scripts from Fallout3.esm. (E.g. Unofficial Patch.) You can use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#DecompileAll|Decompile All]] command to repair the mods."))
+            for mod in self.compiledAllMods: log ('* '+mod.s)
+        log.setHeader(_("=== Active Mods"),True)
+        for name in self.allMods:
+            version = modInfos.getVersion(name)
+            if name in self.loadMods:
+                message = '* %02X ' % (self.loadMods.index(name),)
             else:
-                progress(0,_('Loading...'))
-            #--Load
-            collection = ModCleaner._loadCollection(modInfos)
-            #--Scan
-            progress.setFull(max(len(modInfos),1))
-            ret = []
-            for i,modInfo in enumerate(modInfos):
-                progress(i,_('Scanning...') + '\n' + modInfo.name.s)
-                udr = set()
-                itm = set()
-                fog = set()
-                if len(modInfo.masterNames) > 0:
-                    path = modInfo.getPath()
-                    modFile = collection.LookupModFile(path.stail)
-                    blocks = modFile.aggregates
-                    subprogress1 = SubProgress(progress,i,i+1)
-                    subprogress1.setFull(max(len(blocks),1))
-                    for j,block in enumerate(blocks.values()):
-                        subprogress1(j)
-                        subprogress2 = SubProgress(subprogress1,j,j+1)
-                        subprogress2.setFull(max(len(block),1))
-                        for k,record in enumerate(block):
-                            subprogress2(k)
-                            fid = record.fid
-                            #--Scan UDR
-                            if doUDR and record._Type in ('ACRE','ACHR','REFR') and record.IsDeleted:
-                                udr.add(fid)
-                            #--Scan fog
-                            if doFog and record._Type == 'CELL':
-                                if not (record.fogNear or record.fogFar or record.fogClip):
-                                    fog.add(fid)
-                            #--Scan ITM
-                            if doITM:
-                                if not fid or fid[0] == modFile.GName: continue
-                                master = collection.LookupModFile(fid[0].stail)
-                                if not master: continue
-                                masterRecord = master.LookupRecord(fid)
-                                if not masterRecord: continue
-                                if record.IsIdenticalTo(masterRecord):
-                                    itm.add(fid)
-                ret.append((udr,itm,fog))
-            #--Unload
-            collection.Unload()
-            return ret
-        else:
-            return [(set(),set(),set()) for x in range(len(modInfos))]
+                message = '* ++ '
+            if version:
+                message += _('%s  [Version %s]') % (name.s,version)
+            else:
+                message += name.s
+            log(message)
+        #--Load Mods and error mods
+        if self.aliases:
+            log.setHeader(_("= Mod Aliases"))
+            for key,value in sorted(self.aliases.iteritems()):
+                log('* %s >> %s' % (key.s,value.s))
+        #--Patchers
+        subProgress = SubProgress(progress,0,0.9,len(self.patchers))
+        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('editOrder'))):
+            subProgress(index,_("Completing\n%s...") % (patcher.getName(),))
+            patcher.buildPatchLog(log)
+        progress(1.0,"Compiled.")
+        #--Description
+        numRecords = sum([len(x) for x in self.aggregates.values()])
+        self.TES4.description = Encode(_("Updated: %s\n\nRecords Changed: %d") % (formatDate(time.time()),numRecords),'mbcs')
+#------------------------------------------------------------------------------
+class Patcher:
+    """Abstract base class for patcher elements."""
+    scanOrder = 10
+    editOrder = 10
+    group = 'UNDEFINED'
+    name = 'UNDEFINED'
+    text = "UNDEFINED."
+    tip = None
+    defaultConfig = {'isEnabled':False}
+    iiMode = False
+    selectCommands = True
 
-    @staticmethod
-    def _scan_Python(modInfos,what,progress):
-        if what & (ModCleaner.UDR|ModCleaner.FOG):
-            # Python can't do ITM scanning
-            doUDR = what & ModCleaner.UDR
-            doFog = what & ModCleaner.FOG
-            progress.setFull(max(len(modInfos),1))
-            ret = []
-            for i,modInfo in enumerate(modInfos):
-                progress(i,_('Scanning...') + '\n' + modInfo.name.s)
-                udr = set()
-                itm = set()
-                fog = set()
-                if len(modInfo.masterNames) > 0:
-                    subprogress = SubProgress(progress,i,i+1)
-                    subprogress.setFull(max(modInfo.size,1))
-                    #--File stream
-                    path = modInfo.getPath()
-                    #--Scan
-                    ins = ModReader(modInfo.name,path.open('rb'))
-                    while not ins.atEnd():
-                        subprogress(ins.tell())
-                        (type,size,flags,fid,uint2) = ins.unpackRecHeader()
-                        if type == 'GRUP':
-                            if fid != 0: #--Ignore sub-groups
-                                pass
-                            elif flags not in ('CELL','WRLD'):
-                                ins.read(size-20)
-                        else:
-                            if doUDR and flags & 0x20 and type in ('ACHR','ACRE','REFR'):
-                                udr.add(fid)
-                            if doFog and type == 'CELL':
-                                nextRecord = ins.tell() + size
-                                while ins.tell() < nextRecord:
-                                    (nextType,nextSize) = ins.unpackSubHeader()
-                                    if type != 'XCLL':
-                                        ins.read(nextSize)
-                                    else:
-                                        color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',nextSize,'CELL.XCLL')
-                                        if not (near or far or clip):
-                                            fog.add(fid)
-                            else:
-                                ins.read(size)
-                    #--Done
-                    ins.close()
-                ret.append((udr,itm,fog))
-            return ret
-        else:
-            return [(set(),set(),set()) for x in range(len(modInfos))]
+    def getName(self):
+        """Returns patcher name."""
+        return self.__class__.name
 
-    @staticmethod
-    def _clean_CBash(cleaners,what,progress):
-        if what & (ModCleaner.UDR|ModCleaner.FOG):
-            doUDR = what & ModCleaner.UDR
-            doFog = what & ModCleaner.FOG
-            progress.setFull(max(len(cleaners),1))
-            if len(cleaners) > 1:
-                progress(0,_('Loading...')+'\n'+cleaners[0].modInfo.name.s)
-            else:
-                progress(0,_('Loading...'))
-            #--Load
-            collection = ModCleaner._loadCollection(cleaners)
-            #--Clean
-            for i,cleaner in enumerate(cleaners):
-                progress(i,_('Cleaning...') + '\n' + cleaner.modInfo.name.s)
-                path = cleaner.modInfo.getPath()
-                modFile = collection.LookupModFile(path.stail)
-                changed = False
-                #Only do UDR and Fog right now
-                total = sum([len(cleaner.udr)*doUDR,len(cleaner.fog)*doFog])
-                recordNum = 0
-                subprogress = SubProgress(progress,i,i+1)
-                subprogress.setFull(max(total,1))
-                if doUDR:
-                    for fid in cleaner.udr:
-                        subprogress(recordNum)
-                        recordNum += 1
-                        record = modFile.LookupRecord(fid)
-                        if record and record._Type in ('ACRE','ACHR','REFR') and record.IsDeleted:
-                            changed = True
-                            record.IsDeleted = False
-                            record.IsIgnored = True
-                if doFog:
-                    for fid in cleaner.fog:
-                        subprogress(recordNum)
-                        recordNum += 1
-                        record = modFile.LookupRecord(fid)
-                        if record and record._Type == 'CELL':
-                            if not (record.fogNear or record.fogFar or record.fogClip):
-                                record.fogNear = 0.0001
-                                changed = True
-                #--Save
-                if changed:
-                    try:
-                        modFile.save(False)
-                    except WindowsError, werr:
-                        if werr.winerror != 32: raise
-                        while balt.askYes(None,_('Bash encountered an error when saving %s.\n\nThe file is in use by another process such as TES4Edit.\nPlease close the other program that is accessing %s.\n\nTry again?') % (modPath.stail,modPath.stail),_('%s - Save Error') % modPath.stail):
-                            try:
-                                modFile.save(False)
-                            except WindowsError, werr:
-                                continue
-                            break
-                        else:
-                            raise
-            collection.Unload()
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        """Initialization of common values to defaults."""
+        self.patchFile = None
+        self.scanOrder = self.__class__.scanOrder
+        self.editOrder = self.__class__.editOrder
+        self.isActive = True
+        #--Gui stuff
+        self.isEnabled = False #--Patcher is enabled.
+        self.gConfigPanel = None
 
-    @staticmethod
-    def _clean_Python(cleaners,what,progress):
-        if what & (ModCleaner.UDR|ModCleaner.FOG):
-            doUDR = what & ModCleaner.UDR
-            doFog = what & ModCleaner.FOG
-            progress.setFull(max(len(cleaners),1))
-            #--Clean
-            for i,cleaner in enumerate(cleaners):
-                progress(i,_('Cleaning...')+'\n'+cleaner.modInfo.name.s)
-                subprogress = SubProgress(progress,i,i+1)
-                subprogress.setFull(max(cleaner.modInfo.size,1))
-                #--File stream
-                path = cleaner.modInfo.getPath()
-                #--Scan & clean
-                ins = ModReader(cleaner.modInfo.name,path.open('rb'))
-                out = path.temp.open('wb')
-                def copy(size):
-                    out.write(ins.read(size))
-                def copyPrev(size):
-                    ins.seek(-size,1)
-                    out.write(ins.read(size))
-                changed = False
-                while not ins.atEnd():
-                    subprogress(ins.tell())
-                    (type,size,flags,fid,uint2) = ins.unpackRecHeader()
-                    if type == 'GRUP':
-                        if fid != 0:
-                            pass
-                        elif flags not in ('CELL','WRLD'):
-                            copy(size-20)
-                    else:
-                        if doUDR and flags & 0x20 and type in ('ACHR','ACRE','REFR'):
-                            flags = (flags & ~0x20) | 0x1000
-                            out.seek(-20,1)
-                            out.write(struct.pack('=4s4I',type,size,flags,fid,uint2))
-                            change = True
-                        if doFog and type == 'CELL':
-                            nextRecord = ins.tell() + size
-                            while ins.tell() < nextRecord:
-                                subprogress(ins.tell())
-                                (nextType,nextSize) = ins.unpackSubHeader()
-                                copyPrev(6)
-                                if nextType != 'XCLL':
-                                    copy(nextSize)
-                                else:
-                                    color,near,far,rotXY,rotZ,fade,clip = ins.unpack('=12s2f2l2f',size,'CELL.XCLL')
-                                    if not (near or far or clip):
-                                        near = 0.0001
-                                        changed = True
-                                    out.write(struct.pack('=12s2f2l2f',color,near,far,rotXY,rotZ,fade,clip))
-                        else:
-                            copy(size)
-                #--Done
-                ins.close()
-                out.close()
-                #--Save
-                if changed:
-                    modInfo.makeBackup()
-                    try:
-                        path.untemp()
-                    except WindowsError, werr:
-                        if werr.winerror != 32: raise
-                        while balt.askYes(None,_('Bash encountered an error when saving %s.\n\nThe file is in use by another process such as TES4Edit.\nPlease close the other program that is accessing %s.\n\nTry again?') % (modPath.stail,modPath.stail),_('%s - Save Error') % modPath.stail):
-                            try:
-                                path.untemp()
-                            except WindowsError,werr:
-                                continue
-                            break
-                        else:
-                            raise
-                    modInfo.setmtime()
-                else:
-                    path.temp.remove()
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        config = configs.setdefault(self.__class__.__name__,{})
+        for attr,default in self.__class__.defaultConfig.iteritems():
+            value = copy.deepcopy(config.get(attr,default))
+            setattr(self,attr,value)
 
-#------------------------------------------------------------------------------
-class SaveSpells:
-    """Player spells of a savegame."""
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        config = configs[self.__class__.__name__] = {}
+        for attr in self.__class__.defaultConfig:
+            config[attr] = copy.deepcopy(getattr(self,attr))
 
-    def __init__(self,saveInfo):
-        """Initialize."""
-        self.saveInfo = saveInfo
-        self.saveFile = None
-        self.allSpells = {} #--spells[(modName,objectIndex)] = (name,type)
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        self.patchFile = patchFile
 
-    def load(self,progress=None):
-        """Loads savegame and and extracts created spells from it and its masters."""
-        progress = progress or bolt.Progress()
-        saveFile = self.saveFile = SaveFile(self.saveInfo)
-        saveFile.load(SubProgress(progress,0,0.4))
-        progress = SubProgress(progress,0.4,1.0,len(saveFile.masters)+1)
-        #--Extract spells from masters
-        for index,master in enumerate(saveFile.masters):
-            progress(index,master.s)
-            if master in modInfos:
-                self.importMod(modInfos[master])
-        #--Extract created spells
-        allSpells = self.allSpells
-        saveName = self.saveInfo.name
-        progress(progress.full-1,saveName.s)
-        for record in saveFile.created:
-            if record.recType == 'SPEL':
-                allSpells[(saveName,getObjectIndex(record.fid))] = record.getTypeCopy()
+    def initData(self,progress):
+        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+        pass
 
-    def importMod(self,modInfo):
-        """Imports spell info from specified mod."""
-        #--Spell list already extracted?
-        if 'bash.spellList' in modInfo.extras:
-            self.allSpells.update(modInfo.extras['bash.spellList'])
-            return
-        #--Else extract spell list
-        loadFactory= LoadFactory(False,MreSpel)
-        modFile = ModFile(modInfo,loadFactory)
-        modFile.load(True)
-        modFile.convertToLongFids(('SPEL',))
-        spells = modInfo.extras['bash.spellList'] = dict(
-            [(record.fid,record) for record in modFile.SPEL.getActiveRecords()])
-        self.allSpells.update(spells)
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return None
 
-    def getPlayerSpells(self):
-        """Returns players spell list from savegame. (Returns ONLY spells. I.e., not abilities, etc.)"""
-        saveFile = self.saveFile
-        #--Get masters and npc spell fids
-        masters = saveFile.masters[:]
-        maxMasters = len(masters) - 1
-        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
-        npc = SreNPC(recFlags,data)
-        pcSpells = {} #--pcSpells[spellName] = iref
-        #--NPC doesn't have any spells?
-        if not npc.spells:
-            return pcSpells
-        #--Get spell names to match fids
-        for iref in npc.spells:
-            if (iref >> 24) == 255:
-                fid = iref
-            else:
-                fid = saveFile.fids[iref]
-            modIndex,objectIndex = getFormIndices(fid)
-            if modIndex == 255:
-                master = self.saveInfo.name
-            elif modIndex <= maxMasters:
-                master = masters[modIndex]
-            else: #--Bad fid?
-                continue
-            #--Get spell data
-            record = self.allSpells.get((master,objectIndex),None)
-            if record and record.full and record.spellType == 0 and fid != 0x136:
-                pcSpells[record.full] = (iref,record)
-        return pcSpells
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return None
 
-    def removePlayerSpells(self,spellsToRemove):
-        """Removes specified spells from players spell list."""
-        (fid,recType,recFlags,version,data) = self.saveFile.getRecord(7)
-        npc = SreNPC(recFlags,data)
-        if npc.spells and spellsToRemove:
-            #--Remove spells and save
-            npc.spells = [iref for iref in npc.spells if iref not in spellsToRemove]
-            self.saveFile.setRecord(npc.getTuple(fid,version))
-            self.saveFile.safeSave()
+    def scanModFile(self,modFile,progress):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it. If adds record, should first convert it to long fids."""
+        pass
 
-#------------------------------------------------------------------------------
-class SaveEnchantments:
-    """Player enchantments of a savegame."""
+    def buildPatch(self,log,progress):
+        """Edits patch file as desired. Should write to log."""
+        pass
 
-    def __init__(self,saveInfo):
-        """Initialize."""
-        self.saveInfo = saveInfo
-        self.saveFile = None
-        self.createdEnchantments = []
+class CBash_Patcher:
+    """Abstract base class for patcher elements."""
+    scanOrder = 10
+    editOrder = 10
+    group = 'UNDEFINED'
+    name = 'UNDEFINED'
+    text = "UNDEFINED."
+    unloadedText = ""
+    tip = None
+    defaultConfig = {'isEnabled':False}
+    iiMode = False
+    selectCommands = True
+    allowUnloaded = True
+    scanRequiresChecked = False
+    applyRequiresChecked = False
 
-    def load(self,progress=None):
-        """Loads savegame and and extracts created enchantments from it."""
-        progress = progress or bolt.Progress()
-        saveFile = self.saveFile = SaveFile(self.saveInfo)
-        saveFile.load(SubProgress(progress,0,0.4))
-        #--Extract created enchantments
-        createdEnchantments = self.createdEnchantments
-        saveName = self.saveInfo.name
-        progress(progress.full-1,saveName.s)
-        for index,record in enumerate(saveFile.created):
-            if record.recType == 'ENCH':
-                record = record.getTypeCopy()
-                record.getSize() #--Since type copy makes it changed.
-                saveFile.created[index] = record
-                self.createdEnchantments.append((index,record))
+    def getName(self):
+        """Returns patcher name."""
+        return self.__class__.name
 
-    def setCastWhenUsedEnchantmentNumberOfUses(self,uses):
-        """Sets Cast When Used Enchantment number of uses (via editing the enchat cost)."""
-        count = 0
-        for (index, record) in self.createdEnchantments:
-            if record.itemType in [1,2]:
-                if uses == 0:
-                    if record.enchantCost == 0: continue
-                    record.enchantCost = 0
-                else:
-                    if record.enchantCost == max(record.chargeAmount/uses,1): continue
-                    record.enchantCost = max(record.chargeAmount/uses,1)
-                record.setChanged()
-                record.getSize()
-                count += 1
-        self.saveFile.safeSave()
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        """Initialization of common values to defaults."""
+        self.patchFile = None
+        self.scanOrder = self.__class__.scanOrder
+        self.editOrder = self.__class__.editOrder
+        self.isActive = True
+        #--Gui stuff
+        self.isEnabled = False #--Patcher is enabled.
+        self.gConfigPanel = None
+        if not self.allowUnloaded:
+            self.text = self.text + self.unloadedText
 
-class Save_NPCEdits:
-    """General editing of NPCs/player in savegame."""
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        config = configs.setdefault(self.__class__.__name__,{})
+        for attr,default in self.__class__.defaultConfig.iteritems():
+            value = copy.deepcopy(config.get(attr,default))
+            setattr(self,attr,value)
 
-    def __init__(self,saveInfo):
-        """Initialize."""
-        self.saveInfo = saveInfo
-        self.saveFile = SaveFile(saveInfo)
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        config = configs[self.__class__.__name__] = {}
+        for attr in self.__class__.defaultConfig:
+            config[attr] = copy.deepcopy(getattr(self,attr))
 
-    def renamePlayer(self,newName):
-        """rename the player in  a save file."""
-        self.saveInfo.header.pcName = newName
-        saveFile = self.saveFile
-        saveFile.load()
-        (fid,recType,recFlags,version,data) = saveFile.getRecord(7)
-        npc = SreNPC(recFlags,data)
-        npc.full = Encode(newName,'mbcs')
-        saveFile.pcName = newName
-        saveFile.setRecord(npc.getTuple(fid,version))
-        saveFile.safeSave()
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        self.patchFile = patchFile
 
-# Patchers 1 ------------------------------------------------------------------
-#------------------------------------------------------------------------------
-class PatchFile(ModFile):
-    """Defines and executes patcher configuration."""
-    #--Class
-    mergeClasses = (
-        MreActi, MreAlch, MreAmmo, MreAnio, MreAppa, MreArmo, MreBook, MreBsgn, MreClas,
-        MreClot, MreCont, MreCrea, MreDoor, MreEfsh, MreEnch, MreEyes, MreFact, MreFlor, MreFurn,
-        MreGlob, MreGras, MreHair, MreIngr, MreKeym, MreLigh, MreLscr, MreLvlc, MreLvli,
-        MreLvsp, MreMgef, MreMisc, MreNpc,  MrePack, MreQust, MreRace, MreScpt, MreSgst,
-        MreSlgm, MreSoun, MreSpel, MreStat, MreTree, MreWatr, MreWeap, MreWthr,
-        MreClmt, MreCsty, MreIdle, MreLtex, MreRegn, MreSbsp, MreSkil)
+    def getTypes(self):
+        """Returns the group types that this patcher checks"""
+        return []
 
-    @staticmethod
-    def modIsMergeable(modInfo,progress=None,verbose=True):
-        """Returns True or error message indicating whether specified mod is mergeable."""
-        reasons = ''
-        if reEsmExt.search(modInfo.name.s):
-            if not verbose: return False
-            reasons += _("\n.    Is esm.")
-        #--Bashed Patch
-        if modInfo.header.author == "BASHED PATCH":
-            if not verbose: return False
-            reasons += _("\n.    Is Bashed Patch.")
+    def initData(self,type_patchers,progress):
+        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+        if not self.isActive: return
+        for type in self.getTypes():
+            type_patchers.setdefault(type,[]).append(self)
+        if self.allowUnloaded:
+            loadMods = set([mod for mod in self.srcs if reModExt.search(mod.s) and mod not in self.patchFile.allMods])
+            self.patchFile.scanSet |= loadMods
 
-        #--Bsa?
-        reBsa = re.compile(re.escape(modInfo.name.sroot)+'.*bsa$',re.I)
-        for file in modInfos.dir.list():
-            if reBsa.match(file.s):
-                if not verbose: return False
-                reasons += _("\n.    Has BSA archive.")
-                break
-        #-- Check to make sure NoMerge tag not in tags - if in tags don't show up as mergeable.
-        if 'NoMerge' in modInfos[GPath(modInfo.name.s)].getBashTags():
-            if not verbose: return False
-            reasons += "\n.    Has 'NoMerge' tag."
-        #--Load test
-        mergeTypes = set([recClass.classType for recClass in PatchFile.mergeClasses])
-        modFile = ModFile(modInfo,LoadFactory(False,*mergeTypes))
-        try:
-            modFile.load(True)
-        except ModError, error:
-            if not verbose: return False
-            reasons += '\n.    ' + Unicode(str(error))+'.'
-        #--Skipped over types?
-        if modFile.topsSkipped:
-            if not verbose: return False
-            reasons += (_("\n.    Unsupported types: ") + ', '.join(sorted(modFile.topsSkipped))+'.')
-        #--Empty mod
-        if not modFile.tops:
-            if not verbose: return False
-            reasons += _("\n.    Empty mod.")
-        #--New record
-        lenMasters = len(modFile.tes4.masters)
-        newblocks = []
-        for type,block in modFile.tops.iteritems():
-            for record in block.getActiveRecords():
-                if record.fid >> 24 >= lenMasters:
-                    if not verbose: return False
-                    newblocks.append(type)
-                    break
-        if newblocks: reasons += (_("\n.    New record(s) in block(s): ") + ', '.join(sorted(newblocks))+'.')
-        dependent = [curModInfo.name.s for curModInfo in modInfos.data.values() if curModInfo.header.author != "BASHED PATCH" if GPath(modInfo.name.s) in curModInfo.header.masters]
-        if dependent:
-            if not verbose: return False
-            reasons += (_("\n.    Is a master of mod(s): ") + ', '.join(sorted(dependent))+'.')
-        if reasons: return reasons
-        return True
+    def buildPatchLog(self,log):
+        """Write to log."""
+        pass
+#------------------------------------------------------------------------------
+class ListPatcher(Patcher):
+    """Subclass for patchers that have GUI lists of objects."""
+    #--Get/Save Config
+    choiceMenu = None #--List of possible choices for each config item. Item 0 is default.
+    defaultConfig = {'isEnabled':False,'autoIsChecked':True,'configItems':[],'configChecks':{},'configChoices':{}}
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    forceItemCheck = False #--Force configChecked to True for all items
+    autoRe = re.compile('^UNDEFINED$') #--Compiled re used by getAutoItems
+    autoKey = None
+    forceAuto = True
 
-    #--Instance
-    def __init__(self,modInfo,patchers):
-        """Initialization."""
-        ModFile.__init__(self,modInfo,None)
-        self.tes4.author = 'BASHED PATCH'
-        self.tes4.masters = [modInfos.masterName]
-        self.longFids = True
-        #--New attrs
-        self.aliases = {} #--Aliases from one mod name to another. Used by text file patchers.
-        self.patchers = patchers
-        self.keepIds = set()
-        self.mergeIds = set()
-        self.loadErrorMods = []
-        self.worldOrphanMods = []
-        self.unFilteredMods = []
-        self.compiledAllMods = []
-        self.patcher_mod_skipcount = {}
-        #--Config
-        self.bodyTags = 'ARGHTCCPBS' #--Default bodytags
-        #--Mods
-        self.setMods([name for name in modInfos.ordered if modInfos[name].mtime < self.patchTime],[])
-        for patcher in self.patchers:
-            patcher.initPatchFile(self,self.loadMods)
+    #--Config Phase -----------------------------------------------------------
+    def getAutoItems(self):
+        """Returns list of items to be used for automatic configuration."""
+        autoItems = []
+        autoRe = self.__class__.autoRe
+        autoKey = self.__class__.autoKey
+        if isinstance(autoKey,str):
+            autoKey = set((autoKey,))
+        autoKey = set(autoKey)
+        self.choiceMenu = self.__class__.choiceMenu
+        for modInfo in modInfos.data.values():
+            if autoRe.match(modInfo.name.s) or (autoKey & modInfo.getBashTags()):
+                if modInfo.mtime > PatchFile.patchTime: continue
+                autoItems.append(modInfo.name)
+                if self.choiceMenu: self.getChoice(modInfo.name)
+        reFile = re.compile('_('+('|'.join(autoKey))+r')\.csv$')
+        for fileName in sorted(dirs['patches'].list()):
+            if reFile.search(fileName.s):
+                autoItems.append(fileName)
+        return autoItems
 
-    def setMods(self,loadMods=None,mergeMods=None):
-        """Sets mod lists and sets."""
-        if loadMods != None: self.loadMods = loadMods
-        if mergeMods != None: self.mergeMods = mergeMods
-        self.loadSet = set(self.loadMods)
-        self.mergeSet = set(self.mergeMods)
-        self.allMods = modInfos.getOrdered(self.loadSet|self.mergeSet)
-        self.allSet = set(self.allMods)
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        Patcher.getConfig(self,configs)
+        if self.forceAuto:
+            self.autoIsChecked = True
+        #--Verify file existence
+        newConfigItems = []
+        patchesDir = dirs['patches'].list()
+        for srcPath in self.configItems:
+            if ((reModExt.search(srcPath.s) and srcPath in modInfos) or
+                reCsvExt.search(srcPath.s) and srcPath in patchesDir):
+                    newConfigItems.append(srcPath)
+        self.configItems = newConfigItems
+        if self.__class__.forceItemCheck:
+            for item in self.configItems:
+                self.configChecks[item] = True
+        #--Make sure configChoices are set (if choiceMenu exists).
+        if self.choiceMenu:
+            for item in self.configItems:
+                self.getChoice(item)
+        #--AutoItems?
+        if self.autoIsChecked:
+            self.getAutoItems()
 
-    def getKeeper(self):
-        """Returns a function to add fids to self.keepIds."""
-        def keep(fid):
-            self.keepIds.add(fid)
-            return fid
-        return keep
+    def getChoice(self,item):
+        """Get default config choice."""
+        return self.configChoices.setdefault(item,self.choiceMenu[0])
 
-    def initData(self,progress):
-        """Gives each patcher a chance to get its source data."""
-        if not len(self.patchers): return
-        progress = progress.setFull(len(self.patchers))
-        for index,patcher in enumerate(self.patchers):
-            progress(index,_("Preparing\n%s") % patcher.getName())
-            patcher.initData(SubProgress(progress,index))
-        progress(progress.full,_('Patchers prepared.'))
+    def getItemLabel(self,item):
+        """Returns label for item to be used in list"""
+        if isinstance(item,bolt.Path): item = item.s
+        if self.choiceMenu:
+            return '%s [%s]' % (item,self.getChoice(item))
+        else:
+            return item
 
-    def initFactories(self,progress):
-        """Gets load factories."""
-        progress(0,_("Processing."))
-        def updateClasses(type_classes,newClasses):
-            if not newClasses: return
-            for item in newClasses:
-                if not isinstance(item,str):
-                    type_classes[item.classType] = item
-                elif item not in type_classes:
-                    type_classes[item] = item
-        readClasses = {}
-        writeClasses = {}
-        updateClasses(readClasses,(MreMgef,MreScpt)) #--Need info from magic effects.
-        updateClasses(writeClasses,(MreMgef,)) #--Need info from magic effects.
-        for patcher in self.patchers:
-            updateClasses(readClasses, patcher.getReadClasses())
-            updateClasses(writeClasses, patcher.getWriteClasses())
-        self.readFactory = LoadFactory(False,*readClasses.values())
-        self.loadFactory = LoadFactory(True,*writeClasses.values())
-        #--Merge Factory
-        self.mergeFactory = LoadFactory(False,*PatchFile.mergeClasses)
+    def sortConfig(self,items):
+        """Return sorted items. Default assumes mods and sorts by load order."""
+        return modInfos.getOrdered(items,False)
 
-    def scanLoadMods(self,progress):
-        """Scans load+merge mods."""
-        if not len(self.loadMods): return
-        nullProgress = bolt.Progress()
-        progress = progress.setFull(len(self.allMods))
-        for index,modName in enumerate(self.allMods):
-            bashTags = modInfos[modName].getBashTags()
-            if modName in self.loadMods and 'Filter' in bashTags:
-                self.unFilteredMods.append(modName)
-            try:
-                loadFactory = (self.readFactory,self.mergeFactory)[modName in self.mergeSet]
-                progress(index,_("%s\nLoading...") % modName.s)
-                modInfo = modInfos[GPath(modName)]
-                modFile = ModFile(modInfo,loadFactory)
-                modFile.load(True,SubProgress(progress,index,index+0.5))
-            except ModError:
-                self.loadErrorMods.append(modName)
-                continue
-            try:
-                #--Error checks
-                if 'WRLD' in modFile.tops and modFile.WRLD.orphansSkipped:
-                    self.worldOrphanMods.append(modName)
-                if 'SCPT' in modFile.tops and modName != 'Oblivion.esm':
-                    gls = modFile.SCPT.getRecord(0x00025811)
-                    if gls and gls.compiledSize == 4 and gls.lastIndex == 0:
-                        self.compiledAllMods.append(modName)
-                pstate = index+0.5
-                isMerged = modName in self.mergeSet
-                doFilter = isMerged and 'Filter' in bashTags
-                #--iiMode is a hack to support Item Interchange. Actual key used is InventOnly.
-                iiMode = isMerged and bool(set(('InventOnly','IIM')) & bashTags)
-                if isMerged:
-                    progress(pstate,_("%s\nMerging...") % modName.s)
-                    self.mergeModFile(modFile,nullProgress,doFilter,iiMode)
-                else:
-                    progress(pstate,_("%s\nScanning...") % modName.s)
-                    self.scanModFile(modFile,nullProgress)
-                for patcher in sorted(self.patchers,key=attrgetter('scanOrder')):
-                    if iiMode and not patcher.iiMode: continue
-                    progress(pstate,_("%s\n%s") % (modName.s,patcher.name))
-                    patcher.scanModFile(modFile,nullProgress)
-                # Clip max version at 1.0.  See explanation in the CBash version as to why.
-                self.tes4.version = min(max(modFile.tes4.version, self.tes4.version),1.0)
-            except bolt.CancelError:
-                raise
-            except:
-                print _("MERGE/SCAN ERROR:"),modName.s
-                raise
-        progress(progress.full,_('Load mods scanned.'))
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        #--Toss outdated configCheck data.
+        listSet = set(self.configItems)
+        self.configChecks = dict([(key,value) for key,value in self.configChecks.iteritems() if key in listSet])
+        self.configChoices = dict([(key,value) for key,value in self.configChoices.iteritems() if key in listSet])
+        Patcher.saveConfig(self,configs)
 
-    def mergeModFile(self,modFile,progress,doFilter,iiMode):
-        """Copies contents of modFile into self."""
-        mergeIds = self.mergeIds
-        loadSet = self.loadSet
-        modFile.convertToLongFids()
-        badForm = (GPath("Oblivion.esm"),0xA31D) #--DarkPCB record
-        for blockType,block in modFile.tops.iteritems():
-            iiSkipMerge = iiMode and blockType not in ('LVLC','LVLI','LVSP')
-            #--Make sure block type is also in read and write factories
-            if blockType not in self.loadFactory.recTypes:
-                recClass = self.mergeFactory.type_class[blockType]
-                self.readFactory.addClass(recClass)
-                self.loadFactory.addClass(recClass)
-            patchBlock = getattr(self,blockType)
-            if not isinstance(patchBlock,MobObjects):
-                raise BoltError(_("Merge unsupported for type: ")+blockType)
-            filtered = []
-            for record in block.getActiveRecords():
-                if record.fid == badForm: continue
-                #--Include this record?
-                if not doFilter or record.fid[0] in loadSet:
-                    filtered.append(record)
-                    if doFilter: record.mergeFilter(loadSet)
-                    if iiSkipMerge: continue
-                    record = record.getTypeCopy()
-                    patchBlock.setRecord(record)
-                    mergeIds.add(record.fid)
-            #--Filter records
-            block.records = filtered
-            block.indexRecords()
+    #--Patch Phase ------------------------------------------------------------
+    def getConfigChecked(self):
+        """Returns checked config items in list order."""
+        return [item for item in self.configItems if self.configChecks[item]]
 
-    def scanModFile(self,modFile,progress):
-        """Scans file and overwrites own records with modfile records."""
-        #--Keep all MGEFs
-        modFile.convertToLongFids('MGEF')
-        if 'MGEF' in modFile.tops:
-            for record in modFile.MGEF.getActiveRecords():
-                self.MGEF.setRecord(record.getTypeCopy())
-        #--Merger, override.
-        mergeIds = self.mergeIds
-        mapper = modFile.getLongMapper()
-        for blockType,block in self.tops.iteritems():
-            if blockType in modFile.tops:
-                block.updateRecords(modFile.tops[blockType],mapper,mergeIds)
+class CBash_ListPatcher(CBash_Patcher):
+    """Subclass for patchers that have GUI lists of objects."""
+    unloadedText = _("\n\nAny non-active, non-merged mods in the following list will be IGNORED.")
+    #--Get/Save Config
+    choiceMenu = None #--List of possible choices for each config item. Item 0 is default.
+    defaultConfig = {'isEnabled':False,'autoIsChecked':True,'configItems':[],'configChecks':{},'configChoices':{}}
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    forceItemCheck = False #--Force configChecked to True for all items
+    autoRe = re.compile('^UNDEFINED$') #--Compiled re used by getAutoItems
+    autoKey = None
+    forceAuto = True
 
-    def buildPatch(self,log,progress):
-        """Completes merge process. Use this when finished using scanLoadMods."""
-        if not len(self.patchers): return
-        log.setHeader('= '+self.fileInfo.name.s+' '+'='*30+'#',True)
-        log("{{CONTENTS=1}}")
-        #--Load Mods and error mods
-        log.setHeader(_("= Overview"),True)
-        log.setHeader(_("=== Date/Time"))
-        log('* '+formatDate(time.time()))
-        log(_('* Elapsed Time: ') + 'TIMEPLACEHOLDER')
-        if self.patcher_mod_skipcount:
-            log.setHeader(_("=== Skipped Imports"))
-            log(_("The following import patchers skipped records because the imported record required a missing or non-active mod to work properly. If this was not intentional, rebuild the patch after either deactivating the imported mods listed below or activating the missing mod(s)."))
-            for patcher, mod_skipcount in self.patcher_mod_skipcount.iteritems():
-                log ('* %s skipped %d records:' % (str(patcher),sum(mod_skipcount.values())))
-                for mod, skipcount in mod_skipcount.iteritems():
-                    log ('  * The imported mod, %s, skipped %d records.' % (str(mod),skipcount))
-        if self.unFilteredMods:
-            log.setHeader(_("=== Unfiltered Mods"))
-            log(_("The following mods were active when the patch was built. For the mods to work properly, you should deactivate the mods and then rebuild the patch with the mods [[http://wrye.ufrealms.net/Wrye%20Bash.html#MergeFiltering|Merged]] in."))
-            for mod in self.unFilteredMods: log ('* '+mod.s)
-        if self.loadErrorMods:
-            log.setHeader(_("=== Load Error Mods"))
-            log(_("The following mods had load errors and were skipped while building the patch. Most likely this problem is due to a badly formatted mod. For more info, see [[http://www.uesp.net/wiki/Tes4Mod:Wrye_Bash/Bashed_Patch#Error_Messages|Bashed Patch: Error Messages]]."))
-            for mod in self.loadErrorMods: log ('* '+mod.s)
-        if self.worldOrphanMods:
-            log.setHeader(_("=== World Orphans"))
-            log(_("The following mods had orphaned world groups, which were skipped. This is not a major problem, but you might want to use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#RemoveWorldOrphans|Remove World Orphans]] command to repair the mods."))
-            for mod in self.worldOrphanMods: log ('* '+mod.s)
-        if self.compiledAllMods:
-            log.setHeader(_("=== Compiled All"))
-            log(_("The following mods have an empty compiled version of genericLoreScript. This is usually a sign that the mod author did a __compile all__ while editing scripts. This may interfere with the behavior of other mods that intentionally modify scripts from Oblivion.esm. (E.g. Cobl and Unofficial Oblivion Patch.) You can use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#DecompileAll|Decompile All]] command to repair the mods."))
-            for mod in self.compiledAllMods: log ('* '+mod.s)
-        log.setHeader(_("=== Active Mods"),True)
-        for name in self.allMods:
-            version = modInfos.getVersion(name)
-            if name in self.loadMods:
-                message = '* %02X ' % (self.loadMods.index(name),)
-            else:
-                message = '* ++ '
-            if version:
-                message += _('%s  [Version %s]') % (name.s,version)
-            else:
-                message += name.s
-            log(message)
-        #--Load Mods and error mods
-        if self.aliases:
-            log.setHeader(_("= Mod Aliases"))
-            for key,value in sorted(self.aliases.iteritems()):
-                log('* %s >> %s' % (key.s,value.s))
-        #--Patchers
-        self.keepIds |= self.mergeIds
-        subProgress = SubProgress(progress,0,0.9,len(self.patchers))
-        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('editOrder'))):
-            subProgress(index,_("Completing\n%s...") % (patcher.getName(),))
-            patcher.buildPatch(log,SubProgress(subProgress,index))
-        #--Trim records
-        progress(0.9,_("Completing\nTrimming records..."))
-        for block in self.tops.values():
-            block.keepRecords(self.keepIds)
-        progress(0.95,_("Completing\nConverting fids..."))
-        #--Convert masters to short fids
-        self.tes4.masters = self.getMastersUsed()
-        self.convertToShortFids()
-        progress(1.0,"Compiled.")
-        #--Description
-        numRecords = sum([x.getNumRecords(False) for x in self.tops.values()])
-        self.tes4.description = _("Updated: %s\n\nRecords Changed: %d") % (formatDate(time.time()),numRecords)
+    #--Config Phase -----------------------------------------------------------
+    def getAutoItems(self):
+        """Returns list of items to be used for automatic configuration."""
+        autoItems = []
+        autoRe = self.__class__.autoRe
+        autoKey = self.__class__.autoKey
+        if isinstance(autoKey,str):
+            autoKey = set((autoKey,))
+        autoKey = set(autoKey)
+        self.choiceMenu = self.__class__.choiceMenu
+        for modInfo in modInfos.data.values():
+            if autoRe.match(modInfo.name.s) or (autoKey & modInfo.getBashTags()):
+                if modInfo.mtime > CBash_PatchFile.patchTime: continue
+                autoItems.append(modInfo.name)
+                if self.choiceMenu: self.getChoice(modInfo.name)
+        reFile = re.compile('_('+('|'.join(autoKey))+r')\.csv$')
+        for fileName in sorted(dirs['patches'].list()):
+            if reFile.search(fileName.s):
+                autoItems.append(fileName)
+        return autoItems
 
-class CBash_PatchFile(ObModFile):
-    """Defines and executes patcher configuration."""
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        CBash_Patcher.getConfig(self,configs)
+        if self.forceAuto:
+            self.autoIsChecked = True
+        #--Verify file existence
+        newConfigItems = []
+        patchesDir = dirs['patches'].list()
+        for srcPath in self.configItems:
+            if ((reModExt.search(srcPath.s) and srcPath in modInfos) or
+                reCsvExt.search(srcPath.s) and srcPath in patchesDir):
+                    newConfigItems.append(srcPath)
+        self.configItems = newConfigItems
+        if self.__class__.forceItemCheck:
+            for item in self.configItems:
+                self.configChecks[item] = True
+        #--Make sure configChoices are set (if choiceMenu exists).
+        if self.choiceMenu:
+            for item in self.configItems:
+                self.getChoice(item)
+        #--AutoItems?
+        if self.autoIsChecked:
+            self.getAutoItems()
 
-    #--Class
-    @staticmethod
-    def configIsCBash(patchConfigs):
-        for key in patchConfigs:
-            if 'CBash' in key:
-                return True
-        return False
+    def getChoice(self,item):
+        """Get default config choice."""
+        return self.configChoices.setdefault(item,self.choiceMenu[0])
 
-    @staticmethod
-    def modIsMergeableNoLoad(modInfo,verbose=False):
-        reasons = ''
-        if reEsmExt.search(modInfo.name.s):
-            if not verbose: return False
-            reasons += _("\n.    Is esm.")
-        #--Bashed Patch
-        if modInfo.header.author == "BASHED PATCH":
-            if not verbose: return False
-            reasons += _("\n.    Is Bashed Patch.")
-        #--Bsa?
-        reBsa = re.compile(re.escape(modInfo.name.sroot)+'.*bsa$',re.I)
-        for file in modInfos.dir.list():
-            if reBsa.match(file.s):
-                if not verbose: return False
-                reasons += _("\n.    Has BSA archive.")
-                break
-        #-- Check to make sure NoMerge tag not in tags - if in tags don't show up as mergeable.
-        tags = modInfos[modInfo.name].getBashTags()
-        if 'NoMerge' in tags:
-            if not verbose: return False
-            reasons += _("\n.    Has 'NoMerge' tag.")
-        if reasons: return reasons
-        return True
-
-    @staticmethod
-    def modIsMergeableLoad(modInfo,verbose=False,modFile=None):
-        allowMissingMasters = set(['Filter','IIM','InventOnly'])
-        tags = modInfos[modInfo.name].getBashTags()
-        reasons = ''
-        #--Load test
-        if modFile is None:
-            Current = ObCollection(ModsPath=dirs['mods'].s)
-            Current.addMod(modInfo.getPath().stail, Flags=0x00000128)
-            Current.load()
-            try:
-                modFile = Current.LookupModFile(modInfo.getPath().stail)
-            except KeyError, error:
-                print "modIsMergeableLoad"
-                print error[0]
-                return
-        missingMasters = []
-        nonActiveMasters = []
-        masters = modFile.TES4.masters
-        for master in masters:
-            master = GPath(master)
-            if not tags & allowMissingMasters:
-                if master not in modInfos:
-                    if not verbose: return False
-                    missingMasters.append(master.s)
-                elif not modInfos.isSelected(master):
-                    if not verbose: return False
-                    nonActiveMasters.append(master.s)
-        #--masters not present in mod list?
-        if len(missingMasters):
-            if not verbose: return False
-            reasons += (_("\n.    Masters missing: \n    * ") + '\n    * '.join(sorted(missingMasters)))
-        if len(nonActiveMasters):
-            if not verbose: return False
-            reasons += (_("\n.    Masters not active: \n    * ") + '\n    * '.join(sorted(nonActiveMasters)))
-        #--Empty mod
-        if modFile.IsEmpty():
-            if not verbose: return False
-            reasons += _("\n.    Empty mod.")
-        #--New record
+    def getItemLabel(self,item):
+        """Returns label for item to be used in list"""
+        if isinstance(item,bolt.Path): item = item.s
+        if self.choiceMenu:
+            return '%s [%s]' % (item,self.getChoice(item))
         else:
-            if not tags & allowMissingMasters:
-                newblocks = modFile.GetNewRecordTypes()
-                if newblocks:
-                    if not verbose: return False
-                    reasons += (_("\n.    New record(s) in block(s): ") + ', '.join(sorted(newblocks))+'.')
-        dependent = [curModInfo.name.s for curModInfo in modInfos.data.values() if curModInfo.header.author != "BASHED PATCH" and modInfo.name.s in curModInfo.header.masters and curModInfo.name not in modInfos.mergeable]
-        if dependent:
-            if not verbose: return False
-            reasons += (_("\n.    Is a master of non-mergeable mod(s): ") + ', '.join(sorted(dependent))+'.')
-        if reasons: return reasons
-        return True
+            return item
 
-    @staticmethod
-    def modIsMergeable(modInfo,progress=None,verbose=True,modFile=None):
-        """Returns True or error message indicating whether specified mod is mergeable."""
-        canmerge = CBash_PatchFile.modIsMergeableNoLoad(modInfo, verbose)
-        if not verbose:
-            if canmerge == True:
-                return CBash_PatchFile.modIsMergeableLoad(modInfo, verbose, modFile)
-            return False
-        loadreasons = CBash_PatchFile.modIsMergeableLoad(modInfo, verbose, modFile)
-        reasons = ''
-        if canmerge != True:
-            reasons = canmerge
-        if loadreasons != True:
-            reasons += loadreasons
-        if reasons: return reasons
-        return True
+    def sortConfig(self,items):
+        """Return sorted items. Default assumes mods and sorts by load order."""
+        return modInfos.getOrdered(items,False)
 
-    #--Instance
-    def __init__(self, patchName, patchers):
-        """Initialization."""
-        self.patchName = patchName
-        #--New attrs
-        self.aliases = {} #--Aliases from one mod name to another. Used by text file patchers.
-        self.patchers = patchers
-        self.mergeIds = set()
-        self.loadErrorMods = []
-        self.worldOrphanMods = []
-        self.unFilteredMods = []
-        self.compiledAllMods = []
-        self.type_patchers = {}
-        self.indexMGEFs = False
-        self.mgef_school = bush.mgef_school.copy()
-        self.mgef_name = bush.mgef_name.copy()
-        self.hostileEffects = bush.hostileEffects.copy()
-        self.scanSet = set()
-        self.patcher_mod_skipcount = {}
-        #--Config
-        self.bodyTags = 'ARGHTCCPBS' #--Default bodytags
-        #--Mods
-        self.setMods([name for name in modInfos.ordered if modInfos[name].mtime < self.patchTime],[])
-        for patcher in self.patchers:
-            patcher.initPatchFile(self,self.loadMods)
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        #--Toss outdated configCheck data.
+        listSet = set(self.configItems)
+        self.configChecks = dict([(key,value) for key,value in self.configChecks.iteritems() if key in listSet])
+        self.configChoices = dict([(key,value) for key,value in self.configChoices.iteritems() if key in listSet])
+        CBash_Patcher.saveConfig(self,configs)
 
-    def setMods(self,loadMods=None,mergeMods=None):##,forceMergeMods=[]):
-        """Sets mod lists and sets."""
-        if loadMods != None: self.loadMods = loadMods
-        if mergeMods != None: self.mergeMods = mergeMods
-##        self.forceMergeSet = set(forceMergeMods)
-        self.loadSet = set(self.loadMods)
-        self.mergeSet = set(self.mergeMods)
-        self.allMods = modInfos.getOrdered(self.loadSet|self.mergeSet)##|self.forceMergeSet)
-        self.allSet = set(self.allMods)
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcs = self.getConfigChecked()
+        self.isActive = bool(self.srcs)
 
-    def initData(self,progress):
-        """Gives each patcher a chance to get its source data."""
-        if not len(self.patchers): return
-        progress = progress.setFull(len(self.patchers))
-        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('scanOrder'))):
-            progress(index,_("Preparing\n%s") % patcher.getName())
-            patcher.initData(self.type_patchers,SubProgress(progress,index))
-        progress(progress.full,_('Patchers prepared.'))
+    def getConfigChecked(self):
+        """Returns checked config items in list order."""
+        if self.allowUnloaded:
+            return [item for item in self.configItems if self.configChecks[item]]
+        else:
+            return [item for item in self.configItems if self.configChecks[item] and (item in self.patchFile.allMods or not reModExt.match(item.s))]
 
-    def mergeModFile(self,modFile,progress,doFilter,iiMode):
-        """Copies contents of modFile into self."""
-        """Note that GMST and MGEF records will get assigned new FormID's, due to the way
-           that CBash works.  This is ok, since these types of records are only
-           referenced via their EditorID's."""
-        mergeIds = self.mergeIds
-        loadSet = self.loadSet
-        parentsToLoad = set()
-        recordsToLoad = set()
-        badForm = (GPath("Oblivion.esm"),0xA31D) #--DarkPCB record
-        for blockType, block in modFile.aggregates.iteritems():
-            iiSkipMerge = iiMode and blockType not in ('LVLC','LVLI','LVSP')
-            if iiSkipMerge: continue
-            #--Make sure block type is also in read and write factories
-            for record in block:
-                if record.fid == badForm: continue
-                #--Include this record?
-                if record.IsWinning():
-                    if doFilter:
-                        if not record.fid[0] in loadSet: continue
-                        record.mergeFilter(loadSet)
-                    parent = record.Parent
-                    if parent:
-                        parentFid = parent.fid
-                        if self.HasRecord(parentFid) == False:
-                            #Copy the parent over if it isn't in the patch
-                            parentsToLoad.add(parentFid)
-                    recordsToLoad.add(record)
+#------------------------------------------------------------------------------
+class MultiTweakItem:
+    """A tweak item, optionally with configuration choices."""
+    def __init__(self,label,tip,key,*choices):
+        """Initialize."""
+        self.label = label
+        self.tip = tip
+        self.key = key
+        self.choiceLabels = []
+        self.choiceValues = []
+        self.default = 0
+        for choice in choices:
+            self.choiceLabels.append(choice[0])
+            if choice[0][0] == '[':
+                self.default = choices.index(choice)
+            self.choiceValues.append(choice[1:])
+        #--Config
+        self.isEnabled = False
+        self.chosen = 0
 
-        recordFids = set([x.fid for x in recordsToLoad])
-        otherParentsToLoad = parentsToLoad - recordFids # Parents to copy from the winning mod
-        parentsToLoad -= otherParentsToLoad             # Parents to copy from this mod
+    #--Config Phase -----------------------------------------------------------
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        self.isEnabled,self.chosen = False,0
+        if self.key in configs:
+            self.isEnabled,value = configs[self.key]
+            if value in self.choiceValues:
+                self.chosen = self.choiceValues.index(value)
+            else:
+                for label in self.choiceLabels:
+                    if label.startswith('Custom'):
+                        self.chosen = self.choiceLabels.index(label)
+                        self.choiceValues[self.chosen] = value
+        else:
+            if self.default:
+                self.chosen = self.default
 
-        def isWorldCELL(record):
-            if record._Type == "CELL":
-                parent = record.Parent
-                if parent:
-                    if parent._Type == "WRLD":
-                        cell = parent.WorldCELL
-                        if cell and cell.fid == record.fid:
-                            return True
-            return False
+    def getListLabel(self):
+        """Returns label to be used in list"""
+        label = self.label
+        if len(self.choiceLabels) > 1:
+            label += ' [' + self.choiceLabels[self.chosen] + ']'
+        return label
 
-        # Load parent records from winning mods first
-        for parentFid in otherParentsToLoad:
-            parent = self.ObCollection.LookupRecords(parentFid)
-            if parent:
-                # Deal with WorldCELL's copy flags not being set properly
-                if isWorldCELL(parent[0]):
-                    parent[0].Parent.CopyAsOverride(self)
-                    parent[0].CopyAsOverride(self,4)
-                else:
-                    parent[0].CopyAsOverride(self)
-        # Load parent records from this mod
-        for parentFid in parentsToLoad:
-            parent = self.ObCollection.LookupRecords(parentFid,True)
-            if parent:
-                for p in parent:
-                    if p.GName == modFile.GName:
-                        if isWorldCELL(p):
-                            p.CopyAsOverride(self,4)
-                        else:
-                            p.CopyAsOverride(self)
-        # Load records from this mod
-        for record in recordsToLoad:
-            override = record.CopyAsOverride(self)
-            if override:
-                mergeIds.add(override.fid)
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        if self.choiceValues: value = self.choiceValues[self.chosen]
+        else: value = None
+        configs[self.key] = self.isEnabled,value
 
-##    def forceMergeModFile(self,modFile,progress,doFilter,iiMode):
-##        """Copies contents of modFile into self; as new records in the patch not as overrides including new records so can be dangerous!."""
-##        badForm = (GPath("Oblivion.esm"),0xA31D) #--DarkPCB record
-##        print modFile
-##        for blockType, block in modFile.aggregates.iteritems():
-##            #--Make sure block type is also in read and write factories
-##            print blockType, block
-##            for record in block:
-##                if record.fid == badForm: continue
-##                #--Include this record?
-##                if hasattr(record, '_ParentID'):
-##                    if self.HasRecord(record._ParentID) is None:
-##                        #Copy the winning version of the parent over if it isn't in the patch
-##                        parent = self.ObCollection.LookupRecords(record._ParentID)
-##                        if parent:
-##                            if parent[0].GName == record.GName:
-##                                parent[0].CopyAsNew(self.patchFile)
-##                            else:
-##                                parent[0].CopyAsOverride(self.patchFile)
-##                new = record.CopyAsNew(self)
-##                print new
+class CBash_MultiTweakItem:
+    """A tweak item, optionally with configuration choices."""
+    iiMode = False
+    scanRequiresChecked = False
+    applyRequiresChecked = False
 
-    def buildPatch(self,progress):
-        """Scans load+merge mods."""
-        if not len(self.loadMods): return
-        iiModeSet = set(('InventOnly','IIM'))
-        levelLists = set(('LVLC','LVLI','LVSP'))
-        nullProgress = bolt.Progress()
+    def __init__(self,label,tip,key,*choices):
+        """Initialize."""
+        self.label = label
+        self.tip = tip
+        self.key = key
+        self.choiceLabels = []
+        self.choiceValues = []
+        self.default = 0
+        for choice in choices:
+            self.choiceLabels.append(choice[0])
+            if choice[0][0] == '[':
+                self.default = choices.index(choice)
+            self.choiceValues.append(choice[1:])
+        #--Config
+        self.isEnabled = False
+        self.chosen = 0
 
-        IIMSet = set([modName for modName in (self.allSet|self.scanSet) if bool(modInfos[modName].getBashTags() & iiModeSet)])
+    #--Config Phase -----------------------------------------------------------
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        self.isEnabled,self.chosen = False,0
+        if self.key in configs:
+            self.isEnabled,value = configs[self.key]
+            if value in self.choiceValues:
+                self.chosen = self.choiceValues.index(value)
+            else:
+                for label in self.choiceLabels:
+                    if label.startswith('Custom'):
+                        self.chosen = self.choiceLabels.index(label)
+                        self.choiceValues[self.chosen] = value
+        else:
+            if self.default:
+                self.chosen = self.default
 
-        self.ObCollection = ObCollection(ModsPath=dirs['mods'].s)
+    def getListLabel(self):
+        """Returns label to be used in list"""
+        label = self.label
+        if len(self.choiceLabels) > 1:
+            label += ' [' + self.choiceLabels[self.chosen] + ']'
+        return label
 
-        #add order reordered
-        #mods can't be added more than once, and a mod could be in both the loadSet and mergeSet or loadSet and scanSet
-        #if it was added as a normal mod first, it isn't flagged correctly when later added as a merge mod
-        #if it was added as a scan mod first, it isn't flagged correctly when later added as a normal mod
-        for name in self.mergeSet:
-            if modInfos[name].mtime < self.patchTime:
-                self.ObCollection.addMergeMod(modInfos[name].getPath().stail)
-        for name in self.loadSet:
-            if modInfos[name].mtime < self.patchTime:
-                self.ObCollection.addMod(modInfos[name].getPath().stail)
-        for name in self.scanSet:
-            if modInfos[name].mtime < self.patchTime:
-                self.ObCollection.addScanMod(modInfos[name].getPath().stail)
-##        for name in self.forceMergeSet:
-##            if modInfos[name].mtime < self.patchTime:
-##                self.ObCollection.addMergeMod(modInfos[name].getPath().stail)
-        self.patchName.temp.remove()
-        self.ObCollection.addMod(self.patchName.temp.s, IgnoreExisting=True)
-        self.ObCollection.load()
-        try:
-            patchFile = self.patchFile = self.ObCollection.LookupModFile(self.patchName.temp.s)
-        except KeyError, error:
-            print "buildPatch"
-            print error[0]
-            return
-        ObModFile.__init__(self, patchFile._CollectionID, patchFile._ModID)
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        if self.choiceValues: value = self.choiceValues[self.chosen]
+        else: value = None
+        configs[self.key] = self.isEnabled,value
 
-        self.TES4.author = 'BASHED PATCH'
+#------------------------------------------------------------------------------
+class MultiTweaker(Patcher):
+    """Combines a number of sub-tweaks which can be individually enabled and
+    configured through a choice menu."""
+    group = _('Tweakers')
+    scanOrder = 20
+    editOrder = 20
 
-        #With this indexing, MGEFs may be looped through twice if another patcher also looks through MGEFs
-        #It's inefficient, but it really shouldn't be a problem since there are so few MGEFs.
-        if self.indexMGEFs:
-            mgefId_hostile = {}
-            self.mgef_school.clear()
-            self.mgef_name.clear()
-            for modName in self.allMods:
-                try:
-                    modFile = self.ObCollection.LookupModFile(modName.s)
-                except KeyError, error:
-                    print "indexMGEFs"
-                    print error[0]
-                    continue
-                for record in modFile.MGEF:
-                    full = record.full
-                    eid = record.eid
-                    if (full and eid):
-                        mgefId = cast(eid, POINTER(c_ulong)).contents.value if record.recordVersion is None else record.mgefCode
-                        self.mgef_school[mgefId] = record.school
-                        self.mgef_name[mgefId] = full
-                        mgefId_hostile[mgefId] = record.IsHostile
-                    record.UnloadRecord()
-            self.hostileEffects = set([mgefId for mgefId, hostile in mgefId_hostile.iteritems() if hostile])
-        self.completeMods = modInfos.getOrdered(self.allSet|self.scanSet)
-        type_patchers = self.type_patchers
-        numFinishers = 0
-        for type, patchers in type_patchers.iteritems():
-            if len([patcher.finishPatch for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'finishPatch')]):
-                numFinishers += 1
+    #--Config Phase -----------------------------------------------------------
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        config = configs.setdefault(self.__class__.__name__,{})
+        self.isEnabled = config.get('isEnabled',False)
+        self.tweaks = copy.deepcopy(self.__class__.tweaks)
+        for tweak in self.tweaks:
+            tweak.getConfig(config)
 
-        progress = progress.setFull(len(self.completeMods) + max(numFinishers,1))
-        maxVersion = 0
-        for index,modName in enumerate(self.completeMods):
-            if modName == self.patchName: continue
-            modInfo = modInfos[modName]
-            bashTags = modInfo.getBashTags()
-            isScanned = modName in self.scanSet and modName not in self.loadSet and modName not in self.mergeSet
-            if modName in self.loadMods and 'Filter' in bashTags:
-                self.unFilteredMods.append(modName)
-            isMerged = modName in self.mergeSet
-##            isForceMerged = modName in self.forceMergeSet
-            doFilter = isMerged and 'Filter' in bashTags
-            #--iiMode is a hack to support Item Interchange. Actual key used is InventOnly.
-            iiMode = isMerged and bool(iiModeSet & bashTags)
-            try:
-                modFile = self.ObCollection.LookupModFile(modInfo.getPath().stail)
-            except KeyError, error:
-                print "completeMods"
-                print error[0]
-                continue
-            modGName = modFile.GName
-            #--Error checks
-            gls = modFile.LookupRecord(0x00025811)
-            if gls and gls.compiledSize == 4 and gls.lastIndex == 0 and modName != GPath('Oblivion.esm'):
-                self.compiledAllMods.append(modName)
-            pstate = 0
-            subProgress = SubProgress(progress,index)
-            subProgress.setFull(max(len(type_patchers),1))
-            for type, patchers in type_patchers.iteritems():
-                iiFilter = IIMSet and not (iiMode or type in levelLists)
-                #Filter the used patchers as needed
-                if iiMode:
-                    applyPatchers = [patcher.apply for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'apply') and patcher.iiMode if not patcher.applyRequiresChecked or (modGName in patcher.srcs)]
-                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') and patcher.iiMode if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
-                elif isScanned:
-                    applyPatchers = [] #Scanned mods should never be copied directly into the bashed patch.
-                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') and patcher.allowUnloaded if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
-                else:
-                    applyPatchers = [patcher.apply for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'apply') if not patcher.applyRequiresChecked or (modGName in patcher.srcs)]
-                    scanPatchers = [patcher.scan for patcher in sorted(patchers,key=attrgetter('scanOrder')) if hasattr(patcher,'scan') if not patcher.scanRequiresChecked or (modGName in patcher.srcs)]
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        config = configs[self.__class__.__name__] = {}
+        config['isEnabled'] = self.isEnabled
+        for tweak in self.tweaks:
+            tweak.saveConfig(config)
+        self.enabledTweaks = [tweak for tweak in self.tweaks if tweak.isEnabled]
+        self.isActive = len(self.enabledTweaks) > 0
 
-                #See if all the patchers were filtered out
-                if not (applyPatchers or scanPatchers): continue
-                subProgress(pstate,_("Patching...\n%s::%s") % (modFile.ModName,type))
-                pstate += 1
-                for record in getattr(modFile, type):
-                    #If conflicts is > 0, it will include all conflicts, even the record that called it
-                    #(i.e. len(conflicts) will never equal 1)
-                    #The winning record is at position 0, and the last record is the one most overridden
-                    if doFilter:
-                        if not record.fid[0] in self.loadSet: continue
-                        record.mergeFilter(self.loadSet)
+class CBash_MultiTweaker(CBash_Patcher):
+    """Combines a number of sub-tweaks which can be individually enabled and
+    configured through a choice menu."""
+    group = _('Tweakers')
+    scanOrder = 20
+    editOrder = 20
 
-                    if iiFilter:
-                        #InventOnly/IIM tags are a pain. They don't fit the normal patch model.
-                        #They're basically a mixture of scanned and merged.
-                        #This effectively hides all non-level list records from the other patchers
-                        conflicts = [conflict for conflict in record.Conflicts() if conflict.GName not in IIMSet]
-                        isWinning = (len(conflicts) < 2 or conflicts[0].ModName == record.ModName)
-                    else:
-                        #Prevents scanned records from being scanned twice if the scanned record loads later than the real winning record
-                        # (once when the real winning record is applied, and once when the scanned record is later encountered)
-                        if isScanned and record.IsWinning(True): #Not the most optimized, but works well enough
-                            continue #doesn't work if the record's been copied into the patch...needs work
-                        isWinning = record.IsWinning()
+    #--Config Phase -----------------------------------------------------------
+    def initData(self,type_patchers,progress):
+        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+        if not self.isActive: return
+        for tweak in self.enabledTweaks:
+            for type in tweak.getTypes():
+                type_patchers.setdefault(type,[]).append(tweak)
 
-                    if isWinning:
-                        curPatchers = applyPatchers
-                    else:
-                        curPatchers = scanPatchers
-                    for patcher in curPatchers:
-                        patcher(modFile, record, bashTags)
-                    record.UnloadRecord()
-            if isMerged:
-                progress(index,_("%s\nMerging...") % modFile.ModName)
-                self.mergeModFile(modFile,nullProgress,doFilter,iiMode)
-##            if isForceMerged:
-##                progress(index,_("%s\nMerging...") % modFile.ModName)
-##                self.forceMergeModFile(modFile,nullProgress,doFilter,iiMode)
-            maxVersion = max(modFile.TES4.version, maxVersion)
-        # Force 1.0 as max TES4 version for now, as we don't expext any new esp format changes,
-        # and if they do come about, we can always change this.  Plus this will solve issues where
-        # Mod files mistakenly get have the header version set > 1.0
-        self.TES4.version = min(maxVersion,1.0)
-        #Finish the patch
-        modFile = self
-        progress(len(self.completeMods))
-        subProgress = SubProgress(progress,len(self.completeMods))
-        subProgress.setFull(max(numFinishers,1))
-        pstate = 0
-        for type, patchers in type_patchers.iteritems():
-            finishPatchers = [patcher.finishPatch for patcher in sorted(patchers,key=attrgetter('editOrder')) if hasattr(patcher,'finishPatch')]
-            if finishPatchers:
-                subProgress(pstate,_("Final Patching...\n%s::%s") % (modFile.ModName,type))
-                pstate += 1
-                for patcher in finishPatchers:
-                    patcher(self, subProgress)
-        #--Fix UDR's
-        ## Skip this for now, since we aren't restoring any relevant data, just swapping flags (aka, use TES4Edit instead)
-        ##progress(0,_('Cleaning...'))
-        ##records = self.ACRES + self.ACHRS + self.REFRS
-        ##progress.setFull(max(len(records),1))
-        ##for i,record in enumerate(records):
-        ##    progress(i)
-        ##    if record.IsDeleted:
-        ##        record.IsDeleted = False
-        ##        record.IsIgnored = True
-        #--Done
-        progress(progress.full,_('Patchers applied.'))
-        self.ScanCollection = None
-
-    def buildPatchLog(self,patchName,log,progress):
-        """Completes merge process. Use this when finished using buildPatch."""
-        if not len(self.patchers): return
-        log.setHeader('= '+patchName.s+' '+'='*30+'#',True)
-        log("{{CONTENTS=1}}")
-        #--Load Mods and error mods
-        log.setHeader(_("= Overview"),True)
-        log.setHeader(_("=== Date/Time"))
-        log('* '+formatDate(time.time()))
-        log(_('* Elapsed Time: ') + 'TIMEPLACEHOLDER')
-        if self.patcher_mod_skipcount:
-            log.setHeader(_("=== Skipped Imports"))
-            log(_("The following import patchers skipped records because the imported record required a missing or non-active mod to work properly. If this was not intentional, rebuild the patch after either deactivating the imported mods listed below or activating the missing mod(s)."))
-            for patcher, mod_skipcount in self.patcher_mod_skipcount.iteritems():
-                log ('* %s skipped %d records:' % (str(patcher),sum(mod_skipcount.values())))
-                for mod, skipcount in mod_skipcount.iteritems():
-                    log ('  * The imported mod, %s, skipped %d records.' % (str(mod),skipcount))
+    def getConfig(self,configs):
+        """Get config from configs dictionary and/or set to default."""
+        config = configs.setdefault(self.__class__.__name__,{})
+        self.isEnabled = config.get('isEnabled',False)
+        self.tweaks = copy.deepcopy(self.__class__.tweaks)
+        for tweak in self.tweaks:
+            tweak.getConfig(config)
 
-        if self.unFilteredMods:
-            log.setHeader(_("=== Unfiltered Mods"))
-            log(_("The following mods were active when the patch was built. For the mods to work properly, you should deactivate the mods and then rebuild the patch with the mods [[http://wrye.ufrealms.net/Wrye%20Bash.html#MergeFiltering|Merged]] in."))
-            for mod in self.unFilteredMods: log ('* '+mod.s)
-        if self.loadErrorMods:
-            log.setHeader(_("=== Load Error Mods"))
-            log(_("The following mods had load errors and were skipped while building the patch. Most likely this problem is due to a badly formatted mod. For more info, see [[http://www.uesp.net/wiki/Tes4Mod:Wrye_Bash/Bashed_Patch#Error_Messages|Bashed Patch: Error Messages]]."))
-            for mod in self.loadErrorMods: log ('* '+mod.s)
-        if self.worldOrphanMods:
-            log.setHeader(_("=== World Orphans"))
-            log(_("The following mods had orphaned world groups, which were skipped. This is not a major problem, but you might want to use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#RemoveWorldOrphans|Remove World Orphans]] command to repair the mods."))
-            for mod in self.worldOrphanMods: log ('* '+mod.s)
-        if self.compiledAllMods:
-            log.setHeader(_("=== Compiled All"))
-            log(_("The following mods have an empty compiled version of genericLoreScript. This is usually a sign that the mod author did a __compile all__ while editing scripts. This may interfere with the behavior of other mods that intentionally modify scripts from Oblivion.esm. (E.g. Cobl and Unofficial Oblivion Patch.) You can use Bash's [[http://wrye.ufrealms.net/Wrye%20Bash.html#DecompileAll|Decompile All]] command to repair the mods."))
-            for mod in self.compiledAllMods: log ('* '+mod.s)
-        log.setHeader(_("=== Active Mods"),True)
-        for name in self.allMods:
-            version = modInfos.getVersion(name)
-            if name in self.loadMods:
-                message = '* %02X ' % (self.loadMods.index(name),)
-            else:
-                message = '* ++ '
-            if version:
-                message += _('%s  [Version %s]') % (name.s,version)
-            else:
-                message += name.s
-            log(message)
-        #--Load Mods and error mods
-        if self.aliases:
-            log.setHeader(_("= Mod Aliases"))
-            for key,value in sorted(self.aliases.iteritems()):
-                log('* %s >> %s' % (key.s,value.s))
-        #--Patchers
-        subProgress = SubProgress(progress,0,0.9,len(self.patchers))
-        for index,patcher in enumerate(sorted(self.patchers,key=attrgetter('editOrder'))):
-            subProgress(index,_("Completing\n%s...") % (patcher.getName(),))
-            patcher.buildPatchLog(log)
-        progress(1.0,"Compiled.")
-        #--Description
-        numRecords = sum([len(x) for x in self.aggregates.values()])
-        self.TES4.description = _("Updated: %s\n\nRecords Changed: %d") % (formatDate(time.time()),numRecords)
+    def saveConfig(self,configs):
+        """Save config to configs dictionary."""
+        config = configs[self.__class__.__name__] = {}
+        config['isEnabled'] = self.isEnabled
+        for tweak in self.tweaks:
+            tweak.saveConfig(config)
+        self.enabledTweaks = [tweak for tweak in self.tweaks if tweak.isEnabled]
+        self.isActive = len(self.enabledTweaks) > 0
+# Patchers: 10 ----------------------------------------------------------------
 #------------------------------------------------------------------------------
-class Patcher:
-    """Abstract base class for patcher elements."""
+class AliasesPatcher(Patcher):
+    """Specify mod aliases for patch files."""
     scanOrder = 10
     editOrder = 10
-    group = 'UNDEFINED'
-    name = 'UNDEFINED'
-    text = "UNDEFINED."
+    group = _('General')
+    name = _("Alias Mod Names")
+    text = _("Specify mod aliases for reading CSV source files.")
     tip = None
-    defaultConfig = {'isEnabled':False}
-    iiMode = False
-    selectCommands = True
-
-    def getName(self):
-        """Returns patcher name."""
-        return self.__class__.name
+    defaultConfig = {'isEnabled':True,'aliases':{}}
 
     #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        """Initialization of common values to defaults."""
-        self.patchFile = None
-        self.scanOrder = self.__class__.scanOrder
-        self.editOrder = self.__class__.editOrder
-        self.isActive = True
-        #--Gui stuff
-        self.isEnabled = False #--Patcher is enabled.
-        self.gConfigPanel = None
-
     def getConfig(self,configs):
         """Get config from configs dictionary and/or set to default."""
-        config = configs.setdefault(self.__class__.__name__,{})
-        for attr,default in self.__class__.defaultConfig.iteritems():
-            value = copy.deepcopy(config.get(attr,default))
-            setattr(self,attr,value)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        config = configs[self.__class__.__name__] = {}
-        for attr in self.__class__.defaultConfig:
-            config[attr] = copy.deepcopy(getattr(self,attr))
+        Patcher.getConfig(self,configs)
+        #--Update old configs to use Paths instead of strings.
+        self.aliases = dict(map(GPath,item) for item in self.aliases.iteritems())
 
     #--Patch Phase ------------------------------------------------------------
     def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-
-    def initData(self,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        pass
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return None
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return None
-
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it. If adds record, should first convert it to long fids."""
-        pass
-
-    def buildPatch(self,log,progress):
-        """Edits patch file as desired. Should write to log."""
-        pass
-
-class CBash_Patcher:
-    """Abstract base class for patcher elements."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        if self.isEnabled:
+            self.patchFile.aliases = self.aliases
+class CBash_AliasesPatcher(CBash_Patcher):
+    """Specify mod aliases for patch files."""
     scanOrder = 10
     editOrder = 10
-    group = 'UNDEFINED'
-    name = 'UNDEFINED'
-    text = "UNDEFINED."
-    unloadedText = ""
+    group = _('General')
+    name = _("Alias Mod Names")
+    text = _("Specify mod aliases for reading CSV source files.")
     tip = None
-    defaultConfig = {'isEnabled':False}
-    iiMode = False
-    selectCommands = True
-    allowUnloaded = True
-    scanRequiresChecked = False
-    applyRequiresChecked = False
-
-    def getName(self):
-        """Returns patcher name."""
-        return self.__class__.name
+    defaultConfig = {'isEnabled':True,'aliases':{}}
 
     #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        """Initialization of common values to defaults."""
-        self.patchFile = None
-        self.scanOrder = self.__class__.scanOrder
-        self.editOrder = self.__class__.editOrder
-        self.isActive = True
-        #--Gui stuff
-        self.isEnabled = False #--Patcher is enabled.
-        self.gConfigPanel = None
-        if not self.allowUnloaded:
-            self.text = self.text + self.unloadedText
-
     def getConfig(self,configs):
         """Get config from configs dictionary and/or set to default."""
-        config = configs.setdefault(self.__class__.__name__,{})
-        for attr,default in self.__class__.defaultConfig.iteritems():
-            value = copy.deepcopy(config.get(attr,default))
-            setattr(self,attr,value)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        config = configs[self.__class__.__name__] = {}
-        for attr in self.__class__.defaultConfig:
-            config[attr] = copy.deepcopy(getattr(self,attr))
+        CBash_Patcher.getConfig(self,configs)
+        #--Update old configs to use Paths instead of strings.
+        self.aliases = dict(map(GPath,item) for item in self.aliases.iteritems())
+        self.srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
 
     #--Patch Phase ------------------------------------------------------------
     def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return []
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-            type_patchers.setdefault(type,[]).append(self)
-        if self.allowUnloaded:
-            loadMods = set([mod for mod in self.srcs if reModExt.search(mod.s) and mod not in self.patchFile.allMods])
-            self.patchFile.scanSet |= loadMods
-
-    def buildPatchLog(self,log):
-        """Write to log."""
-        pass
+        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+        if self.isEnabled:
+            self.patchFile.aliases = self.aliases
 #------------------------------------------------------------------------------
-class ListPatcher(Patcher):
-    """Subclass for patchers that have GUI lists of objects."""
-    #--Get/Save Config
-    choiceMenu = None #--List of possible choices for each config item. Item 0 is default.
-    defaultConfig = {'isEnabled':False,'autoIsChecked':True,'configItems':[],'configChecks':{},'configChoices':{}}
+class PatchMerger(ListPatcher):
+    """Merges specified patches into Bashed Patch."""
+    scanOrder = 10
+    editOrder = 10
+    group = _('General')
+    name = _('Merge Patches')
+    text = _("Merge patch mods into Bashed Patch.")
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Merge'
     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    forceItemCheck = False #--Force configChecked to True for all items
-    autoRe = re.compile('^UNDEFINED$') #--Compiled re used by getAutoItems
-    autoKey = None
-    forceAuto = True
 
-    #--Config Phase -----------------------------------------------------------
     def getAutoItems(self):
         """Returns list of items to be used for automatic configuration."""
         autoItems = []
-        autoRe = self.__class__.autoRe
-        autoKey = self.__class__.autoKey
-        if isinstance(autoKey,str):
-            autoKey = set((autoKey,))
-        autoKey = set(autoKey)
-        self.choiceMenu = self.__class__.choiceMenu
         for modInfo in modInfos.data.values():
-            if autoRe.match(modInfo.name.s) or (autoKey & modInfo.getBashTags()):
-                if modInfo.mtime > PatchFile.patchTime: continue
+            if modInfo.name in modInfos.mergeable and 'NoMerge' not in modInfo.getBashTags() and modInfo.mtime < PatchFile.patchTime:
                 autoItems.append(modInfo.name)
-                if self.choiceMenu: self.getChoice(modInfo.name)
-        reFile = re.compile('_('+('|'.join(autoKey))+r')\.csv$')
-        for fileName in sorted(dirs['patches'].list()):
-            if reFile.search(fileName.s):
-                autoItems.append(fileName)
         return autoItems
 
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        Patcher.getConfig(self,configs)
-        if self.forceAuto:
-            self.autoIsChecked = True
-        #--Verify file existence
-        newConfigItems = []
-        patchesDir = dirs['patches'].list()
-        for srcPath in self.configItems:
-            if ((reModExt.search(srcPath.s) and srcPath in modInfos) or
-                reCsvExt.search(srcPath.s) and srcPath in patchesDir):
-                    newConfigItems.append(srcPath)
-        self.configItems = newConfigItems
-        if self.__class__.forceItemCheck:
-            for item in self.configItems:
-                self.configChecks[item] = True
-        #--Make sure configChoices are set (if choiceMenu exists).
-        if self.choiceMenu:
-            for item in self.configItems:
-                self.getChoice(item)
-        #--AutoItems?
-        if self.autoIsChecked:
-            self.getAutoItems()
-
-    def getChoice(self,item):
-        """Get default config choice."""
-        return self.configChoices.setdefault(item,self.choiceMenu[0])
-
-    def getItemLabel(self,item):
-        """Returns label for item to be used in list"""
-        if isinstance(item,bolt.Path): item = item.s
-        if self.choiceMenu:
-            return '%s [%s]' % (item,self.getChoice(item))
-        else:
-            return item
-
-    def sortConfig(self,items):
-        """Return sorted items. Default assumes mods and sorts by load order."""
-        return modInfos.getOrdered(items,False)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        #--Toss outdated configCheck data.
-        listSet = set(self.configItems)
-        self.configChecks = dict([(key,value) for key,value in self.configChecks.iteritems() if key in listSet])
-        self.configChoices = dict([(key,value) for key,value in self.configChoices.iteritems() if key in listSet])
-        Patcher.saveConfig(self,configs)
-
     #--Patch Phase ------------------------------------------------------------
-    def getConfigChecked(self):
-        """Returns checked config items in list order."""
-        return [item for item in self.configItems if self.configChecks[item]]
-
-class CBash_ListPatcher(CBash_Patcher):
-    """Subclass for patchers that have GUI lists of objects."""
-    unloadedText = _("\n\nAny non-active, non-merged mods in the following list will be IGNORED.")
-    #--Get/Save Config
-    choiceMenu = None #--List of possible choices for each config item. Item 0 is default.
-    defaultConfig = {'isEnabled':False,'autoIsChecked':True,'configItems':[],'configChecks':{},'configChoices':{}}
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        #--WARNING: Since other patchers may rely on the following update during
+        #  their initPatchFile section, it's important that PatchMerger first or near first.
+        if self.isEnabled: #--Since other mods may rely on this
+            patchFile.setMods(None,self.getConfigChecked())
+class CBash_PatchMerger(CBash_ListPatcher):
+    """Merges specified patches into Bashed Patch."""
+    scanOrder = 10
+    editOrder = 10
+    group = _('General')
+    name = _('Merge Patches')
+    text = _("Merge patch mods into Bashed Patch.")
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = set(('Merge',))
     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    forceItemCheck = False #--Force configChecked to True for all items
-    autoRe = re.compile('^UNDEFINED$') #--Compiled re used by getAutoItems
-    autoKey = None
-    forceAuto = True
-
-    #--Config Phase -----------------------------------------------------------
+    unloadedText = ""
     def getAutoItems(self):
         """Returns list of items to be used for automatic configuration."""
         autoItems = []
-        autoRe = self.__class__.autoRe
-        autoKey = self.__class__.autoKey
-        if isinstance(autoKey,str):
-            autoKey = set((autoKey,))
-        autoKey = set(autoKey)
-        self.choiceMenu = self.__class__.choiceMenu
         for modInfo in modInfos.data.values():
-            if autoRe.match(modInfo.name.s) or (autoKey & modInfo.getBashTags()):
-                if modInfo.mtime > CBash_PatchFile.patchTime: continue
+            if modInfo.name in modInfos.mergeable and 'NoMerge' not in modInfo.getBashTags() and modInfo.mtime < CBash_PatchFile.patchTime:
                 autoItems.append(modInfo.name)
-                if self.choiceMenu: self.getChoice(modInfo.name)
-        reFile = re.compile('_('+('|'.join(autoKey))+r')\.csv$')
-        for fileName in sorted(dirs['patches'].list()):
-            if reFile.search(fileName.s):
-                autoItems.append(fileName)
         return autoItems
 
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        CBash_Patcher.getConfig(self,configs)
-        if self.forceAuto:
-            self.autoIsChecked = True
-        #--Verify file existence
-        newConfigItems = []
-        patchesDir = dirs['patches'].list()
-        for srcPath in self.configItems:
-            if ((reModExt.search(srcPath.s) and srcPath in modInfos) or
-                reCsvExt.search(srcPath.s) and srcPath in patchesDir):
-                    newConfigItems.append(srcPath)
-        self.configItems = newConfigItems
-        if self.__class__.forceItemCheck:
-            for item in self.configItems:
-                self.configChecks[item] = True
-        #--Make sure configChoices are set (if choiceMenu exists).
-        if self.choiceMenu:
-            for item in self.configItems:
-                self.getChoice(item)
-        #--AutoItems?
-        if self.autoIsChecked:
-            self.getAutoItems()
-
-    def getChoice(self,item):
-        """Get default config choice."""
-        return self.configChoices.setdefault(item,self.choiceMenu[0])
-
-    def getItemLabel(self,item):
-        """Returns label for item to be used in list"""
-        if isinstance(item,bolt.Path): item = item.s
-        if self.choiceMenu:
-            return '%s [%s]' % (item,self.getChoice(item))
-        else:
-            return item
-
-    def sortConfig(self,items):
-        """Return sorted items. Default assumes mods and sorts by load order."""
-        return modInfos.getOrdered(items,False)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        #--Toss outdated configCheck data.
-        listSet = set(self.configItems)
-        self.configChecks = dict([(key,value) for key,value in self.configChecks.iteritems() if key in listSet])
-        self.configChoices = dict([(key,value) for key,value in self.configChoices.iteritems() if key in listSet])
-        CBash_Patcher.saveConfig(self,configs)
-
     #--Patch Phase ------------------------------------------------------------
     def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcs = self.getConfigChecked()
-        self.isActive = bool(self.srcs)
-
-    def getConfigChecked(self):
-        """Returns checked config items in list order."""
-        if self.allowUnloaded:
-            return [item for item in self.configItems if self.configChecks[item]]
-        else:
-            return [item for item in self.configItems if self.configChecks[item] and (item in self.patchFile.allMods or not reModExt.match(item.s))]
-
+        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+        if not self.isActive: return
+        #--WARNING: Since other patchers may rely on the following update during
+        #  their initPatchFile section, it's important that PatchMerger runs first or near first.
+        if self.isEnabled: #--Since other mods may rely on this
+            patchFile.setMods(None,self.srcs)
 #------------------------------------------------------------------------------
-class MultiTweakItem:
-    """A tweak item, optionally with configuration choices."""
-    def __init__(self,label,tip,key,*choices):
-        """Initialize."""
-        self.label = label
-        self.tip = tip
-        self.key = key
-        self.choiceLabels = []
-        self.choiceValues = []
-        self.default = 0
-        for choice in choices:
-            self.choiceLabels.append(choice[0])
-            if choice[0][0] == '[':
-                self.default = choices.index(choice)
-            self.choiceValues.append(choice[1:])
-        #--Config
-        self.isEnabled = False
-        self.chosen = 0
+class UpdateReferences(ListPatcher):
+    """Imports Form Id replacers into the Bashed Patch."""
+    scanOrder = 15
+    editOrder = 15
+    group = _('General')
+    name = _('Replace Form IDs')
+    text = _("Imports Form Id replacers from csv files into the Bashed Patch.")
+    autoKey = 'Formids'
+    defaultItemCheck = False #--GUI: Whether new items are checked by default or not.
 
     #--Config Phase -----------------------------------------------------------
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        self.isEnabled,self.chosen = False,0
-        if self.key in configs:
-            self.isEnabled,value = configs[self.key]
-            if value in self.choiceValues:
-                self.chosen = self.choiceValues.index(value)
-            else:
-                for label in self.choiceLabels:
-                    if label.startswith('Custom'):
-                        self.chosen = self.choiceLabels.index(label)
-                        self.choiceValues[self.chosen] = value
-        else:
-            if self.default:
-                self.chosen = self.default
-
-    def getListLabel(self):
-        """Returns label to be used in list"""
-        label = self.label
-        if len(self.choiceLabels) > 1:
-            label += ' [' + self.choiceLabels[self.chosen] + ']'
-        return label
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
+        self.types = MreRecord.simpleTypes
+        self.classes = [MreRecord.type_class[type] for type in self.types.union(['CELL','WRLD','REFR','ACHR','ACRE'])]
+        self.old_new = {} #--Maps old fid to new fid
+        self.old_eid = {} #--Maps old fid to old editor id
+        self.new_eid = {} #--Maps new fid to new editor id
 
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        if self.choiceValues: value = self.choiceValues[self.chosen]
-        else: value = None
-        configs[self.key] = self.isEnabled,value
-
-class CBash_MultiTweakItem:
-    """A tweak item, optionally with configuration choices."""
-    iiMode = False
-    scanRequiresChecked = False
-    applyRequiresChecked = False
-
-    def __init__(self,label,tip,key,*choices):
-        """Initialize."""
-        self.label = label
-        self.tip = tip
-        self.key = key
-        self.choiceLabels = []
-        self.choiceValues = []
-        self.default = 0
-        for choice in choices:
-            self.choiceLabels.append(choice[0])
-            if choice[0][0] == '[':
-                self.default = choices.index(choice)
-            self.choiceValues.append(choice[1:])
-        #--Config
-        self.isEnabled = False
-        self.chosen = 0
-
-    #--Config Phase -----------------------------------------------------------
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        self.isEnabled,self.chosen = False,0
-        if self.key in configs:
-            self.isEnabled,value = configs[self.key]
-            if value in self.choiceValues:
-                self.chosen = self.choiceValues.index(value)
-            else:
-                for label in self.choiceLabels:
-                    if label.startswith('Custom'):
-                        self.chosen = self.choiceLabels.index(label)
-                        self.choiceValues[self.chosen] = value
-        else:
-            if self.default:
-                self.chosen = self.default
-
-    def getListLabel(self):
-        """Returns label to be used in list"""
-        label = self.label
-        if len(self.choiceLabels) > 1:
-            label += ' [' + self.choiceLabels[self.chosen] + ']'
-        return label
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        if self.choiceValues: value = self.choiceValues[self.chosen]
-        else: value = None
-        configs[self.key] = self.isEnabled,value
-
-#------------------------------------------------------------------------------
-class MultiTweaker(Patcher):
-    """Combines a number of sub-tweaks which can be individually enabled and
-    configured through a choice menu."""
-    group = _('Tweakers')
-    scanOrder = 20
-    editOrder = 20
-
-    #--Config Phase -----------------------------------------------------------
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        config = configs.setdefault(self.__class__.__name__,{})
-        self.isEnabled = config.get('isEnabled',False)
-        self.tweaks = copy.deepcopy(self.__class__.tweaks)
-        for tweak in self.tweaks:
-            tweak.getConfig(config)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        config = configs[self.__class__.__name__] = {}
-        config['isEnabled'] = self.isEnabled
-        for tweak in self.tweaks:
-            tweak.saveConfig(config)
-        self.enabledTweaks = [tweak for tweak in self.tweaks if tweak.isEnabled]
-        self.isActive = len(self.enabledTweaks) > 0
-
-class CBash_MultiTweaker(CBash_Patcher):
-    """Combines a number of sub-tweaks which can be individually enabled and
-    configured through a choice menu."""
-    group = _('Tweakers')
-    scanOrder = 20
-    editOrder = 20
-
-    #--Config Phase -----------------------------------------------------------
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for tweak in self.enabledTweaks:
-            for type in tweak.getTypes():
-                type_patchers.setdefault(type,[]).append(tweak)
-
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        config = configs.setdefault(self.__class__.__name__,{})
-        self.isEnabled = config.get('isEnabled',False)
-        self.tweaks = copy.deepcopy(self.__class__.tweaks)
-        for tweak in self.tweaks:
-            tweak.getConfig(config)
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        config = configs[self.__class__.__name__] = {}
-        config['isEnabled'] = self.isEnabled
-        for tweak in self.tweaks:
-            tweak.saveConfig(config)
-        self.enabledTweaks = [tweak for tweak in self.tweaks if tweak.isEnabled]
-        self.isActive = len(self.enabledTweaks) > 0
-# Patchers: 10 ----------------------------------------------------------------
-#------------------------------------------------------------------------------
-class AliasesPatcher(Patcher):
-    """Specify mod aliases for patch files."""
-    scanOrder = 10
-    editOrder = 10
-    group = _('General')
-    name = _("Alias Mod Names")
-    text = _("Specify mod aliases for reading CSV source files.")
-    tip = None
-    defaultConfig = {'isEnabled':True,'aliases':{}}
-
-    #--Config Phase -----------------------------------------------------------
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        Patcher.getConfig(self,configs)
-        #--Update old configs to use Paths instead of strings.
-        self.aliases = dict(map(GPath,item) for item in self.aliases.iteritems())
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        if self.isEnabled:
-            self.patchFile.aliases = self.aliases
-class CBash_AliasesPatcher(CBash_Patcher):
-    """Specify mod aliases for patch files."""
-    scanOrder = 10
-    editOrder = 10
-    group = _('General')
-    name = _("Alias Mod Names")
-    text = _("Specify mod aliases for reading CSV source files.")
-    tip = None
-    defaultConfig = {'isEnabled':True,'aliases':{}}
-
-    #--Config Phase -----------------------------------------------------------
-    def getConfig(self,configs):
-        """Get config from configs dictionary and/or set to default."""
-        CBash_Patcher.getConfig(self,configs)
-        #--Update old configs to use Paths instead of strings.
-        self.aliases = dict(map(GPath,item) for item in self.aliases.iteritems())
-        self.srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        if self.isEnabled:
-            self.patchFile.aliases = self.aliases
-#------------------------------------------------------------------------------
-class PatchMerger(ListPatcher):
-    """Merges specified patches into Bashed Patch."""
-    scanOrder = 10
-    editOrder = 10
-    group = _('General')
-    name = _('Merge Patches')
-    text = _("Merge patch mods into Bashed Patch.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Merge'
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-
-    def getAutoItems(self):
-        """Returns list of items to be used for automatic configuration."""
-        autoItems = []
-        for modInfo in modInfos.data.values():
-            if modInfo.name in modInfos.mergeable and 'NoMerge' not in modInfo.getBashTags() and modInfo.mtime < PatchFile.patchTime:
-                autoItems.append(modInfo.name)
-        return autoItems
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        #--WARNING: Since other patchers may rely on the following update during
-        #  their initPatchFile section, it's important that PatchMerger first or near first.
-        if self.isEnabled: #--Since other mods may rely on this
-            patchFile.setMods(None,self.getConfigChecked())
-class CBash_PatchMerger(CBash_ListPatcher):
-    """Merges specified patches into Bashed Patch."""
-    scanOrder = 10
-    editOrder = 10
-    group = _('General')
-    name = _('Merge Patches')
-    text = _("Merge patch mods into Bashed Patch.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Merge',))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    unloadedText = ""
-    def getAutoItems(self):
-        """Returns list of items to be used for automatic configuration."""
-        autoItems = []
-        for modInfo in modInfos.data.values():
-            if modInfo.name in modInfos.mergeable and 'NoMerge' not in modInfo.getBashTags() and modInfo.mtime < CBash_PatchFile.patchTime:
-                autoItems.append(modInfo.name)
-        return autoItems
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        #--WARNING: Since other patchers may rely on the following update during
-        #  their initPatchFile section, it's important that PatchMerger runs first or near first.
-        if self.isEnabled: #--Since other mods may rely on this
-            patchFile.setMods(None,self.srcs)
-#------------------------------------------------------------------------------
-class UpdateReferences(ListPatcher):
-    """Imports Form Id replacers into the Bashed Patch."""
-    scanOrder = 15
-    editOrder = 15
-    group = _('General')
-    name = _('Replace Form IDs')
-    text = _("Imports Form Id replacers from csv files into the Bashed Patch.")
-    autoKey = 'Formids'
-    defaultItemCheck = False #--GUI: Whether new items are checked by default or not.
-
-    #--Config Phase -----------------------------------------------------------
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-        self.types = MreRecord.simpleTypes
-        self.classes = [MreRecord.type_class[type] for type in self.types.union(['CELL','WRLD','REFR','ACHR','ACRE'])]
-        self.old_new = {} #--Maps old fid to new fid
-        self.old_eid = {} #--Maps old fid to old editor id
-        self.new_eid = {} #--Maps new fid to new editor id
-
-    def readFromText(self,textPath):
-        """Reads replacment data from specified text file."""
-        old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
-        aliases = self.patchFile.aliases
-        ins = bolt.CsvReader(textPath)
-        pack,unpack = struct.pack,struct.unpack
-        for fields in ins:
-            if len(fields) < 7 or fields[2][:2] != '0x' or fields[6][:2] != '0x': continue
-            oldMod,oldObj,oldEid,newEid,newMod,newObj = fields[1:7]
-            oldMod,newMod = map(GPath,(oldMod,newMod))
-            oldId = (GPath(aliases.get(oldMod,oldMod)),int(oldObj,16))
-            newId = (GPath(aliases.get(newMod,newMod)),int(newObj,16))
-            old_new[oldId] = newId
-            old_eid[oldId] = oldEid
-            new_eid[newId] = newEid
-        ins.close()
+    def readFromText(self,textPath):
+        """Reads replacment data from specified text file."""
+        old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
+        aliases = self.patchFile.aliases
+        ins = bolt.CsvReader(textPath)
+        pack,unpack = struct.pack,struct.unpack
+        for fields in ins:
+            if len(fields) < 7 or fields[2][:2] != '0x' or fields[6][:2] != '0x': continue
+            oldMod,oldObj,oldEid,newEid,newMod,newObj = fields[1:7]
+            oldMod,newMod = map(GPath,(oldMod,newMod))
+            oldId = (GPath(aliases.get(oldMod,oldMod)),int(oldObj,16))
+            newId = (GPath(aliases.get(newMod,newMod)),int(newObj,16))
+            old_new[oldId] = newId
+            old_eid[oldId] = oldEid
+            new_eid[newId] = newEid
+        ins.close()
 
     def initData(self,progress):
         """Get names from source files."""
@@ -19337,111 +21380,111 @@ class UpdateReferences(ListPatcher):
         for srcMod in modInfos.getOrdered(count.keys()):
             log('* %s: %d' % (srcMod.s,count[srcMod]))
 
-class CBash_UpdateReferences(CBash_ListPatcher):
-    """Imports Form Id replacers into the Bashed Patch."""
-    #Much slower than it can be.
-    #At the least, it would be better to pass all possible old_new values to CBash at once
-    #Works though, so updating it comes later
-    scanOrder = 15
-    editOrder = 15
-    group = _('General')
-    name = _('Replace Form IDs')
-    text = _("Imports FormId replacers from csv files into the Bashed Patch.")
-    autoKey = set(('Formids',))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    unloadedText = _("\n\nAny non-active, non-merged mods referenced by files selected in the following list will be IGNORED.")
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.old_new = {} #--Maps old fid to new fid
-        self.old_eid = {} #--Maps old fid to old editor id
-        self.new_eid = {} #--Maps new fid to new editor id
-        self.mod_old_count = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        fidReplacer = CBash_FidReplacer(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            if not reModExt.search(srcFile.s):
-                if srcFile not in patchesDir: continue
-                fidReplacer.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        self.old_new = dict((oldId, newId) for oldId, newId in fidReplacer.old_new.iteritems() if oldId[0] in self.patchFile.loadSet and newId[0] in self.patchFile.loadSet)
-        self.old_eid.update(fidReplacer.old_eid)
-        self.new_eid.update(fidReplacer.new_eid)
-        self.isActive = bool(self.old_new)
-        if not self.isActive: return
-
-        for type in self.getTypes():
-             type_patchers.setdefault(type,[]).append(self)
-
-    def getTypes(self):
-        return ['FACT','RACE','MGEF','SCPT','LTEX','ENCH',
-                'SPEL','BSGN','ACTI','APPA','ARMO','BOOK',
-                'CLOT','CONT','DOOR','INGR','LIGH','MISC',
-                'FLOR','FURN','WEAP','AMMO','NPC_','CREA',
-                'LVLC','SLGM','KEYM','ALCH','SGST','LVLI',
-                'WTHR','CLMT','REGN','CELL','WRLD','ACHRS',
-                'ACRES','REFRS','DIAL','INFOS','QUST','IDLE',
-                'PACK','LSCR','LVSP','ANIO','WATR']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        old_new = self.old_new
-        changed = False
-        for oldId, newId in old_new.iteritems():
-            if record.GetNumReferences(oldId):
-                changed = True
-                break
-        if changed:
-            parent = record.Parent
-            if parent:
-                parent = self.patchFile.ObCollection.LookupRecords(parent.fid)
-                if parent:
-                    #Copy the winning version of the parent over
-                    parent[0].CopyAsOverride(self.patchFile)
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                mod_old_count = self.mod_old_count
-                old_count = mod_old_count.setdefault(modFile.GName,{})
-                for oldId, newId in old_new.iteritems():
-                    count = override.UpdateReferences(oldId,newId) #returns -1 on error
-                    if count > 0: old_count[oldId] = old_count.get(oldId,0) + count
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
-        mod_old_count = self.mod_old_count
-
-        log(_("=== Source Mods"))
-        if not self.srcs:
-            log(_(". ~~None~~"))
-        else:
-            for srcFile in self.srcs:
-                log("* " +srcFile.s)
-        log('\n')
-        for mod in modInfos.getOrdered(mod_old_count.keys()):
-            old_count = mod_old_count[mod]
-            log('\n=== %s' % (mod.s))
-            entries = [(count,old_eid[oldId],new_eid[old_new[oldId]]) for oldId,count in
-                    old_count.iteritems()]
-            entries.sort(key=itemgetter(1))
-            log(_('  * Updated References: %d') % (sum(old_count.values())))
-            log('\n'.join(['    * %3d %s >> %s' % entry for entry in entries]))
-
-        self.mod_old_count = {}
+# class CBash_UpdateReferences(CBash_ListPatcher):
+#     """Imports Form Id replacers into the Bashed Patch."""
+#     #Much slower than it can be.
+#     #At the least, it would be better to pass all possible old_new values to CBash at once
+#     #Works though, so updating it comes later
+#     scanOrder = 15
+#     editOrder = 15
+#     group = _('General')
+#     name = _('Replace Form IDs')
+#     text = _("Imports FormId replacers from csv files into the Bashed Patch.")
+#     autoKey = set(('Formids',))
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     unloadedText = _("\n\nAny non-active, non-merged mods referenced by files selected in the following list will be IGNORED.")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.old_new = {} #--Maps old fid to new fid
+#         self.old_eid = {} #--Maps old fid to old editor id
+#         self.new_eid = {} #--Maps new fid to new editor id
+#         self.mod_old_count = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         fidReplacer = CBash_FidReplacer(aliases=self.patchFile.aliases)
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             if not reModExt.search(srcFile.s):
+#                 if srcFile not in patchesDir: continue
+#                 fidReplacer.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+#         #--Finish
+#         self.old_new = dict((oldId, newId) for oldId, newId in fidReplacer.old_new.iteritems() if oldId[0] in self.patchFile.loadSet and newId[0] in self.patchFile.loadSet)
+#         self.old_eid.update(fidReplacer.old_eid)
+#         self.new_eid.update(fidReplacer.new_eid)
+#         self.isActive = bool(self.old_new)
+#         if not self.isActive: return
+
+#         for type in self.getTypes():
+#              type_patchers.setdefault(type,[]).append(self)
+
+#     def getTypes(self):
+#         return ['FACT','RACE','MGEF','SCPT','LTEX','ENCH',
+#                 'SPEL','BSGN','ACTI','APPA','ARMO','BOOK',
+#                 'CLOT','CONT','DOOR','INGR','LIGH','MISC',
+#                 'FLOR','FURN','WEAP','AMMO','NPC_','CREA',
+#                 'LVLC','SLGM','KEYM','ALCH','SGST','LVLI',
+#                 'WTHR','CLMT','REGN','CELL','WRLD','ACHRS',
+#                 'ACRES','REFRS','DIAL','INFOS','QUST','IDLE',
+#                 'PACK','LSCR','LVSP','ANIO','WATR']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         old_new = self.old_new
+#         changed = False
+#         for oldId, newId in old_new.iteritems():
+#             if record.GetNumReferences(oldId):
+#                 changed = True
+#                 break
+#         if changed:
+#             parent = record.Parent
+#             if parent:
+#                 parent = self.patchFile.ObCollection.LookupRecords(parent.fid)
+#                 if parent:
+#                     #Copy the winning version of the parent over
+#                     parent[0].CopyAsOverride(self.patchFile)
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 mod_old_count = self.mod_old_count
+#                 old_count = mod_old_count.setdefault(modFile.GName,{})
+#                 for oldId, newId in old_new.iteritems():
+#                     count = override.UpdateReferences(oldId,newId) #returns -1 on error
+#                     if count > 0: old_count[oldId] = old_count.get(oldId,0) + count
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         old_new,old_eid,new_eid = self.old_new,self.old_eid,self.new_eid
+#         mod_old_count = self.mod_old_count
+
+#         log(_("=== Source Mods"))
+#         if not self.srcs:
+#             log(_(". ~~None~~"))
+#         else:
+#             for srcFile in self.srcs:
+#                 log("* " +srcFile.s)
+#         log('\n')
+#         for mod in modInfos.getOrdered(mod_old_count.keys()):
+#             old_count = mod_old_count[mod]
+#             log('\n=== %s' % (mod.s))
+#             entries = [(count,old_eid[oldId],new_eid[old_new[oldId]]) for oldId,count in
+#                     old_count.iteritems()]
+#             entries.sort(key=itemgetter(1))
+#             log(_('  * Updated References: %d') % (sum(old_count.values())))
+#             log('\n'.join(['    * %3d %s >> %s' % entry for entry in entries]))
+
+#         self.mod_old_count = {}
 
 # Patchers: 20 ----------------------------------------------------------------
 #------------------------------------------------------------------------------
@@ -19469,21 +21512,21 @@ class ImportPatcher(ListPatcher):
         if not self.isActive: return None
         return self.srcClasses
 
-class CBash_ImportPatcher(CBash_ListPatcher):
-    """Subclass for patchers in group Importer."""
-    group = _('Importers')
-    scanOrder = 20
-    editOrder = 20
-    masters = {}
-    scanRequiresChecked = True
-    applyRequiresChecked = False
+# class CBash_ImportPatcher(CBash_ListPatcher):
+#     """Subclass for patchers in group Importer."""
+#     group = _('Importers')
+#     scanOrder = 20
+#     editOrder = 20
+#     masters = {}
+#     scanRequiresChecked = True
+#     applyRequiresChecked = False
 
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        CBash_ListPatcher.saveConfig(self,configs)
-        if self.isEnabled:
-            importedMods = [item for item,value in self.configChecks.iteritems() if value and reModExt.search(item.s)]
-            configs['ImportedMods'].update(importedMods)
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         CBash_ListPatcher.saveConfig(self,configs)
+#         if self.isEnabled:
+#             importedMods = [item for item,value in self.configChecks.iteritems() if value and reModExt.search(item.s)]
+#             configs['ImportedMods'].update(importedMods)
 
 #------------------------------------------------------------------------------
 # Waruddar - 12/14/2010 - All ForceMerger related code commented out
@@ -19731,7 +21774,8 @@ class CellImporter(ImportPatcher):
             'directionalRed','directionalGreen','directionalBlue','unused2',
             'fogRed','fogGreen','fogBlue','unused3',
             'fogNear','fogFar','directionalXY','directionalZ',
-            'directionalFade','fogClip'),
+            'directionalFade','fogClip','fogPower',
+            'lightTemplate','lightInheritFlags'),
             'C.RecordFlags': ('flags1',), # Yes seems funky but thats the way it is
             }
         self.recFlags = {
@@ -19902,89 +21946,89 @@ class CellImporter(ImportPatcher):
         log(_("\n=== Cells/Worlds Patched"))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('* %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_CellImporter(CBash_ImportPatcher):
-    """Merges changes to cells (climate, lighting, and water.)"""
-    name = _('Import Cells')
-    text = _("Import cells (climate, lighting, and water) from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('C.Climate','C.Light','C.Water','C.Owner','C.Name','C.RecordFlags','C.Music'))#,'C.Maps'
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_attr_value = {}
-        self.mod_count = {}
-        self.tag_attrs = {
-            'C.Climate': ('climate','IsBehaveLikeExterior'),
-            'C.Music': ('musicType',),
-            'C.Name': ('full',),
-            'C.Owner': ('owner','rank','globalVariable','IsPublicPlace'),
-            'C.Water': ('water','waterHeight','IsHasWater'),
-            'C.Light': ('ambientRed','ambientGreen','ambientBlue',
-                        'directionalRed','directionalGreen','directionalBlue',
-                        'fogRed','fogGreen','fogBlue',
-                        'fogNear','fogFar','directionalXY','directionalZ',
-                        'directionalFade','fogClip'),
-            'C.RecordFlags': ('flags1',), # Yes seems funky but thats the way it is
-            }
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CELLS']
-
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        if record.GName in self.patchFile.scanSet: ##Does nothing until I can fix the error in CBash.dll
-            for bashKey in bashTags & self.autoKey:
-                self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.tag_attrs[bashKey],True))
-        else:
-            for bashKey in bashTags & self.autoKey:
-                self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.tag_attrs[bashKey]))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        recordId = record.fid
-
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        prev_attr_value = self.fid_attr_value.get(recordId,None)
-        if prev_attr_value:
-            cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
-            if cur_attr_value != prev_attr_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_attr_value.iteritems():
-                        setattr(override,attr,value)
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Cells/Worlds Patched: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+# class CBash_CellImporter(CBash_ImportPatcher):
+#     """Merges changes to cells (climate, lighting, and water.)"""
+#     name = _('Import Cells')
+#     text = _("Import cells (climate, lighting, and water) from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('C.Climate','C.Light','C.Water','C.Owner','C.Name','C.RecordFlags','C.Music'))#,'C.Maps'
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_attr_value = {}
+#         self.mod_count = {}
+#         self.tag_attrs = {
+#             'C.Climate': ('climate','IsBehaveLikeExterior'),
+#             'C.Music': ('musicType',),
+#             'C.Name': ('full',),
+#             'C.Owner': ('owner','rank','globalVariable','IsPublicPlace'),
+#             'C.Water': ('water','waterHeight','IsHasWater'),
+#             'C.Light': ('ambientRed','ambientGreen','ambientBlue',
+#                         'directionalRed','directionalGreen','directionalBlue',
+#                         'fogRed','fogGreen','fogBlue',
+#                         'fogNear','fogFar','directionalXY','directionalZ',
+#                         'directionalFade','fogClip'),
+#             'C.RecordFlags': ('flags1',), # Yes seems funky but thats the way it is
+#             }
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CELLS']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         if record.GName in self.patchFile.scanSet: ##Does nothing until I can fix the error in CBash.dll
+#             for bashKey in bashTags & self.autoKey:
+#                 self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.tag_attrs[bashKey],True))
+#         else:
+#             for bashKey in bashTags & self.autoKey:
+#                 self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.tag_attrs[bashKey]))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         recordId = record.fid
+
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         prev_attr_value = self.fid_attr_value.get(recordId,None)
+#         if prev_attr_value:
+#             cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
+#             if cur_attr_value != prev_attr_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_attr_value.iteritems():
+#                         setattr(override,attr,value)
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Cells/Worlds Patched: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
 #------------------------------------------------------------------------------
 class GraphicsPatcher(ImportPatcher):
@@ -20009,17 +22053,24 @@ class GraphicsPatcher(ImportPatcher):
         recFidAttrs_class = self.recFidAttrs_class = {}
         for recClass in (MreBsgn,MreLscr, MreClas, MreLtex, MreRegn):
             recAttrs_class[recClass] = ('iconPath',)
-        for recClass in (MreActi, MreDoor, MreFlor, MreFurn, MreGras, MreStat):
+        for recClass in (MreActi, MreDoor, MreFlor, MreFurn, MreGras, MreStat, MreMstt, MreBptd, MreTerm, MrePwat, MreHdpt, MreTact):
             recAttrs_class[recClass] = ('model',)
-        for recClass in (MreAlch, MreAmmo, MreAppa, MreBook, MreIngr, MreKeym, MreLigh, MreMisc, MreSgst, MreSlgm, MreWeap, MreTree):
+        for recClass in (MreLigh,):
             recAttrs_class[recClass] = ('iconPath','model')
-        for recClass in (MreArmo, MreClot):
-            recAttrs_class[recClass] = ('maleBody','maleWorld','maleIconPath','femaleBody','femaleWorld','femaleIconPath','flags')
+        for recClass in (MreMicn,):
+            recAttrs_class[recClass] = ('largeIconPath','smallIconPath')
+        for recClass in (MreAlch, MreAmmo, MreAppa, MreBook, MreIngr, MreKeym, MreMisc, MreSgst, MreSlgm, MreTree):
+            recAttrs_class[recClass] = ('largeIconPath','smallIconPath','model')
+        for recClass in (MreNote,):
+            recAttrs_class[recClass] = ('largeIconPath','smallIconPath','model','texture')
+        for recClass in (MreWeap,):
+            recAttrs_class[recClass] = ('largeIconPath','smallIconPath','model','shellCasingModel','scopeModel','worldModel','firstPersonModel','animationType','gripAnimation','reloadAnimation')
+        for recClass in (MreArmo, MreArma, MreClot):
+            recAttrs_class[recClass] = ('maleBody','maleWorld','maleLargeIconPath','maleSmallIconPath','femaleBody','femaleWorld','femaleLargeIconPath','femaleSmallIconPath','flags')
         for recClass in (MreCrea,):
-            recAttrs_class[recClass] = ('bodyParts','nift_p')
+            recAttrs_class[recClass] = ('model','bodyParts','nift_p','bodyPartData','impactDataset')
         for recClass in (MreMgef,):
-            recAttrs_class[recClass] = ('iconPath','model')
-            recFidAttrs_class[recClass] = ('effectShader','enchantEffect','light')
+            recAttrs_class[recClass] = ('iconPath','model','effectShader','objectDisplayShader','light')
         for recClass in (MreEfsh,):
             recAttrs_class[recClass] = ('particleTexture','fillTexture','flags','unused1','memSBlend',
                                         'memBlendOp','memZFunc','fillRed','fillGreen','fillBlue','unused2',
@@ -20034,8 +22085,18 @@ class GraphicsPatcher(ImportPatcher):
                                         'partKey2Time','key1Red','key1Green','key1Blue','unused4','key2Red',
                                         'key2Green','key2Blue','unused5','key3Red','key3Green','key3Blue',
                                         'unused6','key1A','key2A','key3A','key1Time','key2Time','key3Time')
+        for recClass in (MreExpl,):
+            recAttrs_class[recClass] = ('imageSpaceModifier','light','impactDataset','placedImpactObject')
+        for recClass in (MreTxst,):
+            recAttrs_class[recClass] = ('baseImage','normalMap','environmentMapMask','growMap','parallaxMap','environmentMap','minWidth','maxWidth','minHeight','maxHeight','depth','shininess','parallaxScale','parallaxPasses','decalFlags','red','green','blue','flags')
+        for recClass in (MreIpct,):
+            recAttrs_class[recClass] = ('model','effectDuration','effectOrientation','angleThreshold','placementRadius','flags','minWidth','maxWidth','minHeight','maxHeight','depth','shininess','parallaxScale','parallaxPasses','decalFlags','red','green','blue','textureSet')
+        for recClass in (MreIpds,):
+            recAttrs_class[recClass] = ('stone','dirt','grass','metal','wood','organic','cloth','water','hollowMetal','organicBug','organicGlow')
+        for recClass in (MreProj,):
+            recAttrs_class[recClass] = ('model','light','muzzleFlash','explosion','muzzleFlashDuration','fadeDuration','muzzleFlashPath')
         #--Needs Longs
-        self.longTypes = set(('BSGN','LSCR','CLAS','LTEX','REGN','ACTI','DOOR','FLOR','FURN','GRAS','STAT','ALCH','AMMO','APPA','BOOK','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP','TREE','ARMO','CLOT','CREA','MGEF','EFSH'))
+        self.longTypes = set(('BSGN','LSCR','CLAS','LTEX','REGN','ACTI','DOOR','FLOR','FURN','GRAS','STAT','ALCH','AMMO','BOOK','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP','TREE','ARMO','ARMA','CLOT','CREA','MGEF','EFSH','TXST','EXPL','IPCT','IPDS','PROJ','NOTE','TACT','HDPT'))
 
     def initData(self,progress):
         """Get graphics from source files."""
@@ -20145,7 +22206,7 @@ class GraphicsPatcher(ImportPatcher):
                         if record.__getattribute__(attr).lower() != value.lower():
                             break
                         continue
-                    elif attr == 'model':
+                    elif attr in ('model','shellCasingModel','scopeModel','worldModel'):
                         try:
                             if record.__getattribute__(attr).modPath.lower() != value.modPath.lower():
                                 break
@@ -20169,137 +22230,137 @@ class GraphicsPatcher(ImportPatcher):
         for type,count in sorted(type_count.iteritems()):
             if count: log("* %s: %d" % (type,count))
 
-class CBash_GraphicsPatcher(CBash_ImportPatcher):
-    """Merges changes to graphics (models and icons)."""
-    name = _('Import Graphics')
-    text = _("Import graphics (models, icons, etc.) from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Graphics',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_attr_value = {}
-        self.class_mod_count = {}
-        class_attrs = self.class_attrs = {}
-        class_fidattrs = self.class_fidattrs = {}
-        model = ('modPath','modb','modt_p')
-        icon = ('iconPath',)
-        class_attrs['BSGN'] = icon
-        class_attrs['LSCR'] = icon
-        class_attrs['CLAS'] = icon
-        class_attrs['LTEX'] = icon
-        class_attrs['REGN'] = icon
-        class_attrs['ACTI'] = model
-        class_attrs['DOOR'] = model
-        class_attrs['FLOR'] = model
-        class_attrs['FURN'] = model
-        class_attrs['GRAS'] = model
-        class_attrs['STAT'] = model
-        class_attrs['ALCH'] = icon + model
-        class_attrs['AMMO'] = icon + model
-        class_attrs['APPA'] = icon + model
-        class_attrs['BOOK'] = icon + model
-        class_attrs['INGR'] = icon + model
-        class_attrs['KEYM'] = icon + model
-        class_attrs['LIGH'] = icon + model
-        class_attrs['MISC'] = icon + model
-        class_attrs['SGST'] = icon + model
-        class_attrs['SLGM'] = icon + model
-        class_attrs['WEAP'] = icon + model
-        class_attrs['TREE'] = icon + model
-
-        class_attrs['ARMO'] = ('maleBody_list',
-                               'maleWorld_list',
-                               'maleIconPath',
-                               'femaleBody_list',
-                               'femaleWorld_list',
-                               'femaleIconPath', 'flags')
-        class_attrs['CLOT'] = class_attrs['ARMO']
-
-        class_attrs['CREA'] = ('bodyParts', 'nift_p')
-        class_attrs['MGEF'] = icon + model
-        class_fidattrs['MGEF'] = ('effectShader','enchantEffect','light')
-        class_attrs['EFSH'] = ('fillTexturePath','particleTexturePath','flags','memSBlend','memBlendOp',
-                               'memZFunc','fillRed','fillGreen','fillBlue','fillAIn','fillAFull',
-                               'fillAOut','fillAPRatio','fillAAmp','fillAFreq','fillAnimSpdU',
-                               'fillAnimSpdV','edgeOff','edgeRed','edgeGreen','edgeBlue','edgeAIn',
-                               'edgeAFull','edgeAOut','edgeAPRatio','edgeAAmp','edgeAFreq',
-                               'fillAFRatio','edgeAFRatio','memDBlend','partSBlend','partBlendOp',
-                               'partZFunc','partDBlend','partBUp','partBFull','partBDown',
-                               'partBFRatio','partBPRatio','partLTime','partLDelta','partNSpd',
-                               'partNAcc','partVel1','partVel2','partVel3','partAcc1','partAcc2',
-                               'partAcc3','partKey1','partKey2','partKey1Time','partKey2Time',
-                               'key1Red','key1Green','key1Blue','key2Red','key2Green','key2Blue',
-                               'key3Red','key3Green','key3Blue','key1A','key2A','key3A',
-                               'key1Time','key2Time','key3Time')
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['BSGN','LSCR','CLAS','LTEX','REGN','ACTI','DOOR','FLOR',
-                'FURN','GRAS','STAT','ALCH','AMMO','APPA','BOOK','INGR',
-                'KEYM','LIGH','MISC','SGST','SLGM','WEAP','TREE','ARMO',
-                'CLOT','CREA','MGEF','EFSH']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        _Type = record._Type
-        if _Type in self.class_fidattrs:
-            attr_fidvalue = record.ConflictDetails(self.class_fidattrs[_Type], False)
-            for fidvalue in attr_fidvalue.values():
-                if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
-                    #Ignore the record. Another option would be to just ignore the attr_fidvalue result
-                    mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
-                    mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
-                    return
-            self.fid_attr_value.setdefault(record.fid,{}).update(attr_fidvalue)
-        self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[_Type], False))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        prev_attr_value = self.fid_attr_value.get(record.fid,None)
-        if prev_attr_value:
-            cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
-            if cur_attr_value != prev_attr_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_attr_value.iteritems():
-                        setattr(override,attr,value)
-                    class_mod_count = self.class_mod_count
-                    class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
+# class CBash_GraphicsPatcher(CBash_ImportPatcher):
+#     """Merges changes to graphics (models and icons)."""
+#     name = _('Import Graphics')
+#     text = _("Import graphics (models, icons, etc.) from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Graphics',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_attr_value = {}
+#         self.class_mod_count = {}
+#         class_attrs = self.class_attrs = {}
+#         class_fidattrs = self.class_fidattrs = {}
+#         model = ('modPath','modb','modt_p')
+#         icon = ('iconPath',)
+#         class_attrs['BSGN'] = icon
+#         class_attrs['LSCR'] = icon
+#         class_attrs['CLAS'] = icon
+#         class_attrs['LTEX'] = icon
+#         class_attrs['REGN'] = icon
+#         class_attrs['ACTI'] = model
+#         class_attrs['DOOR'] = model
+#         class_attrs['FLOR'] = model
+#         class_attrs['FURN'] = model
+#         class_attrs['GRAS'] = model
+#         class_attrs['STAT'] = model
+#         class_attrs['ALCH'] = icon + model
+#         class_attrs['AMMO'] = icon + model
+#         class_attrs['APPA'] = icon + model
+#         class_attrs['BOOK'] = icon + model
+#         class_attrs['INGR'] = icon + model
+#         class_attrs['KEYM'] = icon + model
+#         class_attrs['LIGH'] = icon + model
+#         class_attrs['MISC'] = icon + model
+#         class_attrs['SGST'] = icon + model
+#         class_attrs['SLGM'] = icon + model
+#         class_attrs['WEAP'] = icon + model
+#         class_attrs['TREE'] = icon + model
+
+#         class_attrs['ARMO'] = ('maleBody_list',
+#                                'maleWorld_list',
+#                                'maleIconPath',
+#                                'femaleBody_list',
+#                                'femaleWorld_list',
+#                                'femaleIconPath', 'flags')
+#         class_attrs['CLOT'] = class_attrs['ARMO']
+
+#         class_attrs['CREA'] = ('bodyParts', 'nift_p')
+#         class_attrs['MGEF'] = icon + model
+#         class_fidattrs['MGEF'] = ('effectShader','enchantEffect','light')
+#         class_attrs['EFSH'] = ('fillTexturePath','particleTexturePath','flags','memSBlend','memBlendOp',
+#                                'memZFunc','fillRed','fillGreen','fillBlue','fillAIn','fillAFull',
+#                                'fillAOut','fillAPRatio','fillAAmp','fillAFreq','fillAnimSpdU',
+#                                'fillAnimSpdV','edgeOff','edgeRed','edgeGreen','edgeBlue','edgeAIn',
+#                                'edgeAFull','edgeAOut','edgeAPRatio','edgeAAmp','edgeAFreq',
+#                                'fillAFRatio','edgeAFRatio','memDBlend','partSBlend','partBlendOp',
+#                                'partZFunc','partDBlend','partBUp','partBFull','partBDown',
+#                                'partBFRatio','partBPRatio','partLTime','partLDelta','partNSpd',
+#                                'partNAcc','partVel1','partVel2','partVel3','partAcc1','partAcc2',
+#                                'partAcc3','partKey1','partKey2','partKey1Time','partKey2Time',
+#                                'key1Red','key1Green','key1Blue','key2Red','key2Green','key2Blue',
+#                                'key3Red','key3Green','key3Blue','key1A','key2A','key3A',
+#                                'key1Time','key2Time','key3Time')
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['BSGN','LSCR','CLAS','LTEX','REGN','ACTI','DOOR','FLOR',
+#                 'FURN','GRAS','STAT','ALCH','AMMO','APPA','BOOK','INGR',
+#                 'KEYM','LIGH','MISC','SGST','SLGM','WEAP','TREE','ARMO',
+#                 'CLOT','CREA','MGEF','EFSH']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         _Type = record._Type
+#         if _Type in self.class_fidattrs:
+#             attr_fidvalue = record.ConflictDetails(self.class_fidattrs[_Type], False)
+#             for fidvalue in attr_fidvalue.values():
+#                 if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
+#                     #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+#                     mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+#                     mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
+#                     return
+#             self.fid_attr_value.setdefault(record.fid,{}).update(attr_fidvalue)
+#         self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[_Type], False))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         prev_attr_value = self.fid_attr_value.get(record.fid,None)
+#         if prev_attr_value:
+#             cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
+#             if cur_attr_value != prev_attr_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_attr_value.iteritems():
+#                         setattr(override,attr,value)
+#                     class_mod_count = self.class_mod_count
+#                     class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_("\n=== Modified Records"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
 #------------------------------------------------------------------------------
 class ActorImporter(ImportPatcher):
@@ -20324,13 +22385,14 @@ class ActorImporter(ImportPatcher):
         self.actorClasses = (MreNpc,MreCrea)
         for recClass in (MreNpc,):
             self.recAttrs_class[recClass] = {
-                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
-                'Actors.Stats': ('skills','health','attributes'),
-                'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','flags.autoCalc','flags.pcLevelOffset'),
-                                'barterGold','flags.female','flags.essential','flags.respawn','flags.noLowLevel',
-                                'flags.noRumors','flags.summonable','flags.noPersuasion','flags.canCorpseCheck',
+                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','mood','services','trainSkill','trainLevel','assistance','aggroRadiusBehavior','aggroRadius'),
+                'Actors.Stats': ('health','attributes','skillValues','skillOffsets'),
+                'Actors.ACBS': (('fatigue','level','calcMin','calcMax','flags.autoCalc','flags.pcLevelOffset'),
+                                'barterGold','speedMultiplier','karma','dispotionBase','templateFlags',
+                                'flags.female','flags.essential','flags.isChargenFacePreset','flags.respawn','flags.useTemplate','flags.noLowLevel',
+                                'flags.noBloodSpray','flags.noBloodDecal','flags.noVATSMelee','flags.canBeAllRaces','flags.noKnockDown','flags.notPushable','flags.noRotatingHeadTrack',
                                 ),
-                #'Actors.ACBS': ('baseSpell','fatigue','barterGold','level','calcMin','calcMax','flags'),
+                #'Actors.ACBS': ('fatigue','barterGold','level','calcMin','calcMax','speedMultiplier','karma','dispotionBase','templateFlags','flags'),
                 'NPC.Class': ('iclass',),
                 'NPC.Race': ('race',),
                 'Actors.CombatStyle': ('combatStyle',),
@@ -20339,19 +22401,23 @@ class ActorImporter(ImportPatcher):
                 }
         for recClass in (MreCrea,):
             self.recAttrs_class[recClass] = {
-                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
-                'Actors.Stats': ('combat','magic','stealth','soul','health','attackDamage','strength','intelligence','willpower','agility','speed','endurance','personality','luck'),
-                'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','flags.pcLevelOffset',),
-                                'barterGold','flags.biped','flags.essential','flags.weaponAndShield',
-                                'flags.respawn','flags.swims','flags.flies','flags.walks','flags.noLowLevel',
-                                'flags.noBloodSpray','flags.noBloodDecal','flags.noHead','flags.noRightArm',
-                                'flags.noLeftArm','flags.noCombatInWater','flags.noShadow','flags.noCorpseCheck',
+                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','mood','services','trainSkill','trainLevel','assistance','aggroRadiusBehavior','aggroRadius'),
+                'Actors.Stats': ('type','combatSkill','magicSkill','StealthSkill','health','damage','strength','perception','endurance','charisma','intelligence','agility','luck'),
+                'Actors.ACBS': (('fatigue','level','calcMin','calcMax','flags.pcLevelOffset'),
+                                'barterGold','speedMultiplier','karma','dispotionBase','templateFlags',
+                                'flags.biped','flags.essential','flags.weaponAndShield','flags.respawn',
+                                'flags.swims','flags.flies','flags.walks','flags.noLowLevel','flags.noBloodSpray',
+                                'flags.noBloodDecal','flags.noHead','flags.noRightArm','flags.noLeftArm',
+                                'flags.noCombatInWater','flags.noShadow','flags.noVATSMelee','flags.allowPCDialogue',
+                                'flags.cantOpenDoors','flags.immobile','flags.tiltFrontBack','flags.tiltLeftRight',
+                                'flags.noKnockDown','flags.notPushable','flags.allowPickpocket','flags.isGhost',
+                                'flags.noRotatingHeadTrack','flags.invulnerable',
                                 ),
-                #'Actors.ACBS': ('baseSpell','fatigue','barterGold','level','calcMin','calcMax','flags'),
+                #'Actors.ACBS': ('fatigue','barterGold','level','calcMin','calcMax','speedMultiplier','karma','dispotionBase','templateFlags','flags'),
                 'NPC.Class': (),
                 'NPC.Race': (),
                 'Actors.CombatStyle': ('combatStyle',),
-                'Creatures.Blood': ('bloodSprayPath','bloodDecalPath'),
+                'Creatures.Blood': ('impactDataset',),
                 'Actors.Skeleton': ('model',),
                 }
         #--Needs Longs
@@ -20481,110 +22547,110 @@ class ActorImporter(ImportPatcher):
         for type,count in sorted(type_count.iteritems()):
             if count: log("* %s: %d" % (type,count))
 
-class CBash_ActorImporter(CBash_ImportPatcher):
-    """Merges changes to actors."""
-    name = _('Import Actors')
-    text = _("Import Actor components from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Actors.AIData', 'Actors.Stats', 'Actors.ACBS', 'NPC.Class', 'Actors.CombatStyle', 'Creatures.Blood', 'NPC.Race','Actors.Skeleton'))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_attr_value = {}
-        self.class_mod_count = {}
-        class_tag_attrs = self.class_tag_attrs = {}
-        class_tag_attrs['NPC_'] = {
-                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
-                'Actors.Stats': ('armorer','athletics','blade','block','blunt','h2h','heavyArmor','alchemy',
-                                 'alteration','conjuration','destruction','illusion','mysticism','restoration',
-                                 'acrobatics','lightArmor','marksman','mercantile','security','sneak','speechcraft',
-                                 'health',
-                                 'strength','intelligence','willpower','agility','speed','endurance','personality','luck',),
-                'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','IsPCLevelOffset','IsAutoCalc',),
-                                'barterGold','IsFemale','IsEssential','IsRespawn','IsNoLowLevel','IsNoRumors',
-                                'IsSummonable','IsNoPersuasion','IsCanCorpseCheck',
-                                ),
-                'NPC.Class': ('iclass',),
-                'NPC.Race': ('race',),
-                'Actors.CombatStyle': ('combatStyle',),
-                'Creatures.Blood': (),
-                'Actors.Skeleton': ('modPath','modb','modt_p'),
-                }
-        class_tag_attrs['CREA'] = {
-                'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
-                'Actors.Stats': ('combat','magic','stealth','soulType','health','attackDamage','strength','intelligence','willpower',
-                                 'agility','speed','endurance','personality','luck'),
-                'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','IsPCLevelOffset',),
-                                'barterGold','IsBiped','IsEssential','IsWeaponAndShield','IsRespawn',
-                                'IsSwims','IsFlies','IsWalks','IsNoLowLevel','IsNoBloodSpray','IsNoBloodDecal',
-                                'IsNoHead','IsNoRightArm','IsNoLeftArm','IsNoCombatInWater','IsNoShadow',
-                                'IsNoCorpseCheck',
-                                ),
-                'NPC.Class': (),
-                'NPC.Race': (),
-                'Actors.CombatStyle': ('combatStyle',),
-                'Creatures.Blood': ('bloodSprayPath','bloodDecalPath'),
-                'Actors.Skeleton': ('modPath','modb','modt_p',),
-                }
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        if modFile.GName == record.fid[0]: return
-        for bashKey in bashTags & self.autoKey:
-            attrs = self.class_tag_attrs[record._Type].get(bashKey, None)
-            if attrs:
-                self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(attrs))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        recordId = record.fid
-        prev_attr_value = self.fid_attr_value.get(recordId,None)
-        if prev_attr_value:
-            cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
-            if cur_attr_value != prev_attr_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_attr_value.iteritems():
-                        setattr(override,attr,value)
-                    class_mod_count = self.class_mod_count
-                    class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
+# class CBash_ActorImporter(CBash_ImportPatcher):
+#     """Merges changes to actors."""
+#     name = _('Import Actors')
+#     text = _("Import Actor components from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Actors.AIData', 'Actors.Stats', 'Actors.ACBS', 'NPC.Class', 'Actors.CombatStyle', 'Creatures.Blood', 'NPC.Race','Actors.Skeleton'))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_attr_value = {}
+#         self.class_mod_count = {}
+#         class_tag_attrs = self.class_tag_attrs = {}
+#         class_tag_attrs['NPC_'] = {
+#                 'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
+#                 'Actors.Stats': ('armorer','athletics','blade','block','blunt','h2h','heavyArmor','alchemy',
+#                                  'alteration','conjuration','destruction','illusion','mysticism','restoration',
+#                                  'acrobatics','lightArmor','marksman','mercantile','security','sneak','speechcraft',
+#                                  'health',
+#                                  'strength','intelligence','willpower','agility','speed','endurance','personality','luck',),
+#                 'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','IsPCLevelOffset','IsAutoCalc',),
+#                                 'barterGold','IsFemale','IsEssential','IsRespawn','IsNoLowLevel','IsNoRumors',
+#                                 'IsSummonable','IsNoPersuasion','IsCanCorpseCheck',
+#                                 ),
+#                 'NPC.Class': ('iclass',),
+#                 'NPC.Race': ('race',),
+#                 'Actors.CombatStyle': ('combatStyle',),
+#                 'Creatures.Blood': (),
+#                 'Actors.Skeleton': ('modPath','modb','modt_p'),
+#                 }
+#         class_tag_attrs['CREA'] = {
+#                 'Actors.AIData': ('aggression','confidence','energyLevel','responsibility','services','trainSkill','trainLevel'),
+#                 'Actors.Stats': ('combat','magic','stealth','soulType','health','attackDamage','strength','intelligence','willpower',
+#                                  'agility','speed','endurance','personality','luck'),
+#                 'Actors.ACBS': (('baseSpell','fatigue','level','calcMin','calcMax','IsPCLevelOffset',),
+#                                 'barterGold','IsBiped','IsEssential','IsWeaponAndShield','IsRespawn',
+#                                 'IsSwims','IsFlies','IsWalks','IsNoLowLevel','IsNoBloodSpray','IsNoBloodDecal',
+#                                 'IsNoHead','IsNoRightArm','IsNoLeftArm','IsNoCombatInWater','IsNoShadow',
+#                                 'IsNoCorpseCheck',
+#                                 ),
+#                 'NPC.Class': (),
+#                 'NPC.Race': (),
+#                 'Actors.CombatStyle': ('combatStyle',),
+#                 'Creatures.Blood': ('bloodSprayPath','bloodDecalPath'),
+#                 'Actors.Skeleton': ('modPath','modb','modt_p',),
+#                 }
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         if modFile.GName == record.fid[0]: return
+#         for bashKey in bashTags & self.autoKey:
+#             attrs = self.class_tag_attrs[record._Type].get(bashKey, None)
+#             if attrs:
+#                 self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(attrs))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         prev_attr_value = self.fid_attr_value.get(recordId,None)
+#         if prev_attr_value:
+#             cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
+#             if cur_attr_value != prev_attr_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_attr_value.iteritems():
+#                         setattr(override,attr,value)
+#                     class_mod_count = self.class_mod_count
+#                     class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_("\n=== Modified Records"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
 #------------------------------------------------------------------------------
 class KFFZPatcher(ImportPatcher):
@@ -20646,12548 +22712,11736 @@ class KFFZPatcher(ImportPatcher):
                     masterFile.load(True)
                     masterFile.convertToLongFids(longTypes)
                     cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for recClass,recAttrs in recAttrs_class.iteritems():
-                    if recClass.classType not in masterFile.tops: continue
-                    if recClass not in self.classestemp: continue
-                    for record in masterFile.tops[recClass.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if fid not in temp_id_data: continue
-                        for attr, value in temp_id_data[fid].iteritems():
-                            if value == record.__getattribute__(attr): continue
-                            else:
-                                if fid not in id_data: id_data[fid] = dict()
-                                try:
-                                    id_data[fid][attr] = temp_id_data[fid][attr]
-                                except KeyError:
-                                    id_data[fid].setdefault(attr,value)
-            progress.plus()
-        temp_id_data = None
-        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
-        self.isActive = bool(self.srcClasses)
-
-    def scanModFile(self, modFile, progress):
-        """Scan mod file against source data."""
-        if not self.isActive: return
-        id_data = self.id_data
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if self.longTypes:
-            modFile.convertToLongFids(self.longTypes)
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-                        break
-
-    def buildPatch(self,log,progress):
-        """Merge last version of record with patched graphics data as needed."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_data = self.id_data
-        type_count = {}
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        break
-                else:
-                    continue
-                for attr,value in id_data[fid].iteritems():
-                    record.__setattr__(attr,value)
-                keep(fid)
-                type_count[type] += 1
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-
-class CBash_KFFZPatcher(CBash_ImportPatcher):
-    """Merges changes to actor animations."""
-    name = _('Import Actors: Animations')
-    text = _("Import Actor animations from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Actors.Anims',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_animations = {}
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        animations = self.id_animations.setdefault(record.fid,[])
-        animations.extend([anim for anim in record.animations if anim not in animations])
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        if(recordId in self.id_animations and record.animations != self.id_animations[recordId]):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.animations = self.id_animations[recordId]
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Imported Animations: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class NPCAIPackagePatcher(ImportPatcher):
-    """Merges changes to the AI Packages of Actors."""
-    name = _('Import Actors: AIPackages')
-    text = _("Import Actor AIPackage links from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = ('Actors.AIPackages','Actors.AIPackagesForceAdd')
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcMods = self.getConfigChecked()
-        self.isActive = len(self.srcMods) != 0
-        self.data = {}
-        self.longTypes = set(('CREA','NPC_'))
-
-    def initData(self,progress):
-        """Get data from source files."""
-        if not self.isActive: return
-        OOOandUOP = False
-        # Removed OOO compatability check, as newest OOO will have the packages removed in
-        # favor of the UOP ones anyway.
-        ##if GPath("Oscuro's_Oblivion_Overhaul.esm") in self.srcMods or GPath("Oscuro's_Oblivion_Overhaul.esp") in self.srcMods:
-        ##    if GPath("Unofficial Oblivion Patch.esp") in self.srcMods:
-        ##        OOOandUOP = True
-        longTypes = self.longTypes
-        loadFactory = LoadFactory(False,MreCrea,MreNpc)
-        progress.setFull(len(self.srcMods))
-        cachedMasters = {}
-        data = self.data
-        for index,srcMod in enumerate(self.srcMods):
-            tempData = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            bashTags = srcInfo.getBashTags()
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass in (MreNpc,MreCrea):
-                if recClass.classType not in srcFile.tops: continue
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    tempData[fid] = list(record.aiPackages)
-            for master in reversed(masters):
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for block in (MreNpc, MreCrea):
-                    if block.classType not in srcFile.tops: continue
-                    if block.classType not in masterFile.tops: continue
-                    for record in masterFile.tops[block.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if not fid in tempData: continue
-                        if record.aiPackages == tempData[fid] and not 'Actors.AIPackagesForceAdd' in bashTags:
-                            # if subrecord is identical to the last master then we don't care about older masters.
-                            del tempData[fid]
-                            continue
-                        if fid in data:
-                            if tempData[fid] == data[fid]['merged']: continue
-                        recordData = {'deleted':[],'merged':tempData[fid]}
-                        for pkg in list(record.aiPackages):
-                            if not pkg in tempData[fid]:
-                                recordData['deleted'].append(pkg)
-                        if not fid in data:
-                            data[fid] = recordData
-                        else:
-                            for pkg in recordData['deleted']:
-                                if pkg in data[fid]['merged']:
-                                    data[fid]['merged'].remove(pkg)
-                                data[fid]['deleted'].append(pkg)
-                            if data[fid]['merged'] == []:
-                                for pkg in recordData['merged']:
-                                    if pkg in data[fid]['deleted'] and not 'Actors.AIPackagesForceAdd' in bashTags: continue
-                                    data[fid]['merged'].append(pkg)
-                                continue
-                            for index, pkg in enumerate(recordData['merged']):
-                                if not pkg in data[fid]['merged']: # so needs to be added... (unless deleted that is)
-                                    # find the correct position to add and add.
-                                    if pkg in data[fid]['deleted'] and not 'Actors.AIPackagesForceAdd' in bashTags: continue #previously deleted
-                                    if index == 0:
-                                        data[fid]['merged'].insert(0,pkg) #insert as first item
-                                    elif index == (len(recordData['merged'])-1):
-                                        data[fid]['merged'].append(pkg) #insert as last item
-                                    else: #figure out a good spot to insert it based on next or last recognized item (ugly ugly ugly)
-                                        i = index - 1
-                                        while i >= 0:
-                                            if recordData['merged'][i] in data[fid]['merged']:
-                                                slot = data[fid]['merged'].index(recordData['merged'][i])+1
-                                                data[fid]['merged'].insert(slot, pkg)
-                                                break
-                                            i -= 1
-                                        else:
-                                            i = index + 1
-                                            while i != len(recordData['merged']):
-                                                if recordData['merged'][i] in data[fid]['merged']:
-                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
-                                                    data[fid]['merged'].insert(slot, pkg)
-                                                    break
-                                                i += 1
-                                    continue # Done with this package
-                                elif index == data[fid]['merged'].index(pkg) or (len(recordData['merged'])-index) == (len(data[fid]['merged'])-data[fid]['merged'].index(pkg)): continue #pkg same in both lists.
-                                else: #this import is later loading so we'll assume it is better order
-                                    data[fid]['merged'].remove(pkg)
-                                    if index == 0:
-                                        data[fid]['merged'].insert(0,pkg) #insert as first item
-                                    elif index == (len(recordData['merged'])-1):
-                                        data[fid]['merged'].append(pkg) #insert as last item
-                                    else:
-                                        i = index - 1
-                                        while i >= 0:
-                                            if recordData['merged'][i] in data[fid]['merged']:
-                                                slot = data[fid]['merged'].index(recordData['merged'][i]) + 1
-                                                data[fid]['merged'].insert(slot, pkg)
-                                                break
-                                            i -= 1
-                                        else:
-                                            i = index + 1
-                                            while i != len(recordData['merged']):
-                                                if recordData['merged'][i] in data[fid]['merged']:
-                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
-                                                    data[fid]['merged'].insert(slot, pkg)
-                                                    break
-                                                i += 1
-                        ##if OOOandUOP:
-                        ##    for pkg in recordData['merged']:
-                        ##        if pkg[0] == bolt.Path("Oscuro's_Oblivion_Overhaul.esm"):
-                        ##            if pkg[1] in [12892,12893,12894,12895,23921,23922,23926,40669,40671]:
-                        ##                if pkg in data[fid]['merged']:
-                        ##                    data[fid]['merged'].remove(pkg)
-            progress.plus()
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreNpc,MreCrea))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreNpc,MreCrea))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Add record from modFile."""
-        if not self.isActive: return
-        data = self.data
-        mapper = modFile.getLongMapper()
-        modName = modFile.fileInfo.name
-        for type in ('NPC_','CREA'):
-            patchBlock = getattr(self.patchFile,type)
-            for record in getattr(modFile,type).getActiveRecords():
-                fid = mapper(record.fid)
-                if fid in data:
-                    if list(record.aiPackages) != data[fid]['merged']:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Applies delta to patchfile."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        data = self.data
-        mod_count = {}
-        for type in ('NPC_','CREA'):
-            for record in getattr(self.patchFile,type).records:
-                fid = record.fid
-                if not fid in data: continue
-                changed = False
-                if record.aiPackages != data[fid]['merged']:
-                    record.aiPackages = data[fid]['merged']
-                    changed = True
-                if changed:
-                    keep(record.fid)
-                    mod = record.fid[0]
-                    mod_count[mod] = mod_count.get(mod,0) + 1
-        #--Log
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcMods:
-            log("* " +mod.s)
-        log(_("\n=== AI Package Lists Changed: %d") % (sum(mod_count.values()),))
-        for mod in modInfos.getOrdered(mod_count):
-            log('* %s: %3d' % (mod.s,mod_count[mod]))
-
-class CBash_NPCAIPackagePatcher(CBash_ImportPatcher):
-    """Merges changes to the AI Packages of Actors."""
-    name = _('Import Actors: AIPackages')
-    text = _("Import Actor AIPackage links from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Actors.AIPackages','Actors.AIPackagesForceAdd'))
-    scanRequiresChecked = False
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.previousPackages = {}
-        self.mergedPackageList = {}
-        self.mod_count = {}
-        # Removed OOO compatability check, as newest OOO will have the packages removed in
-        # favor of the UOP ones anyway.
-        ##if ("Oscuro's_Oblivion_Overhaul.esm" in self.srcs or "Oscuro's_Oblivion_Overhaul.esp" in self.srcs
-        ##    and "Unofficial Oblivion Patch.esp" in self.srcs):
-        ##    self.OOOandUOP = True
-        ##else:
-        ##    self.OOOandUOP = False
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        recordId = record.fid
-        newPackages = bolt.MemorySet(record.aiPackages)
-        if recordId not in self.previousPackages:
-            self.previousPackages[recordId] = {}
-        self.previousPackages[recordId][modFile.GName] = newPackages
-
-        if modFile.GName in self.srcs:
-            masterPackages = self.previousPackages[recordId].get(recordId[0],None)
-            if masterPackages and not masterPackages ^ newPackages: return
-            if recordId not in self.mergedPackageList:
-                self.mergedPackageList[recordId] = newPackages
-            mergedPackages = self.mergedPackageList[recordId]
-            if newPackages == mergedPackages: return #same as the current list, just skip.
-            for master in reversed(modFile.TES4.masters):
-                masterPath = GPath(master)
-                masterPackages = self.previousPackages[recordId].get(masterPath,None)
-                if masterPackages is None: continue
-
-                # Get differences from master
-                added = newPackages - masterPackages
-                sameButReordered = masterPackages & newPackages
-                prevDeleted = bolt.MemorySet(mergedPackages.discarded)
-                newDeleted = masterPackages - newPackages
-
-                # Merge those changes into mergedPackages
-                mergedPackages |= newPackages
-                if 'Actors.AIPackagesForceAdd' not in bashTags:
-                    prevDeleted -= newPackages
-                prevDeleted |= newDeleted
-                mergedPackages -= prevDeleted
-                self.mergedPackageList[recordId] = mergedPackages
-                break
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        if recordId in self.mergedPackageList:
-            mergedPackages = list(self.mergedPackageList[recordId])
-            ##if self.OOOandUOP:
-            ##    for pkg in mergedPackages:
-            ##        if pkg[0] == bolt.Path("Oscuro's_Oblivion_Overhaul.esm"):
-            ##            if pkg[1] in [12892,12893,12894,12895,23921,23922,23926,40669,40671]:
-            ##                mergedPackages.remove(pkg)
-            if(record.aiPackages != mergedPackages):
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    try:
-                        override.aiPackages = mergedPackages
-                    except:
-                        newMergedPackages = []
-                        for pkg in mergedPackages:
-                            if not pkg[0] == None: newMergedPackages.append(pkg)
-                        override.aiPackages = newMergedPackages
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* AI Package Lists Changed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class DeathItemPatcher(ImportPatcher):
-    """Merges changes to actor death items."""
-    name = _('Import Actors: Death Items')
-    text = _("Import Actor death items from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Actors.DeathItem'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_data = {} #--Names keyed by long fid.
-        self.srcClasses = set() #--Record classes actually provided by src mods/files.
-        self.sourceMods = self.getConfigChecked()
-        self.isActive = len(self.sourceMods) != 0
-        #--Type Fields
-        recAttrs_class = self.recAttrs_class = {}
-        for recClass in (MreCrea,MreNpc):
-            recAttrs_class[recClass] = ('deathItem',)
-        #--Needs Longs
-        self.longTypes = set(('CREA','NPC_'))
-
-    def initData(self,progress):
-        """Get actor death items from source files."""
-        if not self.isActive: return
-        self.classestemp = set()
-        id_data = self.id_data
-        recAttrs_class = self.recAttrs_class
-        loadFactory = LoadFactory(False,*recAttrs_class.keys())
-        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
-        progress.setFull(len(self.sourceMods))
-        cachedMasters = {}
-        for index,srcMod in enumerate(self.sourceMods):
-            temp_id_data = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass,recAttrs in recAttrs_class.iteritems():
-                if recClass.classType not in srcFile.tops: continue
-                self.srcClasses.add(recClass)
-                self.classestemp.add(recClass)
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
-            for master in masters:
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for recClass,recAttrs in recAttrs_class.iteritems():
-                    if recClass.classType not in masterFile.tops: continue
-                    if recClass not in self.classestemp: continue
-                    for record in masterFile.tops[recClass.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if fid not in temp_id_data: continue
-                        for attr, value in temp_id_data[fid].iteritems():
-                            if value == record.__getattribute__(attr): continue
-                            else:
-                                if fid not in id_data: id_data[fid] = dict()
-                                try:
-                                    id_data[fid][attr] = temp_id_data[fid][attr]
-                                except KeyError:
-                                    id_data[fid].setdefault(attr,value)
-            progress.plus()
-        temp_id_data = None
-        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
-        self.isActive = bool(self.srcClasses)
-
-    def scanModFile(self, modFile, progress):
-        """Scan mod file against source data."""
-        if not self.isActive: return
-        id_data = self.id_data
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if self.longTypes:
-            modFile.convertToLongFids(self.longTypes)
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-                        break
-
-    def buildPatch(self,log,progress):
-        """Merge last version of record with patched actor death item as needed."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_data = self.id_data
-        type_count = {}
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            #deprint(recClass,type,type_count[type])
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        break
-                else:
-                    continue
-                for attr,value in id_data[fid].iteritems():
-                    record.__setattr__(attr,value)
-                keep(fid)
-                type_count[type] += 1
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " + mod.s)
-        log(_("\n=== Modified Records"))
-        for type,count in sorted(type_count.items()):
-            if count: log("* %s: %d" % (type,count))
-class CBash_DeathItemPatcher(CBash_ImportPatcher):
-    """Imports actor death items."""
-    name = _('Import Actors: Death Items')
-    text = _("Import Actor death items from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Actors.DeathItem',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_deathItem = {}
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        deathitem = record.ConflictDetails(('deathItem',), False)
-        if deathitem:
-            self.id_deathItem[record.fid] = deathitem['deathItem']
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-                #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        recordId = record.fid
-        if(recordId in self.id_deathItem and record.deathItem != self.id_deathItem[recordId]):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.deathItem = self.id_deathItem[recordId]
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_('* Imported Death Items: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class ImportFactions(ImportPatcher):
-    """Import factions to creatures and NPCs."""
-    name = _('Import Factions')
-    text = _("Import factions from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoKey = 'Factions'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_factions= {} #--Factions keyed by long fid.
-        self.activeTypes = [] #--Types ('CREA','NPC_') of data actually provided by src mods/files.
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-
-    def initData(self,progress):
-        """Get names from source files."""
-        if not self.isActive: return
-        actorFactions = ActorFactions(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if reModExt.search(srcFile.s):
-                if srcPath not in modInfos: continue
-                srcInfo = modInfos[GPath(srcFile)]
-                actorFactions.readFromMod(srcInfo)
-            else:
-                if srcPath not in patchesDir: continue
-                actorFactions.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        id_factions= self.id_factions
-        for type,aFid_factions in actorFactions.type_id_factions.iteritems():
-            if type not in ('CREA','NPC_'): continue
-            self.activeTypes.append(type)
-            for longid,factions in aFid_factions.iteritems():
-                self.id_factions[longid] = factions
-        self.isActive = bool(self.activeTypes)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        return self.activeTypes
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        return [MreRecord.type_class[type] for type in self.activeTypes]
-
-    def scanModFile(self, modFile, progress):
-        """Scan modFile."""
-        if not self.isActive: return
-        id_factions= self.id_factions
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        for type in self.activeTypes:
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            id_records = patchBlock.id_records
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid in id_records: continue
-                if fid not in id_factions: continue
-                patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Make changes to patchfile."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_factions= self.id_factions
-        type_count = {}
-        for type in self.activeTypes:
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid in id_factions:
-                    newFactions = set(id_factions[fid])
-                    curFactions = set((x.faction,x.rank) for x in record.factions)
-                    changed = newFactions - curFactions
-                    if not changed: continue
-                    doKeep = False
-                    for faction,rank in changed:
-                        for entry in record.factions:
-                            if entry.faction == faction:
-                                if entry.rank != rank:
-                                    entry.rank = rank
-                                    doKeep = True
-                                    keep(fid)
-                                break
-                        else:
-                            entry = MelObject()
-                            entry.faction = faction
-                            entry.rank = rank
-                            entry.unused1 = 'ODB'
-                            record.factions.append(entry)
-                            doKeep = True
-                    if doKeep:
-                        record.factions = [x for x in record.factions if x.rank != -1]
-                        type_count[type] += 1
-                        keep(fid)
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Refactioned Actors"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-
-class CBash_ImportFactions(CBash_ImportPatcher):
-    """Import factions to creatures and NPCs."""
-    name = _('Import Factions')
-    text = _("Import factions from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoKey = set(('Factions',))
-    
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_factions = {}
-        self.csvId_factions = {}
-        self.class_mod_count = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        CBash_ImportPatcher.initData(self,type_patchers,progress)
-        actorFactions = CBash_ActorFactions(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            if not reModExt.search(srcFile.s):
-                if srcPath not in patchesDir: continue
-                actorFactions.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        csvId_factions = self.csvId_factions
-        for group,aFid_factions in actorFactions.group_fid_factions.iteritems():
-            if group not in ('CREA','NPC_'): continue
-            for fid,factions in aFid_factions.iteritems():
-                factions = [faction for faction in factions if faction[0][0] in self.patchFile.loadSet]
-                if factions:
-                    csvId_factions[fid] = factions
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        if modFile.GName == record.fid[0]: return
-        factions = record.ConflictDetails(('factions_list',))
-        if factions:
-            masterRecord = [x for x in self.patchFile.ObCollection.LookupRecords(record.fid)][-1]
-            masterFactions = masterRecord.factions_list
-            masterDict = dict((x[0],x[1]) for x in masterFactions)
-            if record.fid not in self.id_factions:
-                # Initialize the factions list with what's in the master record
-                self.id_factions[record.fid] = masterDict
-            # Only add/remove records if different than the master record
-            thisFactions = factions['factions_list']
-            masterFids = set([x[0] for x in masterFactions])
-            thisFids = set([x[0] for x in thisFactions])
-            removedFids = masterFids - thisFids
-            addedFids = thisFids - masterFids
-            # Add new factions
-            self.id_factions[record.fid].update(dict((x[0],x[1]) for x in thisFactions if x[0] in addedFids and x[0][0] in self.patchFile.loadSet))
-            # Remove deleted factions
-            for fid in removedFids:
-                self.id_factions[record.fid].pop(fid,None)
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        fid = record.fid
-        if(fid in self.csvId_factions):
-            newFactions = set(self.csvId_factions[fid])
-        elif(fid in self.id_factions):
-            newFactions = set([(faction,rank) for faction, rank in self.id_factions[fid].iteritems()])
-        else:
-            return
-        curFactions = set([(faction[0],faction[1]) for faction in record.factions_list])
-        changed = newFactions - curFactions
-        removed = curFactions - newFactions
-        if changed or removed:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.factions_list = self.id_factions[fid].items()
-                class_mod_count = self.class_mod_count
-                class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        for type in class_mod_count.keys():
-            log(_('* Refactioned %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-
-#------------------------------------------------------------------------------
-class ImportRelations(ImportPatcher):
-    """Import faction relations to factions."""
-    name = _('Import Relations')
-    text = _("Import relations from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoKey = 'Relations'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_relations= {} #--[(otherLongid0,disp0),(...)] = id_relations[mainLongid].
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-
-    def initData(self,progress):
-        """Get names from source files."""
-        if not self.isActive: return
-        factionRelations = FactionRelations(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if reModExt.search(srcFile.s):
-                if srcPath not in modInfos: continue
-                srcInfo = modInfos[GPath(srcFile)]
-                factionRelations.readFromMod(srcInfo)
-            else:
-                if srcPath not in patchesDir: continue
-                factionRelations.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        for fid, relations in factionRelations.id_relations.iteritems():
-            if fid and (fid[0] is not None and fid[0] in self.patchFile.loadSet):
-                filteredRelations = [relation for relation in relations if relation[0] and (relation[0][0] is not None and relation[0][0] in self.patchFile.loadSet)]
-                if filteredRelations:
-                    self.id_relations[fid] = filteredRelations
-
-        self.isActive = bool(self.id_relations)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreFact,))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreFact,))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Scan modFile."""
-        if not self.isActive: return
-        id_relations= self.id_relations
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        for type in ('FACT',):
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            id_records = patchBlock.id_records
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid in id_records: continue
-                if fid not in id_relations: continue
-                patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Make changes to patchfile."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_relations= self.id_relations
-        type_count = {}
-        for type in ('FACT',):
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid in id_relations:
-                    newRelations = set(id_relations[fid])
-                    curRelations = set((x.faction,x.mod) for x in record.relations)
-                    changed = newRelations - curRelations
-                    if not changed: continue
-                    doKeep = False
-                    for faction,disp in changed:
-                        for entry in record.relations:
-                            if entry.faction == faction:
-                                if entry.mod != disp:
-                                    entry.mod = disp
-                                    doKeep = True
-                                    keep(fid)
-                                break
-                        else:
-                            entry = MelObject()
-                            entry.faction = faction
-                            entry.mod = disp
-                            record.relations.append(entry)
-                            doKeep = True
-                    if doKeep:
-                        type_count[type] += 1
-                        keep(fid)
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Modified Factions: %d") % type_count['FACT'])
-
-class CBash_ImportRelations(CBash_ImportPatcher):
-    """Import faction relations to factions."""
-    name = _('Import Relations')
-    text = _("Import relations from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoKey = set(('Relations',))
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_faction_mod = {}
-        self.csvFid_faction_mod = {}
-        self.mod_count = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        CBash_ImportPatcher.initData(self,type_patchers,progress)
-        factionRelations = CBash_FactionRelations(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            if not reModExt.search(srcFile.s):
-                if srcPath not in patchesDir: continue
-                factionRelations.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        self.csvFid_faction_mod.update(factionRelations.fid_faction_mod)
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['FACT']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        relations = record.ConflictDetails(('relations_list',),False)
-        if relations:
-            self.fid_faction_mod.setdefault(record.fid,{}).update(relations['relations_list'])
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        fid = record.fid
-        if(fid in self.csvFid_faction_mod):
-            newRelations = set((faction,mod) for faction,mod in self.csvFid_faction_mod[fid].iteritems() if faction and (faction[0] is not None and faction[0] in self.patchFile.loadSet))
-        elif(fid in self.fid_faction_mod):
-            newRelations = set((faction,mod) for faction,mod in self.fid_faction_mod[fid].iteritems() if faction and (faction[0] is not None and faction[0] in self.patchFile.loadSet))
-        else:
-            return
-        curRelations = set(record.relations_list)
-        changed = newRelations - curRelations
-        if changed:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                for faction,mod in changed:
-                    for relation in override.relations:
-                        if relation.faction == faction:
-                            relation.mod = mod
-                            break
-                    else:
-                        relation = override.create_relation()
-                        relation.faction,relation.mod = faction,mod
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Re-Relationed Records: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class ImportScripts(ImportPatcher):
-    """Imports attached scripts on objects."""
-    name = _('Import Scripts')
-    text = _("Import Scripts on containers, plants, misc, weapons etc. from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Scripts'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_data = {} #--Names keyed by long fid.
-        self.srcClasses = set() #--Record classes actually provided by src mods/files.
-        self.sourceMods = self.getConfigChecked()
-        self.isActive = len(self.sourceMods) != 0
-        #--Type Fields
-        recAttrs_class = self.recAttrs_class = {}
-        for recClass in (MreWeap,MreActi,MreAlch,MreAppa,MreArmo,MreBook,MreClot,MreCont,MreCrea,MreDoor,MreFlor,MreFurn,MreIngr,MreKeym,MreLigh,MreMisc,MreNpc,MreQust,MreSgst,MreSlgm,):
-            recAttrs_class[recClass] = ('script',)
-        self.longTypes = set(('WEAP','ACTI','ALCH','APPA','ARMO','BOOK','CLOT','CONT','CREA','DOOR','FLOR','FURN','INGR','KEYM','LIGH','MISC','NPC_','QUST','SGST','SLGM'))
-
-    def initData(self,progress):
-        """Get script links from source files."""
-        if not self.isActive: return
-        self.classestemp = set()
-        id_data = self.id_data
-        recAttrs_class = self.recAttrs_class
-        loadFactory = LoadFactory(False,*recAttrs_class.keys())
-        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
-        progress.setFull(len(self.sourceMods))
-        cachedMasters = {}
-        for index,srcMod in enumerate(self.sourceMods):
-            temp_id_data = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass,recAttrs in recAttrs_class.iteritems():
-                if recClass.classType not in srcFile.tops: continue
-                self.srcClasses.add(recClass)
-                self.classestemp.add(recClass)
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
-            for master in masters:
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for recClass,recAttrs in recAttrs_class.iteritems():
-                    if recClass.classType not in masterFile.tops: continue
-                    if recClass not in self.classestemp: continue
-                    for record in masterFile.tops[recClass.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if fid not in temp_id_data: continue
-                        for attr, value in temp_id_data[fid].iteritems():
-                            if value == record.__getattribute__(attr): continue
-                            else:
-                                if fid not in id_data: id_data[fid] = dict()
-                                try:
-                                    id_data[fid][attr] = temp_id_data[fid][attr]
-                                except KeyError:
-                                    id_data[fid].setdefault(attr,value)
-            progress.plus()
-        temp_id_data = None
-        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
-        self.isActive = bool(self.srcClasses)
-
-    def scanModFile(self, modFile, progress):
-        """Scan mod file against source data."""
-        if not self.isActive: return
-        id_data = self.id_data
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if self.longTypes:
-            modFile.convertToLongFids(self.longTypes)
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-                        break
-
-    def buildPatch(self,log,progress):
-        """Merge last version of record with patched scripts link as needed."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_data = self.id_data
-        type_count = {}
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        break
-                else:
-                    continue
-                for attr,value in id_data[fid].iteritems():
-                    record.__setattr__(attr,value)
-                keep(fid)
-                type_count[type] += 1
-        #cleanup to save memory
-        id_data = None
-        #logging
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-
-class CBash_ImportScripts(CBash_ImportPatcher):
-    """Imports attached scripts on objects."""
-    name = _('Import Scripts')
-    text = _("Import Scripts on containers, plants, misc, weapons etc from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Scripts',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_script = {}
-        self.class_mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['ACTI','ALCH','APPA','ARMO','BOOK','CLOT','CONT','CREA',
-                'DOOR','FLOR','FURN','INGR','KEYM','LIGH','LVLC','MISC',
-                'NPC_','QUST','SGST','SLGM','WEAP']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        script = record.ConflictDetails(('script',), False)
-        if script:
-            # Only save if different from the master record
-            if record.GName != record.fid[0]:
-                history = record.History()
-                if history and len(history) > 0:
-                    masterRecord = history[0]
-                    if masterRecord.GName == record.fid[0] and masterRecord.script == record.script:
-                        return # Same
-            self.id_script[record.fid] = script['script']
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        recordId = record.fid
-        if(recordId in self.id_script and record.script != self.id_script[recordId]):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.script = self.id_script[recordId]
-                class_mod_count = self.class_mod_count
-                class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-
-#------------------------------------------------------------------------------
-class ImportScriptContents(ImportPatcher):
-    """Imports the contents of scripts -- currently only object/mgef scripts."""
-    name = _('Import Script Contents')
-    text = _("Import the actual contents of scripts scripts.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'ScriptContents'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_data = {} #--Names keyed by long fid.
-        self.srcClasses = set() #--Record classes actually provided by src mods/files.
-        self.sourceMods = self.getConfigChecked()
-        self.isActive = len(self.sourceMods) != 0
-        self.classestemp = set()
-        #--Type Fields
-        recAttrs_class = self.recAttrs_class = {}
-        for recClass in (MreScpt,):
-            recAttrs_class[recClass] = ('numRefs','lastIndex','compiledSize','scriptType','compiled_p','scriptText','vars','references',) # invalid attributes for plain script: SCHR, 4s4I,SCDA,'SLSD','I12sB7s','index', 'SCVR', 'name',
-#        for recClass in (MreInfo,):
- #           recAttrs_class[recClass] = ('SCHD','schd_p','SCHR','4s4I','numRefs','compiledsize','lastIndex','scriptType','SCDA','compiled_p','SCTX','scriptText','SCRV/SCRO','references',)
-        for recClass in (MreQust,):
-            recAttrs_class[recClass] = ('stages',)# 'SCHD','schd_p','SCHR','4s4I','numRefs','compiledsize','lastIndex','scriptType','SCDA','compiled_p','SCTX','scriptText','SCRV/SCRO','references',)
-        self.longTypes = set(('SCPT','QUST','DIAL','INFO'))
-#        MelGroups('stages',
-#            MelStruct('INDX','h','stage'),
-#            MelGroups('entries',
-#                MelStruct('QSDT','B',(stageFlags,'flags')),
-#                MelConditions(),
-#                MelString('CNAM','text'),
-#                MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
-#                MelBase('SCDA','compiled_p'),
-#                MelString('SCTX','scriptText'),
-#                MelScrxen('SCRV/SCRO','references')
-#                ),
-
-
-    def initData(self,progress):
-        """Get graphics from source files."""
-        if not self.isActive: return
-        id_data = self.id_data
-        recAttrs_class = self.recAttrs_class
-        loadFactory = LoadFactory(False,*recAttrs_class.keys())
-        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
-        progress.setFull(len(self.sourceMods))
-        cachedMasters = {}
-        for index,srcMod in enumerate(self.sourceMods):
-            temp_id_data = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass,recAttrs in recAttrs_class.iteritems():
-                if recClass.classType not in srcFile.tops: continue
-                self.srcClasses.add(recClass)
-                self.classestemp.add(recClass)
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
-            for master in masters:
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for recClass,recAttrs in recAttrs_class.iteritems():
-                    if recClass.classType not in masterFile.tops: continue
-                    if recClass not in self.classestemp: continue
-                    for record in masterFile.tops[recClass.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if fid not in temp_id_data: continue
-                        for attr, value in temp_id_data[fid].iteritems():
-                            if value == record.__getattribute__(attr): continue
-                            else:
-                                if fid not in id_data: id_data[fid] = dict()
-                                try:
-                                    id_data[fid][attr] = temp_id_data[fid][attr]
-                                except KeyError:
-                                    id_data[fid].setdefault(attr,value)
-            progress.plus()
-        temp_id_data = None
-        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
-        self.isActive = bool(self.srcClasses)
-
-    def scanModFile(self, modFile, progress):
-        """Scan mod file against source data."""
-        if not self.isActive: return
-        id_data = self.id_data
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if self.longTypes:
-            modFile.convertToLongFids(self.longTypes)
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-                        break
-
-    def buildPatch(self,log,progress):
-        """Merge last version of record with patched graphics data as needed."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_data = self.id_data
-        type_count = {}
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            #deprint(recClass,type,type_count[type])
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        break
-                else:
-                    continue
-                for attr,value in id_data[fid].iteritems():
-                    record.__setattr__(attr,value)
-                keep(fid)
-                type_count[type] += 1
-        id_data = None
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-##class CBash_ImportScriptContents(CBash_ImportPatcher):
-##    raise NotImplementedError
-#------------------------------------------------------------------------------
-class ImportInventory(ImportPatcher):
-    """Merge changes to actor inventories."""
-    name = _('Import Inventory')
-    text = _("Merges changes to NPC, creature and container inventories.")
-    autoKey = ('Invent','InventOnly')
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    iiMode = True
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_deltas = {}
-        self.srcMods = self.getConfigChecked()
-        self.srcMods = [x for x in self.srcMods if (x in modInfos and x in patchFile.allMods)]
-        self.inventOnlyMods = set(x for x in self.srcMods if
-            (x in patchFile.mergeSet and set(('InventOnly','IIM')) & modInfos[x].getBashTags()))
-        self.isActive = bool(self.srcMods)
-        self.masters = set()
-        for srcMod in self.srcMods:
-            self.masters |= set(modInfos[srcMod].header.masters)
-        self.allMods = self.masters | set(self.srcMods)
-        self.mod_id_entries = {}
-        self.touched = set()
-
-    def initData(self,progress):
-        """Get data from source files."""
-        if not self.isActive or not self.srcMods: return
-        loadFactory = LoadFactory(False,'CREA','NPC_','CONT')
-        progress.setFull(len(self.srcMods))
-        for index,srcMod in enumerate(self.srcMods):
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            srcFile.load(True)
-            mapper = srcFile.getLongMapper()
-            for block in (srcFile.CREA, srcFile.NPC_, srcFile.CONT):
-                for record in block.getActiveRecords():
-                    self.touched.add(mapper(record.fid))
-            progress.plus()
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreNpc,MreCrea,MreCont))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreNpc,MreCrea,MreCont))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Add record from modFile."""
-        if not self.isActive: return
-        touched = self.touched
-        id_deltas = self.id_deltas
-        mod_id_entries = self.mod_id_entries
-        mapper = modFile.getLongMapper()
-        modName = modFile.fileInfo.name
-        #--Master or source?
-        if modName in self.allMods:
-            id_entries = mod_id_entries[modName] = {}
-            modFile.convertToLongFids(('NPC_','CREA','CONT'))
-            for type in ('NPC_','CREA','CONT'):
-                for record in getattr(modFile,type).getActiveRecords():
-                    if record.fid in touched:
-                        id_entries[record.fid] = record.items[:]
-        #--Source mod?
-        if modName in self.srcMods:
-            id_entries = {}
-            for master in modFile.tes4.masters:
-                if master in mod_id_entries:
-                    id_entries.update(mod_id_entries[master])
-            for fid,entries in mod_id_entries[modName].iteritems():
-                masterEntries = id_entries.get(fid)
-                if masterEntries is None: continue
-                masterItems = set(x.item for x in masterEntries)
-                modItems = set(x.item for x in entries)
-                removeItems = masterItems - modItems
-                addItems = modItems - masterItems
-                addEntries = [x for x in entries if x.item in addItems]
-                deltas = self.id_deltas.get(fid)
-                if deltas is None: deltas = self.id_deltas[fid] = []
-                deltas.append((removeItems,addEntries))
-        #--Keep record?
-        if modFile.fileInfo.name not in self.inventOnlyMods:
-            for type in ('NPC_','CREA','CONT'):
-                patchBlock = getattr(self.patchFile,type)
-                id_records = patchBlock.id_records
-                for record in getattr(modFile,type).getActiveRecords():
-                    fid = mapper(record.fid)
-                    if fid in touched and fid not in id_records:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Applies delta to patchfile."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        id_deltas = self.id_deltas
-        mod_count = {}
-        for type in ('NPC_','CREA','CONT'):
-            for record in getattr(self.patchFile,type).records:
-                changed = False
-                deltas = id_deltas.get(record.fid)
-                if not deltas: continue
-                removable = set(x.item for x in record.items)
-                for removeItems,addEntries in reversed(deltas):
-                    if removeItems:
-                        #--Skip if some items to be removed have already been removed
-                        if not removeItems.issubset(removable): continue
-                        record.items = [x for x in record.items if x.item not in removeItems]
-                        removable -= removeItems
-                        changed = True
-                    if addEntries:
-                        current = set(x.item for x in record.items)
-                        for entry in addEntries:
-                            if entry.item not in current:
-                                record.items.append(entry)
-                                changed = True
-                if changed:
-                    keep(record.fid)
-                    mod = record.fid[0]
-                    mod_count[mod] = mod_count.get(mod,0) + 1
-        #--Log
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcMods:
-            log("* " +mod.s)
-        log(_("\n=== Inventories Changed: %d") % (sum(mod_count.values()),))
-        for mod in modInfos.getOrdered(mod_count):
-            log('* %s: %3d' % (mod.s,mod_count[mod]))
-
-class CBash_ImportInventory(CBash_ImportPatcher):
-    """Merge changes to actor inventories."""
-    name = _('Import Inventory')
-    text = _("Merges changes to NPC, creature and container inventories.")
-    autoKey = set(('Invent','InventOnly'))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    iiMode = True
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_deltas = {}
-        #should be redundant since this patcher doesn't allow unloaded
-        #self.srcs = [x for x in self.srcs if (x in modInfos and x in patchFile.allMods)]
-        self.inventOnlyMods = set(x for x in self.srcs if
-            (x in patchFile.mergeSet and set(('InventOnly','IIM')) & modInfos[x].getBashTags()))
-        self.class_mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_','CONT']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        #--Source mod?
-        masters = record.History()
-        if not masters: return
-        masterEntries = []
-        for masterEntry in masters:
-            masterEntries.extend(masterEntry.items_list)
-        entries = record.items_list
-        masterItems = set(item for item,count in masterEntries)
-        modItems = set(item for item,count in entries)
-        removeItems = masterItems - modItems
-        addItems = modItems - masterItems
-        addEntries = [(item,count) for item,count in entries if item in addItems]
-        id_deltas = self.id_deltas
-        fid = record.fid
-        deltas = id_deltas.get(fid)
-        if deltas is None: deltas = id_deltas[fid] = []
-        deltas.append((removeItems,addEntries))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        deltas = self.id_deltas.get(record.fid)
-        if not deltas: return
-        #If only the inventory is imported, the deltas have to be applied to
-        #whatever record would otherwise be winning
-        if modFile.GName in self.inventOnlyMods:
-            conflicts = record.Conflicts()
-            if conflicts:
-                #If this isn't actually the winning record, use it.
-                #This could be the case if a record was already copied into the patch
-                if conflicts[0] != record:
-                    record = conflicts[0]
-                #Otherwise, use the previous one.
-                else:
-                    record = conflicts[1]
-
-        removable = set(entry.item for entry in record.items)
-        changed = False
-        for removeItems,addEntries in reversed(deltas):
-            items = record.items_list
-            if removeItems:
-                #--Skip if some items to be removed have already been removed
-                if not removeItems.issubset(removable): continue
-                items = [(item,count) for item,count in items if item not in removeItems]
-                removable -= removeItems
-                changed = True
-            if addEntries:
-                current = set(item for item,count in items)
-                for item,count in addEntries:
-                    if item not in current:
-                        items.append((item,count))
-                        changed = True
-        if changed:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                try:
-                    override.items_list = items
-                except AttributeError:
-                    override.items_list = [item for item in items if item[0][0]]
-                class_mod_count = self.class_mod_count
-                class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        for type in class_mod_count.keys():
-            log(_('* %s Inventories Changed: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-#------------------------------------------------------------------------------
-class ImportActorsSpells(ImportPatcher):
-    """Merges changes to the spells lists of Actors."""
-    name = _('Import Actors: Spells')
-    text = _("Merges changes to NPC and creature spell lists.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = ('Actors.Spells','Actors.SpellsForceAdd')
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcMods = self.getConfigChecked()
-        self.isActive = len(self.srcMods) != 0
-        self.data = {}
-        self.longTypes = set(('CREA','NPC_'))
-
-    def initData(self,progress):
-        """Get data from source files."""
-        if not self.isActive: return
-        longTypes = self.longTypes
-        loadFactory = LoadFactory(False,MreCrea,MreNpc)
-        progress.setFull(len(self.srcMods))
-        cachedMasters = {}
-        data = self.data
-        for index,srcMod in enumerate(self.srcMods):
-            tempData = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            bashTags = srcInfo.getBashTags()
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass in (MreNpc,MreCrea):
-                if recClass.classType not in srcFile.tops: continue
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    tempData[fid] = list(record.spells)
-            for master in reversed(masters):
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for block in (MreNpc, MreCrea):
-                    if block.classType not in srcFile.tops: continue
-                    if block.classType not in masterFile.tops: continue
-                    for record in masterFile.tops[block.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if not fid in tempData: continue
-                        if record.spells == tempData[fid] and not 'Actors.SpellsForceAdd' in bashTags:
-                            # if subrecord is identical to the last master then we don't care about older masters.
-                            del tempData[fid]
-                            continue
-                        if fid in data:
-                            if tempData[fid] == data[fid]['merged']: continue
-                        recordData = {'deleted':[],'merged':tempData[fid]}
-                        for spell in list(record.spells):
-                            if not spell in tempData[fid]:
-                                recordData['deleted'].append(spell)
-                        if not fid in data:
-                            data[fid] = recordData
-                        else:
-                            for spell in recordData['deleted']:
-                                if spell in data[fid]['merged']:
-                                    data[fid]['merged'].remove(spell)
-                                data[fid]['deleted'].append(spell)
-                            if data[fid]['merged'] == []:
-                                for spell in recordData['merged']:
-                                    if spell in data[fid]['deleted'] and not 'Actors.SpellsForceAdd' in bashTags: continue
-                                    data[fid]['merged'].append(spell)
-                                continue
-                            for index, spell in enumerate(recordData['merged']):
-                                if not spell in data[fid]['merged']: # so needs to be added... (unless deleted that is)
-                                    # find the correct position to add and add.
-                                    if spell in data[fid]['deleted'] and not 'Actors.SpellsForceAdd' in bashTags: continue #previously deleted
-                                    if index == 0:
-                                        data[fid]['merged'].insert(0,spell) #insert as first item
-                                    elif index == (len(recordData['merged'])-1):
-                                        data[fid]['merged'].append(spell) #insert as last item
-                                    else: #figure out a good spot to insert it based on next or last recognized item (ugly ugly ugly)
-                                        i = index - 1
-                                        while i >= 0:
-                                            if recordData['merged'][i] in data[fid]['merged']:
-                                                slot = data[fid]['merged'].index(recordData['merged'][i])+1
-                                                data[fid]['merged'].insert(slot, spell)
-                                                break
-                                            i -= 1
-                                        else:
-                                            i = index + 1
-                                            while i != len(recordData['merged']):
-                                                if recordData['merged'][i] in data[fid]['merged']:
-                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
-                                                    data[fid]['merged'].insert(slot, spell)
-                                                    break
-                                                i += 1
-                                    continue # Done with this package
-                                elif index == data[fid]['merged'].index(spell) or (len(recordData['merged'])-index) == (len(data[fid]['merged'])-data[fid]['merged'].index(spell)): continue #spell same in both lists.
-                                else: #this import is later loading so we'll assume it is better order
-                                    data[fid]['merged'].remove(spell)
-                                    if index == 0:
-                                        data[fid]['merged'].insert(0,spell) #insert as first item
-                                    elif index == (len(recordData['merged'])-1):
-                                        data[fid]['merged'].append(spell) #insert as last item
-                                    else:
-                                        i = index - 1
-                                        while i >= 0:
-                                            if recordData['merged'][i] in data[fid]['merged']:
-                                                slot = data[fid]['merged'].index(recordData['merged'][i]) + 1
-                                                data[fid]['merged'].insert(slot, spell)
-                                                break
-                                            i -= 1
-                                        else:
-                                            i = index + 1
-                                            while i != len(recordData['merged']):
-                                                if recordData['merged'][i] in data[fid]['merged']:
-                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
-                                                    data[fid]['merged'].insert(slot, spell)
-                                                    break
-                                                i += 1
-            progress.plus()
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreNpc,MreCrea))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreNpc,MreCrea))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Add record from modFile."""
-        if not self.isActive: return
-        data = self.data
-        mapper = modFile.getLongMapper()
-        modName = modFile.fileInfo.name
-        for type in ('NPC_','CREA'):
-            patchBlock = getattr(self.patchFile,type)
-            for record in getattr(modFile,type).getActiveRecords():
-                fid = mapper(record.fid)
-                if fid in data:
-                    if list(record.spells) != data[fid]['merged']:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Applies delta to patchfile."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        data = self.data
-        mod_count = {}
-        for type in ('NPC_','CREA'):
-            for record in getattr(self.patchFile,type).records:
-                fid = record.fid
-                if not fid in data: continue
-                changed = False
-                mergedSpells = sorted(data[fid]['merged'])
-                if sorted(list(record.spells)) != mergedSpells:
-                    record.spells = mergedSpells
-                    changed = True
-                if changed:
-                    keep(record.fid)
-                    mod = record.fid[0]
-                    mod_count[mod] = mod_count.get(mod,0) + 1
-        #--Log
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcMods:
-            log("* " +mod.s)
-        log(_("\n=== Spell Lists Changed: %d") % (sum(mod_count.values()),))
-        for mod in modInfos.getOrdered(mod_count):
-            log('* %s: %3d' % (mod.s,mod_count[mod]))
-class CBash_ImportActorsSpells(CBash_ImportPatcher):
-    """Merges changes to the spells lists of Actors."""
-    name = _('Import Actors: Spells')
-    text = _("Merges changes to NPC and creature spell lists.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Actors.Spells','Actors.SpellsForceAdd'))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_spells = {}
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CREA','NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        curData = {'deleted':[],'merged':[]}
-        curspells = record.spells
-##            print curspells
-        parentRecords = record.History()
-        if parentRecords:
-            if parentRecords[-1].spells != curspells or 'Actors.SpellsForceAdd' in bashTags:
-                for spell in parentRecords[-1].spells:
-                    if spell not in curspells:
-                        curData['deleted'].append(spell)
-            curData['merged'] = curspells
-            if not record.fid in self.id_spells:
-                self.id_spells[record.fid] = curData
-            else:
-                id_spells = self.id_spells[record.fid]
-                for spell in curData['deleted']:
-                    if spell in id_spells['merged']:
-                        id_spells['merged'].remove(spell)
-                    id_spells['deleted'].append(spell)
-                for spell in curData['merged']:
-                    if spell in id_spells['merged']: continue #don't want to add 20 copies of the spell afterall
-                    if not spell in id_spells['deleted'] or 'Actors.SpellsForceAdd' in bashTags:
-                        id_spells['merged'].append(spell)
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break        
-        recordId = record.fid
-        mergedSpells = self.id_spells.get(recordId,None)
-        if mergedSpells:
-            if sorted(record.spells) != sorted(mergedSpells['merged']):
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.spells = mergedSpells['merged']
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_('* Imported Spell Lists: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-#------------------------------------------------------------------------------
-class NamesPatcher(ImportPatcher):
-    """Merged leveled lists mod file."""
-    name = _('Import Names')
-    text = _("Import names from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^Oblivion.esm$",re.I)
-    autoKey = 'Names'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_full = {} #--Names keyed by long fid.
-        self.activeTypes = [] #--Types ('ALCH', etc.) of data actually provided by src mods/files.
-        self.skipTypes = [] #--Unknown types that were skipped.
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-
-    def initData(self,progress):
-        """Get names from source files."""
-        if not self.isActive: return
-        fullNames = FullNames(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if reModExt.search(srcFile.s):
-                if srcPath not in modInfos: continue
-                srcInfo = modInfos[GPath(srcFile)]
-                fullNames.readFromMod(srcInfo)
-            else:
-                if srcPath not in patchesDir: continue
-                fullNames.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        id_full = self.id_full
-        knownTypes = set(MreRecord.type_class.keys())
-        for type,id_name in fullNames.type_id_name.iteritems():
-            if type not in knownTypes:
-                self.skipTypes.append(type)
-                continue
-            self.activeTypes.append(type)
-            for longid,(eid,name) in id_name.iteritems():
-                if name != 'NO NAME':
-                    id_full[longid] = name
-        self.isActive = bool(self.activeTypes)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        return [MreRecord.type_class[type] for type in self.activeTypes]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        return [MreRecord.type_class[type] for type in self.activeTypes]
-
-    def scanModFile(self, modFile, progress):
-        """Scan modFile."""
-        if not self.isActive: return
-        id_full = self.id_full
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        for type in self.activeTypes:
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            id_records = patchBlock.id_records
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid in id_records: continue
-                if fid not in id_full: continue
-                if record.full != id_full[fid]:
-                    patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Make changes to patchfile."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_full = self.id_full
-        type_count = {}
-        for type in self.activeTypes:
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid in id_full and record.full != id_full[fid]:
-                    record.full = id_full[fid]
-                    keep(fid)
-                    type_count[type] += 1
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Renamed Items"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-
-class CBash_NamesPatcher(CBash_ImportPatcher):
-    """Import names from source mods/files."""
-    name = _('Import Names')
-    text = _("Import names from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^Oblivion.esm$",re.I)
-    autoKey = set(('Names',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_full = {}
-        self.csvId_full = {}
-        self.class_mod_count = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        CBash_ImportPatcher.initData(self,type_patchers,progress)
-        fullNames = CBash_FullNames(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            if not reModExt.search(srcFile.s):
-                if srcPath not in patchesDir: continue
-                fullNames.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
-        #--Finish
-        csvId_full = self.csvId_full
-        for group,fid_name in fullNames.group_fid_name.iteritems():
-            if group not in validTypes: continue
-            for fid,(eid,name) in fid_name.iteritems():
-                if name != 'NO NAME':
-                    csvId_full[fid] = name
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ["CLAS","FACT","HAIR","EYES","RACE","MGEF","ENCH",
-                "SPEL","BSGN","ACTI","APPA","ARMO","BOOK","CLOT",
-                "CONT","DOOR","INGR","LIGH","MISC","FLOR","FURN",
-                "WEAP","AMMO","NPC_","CREA","SLGM","KEYM","ALCH",
-                "SGST","WRLD","CELL","DIAL","QUST"]
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        full = record.ConflictDetails(('full',),False)
-        if full:
-            self.id_full[record.fid] = full['full']
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        full = self.id_full.get(recordId, None)
-        full = self.csvId_full.get(recordId, full)
-        if(full and record.full != full):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.full = full
-                class_mod_count = self.class_mod_count
-                class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcs:
-            log("* " +file.s)
-        log(_("\n=== Renamed Items"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-
-#------------------------------------------------------------------------------
-class NpcFacePatcher(ImportPatcher):
-    """NPC Faces patcher, for use with TNR or similar mods."""
-    name = _('Import NPC Faces')
-    text = _("Import NPC face/eyes/hair from source mods. For use with TNR and similar mods.")
-    autoRe = re.compile(r"^TNR .*.esp$",re.I)
-    autoKey = ('NpcFaces','NpcFacesForceFullImport','Npc.HairOnly','Npc.EyesOnly')
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.faceData = {}
-        self.faceMods = self.getConfigChecked()
-        self.isActive = len(self.faceMods) != 0
-
-    def initData(self,progress):
-        """Get faces from TNR files."""
-        if not self.isActive: return
-        faceData = self.faceData
-        loadFactory = LoadFactory(False,MreNpc)
-        progress.setFull(len(self.faceMods))
-        cachedMasters = {}
-        for index,faceMod in enumerate(self.faceMods):
-            if faceMod not in modInfos: continue
-            temp_faceData = {}
-            faceInfo = modInfos[faceMod]
-            faceFile = ModFile(faceInfo,loadFactory)
-            masters = faceInfo.header.masters
-            bashTags = faceInfo.getBashTags()
-            faceFile.load(True)
-            faceFile.convertToLongFids(('NPC_',))
-            for npc in faceFile.NPC_.getActiveRecords():
-                if npc.fid[0] in self.patchFile.loadSet:
-                    attrs, fidattrs = [],[]
-                    if 'Npc.HairOnly' in bashTags: 
-                        fidattrs += ['hair']
-                        attrs = ['hairLength','hairRed','hairBlue','hairGreen']
-                    if 'Npc.EyesOnly' in bashTags: fidattrs += ['eye']
-                    if fidattrs:
-                        attr_fidvalue = dict((attr,npc.__getattribute__(attr)) for attr in fidattrs)
-                    else:
-                        attr_fidvalue = dict((attr,npc.__getattribute__(attr)) for attr in ('eye','hair'))
-                    for fidvalue in attr_fidvalue.values():
-                        if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
-                            #Ignore the record. Another option would be to just ignore the attr_fidvalue result
-                            mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
-                            mod_skipcount[faceMod] = mod_skipcount.setdefault(faceMod, 0) + 1
-                            break
-                    else:
-                        if not fidattrs: temp_faceData[npc.fid] = dict((attr,npc.__getattribute__(attr)) for attr in ('fggs_p','fgga_p','fgts_p','hairLength','hairRed','hairBlue','hairGreen','unused3'))
-                        else: temp_faceData[npc.fid] = dict((attr,npc.__getattribute__(attr)) for attr in attrs)
-                        temp_faceData[npc.fid].update(attr_fidvalue)
-            if 'NpcFacesForceFullImport' in bashTags:
-                for fid in temp_faceData:
-                    faceData[fid] = temp_faceData[fid]
-            else:
-                for master in masters:
-                    if not master in modInfos: continue # or break filter mods
-                    if master in cachedMasters:
-                        masterFile = cachedMasters[master]
-                    else:
-                        masterInfo = modInfos[master]
-                        masterFile = ModFile(masterInfo,loadFactory)
-                        masterFile.load(True)
-                        masterFile.convertToLongFids(('NPC_',))
-                        cachedMasters[master] = masterFile
-                    mapper = masterFile.getLongMapper()
-                    if 'NPC_' not in masterFile.tops: continue
-                    for npc in masterFile.NPC_.getActiveRecords():
-                        if npc.fid not in temp_faceData: continue
-                        for attr, value in temp_faceData[npc.fid].iteritems():
-                            if value == npc.__getattribute__(attr): continue
-                            if npc.fid not in faceData: faceData[npc.fid] = dict()
-                            try:
-                                faceData[npc.fid][attr] = temp_faceData[npc.fid][attr]
-                            except KeyError:
-                                faceData[npc.fid].setdefault(attr,value)
-            progress.plus()
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreNpc,))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreNpc,))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Add lists from modFile."""
-        modName = modFile.fileInfo.name
-        if not self.isActive or modName in self.faceMods or 'NPC_' not in modFile.tops:
-            return
-        mapper = modFile.getLongMapper()
-        faceData,patchNpcs = self.faceData,self.patchFile.NPC_
-        modFile.convertToLongFids(('NPC_',))
-        for npc in modFile.NPC_.getActiveRecords():
-            if npc.fid in faceData:
-                patchNpcs.setRecord(npc)
-
-    def buildPatch(self,log,progress):
-        """Adds merged lists to patchfile."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        faceData, count = self.faceData, 0
-        for npc in self.patchFile.NPC_.records:
-            if npc.fid in faceData:
-                changed = False
-                for attr, value in faceData[npc.fid].iteritems():
-                    if value != npc.__getattribute__(attr):
-                        npc.__setattr__(attr,value)
-                        changed = True
-                if changed:
-                    npc.setChanged()
-                    keep(npc.fid)
-                    count += 1
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.faceMods:
-            log("* " +mod.s)
-        log(_("\n=== Faces Patched: %d") % count)
-
-class CBash_NpcFacePatcher(CBash_ImportPatcher):
-    """NPC Faces patcher, for use with TNR or similar mods."""
-    name = _('Import NPC Faces')
-    text = _("Import NPC face/eyes/hair from source mods. For use with TNR and similar mods.")
-    autoRe = re.compile(r"^TNR .*.esp$",re.I)
-    autoKey = set(('NpcFaces','NpcFacesForceFullImport','Npc.HairOnly','Npc.EyesOnly'))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_face = {}
-        ##Can't allow merging from unloaded mods if fids are involved. Might end up with a dependency on that mod.
-        ##self.faceData = ('fggs_p','fgga_p','fgts_p','eye','hair','hairLength','hairRed','hairBlue','hairGreen','fnam')
-        self.faceData = ('fggs_p','fgga_p','fgts_p','hairLength','hairRed','hairBlue','hairGreen','fnam')
-        self.faceFidData = ('eye','hair')
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['NPC_']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        if 'NpcFacesForceFullImport' in bashTags:
-            face = {}
-            for attr in self.faceFidData:
-                face[attr] = getattr(record,attr)
-            for fidvalue in face.values():
-                if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
-                    #Ignore the record. Another option would be to just ignore the attr_fidvalue result
-                    mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
-                    mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
-                    return
-            for attr in self.faceData:
-                face[attr] = getattr(record,attr)
-            self.id_face[record.fid] = face
-        else:
-            fidattrs, attrs = [], []
-            if 'Npc.HairOnly' in bashTags: 
-                fidattrs += ['hair']
-                attrs =['hairLength','hairRed','hairBlue','hairGreen']
-            if 'Npc.EyesOnly' in bashTags: fidattrs += ['eye']
-            if fidattrs:
-                attr_fidvalue = record.ConflictDetails(fidattrs, False)
-            else:
-                attr_fidvalue = record.ConflictDetails(self.faceFidData, False)
-            for fidvalue in attr_fidvalue.values():
-                if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
-                    #Ignore the record. Another option would be to just ignore the attr_fidvalue result
-                    mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
-                    mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
-                    return
-            fid = record.fid
-            # Only save if different from the master record
-            if record.GName != fid[0]:
-                history = record.History()
-                if history and len(history) > 0:
-                    masterRecord = history[0]
-                    if masterRecord.GName == record.fid[0]:
-                        same = True
-                        for attr in (attrs + fidattrs) or (self.faceFidData + self.faceData):
-                            if getattr(masterRecord,attr) != getattr(record,attr):
-                                same = False
-                                break
-                        if same:
-                            return
-            self.id_face.setdefault(fid,{}).update(attr_fidvalue)
-            if fidattrs: 
-                self.id_face.setdefault(fid,{}).update(record.ConflictDetails(attrs, False))
-            else:
-                self.id_face.setdefault(fid,{}).update(record.ConflictDetails(self.faceData, False))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        prev_face_value = self.id_face.get(recordId,None)
-        if prev_face_value:
-            cur_face_value = dict((attr,getattr(record,attr)) for attr in prev_face_value)
-            if cur_face_value != prev_face_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_face_value.iteritems():
-                        setattr(override,attr,value)
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_('* Faces Patched: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class RoadImporter(ImportPatcher):
-    """Imports roads."""
-    name = _('Import Roads')
-    text = _("Import roads from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Roads'
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.sourceMods = self.getConfigChecked()
-        self.isActive = bool(self.sourceMods)
-        self.world_road = {}
-
-    def initData(self,progress):
-        """Get cells from source files."""
-        if not self.isActive: return
-        loadFactory = LoadFactory(False,MreCell,MreWrld,MreRoad)
-        progress.setFull(len(self.sourceMods))
-        for srcMod in self.sourceMods:
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            srcFile.load(True)
-            srcFile.convertToLongFids(('WRLD','ROAD'))
-            for worldBlock in srcFile.WRLD.worldBlocks:
-                if worldBlock.road:
-                    worldId = worldBlock.world.fid
-                    road = worldBlock.road.getTypeCopy()
-                    self.world_road[worldId] = road
-        self.isActive = bool(self.world_road)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreCell,MreWrld,MreRoad))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreCell,MreWrld,MreRoad))[self.isActive]
-
-    def scanModFile(self, modFile, progress):
-        """Add lists from modFile."""
-        if not self.isActive or 'WRLD' not in modFile.tops: return
-        patchWorlds = self.patchFile.WRLD
-        modFile.convertToLongFids(('CELL','WRLD','ROAD'))
-        for worldBlock in modFile.WRLD.worldBlocks:
-            if worldBlock.road:
-                worldId = worldBlock.world.fid
-                road = worldBlock.road.getTypeCopy()
-                patchWorlds.setWorld(worldBlock.world)
-                patchWorlds.id_worldBlocks[worldId].road = road
-
-    def buildPatch(self,log,progress):
-        """Adds merged lists to patchfile."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        worldsPatched = set()
-        for worldBlock in self.patchFile.WRLD.worldBlocks:
-            worldId = worldBlock.world.fid
-            curRoad = worldBlock.road
-            newRoad = self.world_road.get(worldId)
-            if newRoad and (not curRoad or curRoad.points_p != newRoad.points_p
-                or curRoad.connections_p != newRoad.connections_p
-                ):
-                worldBlock.road = newRoad
-                keep(worldId)
-                keep(newRoad.fid)
-                worldsPatched.add((worldId[0].s,worldBlock.world.eid))
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " +mod.s)
-        log(_("\n=== Worlds Patched"))
-        for modWorld in sorted(worldsPatched):
-            log('* %s: %s' % modWorld)
-
-class CBash_RoadImporter(CBash_ImportPatcher):
-    """Imports roads."""
-    name = _('Import Roads')
-    text = _("Import roads from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Roads',))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    #The regular patch routine doesn't allow merging of world records. The CBash patch routine does.
-    #So, allowUnloaded isn't needed for this patcher to work. The same functionality could be gained by merging the tagged record.
-    #It is needed however so that the regular patcher and the CBash patcher have the same behavior.
-    #The regular patcher has to allow unloaded mods because it can't otherwise force the road record to be merged
-    #This isn't standard behavior for import patchers, but consistency between patchers is more important.
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_ROAD = {}
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['ROADS']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        self.id_ROAD[record.fid] = record
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        #If a previous road was scanned, and it is replaced by a new road
-        curRoad = record
-        newRoad = self.id_ROAD.get(recordId, None)
-        if newRoad:
-            #Roads and pathgrids are complex records...
-            #No good way to tell if the roads are equal.
-            #A direct comparison can prove equality, but not inequality
-            if curRoad.pgrp_list == newRoad.pgrp_list and curRoad.pgrr_list == newRoad.pgrr_list:
-                return
-            #So some records that are actually equal won't pass the above test and end up copied over
-            #Bloats the patch a little, but won't hurt anything.
-            if newRoad.fid[0] in self.patchFile.loadSet:
-                copyRoad = newRoad #Copy the new road over
-            elif curRoad and curRoad.fid[0] in self.patchFile.loadSet:
-                copyRoad = curRoad #Copy the current road over (it's formID is acceptable)
-            else:
-                #Ignore the record. Another option would be to just ignore the attr_fidvalue result
-                mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
-                mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
-                return
-
-            parent = self.patchFile.ObCollection.LookupRecords(copyRoad.Parent.fid)
-            override = parent[0].CopyAsOverride(self.patchFile) #Copies the winning parent world over if needed
-            if override:
-                override = copyRoad.CopyAsOverride(self.patchFile) #Copies the road over
-                if override:
-                    #Copy the new road values into the override (in case the CopyAsOverride returned a record pre-existing in the patch file)
-                    for copyattr in newRoad.copyattrs:
-                        setattr(override, copyattr, getattr(newRoad, copyattr))
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Roads Imported: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class SoundPatcher(ImportPatcher):
-    """Imports sounds from source mods into patch."""
-    name = _('Import Sounds')
-    text = _("Import sounds (from Magic Effects, Containers, Activators, Lights, Weathers and Doors) from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Sound'
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_data = {} #--Names keyed by long fid.
-        self.srcClasses = set() #--Record classes actually provided by src mods/files.
-        self.sourceMods = self.getConfigChecked()
-        self.isActive = len(self.sourceMods) != 0
-        self.classestemp = set()
-        #--Type Fields
-        recAttrs_class = self.recAttrs_class = {}
-        for recClass in (MreMgef,):
-            recAttrs_class[recClass] = ('castingSound','boltSound','hitSound','areaSound')
-        for recClass in (MreActi,MreLigh):
-            recAttrs_class[recClass] = ('sound',)
-        for recClass in (MreWthr,):
-            recAttrs_class[recClass] = ('sounds',)
-        for recClass in (MreCont,):
-            recAttrs_class[recClass] = ('soundOpen','soundClose')
-        for recClass in (MreDoor,):
-            recAttrs_class[recClass] = ('soundOpen','soundClose','soundLoop')
-        #--Needs Longs
-        self.longTypes = set(('MGEF','ACTI','LIGH','WTHR','CONT','DOOR'))
-
-    def initData(self,progress):
-        """Get sounds from source files."""
-        if not self.isActive: return
-        id_data = self.id_data
-        recAttrs_class = self.recAttrs_class
-        loadFactory = LoadFactory(False,*recAttrs_class.keys())
-        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
-        progress.setFull(len(self.sourceMods))
-        cachedMasters = {}
-        for index,srcMod in enumerate(self.sourceMods):
-            temp_id_data = {}
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            masters = srcInfo.header.masters
-            srcFile.load(True)
-            srcFile.convertToLongFids(longTypes)
-            mapper = srcFile.getLongMapper()
-            for recClass,recAttrs in recAttrs_class.iteritems():
-                if recClass.classType not in srcFile.tops: continue
-                self.srcClasses.add(recClass)
-                self.classestemp.add(recClass)
-                for record in srcFile.tops[recClass.classType].getActiveRecords():
-                    fid = mapper(record.fid)
-                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
-            for master in masters:
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
-                else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    masterFile.convertToLongFids(longTypes)
-                    cachedMasters[master] = masterFile
-                mapper = masterFile.getLongMapper()
-                for recClass,recAttrs in recAttrs_class.iteritems():
-                    if recClass.classType not in masterFile.tops: continue
-                    if recClass not in self.classestemp: continue
-                    for record in masterFile.tops[recClass.classType].getActiveRecords():
-                        fid = mapper(record.fid)
-                        if fid not in temp_id_data: continue
-                        for attr, value in temp_id_data[fid].iteritems():
-                            if value == record.__getattribute__(attr): continue
-                            else:
-                                if fid not in id_data: id_data[fid] = dict()
-                                try:
-                                    id_data[fid][attr] = temp_id_data[fid][attr]
-                                except KeyError:
-                                    id_data[fid].setdefault(attr,value)
-            progress.plus()
-        temp_id_data = None
-        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
-        self.isActive = bool(self.srcClasses)
-
-    def scanModFile(self, modFile, progress):
-        """Scan mod file against source data."""
-        if not self.isActive: return
-        id_data = self.id_data
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if self.longTypes:
-            modFile.convertToLongFids(self.longTypes)
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            patchBlock = getattr(self.patchFile,type)
-            for record in modFile.tops[type].getActiveRecords():
-                fid = record.fid
-                if not record.longFids: fid = mapper(fid)
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        patchBlock.setRecord(record.getTypeCopy(mapper))
-                        break
-
-    def buildPatch(self,log,progress):
-        """Merge last version of record with patched sound data as needed."""
-        if not self.isActive: return
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_data = self.id_data
-        type_count = {}
-        for recClass in self.srcClasses:
-            type = recClass.classType
-            if type not in modFile.tops: continue
-            type_count[type] = 0
-            #deprint(recClass,type,type_count[type])
-            for record in modFile.tops[type].records:
-                fid = record.fid
-                if fid not in id_data: continue
-                for attr,value in id_data[fid].iteritems():
-                    if record.__getattribute__(attr) != value:
-                        break
-                else:
-                    continue
-                for attr,value in id_data[fid].iteritems():
-                    record.__setattr__(attr,value)
-                keep(fid)
-                type_count[type] += 1
-        id_data = None
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.sourceMods:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type,count in sorted(type_count.iteritems()):
-            if count: log("* %s: %d" % (type,count))
-
-
-class CBash_SoundPatcher(CBash_ImportPatcher):
-    """Imports sounds from source mods into patch."""
-    name = _('Import Sounds')
-    text = _("Import sounds (from Activators, Containers, Creatures, Doors, Lights, Magic Effects and Weathers) from source mods.")
-    tip = text
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Sound',))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_attr_value = {}
-        self.class_mod_count = {}
-        class_attrs = self.class_attrs = {}
-        class_attrs['ACTI'] = ('sound',)
-        class_attrs['CONT'] = ('soundOpen','soundClose')
-        class_attrs['CREA'] = ('footWeight','inheritsSoundsFrom','sounds_list')
-        class_attrs['DOOR'] = ('soundOpen','soundClose','soundLoop')
-        class_attrs['LIGH'] = ('sound',)
-        class_attrs['MGEF'] = ('castingSound','boltSound','hitSound','areaSound')
-##        class_attrs['REGN'] = ('sound','sounds_list')
-        class_attrs['WTHR'] = ('sounds_list',)
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['ACTI','CONT','CREA','DOOR','LIGH','MGEF','WTHR']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[record._Type]))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break        
-        recordId = record.fid
-        prev_attr_value = self.fid_attr_value.get(recordId,None)
-        if prev_attr_value:
-            cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
-            if cur_attr_value != prev_attr_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_attr_value.iteritems():
-                        setattr(override,attr,value)
-                    class_mod_count = self.class_mod_count
-                    class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcs:
-            log("* " +mod.s)
-        log(_("\n=== Modified Records"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-
-#------------------------------------------------------------------------------
-class StatsPatcher(ImportPatcher):
-    """Import stats from mod file."""
-    scanOrder = 28
-    editOrder = 28 #--Run ahead of bow patcher
-    name = _('Import Stats')
-    text = _("Import stats from any pickupable items from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'Stats'
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-        #--To be filled by initData
-        self.fid_attr_value = {} #--Stats keyed by long fid.
-        self.activeTypes = [] #--Types ('ARMO', etc.) of data actually provided by src mods/files.
-        self.class_attrs = {}
-
-    def initData(self,progress):
-        """Get stats from source files."""
-        if not self.isActive: return
-        itemStats = ItemStats(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if reModExt.search(srcFile.s):
-                if srcPath not in modInfos: continue
-                srcInfo = modInfos[GPath(srcFile)]
-                itemStats.readFromMod(srcInfo)
-            else:
-                if srcPath not in patchesDir: continue
-                itemStats.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
-        #--Finish
-        for group,nId_attr_value in itemStats.class_fid_attr_value.iteritems():
-            self.activeTypes.append(group)
-            for id, attr_value in nId_attr_value.iteritems():
-                del attr_value['eid']
-            self.fid_attr_value.update(nId_attr_value)
-            self.class_attrs[group] = itemStats.class_attrs[group][1:]
-
-        self.isActive = bool(self.activeTypes)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        return [MreRecord.type_class[type] for type in self.activeTypes]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        return [MreRecord.type_class[type] for type in self.activeTypes]
-
-    def scanModFile(self, modFile, progress):
-        """Add affected items to patchFile."""
-        if not self.isActive: return
-        fid_attr_value = self.fid_attr_value
-        mapper = modFile.getLongMapper()
-        for group in self.activeTypes:
-            if group not in modFile.tops: continue
-            attrs = self.class_attrs[group]
-            patchBlock = getattr(self.patchFile,group)
-            id_records = patchBlock.id_records
-            for record in getattr(modFile,group).getActiveRecords():
-                longid = record.fid
-                if not record.longFids: longid = mapper(longid)
-                if longid in id_records: continue
-                itemStats = fid_attr_value.get(longid,None)
-                if not itemStats: continue
-                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
-                if oldValues != itemStats:
-                    patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Adds merged lists to patchfile."""
-        if not self.isActive: return
-        patchFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        fid_attr_value = self.fid_attr_value
-        allCounts = []
-        for group in self.activeTypes:
-            if group not in patchFile.tops: continue
-            attrs = self.class_attrs[group]
-            count,counts = 0,{}
-            for record in patchFile.tops[group].records:
-                fid = record.fid
-                itemStats = fid_attr_value.get(fid,None)
-                if not itemStats: continue
-                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
-                if oldValues != itemStats:
-                    for attr, value in itemStats.iteritems():
-                        setattr(record,attr,value)
-                    keep(fid)
-                    count += 1
-                    counts[fid[0]] = 1 + counts.get(fid[0],0)
-            allCounts.append((group,count,counts))
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Modified Stats"))
-        for type,count,counts in allCounts:
-            if not count: continue
-            typeName = {'ALCH':_('Potions'),'AMMO':_('Ammo'),'ARMO':_('Armors'),'INGR':_('Ingredients'),'MISC':_('Misc'),'WEAP':_('Weapons'),'SLGM':_('Soulgems'),'SGST':_('Sigil Stones'),'LIGH':_('Lights'),'KEYM':_('Keys'),'CLOT':_('Clothes'),'BOOK':_('Books'),'APPA':_('Apparatuses')}[type]
-            log("* %s: %d" % (typeName,count))
-            for modName in sorted(counts):
-                log("  * %s: %d" % (modName.s,counts[modName]))
-
-class CBash_StatsPatcher(CBash_ImportPatcher):
-    """Import stats from mod file."""
-    scanOrder = 28
-    editOrder = 28 #--Run ahead of bow patcher
-    name = _('Import Stats')
-    text = _("Import stats from any pickupable items from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Stats',))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.fid_attr_value = {}
-        self.csvFid_attr_value = {}
-        self.class_attrs = CBash_ItemStats.class_attrs
-        self.class_mod_count = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        CBash_ImportPatcher.initData(self,type_patchers,progress)
-        itemStats = CBash_ItemStats(aliases=self.patchFile.aliases)
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            if not reModExt.search(srcFile.s):
-                if srcFile not in patchesDir: continue
-                itemStats.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
-        #--Finish
-        for group,nId_attr_value in itemStats.class_fid_attr_value.iteritems():
-            if group not in validTypes: continue
-            self.csvFid_attr_value.update(nId_attr_value)
-
-        for group in self.getTypes():
-             type_patchers.setdefault(group,[]).append(self)
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return self.class_attrs.keys()
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[record._Type], False))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        prev_attr_value = self.fid_attr_value.get(recordId, None)
-        prev_attr_value = self.csvFid_attr_value.get(recordId, prev_attr_value)
-        if prev_attr_value:
-            cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
-            if cur_attr_value != prev_attr_value:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_attr_value.iteritems():
-                        setattr(override,attr,value)
-                    class_mod_count = self.class_mod_count
-                    class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        class_mod_count = self.class_mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcs:
-            log("* " +file.s)
-        log(_("\n=== Imported Stats"))
-        for type in class_mod_count.keys():
-            log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
-            for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
-                log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
-        self.class_mod_count = {}
-
-
-#------------------------------------------------------------------------------
-class SpellsPatcher(ImportPatcher):
-    """Import spell changes from mod files."""
-    scanOrder = 29
-    editOrder = 29 #--Run ahead of bow patcher
-    name = _('Import Spell Stats')
-    text = _("Import stats from any spells from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = ('Spells','SpellStats')
-
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles)
-        #--To be filled by initData
-        self.id_stat = {} #--Stats keyed by long fid.
-        self.attrs = None #set in initData
-
-    def initData(self,progress):
-        """Get stats from source files."""
-        if not self.isActive: return
-        spellStats = SpellRecords(aliases=self.patchFile.aliases)
-        self.attrs = spellStats.attrs
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if reModExt.search(srcFile.s):
-                if srcPath not in modInfos: continue
-                srcInfo = modInfos[GPath(srcFile)]
-                spellStats.readFromMod(srcInfo)
-            else:
-                if srcPath not in patchesDir: continue
-                spellStats.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        self.id_stat.update(spellStats.fid_stats)
-        self.isActive = bool(self.id_stat)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        return [MreSpel]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        return [MreSpel]
-
-    def scanModFile(self, modFile, progress):
-        """Add affected items to patchFile."""
-        if not self.isActive or 'SPEL' not in modFile.tops:
-            return
-        id_stat = self.id_stat
-        mapper = modFile.getLongMapper()
-        attrs = self.attrs
-        patchBlock = self.patchFile.SPEL
-        id_records = patchBlock.id_records
-        for record in modFile.SPEL.getActiveRecords():
-            fid = record.fid
-            if not record.longFids: fid = mapper(fid)
-            if fid in id_records: continue
-            spellStats = id_stat.get(fid)
-            if not spellStats: continue
-            oldValues = [getattr_deep(record, attr) for attr in attrs]
-            if oldValues != spellStats:
-                patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress):
-        """Adds merged lists to patchfile."""
-        if not self.isActive: return
-        patchFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        id_stat = self.id_stat
-        allCounts = []
-        attrs = self.attrs
-        count,counts = 0,{}
-        for record in patchFile.SPEL.records:
-            fid = record.fid
-            spellStats = id_stat.get(fid)
-            if not spellStats: continue
-            oldValues = [getattr_deep(record, attr) for attr in attrs]
-            if oldValues == spellStats: continue
-            for attr,value in zip(attrs,spellStats):
-                setattr_deep(record,attr,value)
-            keep(fid)
-            count += 1
-            counts[fid[0]] = 1 + counts.get(fid[0],0)
-        allCounts.append(('SPEL',count,counts))
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Modified Stats"))
-        for type,count,counts in allCounts:
-            if not count: continue
-            typeName = {'SPEL':_('Spells'),}[type]
-            log("* %s: %d" % (typeName,count))
-            for modName in sorted(counts):
-                log("  * %s: %d" % (modName.s,counts[modName]))
-
-
-class CBash_SpellsPatcher(CBash_ImportPatcher):
-    """Import spell changes from mod files."""
-    scanOrder = 29
-    editOrder = 29 #--Run ahead of bow patcher
-    name = _('Import Spell Stats')
-    text = _("Import stats from any spells from source mods/files.")
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Spells','SpellStats'))
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.id_stats = {}
-        self.csvId_stats = {}
-        self.mod_count = {}
-        self.attrs = None #set in initData
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        CBash_ImportPatcher.initData(self,type_patchers,progress)
-        spellStats = CBash_SpellRecords(aliases=self.patchFile.aliases)
-        self.attrs = spellStats.attrs
-        progress.setFull(len(self.srcs))
-        patchesDir = dirs['patches'].list()
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            if not reModExt.search(srcFile.s):
-                if srcPath not in patchesDir: continue
-                spellStats.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-        #--Finish
-        self.csvId_stats.update(spellStats.fid_stats)
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['SPEL']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        self.id_stats.setdefault(record.fid,{}).update(record.ConflictDetails(self.attrs))
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-
-        recordId = record.fid
-        prev_values = self.id_stats.get(recordId, None)
-        prev_values = self.csvId_stats.get(recordId, prev_values)
-        if prev_values:
-            rec_values = dict((attr,getattr(record,attr)) for attr in prev_values)
-            if rec_values != prev_values:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for attr, value in prev_values.iteritems():
-                        setattr(override,attr,value)
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Modified SPEL Stats: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-# Patchers: 30 ----------------------------------------------------------------
-#------------------------------------------------------------------------------
-class AssortedTweak_ArmorShows(MultiTweakItem):
-    """Fix armor to show amulets/rings."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key):
-        MultiTweakItem.__init__(self,label,tip,key)
-        self.hidesBit = {'armorShowsRings':16,'armorShowsAmulets':17}[key]
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreArmo,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreArmo,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.ARMO
-        hidesBit = self.hidesBit
-        for record in modFile.ARMO.getActiveRecords():
-            if record.flags[hidesBit] and not record.flags.notPlayable:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        hidesBit = self.hidesBit
-        for record in patchFile.ARMO.records:
-            if record.flags[hidesBit] and not record.flags.notPlayable:
-                record.flags[hidesBit] = False
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader('=== '+self.label)
-        log(_('* Armor Pieces Tweaked: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_ArmorShows(CBash_MultiTweakItem):
-    """Fix armor to show amulets/rings."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Armor Tweaks')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key):
-        CBash_MultiTweakItem.__init__(self,label,tip,key)
-        self.hideFlag = {'armorShowsRings':'IsHideRings','armorShowsAmulets':'IsHideAmulets'}[key]
-        self.mod_count = {}
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['ARMO']
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if record.IsNonPlayable:
-            return
-
-        if (getattr(record, self.hideFlag)):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                setattr(override, self.hideFlag, False)
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        log.setHeader('=== '+self.label)
-        log(_('* Armor Pieces Tweaked: %d') % (sum(self.mod_count.values()),))
-        for srcMod in modInfos.getOrdered(self.mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,self.mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_ClothingShows(MultiTweakItem):
-    """Fix robes, gloves and the like to show amulets/rings."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key):
-        MultiTweakItem.__init__(self,label,tip,key)
-        self.hidesBit = {'ClothingShowsRings':16,'ClothingShowsAmulets':17}[key]
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreClot,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreClot,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.CLOT
-        hidesBit = self.hidesBit
-        for record in modFile.CLOT.getActiveRecords():
-            if record.flags[hidesBit] and not record.flags.notPlayable:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        hidesBit = self.hidesBit
-        for record in patchFile.CLOT.records:
-            if record.flags[hidesBit] and not record.flags.notPlayable:
-                record.flags[hidesBit] = False
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader('=== '+self.label)
-        log(_('* Clothing Pieces Tweaked: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_ClothingShows(CBash_MultiTweakItem):
-    """Fix robes, gloves and the like to show amulets/rings."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Clothing Tweaks')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key):
-        CBash_MultiTweakItem.__init__(self,label,tip,key)
-        self.hideFlag = {'ClothingShowsRings':'IsHideRings','ClothingShowsAmulets':'IsHideAmulets'}[key]
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CLOT']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if record.IsNonPlayable:
-            return
-        if (getattr(record, self.hideFlag)):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                setattr(override, self.hideFlag, False)
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.label)
-        log(_('* Clothing Pieces Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_BowReach(MultiTweakItem):
-    """Fix bows to have reach = 1.0."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Bow Reach Fix"),
-            _('Fix bows with zero reach. (Zero reach causes CTDs.)'),
-            'BowReach',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreWeap,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreWeap,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.WEAP
-        for record in modFile.WEAP.getActiveRecords():
-            if record.weaponType == 5 and record.reach <= 0:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.WEAP.records:
-            if record.weaponType == 5 and record.reach <= 0:
-                record.reach = 1
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Bow Reach Fix'))
-        log(_('* Bows fixed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_BowReach(CBash_MultiTweakItem):
-    """Fix bows to have reach = 1.0."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Bow Reach Fix')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Bow Reach Fix"),
-            _('Fix bows with zero reach. (Zero reach causes CTDs.)'),
-            'BowReach',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['WEAP']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if (record.IsBow and record.reach <= 0):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.reach = 1.0
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Bow Reach Fix'))
-        log(_('* Bows fixed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_ConsistentRings(MultiTweakItem):
-    """Sets rings to all work on same finger."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Right Hand Rings"),
-            _('Fixes rings to unequip consistently by making them prefer the right hand.'),
-            'ConsistentRings',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreClot,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreClot,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.CLOT
-        for record in modFile.CLOT.getActiveRecords():
-            if record.flags.leftRing:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.CLOT.records:
-            if record.flags.leftRing:
-                record.flags.leftRing = False
-                record.flags.rightRing = True
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Right Hand Rings'))
-        log(_('* Rings fixed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_AssortedTweak_ConsistentRings(CBash_MultiTweakItem):
-    """Sets rings to all work on same finger."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Right Hand Rings')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Right Hand Rings"),
-            _('Fixes rings to unequip consistently by making them prefer the right hand.'),
-            'ConsistentRings',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CLOT']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsLeftRing:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.IsLeftRing = False
-                override.IsRightRing = True
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Right Hand Rings'))
-        log(_('* Rings fixed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_ClothingPlayable(MultiTweakItem):
-    """Sets all clothes to playable"""
-    reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)|(?:ghostly immobility)|(?:corspe)',re.I)
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("All Clothing Playable"),
-            _('Sets all clothing to be playable.'),
-            'PlayableClothing',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreClot,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreClot,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.CLOT
-        for record in modFile.CLOT.getActiveRecords():
-            if record.flags.notPlayable:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        reSkip = self.reSkip
-        for record in patchFile.CLOT.records:
-            if record.flags.notPlayable:
-                full = record.full
-                if not full: continue
-                if record.script: continue
-                if reSkip.search(full): continue #probably truly shouldn't be playable
-                #If only the right ring and no other body flags probably a token that wasn't zeroed (which there are a lot of).
-                if record.flags.leftRing != 0 or record.flags.foot != 0 or record.flags.hand != 0 or record.flags.amulet != 0 or record.flags.lowerBody != 0 or record.flags.upperBody != 0 or record.flags.head != 0 or record.flags.hair != 0 or record.flags.tail != 0:
-                    record.flags.notPlayable = 0
-                    keep(record.fid)
-                    srcMod = record.fid[0]
-                    count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Playable Clothes'))
-        log(_('* Clothes set as playable: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_ClothingPlayable(CBash_MultiTweakItem):
-    """Sets all clothes to playable"""
-    scanOrder = 29 #Run before the show clothing tweaks
-    editOrder = 29
-    name = _('Playable Clothes')
-    reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)|(?:ghostly immobility)|(?:corspe)',re.I)
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("All Clothing Playable"),
-            _('Sets all clothing to be playable.'),
-            'PlayableClothing',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CLOT']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsNonPlayable:
-            full = record.full
-            if not full: return
-            if record.script: return
-            if self.reSkip.search(full): return #probably truly shouldn't be playable
-            #If only the right ring and no other body flags probably a token that wasn't zeroed (which there are a lot of).
-            if record.IsLeftRing or record.IsFoot or record.IsHand or record.IsAmulet or record.IsLowerBody or record.IsUpperBody or record.IsHead or record.IsHair or record.IsTail:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.IsNonPlayable = False
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Playable Clothes'))
-        log(_('* Clothes set as playable: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_ArmorPlayable(MultiTweakItem):
-    """Sets all armors to be playable"""
-    reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)',re.I)
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("All Armor Playable"),
-            _('Sets all armor to be playable.'),
-            'PlayableArmor',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreArmo,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreArmo,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.ARMO
-        for record in modFile.ARMO.getActiveRecords():
-            if record.flags.notPlayable:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        reSkip = self.reSkip
-        for record in patchFile.ARMO.records:
-            if record.flags.notPlayable:
-                full = record.full
-                if not full: continue
-                if record.script: continue
-                if reSkip.search(full): continue #probably truly shouldn't be playable
-                # We only want to set playable if the record has at least one body flag... otherwise most likely a token.
-                if record.flags.leftRing != 0 or record.flags.rightRing != 0 or record.flags.foot != 0 or record.flags.hand != 0 or record.flags.amulet != 0 or record.flags.lowerBody != 0 or record.flags.upperBody != 0 or record.flags.head != 0 or record.flags.hair != 0 or record.flags.tail != 0 or record.flags.shield != 0:
-                    record.flags.notPlayable = 0
-                    keep(record.fid)
-                    srcMod = record.fid[0]
-                    count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Playable Armor'))
-        log(_('* Armor pieces set as playable: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_AssortedTweak_ArmorPlayable(CBash_MultiTweakItem):
-    """Sets all armors to be playable"""
-    scanOrder = 29 #Run before the show armor tweaks
-    editOrder = 29
-    name = _('Playable Armor')
-    reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)',re.I)
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("All Armor Playable"),
-            _('Sets all armor to be playable.'),
-            'PlayableArmor',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['ARMO']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsNonPlayable:
-            full = record.full
-            if not full: return
-            if record.script: return
-            if self.reSkip.search(full): return #probably truly shouldn't be playable
-            #If no body flags are set it is probably a token.
-            if record.IsLeftRing or record.IsRightRing or record.IsFoot or record.IsHand or record.IsAmulet or record.IsLowerBody or record.IsUpperBody or record.IsHead or record.IsHair or record.IsTail or record.IsShield:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.IsNonPlayable = False
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Playable Armor'))
-        log(_('* Armor pieces set as playable: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_DarnBooks(MultiTweakItem):
-    """DarNifies books."""
-    scanOrder = 32
-    editOrder = 32
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("DarNified Books"),
-            _('Books will be reformatted for DarN UI.'),
-            'DarnBooks',
-            ('default',  'default'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreBook,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreBook,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.BOOK
-        id_records = patchBlock.id_records
-        for record in modFile.BOOK.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if not record.enchantment:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        reColor = re.compile(r'<font color="?([a-fA-F0-9]+)"?>',re.I+re.M)
-        reTagInWord = re.compile(r'([a-z])<font face=1>',re.M)
-        reFont1 = re.compile(r'(<?<font face=1( ?color=[0-9a-zA]+)?>)+',re.I+re.M)
-        reDiv = re.compile(r'<div',re.I+re.M)
-        reFont = re.compile(r'<font',re.I+re.M)
-        keep = patchFile.getKeeper()
-        reHead2 = re.compile(r'^(<<|\^\^|>>|)==\s*(\w[^=]+?)==\s*\r\n',re.M)
-        reHead3 = re.compile(r'^(<<|\^\^|>>|)===\s*(\w[^=]+?)\r\n',re.M)
-        reBold = re.compile(r'(__|\*\*|~~)')
-        reAlign = re.compile(r'^(<<|\^\^|>>)',re.M)
-        align_text = {'^^':'center','<<':'left','>>':'right'}
-        self.inBold = False
-        def replaceBold(mo):
-            self.inBold = not self.inBold
-            str = '<font face=3 color=%s>' % ('444444','440000')[self.inBold]
-            return str
-        def replaceAlign(mo):
-            return '<div align=%s>' % align_text[mo.group(1)]
-        for record in patchFile.BOOK.records:
-            if record.text and not record.enchantment:
-                text = record.text
-                if reHead2.match(text):
-                    inBold = False
-                    text = reHead2.sub(r'\1<font face=1 color=220000>\2<font face=3 color=444444>\r\n',text)
-                    text = reHead3.sub(r'\1<font face=3 color=220000>\2<font face=3 color=444444>\r\n',text)
-                    text = reAlign.sub(replaceAlign,text)
-                    text = reBold.sub(replaceBold,text)
-                    text = re.sub(r'\r\n',r'<br>\r\n',text)
-                else:
-                    maColor = reColor.search(text)
-                    if maColor:
-                        color = maColor.group(1)
-                    elif record.flags.isScroll:
-                        color = '000000'
-                    else:
-                        color = '444444'
-                    fontFace = '<font face=3 color='+color+'>'
-                    text = reTagInWord.sub(r'\1',text)
-                    text.lower()
-                    if reDiv.search(text) and not reFont.search(text):
-                        text = fontFace+text
-                    else:
-                        text = reFont1.sub(fontFace,text)
-                if text != record.text:
-                    record.text = text
-                    keep(record.fid)
-                    srcMod = record.fid[0]
-                    count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader('=== '+self.label)
-        log(_('* Books DarNified: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_DarnBooks(CBash_MultiTweakItem):
-    """DarNifies books."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Books DarNified')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("DarNified Books"),
-            _('Books will be reformatted for DarN UI.'),
-            'DarnBooks',
-            ('default',  'default'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['BOOK']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        def replaceBold(mo):
-            self.inBold = not self.inBold
-            str = '<font face=3 color=%s>' % ('444444','440000')[self.inBold]
-            return str
-        def replaceAlign(mo):
-            return '<div align=%s>' % align_text[mo.group(1)]
-
-        if record.text and not record.enchantment:
-            text = record.text
-
-            reColor = re.compile(r'<font color="?([a-fA-F0-9]+)"?>',re.I+re.M)
-            reTagInWord = re.compile(r'([a-z])<font face=1>',re.M)
-            reFont1 = re.compile(r'(<?<font face=1( ?color=[0-9a-zA]+)?>)+',re.I+re.M)
-            reDiv = re.compile(r'<div',re.I+re.M)
-            reFont = re.compile(r'<font',re.I+re.M)
-            reHead2 = re.compile(r'^(<<|\^\^|>>|)==\s*(\w[^=]+?)==\s*\r\n',re.M)
-            reHead3 = re.compile(r'^(<<|\^\^|>>|)===\s*(\w[^=]+?)\r\n',re.M)
-            reBold = re.compile(r'(__|\*\*|~~)')
-            reAlign = re.compile(r'^(<<|\^\^|>>)',re.M)
-            align_text = {'^^':'center','<<':'left','>>':'right'}
-            self.inBold = False
-            if reHead2.match(text):
-                text = reHead2.sub(r'\1<font face=1 color=220000>\2<font face=3 color=444444>\r\n',text)
-                text = reHead3.sub(r'\1<font face=3 color=220000>\2<font face=3 color=444444>\r\n',text)
-                text = reAlign.sub(replaceAlign,text)
-                text = reBold.sub(replaceBold,text)
-                text = re.sub(r'\r\n',r'<br>\r\n',text)
-            else:
-                maColor = reColor.search(text)
-                if maColor:
-                    color = maColor.group(1)
-                elif record.IsScroll:
-                    color = '000000'
-                else:
-                    color = '444444'
-                fontFace = '<font face=3 color='+color+'>'
-                text = reTagInWord.sub(r'\1',text)
-                text.lower()
-                if reDiv.search(text) and not reFont.search(text):
-                    text = fontFace+text
-                else:
-                    text = reFont1.sub(fontFace,text)
-            if text != record.text:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.text = text
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.label)
-        log(_('* Books DarNified: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_FogFix(MultiTweakItem):
-    """Fix fog in cell to be non-zero."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Nvidia Fog Fix"),
-            _('Fix fog related Nvidia black screen problems.'),
-            'FogFix',
-            ('0.0001',  '0.0001'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreCell,MreWrld)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreCell,MreWrld)
-
-    def scanModFile(self, modFile, progress,patchFile):
-        """Add lists from modFile."""
-        if 'CELL' not in modFile.tops: return
-        patchCells = patchFile.CELL
-        modFile.convertToLongFids(('CELL',))
-        for cellBlock in modFile.CELL.cellBlocks:
-            cell = cellBlock.cell
-            if not (cell.fogNear or cell.fogFar or cell.fogClip):
-                patchCells.setCell(cell)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Adds merged lists to patchfile."""
-        keep = patchFile.getKeeper()
-        count = {}
-        for cellBlock in patchFile.CELL.cellBlocks:
-            for cellBlock in patchFile.CELL.cellBlocks:
-                cell = cellBlock.cell
-                if not (cell.fogNear or cell.fogFar or cell.fogClip):
-                    cell.fogNear = 0.0001
-                    keep(cell.fid)
-                    count.setdefault(cell.fid[0],0)
-                    count[cell.fid[0]] += 1
-        #--Log
-        log.setHeader(_('=== Nvidia Fog Fix'))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_FogFix(CBash_MultiTweakItem):
-    """Fix fog in cell to be non-zero."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Nvidia Fog Fix')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Nvidia Fog Fix"),
-            _('Fix fog related Nvidia black screen problems.'),
-            'FogFix',
-            ('0.0001',  '0.0001'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CELL'] #or 'CELLS' to also affect worldspaces. Don't think it's a problem in those cells though.
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if not (record.fogNear or record.fogFar or record.fogClip):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.fogNear = 0.0001
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Nvidia Fog Fix'))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_NoLightFlicker(MultiTweakItem):
-    """Remove light flickering for low end machines."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("No Light Flicker"),
-            _('Remove flickering from lights. For use on low-end machines.'),
-            'NoLightFlicker',
-            ('1.0',  '1.0'),
-            )
-        self.flags = flags = MreLigh._flags()
-        flags.flickers = flags.flickerSlow = flags.pulse = flags.pulseSlow = True
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreLigh,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreLigh,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        flickerFlags = self.flags
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.LIGH
-        for record in modFile.LIGH.getActiveRecords():
-            if record.flags & flickerFlags:
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        flickerFlags = self.flags
-        notFlickerFlags = ~flickerFlags
-        keep = patchFile.getKeeper()
-        for record in patchFile.LIGH.records:
-            if int(record.flags & flickerFlags):
-                record.flags &= notFlickerFlags
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== No Light Flicker'))
-        log(_('* Lights unflickered: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_NoLightFlicker(CBash_MultiTweakItem):
-    """Remove light flickering for low end machines."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('No Light Flicker')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("No Light Flicker"),
-            _('Remove flickering from lights. For use on low-end machines.'),
-            'NoLightFlicker',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['LIGH']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if (record.IsFlickers or record.IsFlickerSlow or record.IsPulse or record.IsPulseSlow):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.IsFlickers = False
-                override.IsFlickerSlow = False
-                override.IsPulse = False
-                override.IsPulseSlow = False
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== No Light Flicker'))
-        log(_('* Lights unflickered: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_PotionWeight(MultiTweakItem):
-    """Reweighs standard potions down to 0.1."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Reweigh: Potions (Maximum)"),
-            _('Potion weight will be capped.'),
-            'MaximumPotionWeight',
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreAlch,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreAlch,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.ALCH
-        id_records = patchBlock.id_records
-        for record in modFile.ALCH.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.weight > maxWeight and record.weight < 1:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.ALCH.records:
-            if record.weight > maxWeight and record.weight < 1 and not ('SEFF',0) in record.getEffects():
-                record.weight = maxWeight
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Reweigh: Potions (Maximum)'))
-        log(_('Potions set to maximum weight of %f') % maxWeight)
-        log(_('* Potions Reweighed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_PotionWeight(CBash_MultiTweakItem):
-    """Reweighs standard potions down to 0.1."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Reweigh: Potions (Maximum)")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Reweigh: Potions (Maximum)"),
-            _('Potion weight will be capped.'),
-            'MaximumPotionWeight',
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0.0),
-            )
-        self.mod_count = {}
-        self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
-
-    def getTypes(self):
-        return ['ALCH']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        maxWeight = self.choiceValues[self.chosen][0]
-        SEFFValue = self.SEFFValue
-        if (record.weight > maxWeight and record.weight < 1.0):
-            for effect in record.effects:
-                if effect.name == SEFFValue: #name actually returns a UINT32 or MGEFCode
-                    return
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = maxWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Reweigh: Potions (Maximum)'))
-        log(_('Potions set to maximum weight of %f') % self.choiceValues[self.chosen][0])
-        log(_('* Potions Reweighed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_IngredientWeight(MultiTweakItem):
-    """Reweighs standard ingredients down to 0.1."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Reweigh: Ingredients"),
-            _('Ingredient weight will be capped.'),
-            'MaximumIngredientWeight',
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreIngr,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreIngr,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.INGR
-        id_records = patchBlock.id_records
-        for record in modFile.INGR.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.weight > maxWeight:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.INGR.records:
-            if record.weight > maxWeight:
-                record.weight = maxWeight
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Reweigh: Ingredients'))
-        log(_('Ingredients set to maximum weight of %f') % maxWeight)
-        log(_('* Ingredients Reweighed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_IngredientWeight(CBash_MultiTweakItem):
-    """Reweighs standard ingredients down to 0.1."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Reweigh: Ingredients')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Reweigh: Ingredients"),
-            _('Ingredient weight will be capped.'),
-            'MaximumIngredientWeight',
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0.0),
-            )
-        self.mod_count = {}
-        self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
-
-    def getTypes(self):
-        return ['INGR']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        maxWeight = self.choiceValues[self.chosen][0]
-        SEFFValue = self.SEFFValue
-
-        if record.weight > maxWeight:
-            for effect in record.effects:
-                if effect.name == SEFFValue: #name actually returns a UINT32 or MGEFCode
-                    return
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = maxWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Reweigh: Ingredients'))
-        log(_('Ingredients set to maximum weight of %f') % self.choiceValues[self.chosen][0])
-        log(_('* Ingredients Reweighed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_PotionWeightMinimum(MultiTweakItem):
-    """Reweighs any potions up to 4."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Reweigh: Potions (Minimum)"),
-            _('Potion weight will be floored.'),
-            'MinimumPotionWeight',
-            (_('1'),  1),
-            (_('2'),  2),
-            (_('3'),  3),
-            (_('4'),  4),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreAlch,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreAlch,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        minWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.ALCH
-        id_records = patchBlock.id_records
-        for record in modFile.ALCH.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.weight < minWeight:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        minWeight = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.ALCH.records:
-            if record.weight < minWeight:
-                record.weight = minWeight
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Reweigh: Potions (Minimum)'))
-        log(_('Potions set to minimum weight of %f') % minWeight)
-        log(_('* Potions Reweighed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_PotionWeightMinimum(CBash_MultiTweakItem):
-    """Reweighs any potions up to 4."""
-    scanOrder = 33 #Have it run after the max weight for consistent results
-    editOrder = 33
-    name = _('Reweigh: Potions (Minimum)')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Reweigh: Potions (Minimum)"),
-            _('Potion weight will be floored.'),
-            'MinimumPotionWeight',
-            (_('1'),  1),
-            (_('2'),  2),
-            (_('3'),  3),
-            (_('4'),  4),
-            (_('Custom'),0.0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['ALCH']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        minWeight = self.choiceValues[self.chosen][0]
-        if (record.weight < minWeight):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = minWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Reweigh: Potions (Minimum)'))
-        log(_('Potions set to minimum weight of %f') % self.choiceValues[self.chosen][0])
-        log(_('* Potions Reweighed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_StaffWeight(MultiTweakItem):
-    """Reweighs staffs."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Reweigh: Staffs"),
-            _('Staff weight will be capped.'),
-            'StaffWeight',
-            (_('1'),  1),
-            (_('2'),  2),
-            (_('3'),  3),
-            (_('4'),  4),
-            (_('5'),  5),
-            (_('6'),  6),
-            (_('7'),  7),
-            (_('8'),  8),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreWeap,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreWeap,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.WEAP
-        id_records = patchBlock.id_records
-        for record in modFile.WEAP.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.weaponType == 4 and record.weight > maxWeight:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.WEAP.records:
-            if record.weaponType == 4 and record.weight > maxWeight:
-                record.weight = maxWeight
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Reweigh: Staffs'))
-        log(_('Staffs set to maximum weight of %f') % maxWeight)
-        log(_('* Staffs Reweighed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_StaffWeight(CBash_MultiTweakItem):
-    """Reweighs staffs."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Reweigh: Staffs')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Reweigh: Staffs"),
-            _('Staff weight will be capped.'),
-            'StaffWeight',
-            (_('1'),  1.0),
-            (_('2'),  2.0),
-            (_('3'),  3.0),
-            (_('4'),  4.0),
-            (_('5'),  5.0),
-            (_('6'),  6.0),
-            (_('7'),  7.0),
-            (_('8'),  8.0),
-            (_('Custom'),0.0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['WEAP']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        maxWeight = self.choiceValues[self.chosen][0]
-
-        if (record.IsStaff and record.weight > maxWeight):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = maxWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Reweigh: Staffs'))
-        log(_('Staffs set to maximum weight of %f') % self.choiceValues[self.chosen][0])
-        log(_('* Staffs Reweighed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_ArrowWeight(MultiTweakItem):
-    """Reweighs standard arrows down to 0."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Reweigh: Arrows"),
-            _('Arrow weights will be capped.'),
-            'MaximumArrowWeight',
-            (_('0'),    0),
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0.0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreAmmo,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreAmmo,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.AMMO
-        id_records = patchBlock.id_records
-        for record in modFile.AMMO.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.weight > maxWeight:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        maxWeight = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.AMMO.records:
-            if record.weight > maxWeight:
-                record.weight = maxWeight
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Reweigh: Arrows'))
-        log(_('Arrows set to maximum weight of %f') % maxWeight)
-        log(_('* Arrows Reweighed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_ArrowWeight(CBash_MultiTweakItem):
-    """Reweighs standard arrows down to 0.1."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Reweigh: Arrows')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Reweigh: Arrows"),
-            _('Arrow weights will be capped.'),
-            'MaximumArrowWeight',
-            (_('0'), 0.0),
-            (_('0.1'),  0.1),
-            (_('0.2'),  0.2),
-            (_('0.4'),  0.4),
-            (_('0.6'),  0.6),
-            (_('Custom'),0.0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['AMMO']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        maxWeight = self.choiceValues[self.chosen][0]
-
-        if record.weight > maxWeight:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = maxWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Reweigh: Arrows'))
-        log(_('Arrows set to maximum weight of %f') % self.choiceValues[self.chosen][0])
-        log(_('* Arrows Reweighed: %d') % (sum(mod_count.values())))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_ScriptEffectSilencer(MultiTweakItem):
-    """Silences and invisibleates the Script Effect."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Magic: Script Effect Silencer"),
-            _('Script Effect will be silenced and have no graphics.'),
-            'SilentScriptEffect',
-            (_('0'),    0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreMgef,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreMgef,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.MGEF
-        id_records = patchBlock.id_records
-        modFile.convertToLongFids(('MGEF',))
-        for record in modFile.MGEF.getActiveRecords():
-            fid = record.fid
-            if not record.longFids: fid = mapper(fid)
-            if fid in id_records: continue
-            if record.eid != 'SEFF': continue
-            patchBlock.setRecord(record.getTypeCopy(mapper))
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        nullRef = (GPath('Oblivion.esm'),0)
-        silentattrs = {
-            'model' : None,
-            'projectileSpeed' : 9999,
-            'light' : nullRef,
-            'effectShader' : nullRef,
-            'enchantEffect' : nullRef,
-            'castingSound' : nullRef,
-            'boltSound' : nullRef,
-            'hitSound' : nullRef,
-            'areaSound' : nullRef}
-        keep = patchFile.getKeeper()
-        for record in patchFile.MGEF.records:
-            if record.eid != 'SEFF' or not record.longFids: continue
-            record.flags.noHitEffect = True
-            for attr in silentattrs:
-                if getattr(record,attr) != silentattrs[attr]:
-                    setattr(record,attr,silentattrs[attr])
-                    keep(record.fid)
-        #--Log
-        log.setHeader(_('=== Magic: Script Effect Silencer'))
-        log(_('Script Effect silenced.'))
-class CBash_AssortedTweak_ScriptEffectSilencer(CBash_MultiTweakItem):
-    """Reweighs standard arrows down to 0.1."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Magic: Script Effect Silencer')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Magic: Script Effect Silencer"),
-             _('Script Effect will be silenced and have no graphics.'),
-            'SilentScriptEffect',
-            (_('0'),    0),
-            )
-        self.attrs = ['modPath','modb','modt_p','projectileSpeed','light','effectShader',
-                      'enchantEffect','castingSound','boltSound','hitSound','areaSound',
-                      'IsNoHitEffect']
-        self.newValues = [None,None,None,9999,None,None,None,None,None,None,None,True]
-
-    def getTypes(self):
-        return ['MGEF']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.eid == 'SEFF':
-            attrs = self.attrs
-            newValues = self.newValues
-            oldValues = map(record.__getattribute__, attrs)
-            if oldValues != newValues:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    map(record.__setattr__, attrs, newValues)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        log.setHeader(_('=== Magic: Script Effect Silencer'))
-        log(_('Script Effect silenced.'))
-#------------------------------------------------------------------------------
-class AssortedTweak_HarvestChance(MultiTweakItem):
-    """Sets Harvest Chances."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Harvest Chance"),
-            _('Harvest chances on all plants will be set to the chosen percentage.'),
-            'HarvestChance',
-            (_('10%'),  10),
-            (_('20%'),  20),
-            (_('30%'),  30),
-            (_('40%'),  40),
-            (_('50%'),  50),
-            (_('60%'),  60),
-            (_('70%'),  70),
-            (_('80%'),  80),
-            (_('90%'),  90),
-            (_('100%'), 100),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreFlor,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreFlor,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        chance = self.choiceValues[self.chosen][0]
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.FLOR
-        id_records = patchBlock.id_records
-        for record in modFile.FLOR.getActiveRecords():
-            if record.eid.startswith('Nirnroot'): continue #skip Nirnroots
-            if mapper(record.fid) in id_records: continue
-            for attr in ['spring','summer','fall','winter']:
-                if getattr(record,attr) != chance:
-                    record = record.getTypeCopy(mapper)
-                    patchBlock.setRecord(record)
-                    break
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        chance = self.choiceValues[self.chosen][0]
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.FLOR.records:
-            record.spring,record.summer,record.fall,record.winter = chance, chance, chance, chance
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Harvest Chance'))
-        log(_('* Harvest Chances Changed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_HarvestChance(CBash_MultiTweakItem):
-    """Adjust Harvest Chances."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Harvest Chance')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Harvest Chance"),
-            _('Harvest chances on all plants will be set to the chosen percentage.'),
-            'HarvestChance',
-            (_('10%'),  10),
-            (_('20%'),  20),
-            (_('30%'),  30),
-            (_('40%'),  40),
-            (_('50%'),  50),
-            (_('60%'),  60),
-            (_('70%'),  70),
-            (_('80%'),  80),
-            (_('90%'),  90),
-            (_('100%'), 100),
-            (_('Custom'),0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['FLOR']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        chance = self.choiceValues[self.chosen][0]
-        if record.eid.startswith('Nirnroot'): return #skip Nirnroots
-        for attr in ['spring','summer','fall','winter']:
-            if getattr(record,attr) != chance:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.spring,override.summer,override.fall,override.winter = chance, chance, chance, chance
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-                break
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Harvest Chance'))
-        log(_('* Harvest Chances Changed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_WindSpeed(MultiTweakItem):
-    """Disables WTHR winds."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Disable Wind"),
-            _('Disables the wind on all weathers.'),
-            'windSpeed',
-            (_('Disable'),  0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreWthr,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreWthr,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.WTHR
-        id_records = patchBlock.id_records
-        for record in modFile.WTHR.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.windSpeed != 0:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.WTHR.records:
-            if record.windSpeed != 0:
-                record.windSpeed = 0
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Disable Wind'))
-        log(_('* Winds Disabled: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_WindSpeed(CBash_MultiTweakItem):
-    """Disables Weather winds."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Disable Wind')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Disable Wind"),
-            _('Disables the wind on all weathers.'),
-            'windSpeed',
-            (_('Disable'),  0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['WTHR']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.windSpeed != 0:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.windSpeed = 0
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Disable Wind'))
-        log(_('* Winds Disabled: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_SetCastWhenUsedEnchantmentCosts(MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-#info: 'itemType','chargeAmount','enchantCost'
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Number of uses for pre-enchanted weapons and staffs"),
-            _('The charge amount and cast cost will be edited so that all enchanted weapons and staffs have the amount of uses specified. Cost will be rounded up to 1 (unless set to unlimited) so number of uses may not exactly match for all weapons.'),
-            'Number of uses:',
-            (_('1'), 1),
-            (_('5'), 5),
-            (_('10'), 10),
-            (_('20'), 20),
-            (_('30'), 30),
-            (_('40'), 40),
-            (_('50'), 50),
-            (_('80'), 80),
-            (_('100'), 100),
-            (_('250'), 250),
-            (_('500'), 500),
-            (_('Unlimited'), 0),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreEnch,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreEnch,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.ENCH
-        id_records = patchBlock.id_records
-        for record in modFile.ENCH.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.itemType in [1,2]:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.ENCH.records:
-            if record.itemType in [1,2]:
-                uses = self.choiceValues[self.chosen][0]
-                cost = uses
-                if uses != 0:
-                    cost = max(record.chargeAmount/uses,1)
-                record.enchantCost = cost
-                record.chargeAmount = cost * uses
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Set Enchantment Number of Uses'))
-        log(_('* Enchantments set: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_SetCastWhenUsedEnchantmentCosts(CBash_MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Set Enchantment Number of Uses')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Number of uses for pre-enchanted weapons and staffs"),
-            _('The charge amount and cast cost will be edited so that all enchanted weapons and staffs have the amount of uses specified. Cost will be rounded up to 1 (unless set to unlimited) so number of uses may not exactly match for all weapons.'),
-            'Number of uses:',
-            (_('1'), 1),
-            (_('5'), 5),
-            (_('10'), 10),
-            (_('20'), 20),
-            (_('30'), 30),
-            (_('40'), 40),
-            (_('50'), 50),
-            (_('80'), 80),
-            (_('100'), 100),
-            (_('250'), 250),
-            (_('500'), 500),
-            (_('Unlimited'), 0),
-            (_('Custom'),0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['ENCH']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-
-        if (record.IsStaff or record.IsWeapon):
-            uses = self.choiceValues[self.chosen][0]
-            cost = uses
-            if uses != 0:
-                cost = max(record.chargeAmount/uses,1)
-            amount = cost * uses
-            if record.enchantCost != cost or record.chargeAmount != amount:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.enchantCost = cost
-                    override.chargeAmount = amount
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Set Enchantment Number of Uses'))
-        log(_('* Enchantments set: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_DefaultIcons(MultiTweakItem):
-    """Sets a default icon for any records that don't have any icon assigned."""
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        self.activeTypes = ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
-                            'CLAS','CLOT','FACT','INGR','KEYM','LIGH',
-                            'MISC','QUST','SGST','SLGM','WEAP']
-        MultiTweakItem.__init__(self,_("Default Icons"),
-            _("Sets a default icon for any records that don't have any icon assigned"),
-            'icons',
-            (_('1'), 1),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
-                MreClas,MreClot,MreFact,MreIngr,MreKeym,MreLigh,
-                MreMisc,MreQust,MreSgst,MreSlgm,MreWeap)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
-                MreClas,MreClot,MreFact,MreIngr,MreKeym,MreLigh,
-                MreMisc,MreQust,MreSgst,MreSlgm,MreWeap)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        for blockType in self.activeTypes:
-            if blockType not in modFile.tops: continue
-            modBlock = getattr(modFile,blockType)
-            patchBlock = getattr(patchFile,blockType)
-            id_records = patchBlock.id_records
-            for record in modBlock.getActiveRecords():
-                if mapper(record.fid) not in id_records:
-                    record = record.getTypeCopy(mapper)
-                    patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        count = {}
-        keep = patchFile.getKeeper()
-        for type in self.activeTypes:
-            if type not in patchFile.tops: continue
-            for record in patchFile.tops[type].records:
-                changed = False
-                try:
-                    if record.icon: continue
-                except:
-                    try:
-                        if record.maleIcon or record.femaleIcon: continue
-                        if record.flags.notPlayable: continue
-                    except: continue
-                if type == 'ALCH':
-                    record.icon = r"Clutter\Potions\IconPotion01.dds"
-                    changed = True
-                elif type == 'AMMO':
-                    record.icon = r"Weapons\IronArrow.dds"
-                    changed = True
-                elif type == 'APPA':
-                    record.icon = r"Clutter\IconMortarPestle.dds"
-                    changed = True
-                elif type == 'AMMO':
-                    record.icon = r"Weapons\IronArrow.dds"
-                    changed = True
-                elif type == 'ARMO':
-                    #choose based on body flags:
-                    if record.flags.upperBody != 0:
-                        record.maleIcon = r"Armor\Iron\M\Cuirass.dds"
-                        record.femaleIcon = r"Armor\Iron\F\Cuirass.dds"
-                        changed = True
-                    elif record.flags.lowerBody != 0:
-                        record.maleIcon = r"Armor\Iron\M\Greaves.dds"
-                        record.femaleIcon = r"Armor\Iron\F\Greaves.dds"
-                        changed = True
-                    elif record.flags.head != 0 or record.flags.hair != 0:
-                        record.maleIcon = r"Armor\Iron\M\Helmet.dds"
-                        changed = True
-                    elif record.flags.hand != 0:
-                        record.maleIcon = r"Armor\Iron\M\Gauntlets.dds"
-                        record.femaleIcon = r"Armor\Iron\F\Gauntlets.dds"
-                        changed = True
-                    elif record.flags.foot != 0:
-                        record.maleIcon = r"Armor\Iron\M\Boots.dds"
-                        changed = True
-                    elif record.flags.shield != 0:
-                        record.maleIcon = r"Armor\Iron\M\Shield.dds"
-                        changed = True
-                    else: #Default icon, probably a token or somesuch
-                        record.maleIcon = r"Armor\Iron\M\Shield.dds"
-                        changed = True
-                elif type in ['BOOK','BSGN','CLAS']: #just a random book icon for class/birthsign as well.
-                    record.icon = r"Clutter\iconbook%d.dds" % (random.randint(1,13))
-                    changed = True
-                elif type == 'CLOT':
-                    #choose based on body flags:
-                    if record.flags.upperBody != 0:
-                        record.maleIcon = r"Clothes\MiddleClass\01\M\Shirt.dds"
-                        record.femaleIcon = r"Clothes\MiddleClass\01\F\Shirt.dds"
-                        changed = True
-                    elif record.flags.lowerBody != 0:
-                        record.maleIcon = r"Clothes\MiddleClass\01\M\Pants.dds"
-                        record.femaleIcon = r"Clothes\MiddleClass\01\F\Pants.dds"
-                        changed = True
-                    elif record.flags.head or record.flags.hair:
-                        record.maleIcon = r"Clothes\MythicDawnrobe\hood.dds"
-                        changed = True
-                    elif record.flags.hand != 0:
-                        record.maleIcon = r"Clothes\LowerClass\Jail\M\JailShirtHandcuff.dds"
-                        changed = True
-                    elif record.flags.foot != 0:
-                        record.maleIcon = r"Clothes\MiddleClass\01\M\Shoes.dds"
-                        record.femaleIcon = r"Clothes\MiddleClass\01\F\Shoes.dds"
-                        changed = True
-                    elif record.flags.leftRing or record.flags.rightRing:
-                        record.maleIcon = r"Clothes\Ring\RingNovice.dds"
-                        changed = True
-                    else: #amulet
-                        record.maleIcon = r"Clothes\Amulet\AmuletSilver.dds"
-                        changed = True
-                elif type == 'FACT':
-                    #todo
-                    changed = True
-                elif type == 'INGR':
-                    record.icon = r"Clutter\IconSeeds.dds"
-                    changed = True
-                elif type == 'KEYM':
-                    record.icon = [r"Clutter\Key\Key.dds",r"Clutter\Key\Key02.dds"][random.randint(0,1)]
-                    changed = True
-                elif type == 'LIGH':
-                    record.icon = r"Lights\IconTorch02.dds"
-                    changed = True
-                elif type == 'MISC':
-                    record.icon = r"Clutter\Soulgems\AzurasStar.dds"
-                    changed = True
-                elif type == 'QUST':
-                    if not record.stages: continue
-                    record.icon = r"Quest\icon_miscellaneous.dds"
-                    changed = True
-                elif type == 'SGST':
-                    record.icon = r"IconSigilStone.dds"
-                    changed = True
-                elif type == 'SLGM':
-                    record.icon = r"Clutter\Soulgems\AzurasStar.dds"
-                    changed = True
-                elif type == 'WEAP':
-                    if record.type == 0:
-                        record.icon = r"Weapons\IronDagger.dds"
-                    elif record.type == 1:
-                        record.icon = r"Weapons\IronClaymore.dds"
-                    elif record.type == 2:
-                        record.icon = r"Weapons\IronMace.dds"
-                    elif record.type == 3:
-                        record.icon = r"Weapons\IronBattleAxe.dds"
-                    elif record.type == 4:
-                        record.icon = r"Weapons\Staff.dds"
-                    elif record.type == 5:
-                        record.icon = r"Weapons\IronBow.dds"
-                    else: #Should never reach this point
-                        record.icon = r"Weapons\IronDagger.dds"
-                    changed = True
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_DefaultIcons(CBash_MultiTweakItem):
-    """Sets a default icon for any records that don't have any icon assigned."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Default Icons')
-    type_defaultIcon = {
-                'ALCH': r"Clutter\Potions\IconPotion01.dds",
-                'AMMO': r"Weapons\IronArrow.dds",
-                'APPA': r"Clutter\IconMortarPestle.dds",
-                'AMMO': r"Weapons\IronArrow.dds",
-                'ARMO': ((r"Armor\Iron\M\Cuirass.dds",r"Armor\Iron\F\Cuirass.dds"),
-                         (r"Armor\Iron\M\Greaves.dds",r"Armor\Iron\F\Greaves.dds"),
-                         (r"Armor\Iron\M\Helmet.dds",),
-                         (r"Armor\Iron\M\Gauntlets.dds",r"Armor\Iron\F\Gauntlets.dds"),
-                         (r"Armor\Iron\M\Boots.dds",),
-                         (r"Armor\Iron\M\Shield.dds",),
-                         (r"Armor\Iron\M\Shield.dds",), #Default Armor icon
-                         ),
-                'BOOK': r"Clutter\iconbook%d.dds",
-                'BSGN': r"Clutter\iconbook%d.dds",
-                'CLAS': r"Clutter\iconbook%d.dds",
-                'CLOT': ((r"Clothes\MiddleClass\01\M\Shirt.dds",r"Clothes\MiddleClass\01\F\Shirt.dds"),
-                         (r"Clothes\MiddleClass\01\M\Pants.dds",r"Clothes\MiddleClass\01\F\Pants.dds"),
-                         (r"Clothes\MythicDawnrobe\hood.dds",),
-                         (r"Clothes\LowerClass\Jail\M\JailShirtHandcuff.dds",),
-                         (r"Clothes\MiddleClass\01\M\Shoes.dds",r"Clothes\MiddleClass\01\F\Shoes.dds"),
-                         (r"Clothes\Ring\RingNovice.dds",),
-                         (r"Clothes\Amulet\AmuletSilver.dds",),
-                         ),
-##                'FACT': r"", ToDo
-                'INGR': r"Clutter\IconSeeds.dds",
-                'KEYM': (r"Clutter\Key\Key.dds",r"Clutter\Key\Key02.dds"),
-                'LIGH': r"Lights\IconTorch02.dds",
-                'MISC': r"Clutter\Soulgems\AzurasStar.dds",
-                'QUST': r"Quest\icon_miscellaneous.dds",
-                'SGST': r"IconSigilStone.dds",
-                'SLGM': r"Clutter\Soulgems\AzurasStar.dds",
-                'WEAP': (r"Weapons\IronDagger.dds",
-                         r"Weapons\IronClaymore.dds",
-                         r"Weapons\IronMace.dds",
-                         r"Weapons\IronBattleAxe.dds",
-                         r"Weapons\Staff.dds",
-                         r"Weapons\IronBow.dds",
-                         ),
-                }
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Default Icons"),
-            _("Sets a default icon for any records that don't have any icon assigned"),
-            'icons',
-            (_('1'), 1),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return [_type for _type in self.type_defaultIcon.keys()]
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if getattr(record, 'iconPath', None): return
-        if getattr(record, 'maleIconPath', None): return
-        if getattr(record, 'femaleIconPath', None): return
-        if record._Type == 'LIGH' and not record.IsCanTake: return
-        if record._Type == 'QUST' and not record.stages: return
-        if record._Type in ['ARMO','CLOT'] and not record.IsPlayable: return
-
-        override = record.CopyAsOverride(self.patchFile)
-        if override:
-            icons = self.type_defaultIcon[override._Type]
-            if isinstance(icons, tuple):
-                if override._Type == 'ARMO':
-                    #choose based on body flags:
-                    if override.IsUpperBody:
-                        icons = icons[0]
-                    elif override.IsLowerBody:
-                        icons = icons[1]
-                    elif override.IsHead or record.IsHair:
-                        icons = icons[2]
-                    elif override.IsHand:
-                        icons = icons[3]
-                    elif override.IsFoot:
-                        icons = icons[4]
-                    elif override.IsShield:
-                        icons = icons[5]
-                    else: #default icon, probably a token or somesuch
-                        icons = icons[6]
-                elif override._Type == 'CLOT':
-                    #choose based on body flags:
-                    if override.IsUpperBody:
-                        icons = icons[0]
-                    elif override.IsLowerBody:
-                        icons = icons[1]
-                    elif override.IsHead or record.IsHair:
-                        icons = icons[2]
-                    elif override.IsHand:
-                        icons = icons[3]
-                    elif override.IsFoot:
-                        icons = icons[4]
-                    elif override.IsLeftRing or override.IsRightRing:
-                        icons = icons[5]
-                    else:
-                        icons = icons[6]
-                elif override._Type == 'KEYM':
-                    icons = icons[random.randint(0,1)]
-                elif override._Type == 'WEAP':
-                    #choose based on weapon type:
-                    try:
-                        icons = icons[override.weaponType]
-                    except IndexError: #just in case
-                        icons = icons[0]
-            else:
-                if override._Type in ['BOOK','BSGN','CLAS']: #just a random book icon for class/birthsign as well.
-                    icons = icons % (random.randint(1,13))
-
-            try:
-                if isinstance(icons, tuple):
-                    if len(icons) == 1:
-                        override.maleIconPath = icons[0]
-                    else:
-                        override.maleIconPath, override.femaleIconPath = icons
-                else:
-                    override.iconPath = icons
-            except ValueError, error:
-                print override._Type
-                print icons
-                print error
-                print self.patchFile.ObCollection.Debug_DumpModFiles()
-                raise error
-            mod_count = self.mod_count
-            mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-            record.UnloadRecord()
-            record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Default Icons'))
-        log(_('* Default Icons set: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_SetSoundAttenuationLevels(MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels"),
-            _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume.'),
-            'Attenuation%:',
-            (_('0%'), 0),
-            (_('5%'), 5),
-            (_('10%'), 10),
-            (_('20%'), 20),
-            (_('50%'), 50),
-            (_('80%'), 80),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreSoun,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreSoun,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.SOUN
-        id_records = patchBlock.id_records
-        for record in modFile.SOUN.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.staticAtten:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.SOUN.records:
-            if record.staticAtten:
-                record.staticAtten = record.staticAtten*self.choiceValues[self.chosen][0]/100
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Set Sound Attenuation Levels'))
-        log(_('* Sounds Modified: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_SetSoundAttenuationLevels(CBash_MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Set Sound Attenuation Levels')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels"),
-            _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume.'),
-            'Attenuation%:',
-            (_('0%'), 0),
-            (_('5%'), 5),
-            (_('10%'), 10),
-            (_('20%'), 20),
-            (_('50%'), 50),
-            (_('80%'), 80),
-            (_('Custom'),0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['SOUN']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-
-        if record.staticAtten:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                    override.staticAtten = override.staticAtten*self.choiceValues[self.chosen][0]/100
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Set Sound Attenuation Levels'))
-        log(_('* Sounds modified: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels: Nirnroots Only"),
-            _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume. This one only affects Nirnroots.'),
-            'Nirnroot Attenuation%:',
-            (_('0%'), 0),
-            (_('5%'), 5),
-            (_('10%'), 10),
-            (_('20%'), 20),
-            (_('50%'), 50),
-            (_('80%'), 80),
-            (_('Custom'),0),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreSoun,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreSoun,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchBlock = patchFile.SOUN
-        id_records = patchBlock.id_records
-        for record in modFile.SOUN.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.staticAtten and 'nirnroot' in record.eid.lower():
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.SOUN.records:
-            if record.staticAtten and 'nirnroot' in record.eid.lower():
-                record.staticAtten = record.staticAtten*self.choiceValues[self.chosen][0]/100
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Set Sound Attenuation Levels: Nirnroots Only'))
-        log(_('* Sounds Modified: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(CBash_MultiTweakItem):
-    """Sets Cast When Used Enchantment number of uses."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Set Sound Attenuation Levels: Nirnroots Only')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels: Nirnroots Only"),
-            _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume. This one only affects Nirnroots.'),
-            'Nirnroot Attenuation%:',
-            (_('0%'), 0),
-            (_('5%'), 5),
-            (_('10%'), 10),
-            (_('20%'), 20),
-            (_('50%'), 50),
-            (_('80%'), 80),
-            (_('Custom'),0),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['SOUN']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-
-        if record.staticAtten and 'nirnroot' in record.eid.lower() :
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                    override.staticAtten = override.staticAtten*self.choiceValues[self.chosen][0]/100
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Set Sound Attenuation Levels: Nirnroots Only'))
-        log(_('* Sounds modified: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AssortedTweak_FactioncrimeGoldMultiplier(MultiTweakItem):
-    """Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Faction crime Gold Multiplier Fix"),
-            _('Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0.'),
-            'FactioncrimeGoldMultiplier',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreFact,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreFact,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.FACT
-        for record in modFile.FACT.getActiveRecords():
-            if not isinstance(record.crimeGoldMultiplier,float):
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.FACT.records:
-            if not isinstance(record.crimeGoldMultiplier,float):
-                record.crimeGoldMultiplier = 1.0
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== Faction crime Gold Multiplier Fix'))
-        log(_('* Factions fixed: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_FactioncrimeGoldMultiplier(CBash_MultiTweakItem):
-    """Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Faction crime Gold Multiplier Fix')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Faction crime Gold Multiplier Fix"),
-            _('Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0.'),
-            'FactioncrimeGoldMultiplier',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['FACT']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if not isinstance(record.crimeGoldMultiplier,float):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.crimeGoldMultiplier = 1.0
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== Faction crime Gold Multiplier Fix'))
-        log(_('* Factions fixed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweak_LightFadeValueFix(MultiTweakItem):
-    """Sets light fade value when not set to 1.0."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("No Light Fade Value Fix"),
-            _("Sets Light's Fade values to default of 1.0 if not set."),
-            'NoLightFadeValueFix',
-            ('1.0',  '1.0'),
-            )
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreLigh,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreLigh,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.LIGH
-        for record in modFile.LIGH.getActiveRecords():
-            if not isinstance(record.fade,float):
-                record = record.getTypeCopy(mapper)
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.LIGH.records:
-            if not isinstance(record.fade,float):
-                record.fade = 1.0
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('=== No Light Fade Value Fix'))
-        log(_('* Lights with fade values added: %d') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_AssortedTweak_LightFadeValueFix(CBash_MultiTweakItem):
-    """Remove light flickering for low end machines."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('No Light Fade Value Fix')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("No Light Fade Value Fix"),
-            _("Sets Light's Fade values to default of 1.0 if not set."),
-            'NoLightFadeValueFix',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['LIGH']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if not isinstance(record.fade,float):
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.fade = 1.0
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader(_('=== No Light Fade Value Fix'))
-        log(_('* Lights with fade values added: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class AssortedTweaker(MultiTweaker):
-    """Tweaks assorted stuff. Sub-tweaks behave like patchers themselves."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Tweak Assorted')
-    text = _("Tweak various records in miscellaneous ways.")
-    tweaks = sorted([
-        AssortedTweak_ArmorShows(_("Armor Shows Amulets"),
-            _("Prevents armor from hiding amulets."),
-            'armorShowsAmulets',
-            ),
-        AssortedTweak_ArmorShows(_("Armor Shows Rings"),
-            _("Prevents armor from hiding rings."),
-            'armorShowsRings',
-            ),
-        AssortedTweak_ClothingShows(_("Clothing Shows Amulets"),
-            _("Prevents Clothing from hiding amulets."),
-            'ClothingShowsAmulets',
-            ),
-        AssortedTweak_ClothingShows(_("Clothing Shows Rings"),
-            _("Prevents Clothing from hiding rings."),
-            'ClothingShowsRings',
-            ),
-        AssortedTweak_ArmorPlayable(),
-        AssortedTweak_ClothingPlayable(),
-        AssortedTweak_BowReach(),
-        AssortedTweak_ConsistentRings(),
-        AssortedTweak_DarnBooks(),
-        AssortedTweak_FogFix(),
-        AssortedTweak_NoLightFlicker(),
-        AssortedTweak_PotionWeight(),
-        AssortedTweak_PotionWeightMinimum(),
-        AssortedTweak_StaffWeight(),
-        AssortedTweak_SetCastWhenUsedEnchantmentCosts(),
-        AssortedTweak_WindSpeed(),
-        AssortedTweak_HarvestChance(),
-        AssortedTweak_IngredientWeight(),
-        AssortedTweak_ArrowWeight(),
-        AssortedTweak_ScriptEffectSilencer(),
-        AssortedTweak_DefaultIcons(),
-        AssortedTweak_SetSoundAttenuationLevels(),
-        AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(),
-        AssortedTweak_FactioncrimeGoldMultiplier(),
-        AssortedTweak_LightFadeValueFix(),
-        ],key=lambda a: a.label.lower())
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
-
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        if not self.isActive: return
-        for tweak in self.enabledTweaks:
-            tweak.scanModFile(modFile,progress,self.patchFile)
-
-    def buildPatch(self,log,progress):
-        """Applies individual clothes tweaks."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(log,progress,self.patchFile)
-
-class CBash_AssortedTweaker(CBash_MultiTweaker):
-    """Tweaks assorted stuff. Sub-tweaks behave like patchers themselves."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Tweak Assorted')
-    text = _("Tweak various records in miscellaneous ways.")
-    tweaks = sorted([
-        CBash_AssortedTweak_ArmorShows(_("Armor Shows Amulets"),
-            _("Prevents armor from hiding amulets."),
-            'armorShowsAmulets',
-            ),
-        CBash_AssortedTweak_ArmorShows(_("Armor Shows Rings"),
-            _("Prevents armor from hiding rings."),
-            'armorShowsRings',
-            ),
-        CBash_AssortedTweak_ClothingShows(_("Clothing Shows Amulets"),
-            _("Prevents Clothing from hiding amulets."),
-            'ClothingShowsAmulets',
-            ),
-        CBash_AssortedTweak_ClothingShows(_("Clothing Shows Rings"),
-            _("Prevents Clothing from hiding rings."),
-            'ClothingShowsRings',
-            ),
-        CBash_AssortedTweak_ArmorPlayable(),
-        CBash_AssortedTweak_ClothingPlayable(),
-        CBash_AssortedTweak_BowReach(),
-        CBash_AssortedTweak_ConsistentRings(),
-        CBash_AssortedTweak_DarnBooks(),
-        CBash_AssortedTweak_FogFix(),
-        CBash_AssortedTweak_NoLightFlicker(),
-        CBash_AssortedTweak_PotionWeight(),
-        CBash_AssortedTweak_PotionWeightMinimum(),
-        CBash_AssortedTweak_StaffWeight(),
-        CBash_AssortedTweak_SetCastWhenUsedEnchantmentCosts(),
-        CBash_AssortedTweak_HarvestChance(),
-        CBash_AssortedTweak_WindSpeed(),
-        CBash_AssortedTweak_IngredientWeight(),
-        CBash_AssortedTweak_ArrowWeight(),
-        CBash_AssortedTweak_ScriptEffectSilencer(),
-        CBash_AssortedTweak_DefaultIcons(),
-        CBash_AssortedTweak_SetSoundAttenuationLevels(),
-        CBash_AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(),
-        CBash_AssortedTweak_FactioncrimeGoldMultiplier(),
-        CBash_AssortedTweak_LightFadeValueFix(),
-        ],key=lambda a: a.label.lower())
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks:
-            tweak.patchFile = patchFile
-
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-
-#------------------------------------------------------------------------------
-class GlobalsTweak(MultiTweakItem):
-    """set a global to specified value"""
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatch(self,patchFile,keep,log):
-        """Build patch."""
-        value = self.choiceValues[self.chosen][0]
-        for record in patchFile.GLOB.records:
-            if record.eid.lower() == self.key:
-                if record.value != value:
-                    record.value = value
-                    keep(record.fid)
-        log('* %s set to: %4.2f' % (self.label,value))
-class CBash_GlobalsTweak(CBash_MultiTweakItem):
-    """Sets a global to specified value"""
-    scanOrder = 29
-    editOrder = 29
-    #--Config Phase -----------------------------------------------------------
-    def getTypes(self):
-        return ['GLOB']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if (record.eid == self.key): #eid is case insensitive on comparisons by default
-            value = self.value = self.choiceValues[self.chosen][0]
-            if record.value != value:
-                self.count = 1
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.value = float(value) #Globals are always stored as floats, regardless of what the CS says
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        if self.count:
-            log('  * %s set to: %4.2f' % (self.label,self.value))
-
-#------------------------------------------------------------------------------
-class GlobalsTweaker(MultiTweaker):
-    """Select values to set various globals to."""
-    scanOrder = 29
-    editOrder = 29
-    name = _('Globals')
-    text = _("Set globals to various values")
-    tweaks = sorted([
-        GlobalsTweak(_("Timescale"),
-            _("Timescale will be set to:"),
-            'timescale',
-            (_('1'),1),
-            (_('8'),8),
-            (_('10'),10),
-            (_('12'),12),
-            (_('18'),18),
-            (_('24'),24),
-            (_('[30]'),30),
-            (_('40'),40),
-            (_('Custom'),0),
-            ),
-        GlobalsTweak(_("Thieves Guild: Quest Stealing Penalty"),
-            _("The penalty (in Septims) for stealing while doing a Thieves Guild job:"),
-            'tgpricesteal',
-            (_('100'),100),
-            (_('150'),150),
-            (_('[200]'),200),
-            (_('300'),300),
-            (_('400'),400),
-            (_('Custom'),0),
-            ),
-        GlobalsTweak(_("Thieves Guild: Quest Killing Penalty"),
-            _("The penalty (in Septims) for killing while doing a Thieves Guild job:"),
-            'tgpriceperkill',
-            (_('250'),250),
-            (_('500'),500),
-            (_('[1000]'),1000),
-            (_('1500'),1500),
-            (_('2000'),2000),
-            (_('Custom'),0),
-            ),
-        GlobalsTweak(_("Thieves Guild: Quest Attacking Penalty"),
-            _("The penalty (in Septims) for attacking while doing a Thieves Guild job:"),
-            'tgpriceattack',
-            (_('100'),100),
-            (_('250'),250),
-            (_('[500]'),500),
-            (_('750'),750),
-            (_('1000'),1000),
-            (_('Custom'),0),
-            ),
-        GlobalsTweak(_("Crime: Force Jail"),
-            _("The amount of Bounty at which a jail sentence is mandatory"),
-            'crimeforcejail',
-            (_('1000'),1000),
-            (_('2500'),2500),
-            (_('[5000]'),5000),
-            (_('7500'),7500),
-            (_('10000'),10000),
-            (_('Custom'),0),
-            ),
-        ],key=lambda a: a.label.lower())
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreGlob,))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreGlob,))[self.isActive]
-
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        if not self.isActive or 'GLOB' not in modFile.tops: return
-        mapper = modFile.getLongMapper()
-        patchRecords = self.patchFile.GLOB
-        id_records = patchRecords.id_records
-        for record in modFile.GLOB.getActiveRecords():
-            if record.flags1.deleted: continue
-            if mapper(record.fid) in id_records: continue
-            if record.eid is None: continue
-            for tweak in self.enabledTweaks:
-                if record.eid.lower() == tweak.key:
-                    record = record.getTypeCopy(mapper)
-                    patchRecords.setRecord(record)
-                    break
-
-    def buildPatch(self,log,progress):
-        """Applies individual clothes tweaks."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        log.setHeader('= '+self.__class__.name)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(self.patchFile,keep,log)
-
-class CBash_GlobalsTweaker(CBash_MultiTweaker):
-    """Select values to set various globals to."""
-    scanOrder = 29
-    editOrder = 29
-    name = _('Globals')
-    text = _("Set globals to various values")
-    tweaks = sorted([
-        CBash_GlobalsTweak(_("Timescale"),
-            _("Timescale will be set to:"),
-            'timescale',
-            (_('1'),1),
-            (_('8'),8),
-            (_('10'),10),
-            (_('12'),12),
-            (_('18'),18),
-            (_('24'),24),
-            (_('[30]'),30),
-            (_('40'),40),
-            (_('Custom'),0),
-            ),
-        CBash_GlobalsTweak(_("Thieves Guild: Quest Stealing Penalty"),
-            _("The penalty (in Septims) for stealing while doing a Thieves Guild job:"),
-            'tgpricesteal',
-            (_('100'),100),
-            (_('150'),150),
-            (_('[200]'),200),
-            (_('300'),300),
-            (_('400'),400),
-            (_('Custom'),0),
-            ),
-        CBash_GlobalsTweak(_("Thieves Guild: Quest Killing Penalty"),
-            _("The penalty (in Septims) for killing while doing a Thieves Guild job:"),
-            'tgpriceperkill',
-            (_('250'),250),
-            (_('500'),500),
-            (_('[1000]'),1000),
-            (_('1500'),1500),
-            (_('2000'),2000),
-            (_('Custom'),0),
-            ),
-        CBash_GlobalsTweak(_("Thieves Guild: Quest Attacking Penalty"),
-            _("The penalty (in Septims) for attacking while doing a Thieves Guild job:"),
-            'tgpriceattack',
-            (_('100'),100),
-            (_('250'),250),
-            (_('[500]'),500),
-            (_('750'),750),
-            (_('1000'),1000),
-            (_('Custom'),0),
-            ),
-        CBash_GlobalsTweak(_("Crime: Force Jail"),
-            _("The amount of Bounty at which a jail sentence is mandatory"),
-            'crimeforcejail',
-            (_('1000'),1000),
-            (_('2500'),2500),
-            (_('[5000]'),5000),
-            (_('7500'),7500),
-            (_('10000'),10000),
-            (_('Custom'),0),
-            ),
-        ],key=lambda a: a.label.lower())
-
-    #--Config Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks:
-            tweak.patchFile = patchFile
-            tweak.count = 0
-
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-
-
-#------------------------------------------------------------------------------
-class ClothesTweak(MultiTweakItem):
-    flags = {
-        'hoods':   1<<1,
-        'shirts':  1<<2,
-        'pants':   1<<3,
-        'gloves':  1<<4,
-        'amulets': 1<<8,
-        'rings2':  1<<16,
-        'amulets2': 1<<17,
-        #--Multi
-        'robes':   (1<<2) + (1<<3),
-        'rings':   (1<<6) + (1<<7),
-        }
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key,*choices):
-        MultiTweakItem.__init__(self,label,tip,key,*choices)
-        typeKey = key[:key.find('.')]
-        self.orTypeFlags = typeKey == 'rings'
-        self.typeFlags = self.__class__.flags[typeKey]
-
-    def isMyType(self,record):
-        """Returns true to save record for late processing."""
-        if record.flags.notPlayable: return False #--Ignore non-playable items.
-        recTypeFlags = int(record.flags) & 0xFFFF
-        myTypeFlags = self.typeFlags
-        return (
-            (recTypeFlags == myTypeFlags) or
-            (self.orTypeFlags and (recTypeFlags & myTypeFlags == recTypeFlags))
-            )
-class CBash_ClothesTweak(CBash_MultiTweakItem):
-    flags = {
-        'hoods':    0x00000002,
-        'shirts':   0x00000004,
-        'pants':    0x00000008,
-        'gloves':   0x00000010,
-        'amulets':  0x00000100,
-        'rings2':   0x00010000,
-        'amulets2': 0x00020000,
-        #--Multi
-        'robes':    0x0000000C,
-        'rings':    0x000000C0,
-        }
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key,*choices):
-        CBash_MultiTweakItem.__init__(self,label,tip,key,*choices)
-        typeKey = key[:key.find('.')]
-        self.orTypeFlags = typeKey == 'rings'
-        self.typeFlags = self.__class__.flags[typeKey]
-
-    def isMyType(self,record):
-        """Returns true to save record for late processing."""
-        recTypeFlags = int(record.flags) & 0xFFFF
-        myTypeFlags = self.typeFlags
-        return ((recTypeFlags == myTypeFlags) or
-                (self.orTypeFlags and (recTypeFlags & myTypeFlags == recTypeFlags)))
-#------------------------------------------------------------------------------
-class ClothesTweak_MaxWeight(ClothesTweak):
-    """Enforce a max weight for specified clothes."""
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatch(self,patchFile,keep,log):
-        """Build patch."""
-        tweakCount = 0
-        maxWeight = self.choiceValues[self.chosen][0]
-        superWeight = max(10,5*maxWeight) #--Guess is intentionally overweight
-        for record in patchFile.CLOT.records:
-            weight = record.weight
-            if self.isMyType(record) and weight > maxWeight and weight < superWeight:
-                record.weight = maxWeight
-                keep(record.fid)
-                tweakCount += 1
-        log('* %s: [%4.2f]: %d' % (self.label,maxWeight,tweakCount))
-
-
-class CBash_ClothesTweak_MaxWeight(CBash_ClothesTweak):
-    """Enforce a max weight for specified clothes."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Reweigh Clothes')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key,*choices):
-        CBash_ClothesTweak.__init__(self,label,tip,key,*choices)
-        self.matchFlags = {'amulets.maxWeight':('IsAmulet',),
-                         'rings.maxWeight':('IsRightRing','IsLeftRing'),
-                         'hoods.maxWeight':('IsHair',)
-                         }[key]
-        self.mod_count = {}
-
-
-    def getTypes(self):
-        return ['CLOT']
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsNonPlayable:
-            return
-
-        maxWeight = self.choiceValues[self.chosen][0]
-
-        if (record.weight > maxWeight) and self.isMyType(record):
-            for attr in self.matchFlags:
-                if(getattr(record, attr)):
-                    break
-            else:
-                return
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.weight = maxWeight
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        maxWeight = self.choiceValues[self.chosen][0]
-        log.setHeader('=== %s' % self.label)
-        log(_('* Clothes Reweighed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: [%4.2f]: %d' % (srcMod.s,maxWeight,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class ClothesTweak_Unblock(ClothesTweak):
-    """Unlimited rings, amulets."""
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key,*choices):
-        ClothesTweak.__init__(self,label,tip,key,*choices)
-        self.unblockFlags = self.__class__.flags[key[key.rfind('.')+1:]]
-
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatch(self,patchFile,keep,log):
-        """Build patch."""
-        tweakCount = 0
-        for record in patchFile.CLOT.records:
-            if self.isMyType(record) and int(record.flags & self.unblockFlags):
-                record.flags &= ~self.unblockFlags
-                keep(record.fid)
-                tweakCount += 1
-        log('* %s: %d' % (self.label,tweakCount))
-class CBash_ClothesTweak_Unblock(CBash_ClothesTweak):
-    """Unlimited rings, amulets."""
-    scanOrder = 31
-    editOrder = 31
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key):
-        CBash_ClothesTweak.__init__(self,label,tip,key)
-        self.hideFlags = {'amulets.unblock.amulets':('IsAmulet',),
-                         'robes.show.amulets2':('IsHideAmulets',),
-                         'rings.unblock.rings':('IsRightRing','IsLeftRing'),
-                         'gloves.unblock.rings2':('IsHideRings',),
-                         'robes.unblock.pants':('IsLowerBody',)
-                         }[key]
-        self.mod_count = {}
-
-
-    def getTypes(self):
-        return ['CLOT']
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsNonPlayable:
-            return
-
-        if self.isMyType(record):
-            for flag in self.hideFlags:
-                if(getattr(record, flag)):
-                    break
-            else:
-                return
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                for attr in self.hideFlags:
-                    setattr(override, attr, False)
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        log.setHeader('=== '+self.label)
-        log(_('* Clothing Pieces Tweaked: %d') % (sum(self.mod_count.values()),))
-        for srcMod in modInfos.getOrdered(self.mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,self.mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class ClothesTweaker(MultiTweaker):
-    """Patches clothes in miscellaneous ways."""
-    scanOrder = 31
-    editOrder = 31
-    name = _('Tweak Clothes')
-    text = _("Tweak clothing weight and blocking.")
-    tweaks = sorted([
-        ClothesTweak_Unblock(_("Unlimited Amulets"),
-            _("Wear unlimited number of amulets - but they won't display."),
-            'amulets.unblock.amulets'),
-        ClothesTweak_Unblock(_("Unlimited Rings"),
-            _("Wear unlimited number of rings - but they won't display."),
-            'rings.unblock.rings'),
-        ClothesTweak_Unblock(_("Gloves Show Rings"),
-            _("Gloves will always show rings. (Conflicts with Unlimited Rings.)"),
-            'gloves.unblock.rings2'),
-        ClothesTweak_Unblock(_("Robes Show Pants"),
-            _("Robes will allow pants, greaves, skirts - but they'll clip."),
-            'robes.unblock.pants'),
-        ClothesTweak_Unblock(_("Robes Show Amulets"),
-            _("Robes will always show amulets. (Conflicts with Unlimited Amulets.)"),
-            'robes.show.amulets2'),
-        ClothesTweak_MaxWeight(_("Max Weight Amulets"),
-            _("Amulet weight will be capped."),
-            'amulets.maxWeight',
-            (_('0.0'),0),
-            (_('0.1'),0.1),
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('Custom'),0),
-            ),
-        ClothesTweak_MaxWeight(_("Max Weight Rings"),
-            _('Ring weight will be capped.'),
-            'rings.maxWeight',
-            (_('0.0'),0),
-            (_('0.1'),0.1),
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('Custom'),0),
-            ),
-        ClothesTweak_MaxWeight(_("Max Weight Hoods"),
-            _('Hood weight will be capped.'),
-            'hoods.maxWeight',
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('1.0'),1.0),
-            (_('Custom'),0),
-            ),
-        ],key=lambda a: a.label.lower())
-
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (None,(MreClot,))[self.isActive]
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreClot,))[self.isActive]
-
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        if not self.isActive or 'CLOT' not in modFile.tops: return
-        mapper = modFile.getLongMapper()
-        patchRecords = self.patchFile.CLOT
-        id_records = patchRecords.id_records
-        for record in modFile.CLOT.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            for tweak in self.enabledTweaks:
-                if tweak.isMyType(record):
-                    record = record.getTypeCopy(mapper)
-                    patchRecords.setRecord(record)
-                    break
-
-    def buildPatch(self,log,progress):
-        """Applies individual clothes tweaks."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        log.setHeader('= '+self.__class__.name)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(self.patchFile,keep,log)
-class CBash_ClothesTweaker(CBash_MultiTweaker):
-    """Patches clothes in miscellaneous ways."""
-    scanOrder = 31
-    editOrder = 31
-    name = _('Tweak Clothes')
-    text = _("Tweak clothing weight and blocking.")
-    tweaks = sorted([
-        CBash_ClothesTweak_Unblock(_("Unlimited Amulets"),
-            _("Wear unlimited number of amulets - but they won't display."),
-            'amulets.unblock.amulets'),
-        CBash_ClothesTweak_Unblock(_("Unlimited Rings"),
-            _("Wear unlimited number of rings - but they won't display."),
-            'rings.unblock.rings'),
-        CBash_ClothesTweak_Unblock(_("Gloves Show Rings"),
-            _("Gloves will always show rings. (Conflicts with Unlimited Rings.)"),
-            'gloves.unblock.rings2'),
-        CBash_ClothesTweak_Unblock(_("Robes Show Pants"),
-            _("Robes will allow pants, greaves, skirts - but they'll clip."),
-            'robes.unblock.pants'),
-        CBash_ClothesTweak_Unblock(_("Robes Show Amulets"),
-            _("Robes will always show amulets. (Conflicts with Unlimited Amulets.)"),
-            'robes.show.amulets2'),
-        CBash_ClothesTweak_MaxWeight(_("Max Weight Amulets"),
-            _("Amulet weight will be capped."),
-            'amulets.maxWeight',
-            (_('0.0'),0.0),
-            (_('0.1'),0.1),
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('Custom'),0.0),
-            ),
-        CBash_ClothesTweak_MaxWeight(_("Max Weight Rings"),
-            _('Ring weight will be capped.'),
-            'rings.maxWeight',
-            (_('0.0'),0.0),
-            (_('0.1'),0.1),
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('Custom'),0.0),
-            ),
-        CBash_ClothesTweak_MaxWeight(_("Max Weight Hoods"),
-            _('Hood weight will be capped.'),
-            'hoods.maxWeight',
-            (_('0.2'),0.2),
-            (_('0.5'),0.5),
-            (_('1.0'),1.0),
-            (_('Custom'),0.0),
-            ),
-        ],key=lambda a: a.label.lower())
-
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks:
-            tweak.patchFile = patchFile
-
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-
-#------------------------------------------------------------------------------
-class GmstTweak(MultiTweakItem):
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatch(self,patchFile,keep,log):
-        """Build patch."""
-        eids = ((self.key,),self.key)[isinstance(self.key,tuple)]
-        for eid,value in zip(eids,self.choiceValues[self.chosen]):
-            if value < 0:
-                deprint("GMST float value can't be a negative number - currently %f - skipping setting GMST." % value)
-                return
-            for record in patchFile.GMST.records:
-                if record.eid.lower() == eid.lower():
-                    if record.value != value:
-                        record.value = value
-                        keep(record.fid)
-                    break
-            else:
-                gmst = MreGmst(('GMST',0,0,0,0))
-                gmst.eid,gmst.value,gmst.longFids = eid,value,True
-                fid = gmst.fid = keep(gmst.getGMSTFid())
-                patchFile.GMST.setRecord(gmst)
-        if len(self.choiceLabels) > 1:
-            if self.choiceLabels[self.chosen].startswith('Custom'):
-                if isinstance(self.choiceValues[self.chosen][0],(str,unicode)):
-                    log('* %s: %s %s' % (self.label,self.choiceLabels[self.chosen],self.choiceValues[self.chosen][0]))
-                else:
-                    log('* %s: %s %4.2f' % (self.label,self.choiceLabels[self.chosen],self.choiceValues[self.chosen][0]))
-            else: log('* %s: %s' % (self.label,self.choiceLabels[self.chosen]))
-        else:
-            log('* ' + self.label)
-
-class CBash_GmstTweak(CBash_MultiTweakItem):
-    """Sets a gmst to specified value"""
-    scanOrder = 29
-    editOrder = 29
-    #--Config Phase -----------------------------------------------------------
-    def getTypes(self):
-        return ['GMST']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        values = self.values = self.choiceValues[self.chosen]
-        recEid = record.eid
-        for eid,value in zip(self.key,values):
-            if eid == recEid:
-                newValue = value
-                break
-        else:
-            return
-        if record.value != newValue:
-            self.eid_count[eid] = 1
-            if newValue < 0:
-                deprint("GMST float value can't be a negative number - currently %f - skipping settingGMST" % newValue)
-                return
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.value = newValue
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def finishPatch(self,patchFile,progress):
-        """Edits the bashed patch file directly."""
-        subProgress = SubProgress(progress)
-        values = self.values = self.choiceValues[self.chosen]
-        subProgress.setFull(max(len(values),1))
-        pstate = 0
-        for eid,value in zip(self.key,values):
-            subProgress(pstate, _("Finishing GMST Tweaks..."))
-            if not self.eid_count.get(eid,0):
-                self.eid_count[eid] = 1
-                record = patchFile.create_GMST(eid)
-                if not record:
-                    print eid
-                    print patchFile.ObCollection.Debug_DumpModFiles()
-                    for conflict in patchFile.ObCollection.LookupRecords(eid, False):
-                        print conflict.ModName
-                    raise StateError(_("Tweak Settings: Unable to create GMST!"))
-                record.value = value
-            pstate += 1
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        if len(self.choiceLabels) > 1:
-            if self.choiceLabels[self.chosen].startswith('Custom'):
-                if isinstance(self.values[0],(str,unicode)):
-                    log('  * %s: %s %s' % (self.label,self.choiceLabels[self.chosen],self.values[0]))
-                else:
-                    log('  * %s: %s %4.2f' % (self.label,self.choiceLabels[self.chosen],self.values[0]))
-            else: log('  * %s: %s' % (self.label,self.choiceLabels[self.chosen]))
-        else:
-            log('  * ' + self.label)
-
-#------------------------------------------------------------------------------
-class GmstTweaker(MultiTweaker):
-    """Tweaks miscellaneous gmsts in miscellaneous ways."""
-    scanOrder = 29
-    editOrder = 29
-    name = _('Tweak Settings')
-    text = _("Tweak game settings.")
-    tweaks = sorted([
-        GmstTweak(_('Arrow: Litter Count'),
-            _("Maximum number of spent arrows allowed in cell."),
-            ('iArrowMaxRefCount',),
-            ('[15]',15),
-            ('25',25),
-            ('35',35),
-            ('50',50),
-            ('100',100),
-            ('500',500),
-            (_('Custom'),15),
-            ),
-        GmstTweak(_('Arrow: Litter Time'),
-            _("Time before spent arrows fade away from cells and actors."),
-            ('fArrowAgeMax',),
-            (_('1 Minute'),60.0),
-            (_('[1.5 Minutes]'),90.0),
-            (_('2 Minutes'),120.0),
-            (_('3 Minutes'),180.0),
-            (_('5 Minutes'),300.0),
-            (_('10 Minutes'),600.0),
-            (_('30 Minutes'),1800.0),
-            (_('1 Hour'),3600.0),
-            (_('Custom (in seconds)'),90),
-            ),
-        GmstTweak(_('Arrow: Recovery from Actor'),
-            _("Chance that an arrow shot into an actor can be recovered."),
-            ('iArrowInventoryChance',),
-            ('[50%]',50),
-            ('60%',60),
-            ('70%',70),
-            ('80%',80),
-            ('90%',90),
-            ('100%',100),
-            (_('Custom'),50),
-            ),
-        GmstTweak(_('Arrow: Speed'),
-            _("Speed of full power arrow."),
-            ('fArrowSpeedMult',),
-            (_('x 1.2'),1500.0*1.2),
-            (_('x 1.4'),1500.0*1.4),
-            (_('x 1.6'),1500.0*1.6),
-            (_('x 1.8'),1500.0*1.8),
-            (_('x 2.0'),1500.0*2.0),
-            (_('x 2.2'),1500.0*2.2),
-            (_('x 2.4'),1500.0*2.4),
-            (_('x 2.6'),1500.0*2.6),
-            (_('x 2.8'),1500.0*2.8),
-            (_('x 3.0'),1500.0*3.0),
-            (_('Custom (base is 1500)'),1500),
-            ),
-        GmstTweak(_('Camera: Chase Tightness'),
-            _("Tightness of chase camera to player turning."),
-            ('fChase3rdPersonVanityXYMult','fChase3rdPersonXYMult'),
-            (_('x 1.5'),6.0,6.0),
-            (_('x 2.0'),8.0,8.0),
-            (_('x 3.0'),12.0,12.0),
-            (_('x 5.0'),20.0,20.0),
-            (_('ChaseCameraMod.esp (x 24.75)'),99,99),
-            (_('Custom'),4,4),
-            ),
-        GmstTweak(_('Camera: Chase Distance'),
-            _("Distance camera can be moved away from PC using mouse wheel."),
-            ('fVanityModeWheelMax', 'fChase3rdPersonZUnitsPerSecond','fVanityModeWheelMult'),
-            (_('x 1.5'),600.0*1.5, 300.0*1.5, 0.15),
-            (_('x 2'),  600.0*2.0, 300.0*2.0, 0.2),
-            (_('x 3'),  600.0*3.0, 300.0*3.0, 0.3),
-            (_('x 5'),  600.0*5.0, 1000.0,    0.3),
-            (_('x 10'), 600.0*10,  2000.0,    0.3),
-            (_('Custom'),600,      300,       0.15),
-            ),
-        GmstTweak(_('Magic: Chameleon Refraction'),
-            _("Chameleon with transparency instead of refraction effect."),
-            ('fChameleonMinRefraction','fChameleonMaxRefraction'),
-            (_('Zero'),0.0,0.0),
-            (_('[Normal]'),0.01,1.0),
-            (_('Full'),1.0,1.0),
-            (_('Custom'),0.01,1.0),
-            ),
-        GmstTweak(_('Compass: Disable'),
-            _("No quest and/or points of interest markers on compass."),
-            ('iMapMarkerRevealDistance',),
-            (_('Quests'),1803),
-            (_('POIs'),1802),
-            (_('Quests and POIs'),1801),
-            ),
-        GmstTweak(_('Compass: POI Recognition'),
-            _("Distance at which POI markers begin to show on compass."),
-            ('iMapMarkerVisibleDistance',),
-            (_('x 0.25'),3000),
-            (_('x 0.50'),6000),
-            (_('x 0.75'),9000),
-            (_('Custom (base 12000)'),12000),
-            ),
-        GmstTweak(_('Essential NPC Unconsciousness'),
-            _("Time which essential NPCs stay unconscious."),
-            ('fEssentialDeathTime',),
-            (_('[10 Seconds]'),10.0),
-            (_('20 Seconds'),20.0),
-            (_('30 Seconds'),30.0),
-            (_('1 Minute'),60.0),
-            (_('1 1/2 Minutes'),1.5*60.0),
-            (_('2 Minutes'),2*60.0),
-            (_('3 Minutes'),3*60.0),
-            (_('5 Minutes'),5*60.0),
-            (_('Custom (in seconds)'),10),
-            ),
-        GmstTweak(_('Fatigue from Running/Encumbrance'),
-            _("Fatigue cost of running and encumbrance."),
-            ('fFatigueRunBase','fFatigueRunMult'),
-            (_('x 1.5'),12.0,6.0),
-            (_('x 2'),16.0,8.0),
-            (_('x 3'),24.0,12.0),
-            (_('x 4'),32.0,16.0),
-            (_('x 5'),40.0,20.0),
-            (_('Custom'),8,4),
-            ),
-        GmstTweak(_('Horse Turning Speed'),
-            _("Speed at which horses turn."),
-            ('iHorseTurnDegreesPerSecond',),
-            (_('x 1.5'),68),
-            (_('x 2.0'),90),
-            (_('Custom (base is 45)'),45),
-            ),
-        GmstTweak(_('Jump Higher'),
-            _("Maximum height player can jump to."),
-            ('fJumpHeightMax',),
-            (_('x 1.1'),164.0*1.1),
-            (_('x 1.2'),164.0*1.2),
-            (_('x 1.4'),164.0*1.4),
-            (_('x 1.6'),164.0*1.6),
-            (_('x 1.8'),164.0*1.8),
-            (_('x 2.0'),164.0*2.0),
-            (_('x 3.0'),164.0*3.0),
-            (_('Custom (base 164)'),164),
-            ),
-        GmstTweak(_('Camera: PC Death Time'),
-            _("Time after player's death before reload menu appears."),
-            ('fPlayerDeathReloadTime',),
-            (_('15 Seconds'),15.0),
-            (_('30 Seconds'),30.0),
-            (_('1 Minute'),60.0),
-            (_('5 Minute'),300.0),
-            (_('Unlimited'),9999999.0),
-            (_('Custom'),15),
-            ),
-        GmstTweak(_('Cell Respawn Time'),
-            _("Time before unvisited cell respawns. But longer times increase save sizes."),
-            ('iHoursToRespawnCell',),
-            (_('1 Day'),24*1),
-            (_('[3 Days]'),24*3),
-            (_('5 Days'),24*5),
-            (_('10 Days'),24*10),
-            (_('20 Days'),24*20),
-            (_('1 Month'),24*30),
-            (_('6 Months'),24*182),
-            (_('1 Year'),24*365),
-            (_('Custom (in hours)'),72),
-            ),
-        GmstTweak(_('Combat: Recharge Weapons'),
-            _("Allow recharging weapons during combat."),
-            ('iAllowRechargeDuringCombat',),
-            (_('[Allow]'),1),
-            (_('Disallow'),0),
-            ),
-        GmstTweak(_('Magic: Bolt Speed'),
-            _("Speed of magic bolt/projectile."),
-            ('fMagicProjectileBaseSpeed',),
-            (_('x 1.2'),1000.0*1.2),
-            (_('x 1.4'),1000.0*1.4),
-            (_('x 1.6'),1000.0*1.6),
-            (_('x 1.8'),1000.0*1.8),
-            (_('x 2.0'),1000.0*2.0),
-            (_('x 2.2'),1000.0*2.2),
-            (_('x 2.4'),1000.0*2.4),
-            (_('x 2.6'),1000.0*2.6),
-            (_('x 2.8'),1000.0*2.8),
-            (_('x 3.0'),1000.0*3.0),
-            (_('Custom (base 1000)'),1000),
-            ),
-        GmstTweak(_('Msg: Equip Misc. Item'),
-            _("Message upon equipping misc. item."),
-            ('sCantEquipGeneric',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Auto Saving'),
-            _("Message upon auto saving."),
-            ('sAutoSaving',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Harvest Failure'),
-            _("Message upon failure at harvesting flora."),
-            ('sFloraFailureMessage',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Harvest Success'),
-            _("Message upon success at harvesting flora."),
-            ('sFloraSuccesssMessage',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Quick Save'),
-            _("Message upon quick saving."),
-            ('sQuickSaving',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Horse Stabled'),
-            _("Message upon fast traveling with a horse to a city."),
-            ('sFastTravelHorseatGate',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: No Fast Travel'),
-            _("Message when attempting to fast travel when fast travel is unavailable due to location."),
-            ('sNoFastTravelScriptBlock',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Loading Area'),
-            _("Message when background loading area."),
-            ('sLoadingArea',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Quick Load'),
-            _("Message when quick loading."),
-            ('sQuickLoading',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Msg: Not Enough Charge'),
-            _("Message when enchanted item is out of charge."),
-            ('sNoCharge',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        GmstTweak(_('Cost Multiplier: Repair'),
-            _("Cost factor for repairing items."),
-            ('fRepairCostMult',),
-            ('0.1',0.1),
-            ('0.2',0.2),
-            ('0.3',0.3),
-            ('0.4',0.4),
-            ('0.5',0.5),
-            ('0.6',0.6),
-            ('0.7',0.7),
-            ('0.8',0.8),
-            ('[0.9]',0.9),
-            ('1.0',1.0),
-            (_('Custom'),0.9),
-            ),
-        GmstTweak(_('Greeting Distance'),
-            _("Distance at which NPCs will greet the player. Default: 150"),
-            ('fAIMinGreetingDistance',),
-            ('100',100.0),
-            ('125',125.0),
-            ('[150]',150.0),
-            (_('Custom'),150.0),
-            ),
-        GmstTweak(_('Cost Multiplier: Recharge'),
-            _("Cost factor for recharging items."),
-            ('fRechargeGoldMult',),
-            ('0.1',0.1),
-            ('0.2',0.2),
-            ('0.3',0.3),
-            ('0.5',0.5),
-            ('0.7',0.7),
-            ('1.0',1.0),
-            ('1.5',1.5),
-            ('[2.0]',2.0),
-            (_('Custom'),2.0),
-            ),
-        GmstTweak(_('Master of Mercantile extra gold amount'),
-            _("How much more barter gold all merchants have for a master of mercantile."),
-            ('iPerkExtraBarterGoldMaster',),
-            ('300',300),
-            ('400',400),
-            ('[500]',500),
-            ('600',600),
-            ('800',800),
-            ('1000',1000),
-            (_('Custom'),500),
-            ),
-        GmstTweak(_('Combat: Max Actors'),
-            _("Maximum number of actors that can actively be in combat with the player."),
-            ('iNumberActorsInCombatPlayer',),
-            ('[10]',10),
-            ('15',15),
-            ('20',20),
-            ('30',30),
-            ('40',40),
-            ('50',50),
-            ('80',80),
-            (_('Custom'),10),
-            ),
-        GmstTweak(_('Crime Alarm Distance'),
-            _("Distance from player that NPCs(guards) will be alerted of a crime."),
-            ('iCrimeAlarmRecDistance',),
-            ('6000',6000),
-            ('[4000]',4000),
-            ('3000',3000),
-            ('2000',2000),
-            ('1000',1000),
-            ('500',500),
-            (_('Custom'),4000),
-            ),
-        GmstTweak(_('Cost Multiplier: Enchantment'),
-            _("Cost factor for enchanting items, OOO default is 120, vanilla 10."),
-            ('fEnchantmentGoldMult',),
-            ('[10]',10.0),
-            ('20',20.0),
-            ('30',30.0),
-            ('50',50.0),
-            ('70',70.0),
-            ('90',90.0),
-            ('120',120.0),
-            ('150',150.0),
-            (_('Custom'),10),
-            ),
-        GmstTweak(_('Cost Multiplier: Spell Making'),
-            _("Cost factor for making spells."),
-            ('fSpellmakingGoldMult',),
-            ('[3]',3.0),
-            ('5',5.0),
-            ('8',8.0),
-            ('10',10.0),
-            ('15',15.0),
-            (_('Custom'),3),
-            ),
-        GmstTweak(_('AI: Max Active Actors'),
-            _("Maximum actors whose AI can be active. Must be higher than Combat: Max Actors"),
-            ('iAINumberActorsComplexScene',),
-            ('20',20),
-            ('[25]',25),
-            ('30',30),
-            ('35',35),
-            (_('MMM Default: 40'),40),
-            ('50',50),
-            ('60',60),
-            ('100',100),
-            (_('Custom'),25),
-            ),
-        GmstTweak(_('Magic: Max Player Summons'),
-            _("Maximum number of creatures the player can summon."),
-            ('iMaxPlayerSummonedCreatures',),
-            ('[1]',1),
-            ('3',3),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            (_('Custom'),1),
-            ),
-        GmstTweak(_('Combat: Max Ally Hits'),
-            _("Maximum number of hits on an ally allowed in combat before the ally will attack the hitting character."),
-            ('iAllyHitAllowed',),
-            ('3',3),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('15',15),
-            (_('Custom'),5),
-            ),
-        GmstTweak(_('Magic: Max NPC Summons'),
-            _("Maximum number of creatures that each NPC can summon"),
-            ('iAICombatMaxAllySummonCount',),
-            ('1',1),
-            ('[3]',3),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            ('15',15),
-            (_('Custom'),3),
-            ),
-        GmstTweak(_('Bounty: Attack'),
-            _("Bounty for attacking a 'good' npc."),
-            ('iCrimeGoldAttackMin',),
-            ('300',300),
-            ('400',400),
-            ('[500]',500),
-            ('650',650),
-            ('800',800),
-            (_('Custom'),500),
-            ),
-        GmstTweak(_('Bounty: Horse Theft'),
-            _("Bounty for horse theft"),
-            ('iCrimeGoldStealHorse',),
-            ('100',100),
-            ('200',200),
-            ('[250]',250),
-            ('300',300),
-            ('450',450),
-            (_('Custom'),250),
-            ),
-        GmstTweak(_('Bounty: Theft'),
-            _("Bounty for stealing, as fraction of item value."),
-            ('fCrimeGoldSteal',),
-            ('1/4',0.25),
-            ('[1/2]',0.5),
-            ('3/4',0.75),
-            ('1',1.0),
-            (_('Custom'),0.5),
-            ),
-        GmstTweak(_('Combat: Alchemy'),
-            _("Allow alchemy during combat."),
-            ('iAllowAlchemyDuringCombat',),
-            (_('Allow'),1),
-            (_('[Disallow]'),0),
-            ),
-        GmstTweak(_('Combat: Repair'),
-            _("Allow repairing armor/weapons during combat."),
-            ('iAllowRepairDuringCombat',),
-            (_('Allow'),1),
-            (_('[Disallow]'),0),
-            ),
-        GmstTweak(_('Companions: Max Number'),
-            _("Maximum number of actors following the player"),
-            ('iNumberActorsAllowedToFollowPlayer',),
-            ('2',2),
-            ('4',4),
-            ('[6]',6),
-            ('8',8),
-            ('10',10),
-            (_('Custom'),6),
-            ),
-        GmstTweak(_('Training Max'),
-            _("Maximum number of Training allowed by trainers."),
-            ('iTrainingSkills',),
-            ('1',1),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('20',20),
-            (_('Unlimited'),9999),
-            (_('Custom'),0),
-            ),
-        GmstTweak(_('Combat: Maximum Armor Rating'),
-            _("The Maximun amount of protection you will get from armor."),
-            ('fMaxArmorRating',),
-            ('50',50.0),
-            ('75',75.0),
-            ('[85]',85.0),
-            ('90',90.0),
-            ('95',95.0),
-            (_('Custom'),85),
-            ),
-        GmstTweak(_('Warning: Interior Distance to Hostiles'),
-            _("The minimum distance hostile actors have to be to be allowed to sleep, travel etc, when inside interiors."),
-            ('fHostileActorInteriorDistance',),
-            ('10',10.0),
-            ('100',100.0),
-            ('500',500.0),
-            ('1000',1000.0),
-            ('[2000]',2000.0),
-            ('3000',3000.0),
-            ('4000',4000.0),
-            (_('Custom'),2000),
-            ),
-        GmstTweak(_('Warning: Exterior Distance to Hostiles'),
-            _("The minimum distance hostile actors have to be to be allowed to sleep, travel etc, when outside."),
-            ('fHostileActorExteriorDistance',),
-            ('10',10.0),
-            ('100',100.0),
-            ('500',500.0),
-            ('1000',1000.0),
-            ('2000',2000.0),
-            ('[3000]',3000.0),
-            ('4000',4000.0),
-            ('5000',5000.0),
-            ('6000',6000.0),
-            (_('Custom'),3000),
-            ),
-        GmstTweak(_('UOP Vampire Aging and Face Fix.esp'),
-            _("Duplicate of UOP component that disables vampire aging (fixes a bug). Use instead of 'UOP Vampire Aging & Face Fix.esp' to save an esp slot."),
-            ('iVampirismAgeOffset',),
-            ('Fix it!',0),
-            ),
-        GmstTweak(_('AI: Max Dead Actors'),
-            _("Maximum number of dead actors allowed before they're removed."),
-            ('iRemoveExcessDeadCount', 'iRemoveExcessDeadTotalActorCount','iRemoveExcessDeadComplexTotalActorCount',
-             'iRemoveExcessDeadComplexCount', 'fRemoveExcessDeadTime','fRemoveExcessComplexDeadTime'),
-            (_('[x 1]'),int(15*1)  , int(20*1)  , int(20*1)  , int(3*1), 10.0*1.0, 2.5*1.0),
-            (_('x 1.5'),int(15*1.5), int(20*1.5), int(20*1.5), int(3*2), 10.0*3.0, 2.5*3.0),
-            (_('x 2'),  int(15*2)  , int(20*2)  , int(20*2)  , int(3*3), 10.0*5.0, 2.5*5.0),
-            (_('x 2.5'),int(15*2.5), int(20*2.5), int(20*2.5), int(3*4), 10.0*7.0, 2.5*7.0),
-            (_('x 3'),  int(15*3)  , int(20*3)  , int(20*3)  , int(3*5), 10.0*9.0, 2.5*9.0),
-            (_('x 3.5'),int(15*3.5), int(20*3.5), int(20*3.5), int(3*6), 10.0*11.0, 2.5*11.0),
-            (_('x 4'),  int(15*4)  , int(20*4)  , int(20*4)  , int(3*7), 10.0*13.0, 2.5*13.0),
-            (_('Custom'),15,20,20,3,10,2.5),
-            ),
-        GmstTweak(_('Inventory Quantity Prompt'),
-            _("Number of items in a stack at which point Oblivion prompts for a quantity."),
-            ('iInventoryAskQuantityAt',),
-            ('1',1),
-            ('2',2),
-            ('[3]',3),
-            ('4',4),
-            ('10',10),
-            (_('No Prompt'),99999),
-            (_('Custom'),3),
-            ),
-        GmstTweak(_('Crime: Trespass Fine'),
-            _("Fine in septims for trespassing."),
-            ('iCrimeGoldTresspass',),
-            ('1',1),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('20',20),
-            (_('Custom'),5),
-            ),
-        GmstTweak(_('Crime: Pickpocketing Fine'),
-            _("Fine in septims for trespassing."),
-            ('iCrimeGoldPickpocket',),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            ('[25]',25),
-            ('50',50),
-            ('100',100),
-            (_('Custom'),25),
-            ),
-        GmstTweak(_('Leveled Item Max level difference'),
-            _("Maximum difference to player level for leveled items."),
-            ('iLevItemLevelDifferenceMax',),
-            ('1',1),
-            ('5',5),
-            ('[8]',8),
-            ('10',10),
-            ('20',20),
-            (_('Unlimited'),9999),
-            (_('Custom'),8),
-            ),
-        GmstTweak(_('Actor Strength Encumbrance Multiplier'),
-            _("Actor's Strength X this = Actor's Encumbrance capacity."),
-            ('fActorStrengthEncumbranceMult',),
-            ('1',1.0),
-            ('3',3.0),
-            ('[5]',5.0),
-            ('8',8.0),
-            ('10',10.0),
-            ('20',20.0),
-            (_('Unlimited'),999999.0),
-            (_('Custom'),5),
-            ),
-        GmstTweak(_('NPC Blood'),
-            _("NPC Blood Splatter Textures."),
-            ('sBloodTextureDefault', 'sBloodTextureExtra1','sBloodTextureExtra2', 'sBloodParticleDefault', 'sBloodParticleExtra1','sBloodParticleExtra2'),
-            (_('No Blood'),'','','','','',''),
-            (_('Custom'),'','','','','',''),
-            ),
-        GmstTweak(_('AI: Max Smile Distance'),
-            _("Maximum distance for NPCs to start smiling."),
-            ('fAIMaxSmileDistance',),
-            (_('No Smiles'),0.0),
-            (_('Default (128)'),128),
-            (_('Custom'),128),
-            ),
-        GmstTweak(_('Drag: Max Moveable Weight'),
-            _("Maximum weight to be able move things with the drag key."),
-            ('fMoveWeightMax',),
-            (_('MovableBodies.esp'),1500.0),
-            (_('[Default (150)]'),150),
-            (_('Custom'),150),
-            ),
-        ],key=lambda a: a.label.lower())
-    #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreGmst,))[self.isActive]
-        
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (None,(MreGmst,))[self.isActive]
-        
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        if not self.isActive or 'GMST' not in modFile.tops: return
-        mapper = modFile.getLongMapper()
-        patchRecords = self.patchFile.GMST
-        id_records = patchRecords.id_records
-        for record in modFile.GMST.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            record = record.getTypeCopy(mapper)
-            patchRecords.setRecord(record)
-            
-    def buildPatch(self,log,progress):
-        """Edits patch file as desired. Will write to log."""
-        if not self.isActive: return
-        keep = self.patchFile.getKeeper()
-        log.setHeader('= '+self.__class__.name)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(self.patchFile,keep,log)
-
-class CBash_GmstTweaker(CBash_MultiTweaker):
-    """Tweaks miscellaneous gmsts in miscellaneous ways."""
-    name = _('Tweak Settings')
-    text = _("Tweak game settings.")
-    tweaks = sorted([
-        CBash_GmstTweak(_('Arrow: Litter Count'),
-            _("Maximum number of spent arrows allowed in cell."),
-            ('iArrowMaxRefCount',),
-            ('[15]',15),
-            ('25',25),
-            ('35',35),
-            ('50',50),
-            ('100',100),
-            ('500',500),
-            (_('Custom'),15),
-            ),
-        CBash_GmstTweak(_('Arrow: Litter Time'),
-            _("Time before spent arrows fade away from cells and actors."),
-            ('fArrowAgeMax',),
-            (_('1 Minute'),60.0),
-            (_('[1.5 Minutes]'),90.0),
-            (_('2 Minutes'),120.0),
-            (_('3 Minutes'),180.0),
-            (_('5 Minutes'),300.0),
-            (_('10 Minutes'),600.0),
-            (_('30 Minutes'),1800.0),
-            (_('1 Hour'),3600.0),
-            (_('Custom (in seconds)'),90),
-            ),
-        CBash_GmstTweak(_('Arrow: Recovery from Actor'),
-            _("Chance that an arrow shot into an actor can be recovered."),
-            ('iArrowInventoryChance',),
-            ('[50%]',50),
-            ('60%',60),
-            ('70%',70),
-            ('80%',80),
-            ('90%',90),
-            ('100%',100),
-            (_('Custom'),50),
-            ),
-        CBash_GmstTweak(_('Arrow: Speed'),
-            _("Speed of full power arrow."),
-            ('fArrowSpeedMult',),
-            (_('x 1.2'),1500.0*1.2),
-            (_('x 1.4'),1500.0*1.4),
-            (_('x 1.6'),1500.0*1.6),
-            (_('x 1.8'),1500.0*1.8),
-            (_('x 2.0'),1500.0*2.0),
-            (_('x 2.2'),1500.0*2.2),
-            (_('x 2.4'),1500.0*2.4),
-            (_('x 2.6'),1500.0*2.6),
-            (_('x 2.8'),1500.0*2.8),
-            (_('x 3.0'),1500.0*3.0),
-            (_('Custom (base is 1500)'),1500),
-            ),
-        CBash_GmstTweak(_('Camera: Chase Tightness'),
-            _("Tightness of chase camera to player turning."),
-            ('fChase3rdPersonVanityXYMult','fChase3rdPersonXYMult'),
-            (_('x 1.5'),6.0,6.0),
-            (_('x 2.0'),8.0,8.0),
-            (_('x 3.0'),12.0,12.0),
-            (_('x 5.0'),20.0,20.0),
-            (_('ChaseCameraMod.esp (x 24.75)'),99,99),
-            (_('Custom'),4,4),
-            ),
-        CBash_GmstTweak(_('Camera: Chase Distance'),
-            _("Distance camera can be moved away from PC using mouse wheel."),
-            ('fVanityModeWheelMax', 'fChase3rdPersonZUnitsPerSecond','fVanityModeWheelMult'),
-            (_('x 1.5'),600.0*1.5, 300.0*1.5, 0.15),
-            (_('x 2'),  600.0*2.0, 300.0*2.0, 0.2),
-            (_('x 3'),  600.0*3.0, 300.0*3.0, 0.3),
-            (_('x 5'),  600.0*5.0, 1000.0,    0.3),
-            (_('x 10'), 600.0*10,  2000.0,    0.3),
-            (_('Custom'),600,      300,       0.15),
-            ),
-        CBash_GmstTweak(_('Magic: Chameleon Refraction'),
-            _("Chameleon with transparency instead of refraction effect."),
-            ('fChameleonMinRefraction','fChameleonMaxRefraction'),
-            (_('Zero'),0.0,0.0),
-            (_('[Normal]'),0.01,1.0),
-            (_('Full'),1.0,1.0),
-            (_('Custom'),0.01,1.0),
-            ),
-        CBash_GmstTweak(_('Compass: Disable'),
-            _("No quest and/or points of interest markers on compass."),
-            ('iMapMarkerRevealDistance',),
-            (_('Quests'),1803),
-            (_('POIs'),1802),
-            (_('Quests and POIs'),1801),
-            ),
-        CBash_GmstTweak(_('Compass: POI Recognition'),
-            _("Distance at which POI markers begin to show on compass."),
-            ('iMapMarkerVisibleDistance',),
-            (_('x 0.25'),3000),
-            (_('x 0.50'),6000),
-            (_('x 0.75'),9000),
-            (_('Custom (base 12000)'),12000),
-            ),
-        CBash_GmstTweak(_('Essential NPC Unconsciousness'),
-            _("Time which essential NPCs stay unconscious."),
-            ('fEssentialDeathTime',),
-            (_('[10 Seconds]'),10.0),
-            (_('20 Seconds'),20.0),
-            (_('30 Seconds'),30.0),
-            (_('1 Minute'),60.0),
-            (_('1 1/2 Minutes'),1.5*60.0),
-            (_('2 Minutes'),2*60.0),
-            (_('3 Minutes'),3*60.0),
-            (_('5 Minutes'),5*60.0),
-            (_('Custom (in seconds)'),10),
-            ),
-        CBash_GmstTweak(_('Fatigue from Running/Encumbrance'),
-            _("Fatigue cost of running and encumbrance."),
-            ('fFatigueRunBase','fFatigueRunMult'),
-            (_('x 1.5'),12.0,6.0),
-            (_('x 2'),16.0,8.0),
-            (_('x 3'),24.0,12.0),
-            (_('x 4'),32.0,16.0),
-            (_('x 5'),40.0,20.0),
-            (_('Custom'),8,4),
-            ),
-        CBash_GmstTweak(_('Horse Turning Speed'),
-            _("Speed at which horses turn."),
-            ('iHorseTurnDegreesPerSecond',),
-            (_('x 1.5'),68),
-            (_('x 2.0'),90),
-            (_('Custom (base is 45)'),45),
-            ),
-        CBash_GmstTweak(_('Jump Higher'),
-            _("Maximum height player can jump to."),
-            ('fJumpHeightMax',),
-            (_('x 1.1'),164.0*1.1),
-            (_('x 1.2'),164.0*1.2),
-            (_('x 1.4'),164.0*1.4),
-            (_('x 1.6'),164.0*1.6),
-            (_('x 1.8'),164.0*1.8),
-            (_('x 2.0'),164.0*2.0),
-            (_('x 3.0'),164.0*3.0),
-            (_('Custom (base 164)'),164),
-            ),
-        CBash_GmstTweak(_('Camera: PC Death Time'),
-            _("Time after player's death before reload menu appears."),
-            ('fPlayerDeathReloadTime',),
-            (_('15 Seconds'),15.0),
-            (_('30 Seconds'),30.0),
-            (_('1 Minute'),60.0),
-            (_('5 Minute'),300.0),
-            (_('Unlimited'),9999999.0),
-            (_('Custom'),15),
-            ),
-        CBash_GmstTweak(_('Cell Respawn Time'),
-            _("Time before unvisited cell respawns. But longer times increase save sizes."),
-            ('iHoursToRespawnCell',),
-            (_('1 Day'),24*1),
-            (_('[3 Days]'),24*3),
-            (_('5 Days'),24*5),
-            (_('10 Days'),24*10),
-            (_('20 Days'),24*20),
-            (_('1 Month'),24*30),
-            (_('6 Months'),24*182),
-            (_('1 Year'),24*365),
-            (_('Custom (in hours)'),72),
-            ),
-        CBash_GmstTweak(_('Combat: Recharge Weapons'),
-            _("Allow recharging weapons during combat."),
-            ('iAllowRechargeDuringCombat',),
-            (_('[Allow]'),1),
-            (_('Disallow'),0),
-            ),
-        CBash_GmstTweak(_('Magic: Bolt Speed'),
-            _("Speed of magic bolt/projectile."),
-            ('fMagicProjectileBaseSpeed',),
-            (_('x 1.2'),1000.0*1.2),
-            (_('x 1.4'),1000.0*1.4),
-            (_('x 1.6'),1000.0*1.6),
-            (_('x 1.8'),1000.0*1.8),
-            (_('x 2.0'),1000.0*2.0),
-            (_('x 2.2'),1000.0*2.2),
-            (_('x 2.4'),1000.0*2.4),
-            (_('x 2.6'),1000.0*2.6),
-            (_('x 2.8'),1000.0*2.8),
-            (_('x 3.0'),1000.0*3.0),
-            (_('Custom (base 1000)'),1000),
-            ),
-        CBash_GmstTweak(_('Msg: Equip Misc. Item'),
-            _("Message upon equipping misc. item."),
-            ('sCantEquipGeneric',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Auto Saving'),
-            _("Message upon auto saving."),
-            ('sAutoSaving',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Harvest Failure'),
-            _("Message upon failure at harvesting flora."),
-            ('sFloraFailureMessage',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Harvest Success'),
-            _("Message upon success at harvesting flora."),
-            ('sFloraSuccesssMessage',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Quick Save'),
-            _("Message upon quick saving."),
-            ('sQuickSaving',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Horse Stabled'),
-            _("Message upon fast traveling with a horse to a city."),
-            ('sFastTravelHorseatGate',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: No Fast Travel'),
-            _("Message when attempting to fast travel when fast travel is unavailable due to location."),
-            ('sNoFastTravelScriptBlock',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Loading Area'),
-            _("Message when background loading area."),
-            ('sLoadingArea',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Quick Load'),
-            _("Message when quick loading."),
-            ('sQuickLoading',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Msg: Not Enough Charge'),
-            _("Message when enchanted item is out of charge."),
-            ('sNoCharge',),
-            (_('[None]'),' '),
-            ('.','.'),
-            (_('Hmm...'),_('Hmm...')),
-            (_('Custom'),_(' ')),
-            ),
-        CBash_GmstTweak(_('Cost Multiplier: Repair'),
-            _("Cost factor for repairing items."),
-            ('fRepairCostMult',),
-            ('0.1',0.1),
-            ('0.2',0.2),
-            ('0.3',0.3),
-            ('0.4',0.4),
-            ('0.5',0.5),
-            ('0.6',0.6),
-            ('0.7',0.7),
-            ('0.8',0.8),
-            ('[0.9]',0.9),
-            ('1.0',1.0),
-            (_('Custom'),0.9),
-            ),
-        CBash_GmstTweak(_('Greeting Distance'),
-            _("Distance at which NPCs will greet the player. Default: 150"),
-            ('fAIMinGreetingDistance',),
-            ('100',100.0),
-            ('125',125.0),
-            ('[150]',150.0),
-            (_('Custom'),150.0),
-            ),
-        CBash_GmstTweak(_('Cost Multiplier: Recharge'),
-            _("Cost factor for recharging items."),
-            ('fRechargeGoldMult',),
-            ('0.1',0.1),
-            ('0.2',0.2),
-            ('0.3',0.3),
-            ('0.5',0.5),
-            ('0.7',0.7),
-            ('1.0',1.0),
-            ('1.5',1.5),
-            ('[2.0]',2.0),
-            (_('Custom'),2.0),
-            ),
-        CBash_GmstTweak(_('Master of Mercantile extra gold amount'),
-            _("How much more barter gold all merchants have for a master of mercantile."),
-            ('iPerkExtraBarterGoldMaster',),
-            ('300',300),
-            ('400',400),
-            ('[500]',500),
-            ('600',600),
-            ('800',800),
-            ('1000',1000),
-            (_('Custom'),500),
-            ),
-        CBash_GmstTweak(_('Combat: Max Actors'),
-            _("Maximum number of actors that can actively be in combat with the player."),
-            ('iNumberActorsInCombatPlayer',),
-            ('[10]',10),
-            ('15',15),
-            ('20',20),
-            ('30',30),
-            ('40',40),
-            ('50',50),
-            ('80',80),
-            (_('Custom'),10),
-            ),
-        CBash_GmstTweak(_('Crime Alarm Distance'),
-            _("Distance from player that NPCs(guards) will be alerted of a crime."),
-            ('iCrimeAlarmRecDistance',),
-            ('6000',6000),
-            ('[4000]',4000),
-            ('3000',3000),
-            ('2000',2000),
-            ('1000',1000),
-            ('500',500),
-            (_('Custom'),4000),
-            ),
-        CBash_GmstTweak(_('Cost Multiplier: Enchantment'),
-            _("Cost factor for enchanting items, OOO default is 120, vanilla 10."),
-            ('fEnchantmentGoldMult',),
-            ('[10]',10.0),
-            ('20',20.0),
-            ('30',30.0),
-            ('50',50.0),
-            ('70',70.0),
-            ('90',90.0),
-            ('120',120.0),
-            ('150',150.0),
-            (_('Custom'),10),
-            ),
-        CBash_GmstTweak(_('Cost Multiplier: Spell Making'),
-            _("Cost factor for making spells."),
-            ('fSpellmakingGoldMult',),
-            ('[3]',3.0),
-            ('5',5.0),
-            ('8',8.0),
-            ('10',10.0),
-            ('15',15.0),
-            (_('Custom'),3),
-            ),
-        CBash_GmstTweak(_('AI: Max Active Actors'),
-            _("Maximum actors whose AI can be active. Must be higher than Combat: Max Actors"),
-            ('iAINumberActorsComplexScene',),
-            ('20',20),
-            ('[25]',25),
-            ('30',30),
-            ('35',35),
-            (_('MMM Default: 40'),40),
-            ('50',50),
-            ('60',60),
-            ('100',100),
-            (_('Custom'),25),
-            ),
-        CBash_GmstTweak(_('Magic: Max Player Summons'),
-            _("Maximum number of creatures the player can summon."),
-            ('iMaxPlayerSummonedCreatures',),
-            ('[1]',1),
-            ('3',3),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            (_('Custom'),1),
-            ),
-        CBash_GmstTweak(_('Combat: Max Ally Hits'),
-            _("Maximum number of hits on an ally allowed in combat before the ally will attack the hitting character."),
-            ('iAllyHitAllowed',),
-            ('3',3),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('15',15),
-            (_('Custom'),5),
-            ),
-        CBash_GmstTweak(_('Magic: Max NPC Summons'),
-            _("Maximum number of creatures that each NPC can summon"),
-            ('iAICombatMaxAllySummonCount',),
-            ('1',1),
-            ('[3]',3),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            ('15',15),
-            (_('Custom'),3),
-            ),
-        CBash_GmstTweak(_('Bounty: Attack'),
-            _("Bounty for attacking a 'good' npc."),
-            ('iCrimeGoldAttackMin',),
-            ('300',300),
-            ('400',400),
-            ('[500]',500),
-            ('650',650),
-            ('800',800),
-            (_('Custom'),500),
-            ),
-        CBash_GmstTweak(_('Bounty: Horse Theft'),
-            _("Bounty for horse theft"),
-            ('iCrimeGoldStealHorse',),
-            ('100',100),
-            ('200',200),
-            ('[250]',250),
-            ('300',300),
-            ('450',450),
-            (_('Custom'),250),
-            ),
-        CBash_GmstTweak(_('Bounty: Theft'),
-            _("Bounty for stealing, as fraction of item value."),
-            ('fCrimeGoldSteal',),
-            ('1/4',0.25),
-            ('[1/2]',0.5),
-            ('3/4',0.75),
-            ('1',1.0),
-            (_('Custom'),0.5),
-            ),
-        CBash_GmstTweak(_('Combat: Alchemy'),
-            _("Allow alchemy during combat."),
-            ('iAllowAlchemyDuringCombat',),
-            (_('Allow'),1),
-            (_('[Disallow]'),0),
-            ),
-        CBash_GmstTweak(_('Combat: Repair'),
-            _("Allow repairing armor/weapons during combat."),
-            ('iAllowRepairDuringCombat',),
-            (_('Allow'),1),
-            (_('[Disallow]'),0),
-            ),
-        CBash_GmstTweak(_('Companions: Max Number'),
-            _("Maximum number of actors following the player"),
-            ('iNumberActorsAllowedToFollowPlayer',),
-            ('2',2),
-            ('4',4),
-            ('[6]',6),
-            ('8',8),
-            ('10',10),
-            (_('Custom'),6),
-            ),
-        CBash_GmstTweak(_('Training Max'),
-            _("Maximum number of Training allowed by trainers."),
-            ('iTrainingSkills',),
-            ('1',1),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('20',20),
-            (_('Unlimited'),9999),
-            (_('Custom'),0),
-            ),
-        CBash_GmstTweak(_('Combat: Maximum Armor Rating'),
-            _("The Maximun amount of protection you will get from armor."),
-            ('fMaxArmorRating',),
-            ('50',50.0),
-            ('75',75.0),
-            ('[85]',85.0),
-            ('90',90.0),
-            ('95',95.0),
-            (_('Custom'),85),
-            ),
-        CBash_GmstTweak(_('Warning: Interior Distance to Hostiles'),
-            _("The minimum distance hostile actors have to be to be allowed to sleep, travel etc, when inside interiors."),
-            ('fHostileActorInteriorDistance',),
-            ('10',10.0),
-            ('100',100.0),
-            ('500',500.0),
-            ('1000',1000.0),
-            ('[2000]',2000.0),
-            ('3000',3000.0),
-            ('4000',4000.0),
-            (_('Custom'),2000),
-            ),
-        CBash_GmstTweak(_('Warning: Exterior Distance to Hostiles'),
-            _("The minimum distance hostile actors have to be to be allowed to sleep, travel etc, when outside."),
-            ('fHostileActorExteriorDistance',),
-            ('10',10.0),
-            ('100',100.0),
-            ('500',500.0),
-            ('1000',1000.0),
-            ('2000',2000.0),
-            ('[3000]',3000.0),
-            ('4000',4000.0),
-            ('5000',5000.0),
-            ('6000',6000.0),
-            (_('Custom'),3000),
-            ),
-        CBash_GmstTweak(_('UOP Vampire Aging and Face Fix.esp'),
-            _("Duplicate of UOP component that disables vampire aging (fixes a bug). Use instead of 'UOP Vampire Aging & Face Fix.esp' to save an esp slot."),
-            ('iVampirismAgeOffset',),
-            ('Fix it!',0),
-            ),
-        CBash_GmstTweak(_('AI: Max Dead Actors'),
-            _("Maximum number of dead actors allowed before they're removed."),
-            ('iRemoveExcessDeadCount', 'iRemoveExcessDeadTotalActorCount','iRemoveExcessDeadComplexTotalActorCount',
-             'iRemoveExcessDeadComplexCount', 'fRemoveExcessDeadTime','fRemoveExcessComplexDeadTime'),
-            (_('[x 1]'),int(15*1)  , int(20*1)  , int(20*1)  , int(3*1), 10.0*1.0, 2.5*1.0),
-            (_('x 1.5'),int(15*1.5), int(20*1.5), int(20*1.5), int(3*2), 10.0*3.0, 2.5*3.0),
-            (_('x 2'),  int(15*2)  , int(20*2)  , int(20*2)  , int(3*3), 10.0*5.0, 2.5*5.0),
-            (_('x 2.5'),int(15*2.5), int(20*2.5), int(20*2.5), int(3*4), 10.0*7.0, 2.5*7.0),
-            (_('x 3'),  int(15*3)  , int(20*3)  , int(20*3)  , int(3*5), 10.0*9.0, 2.5*9.0),
-            (_('x 3.5'),int(15*3.5), int(20*3.5), int(20*3.5), int(3*6), 10.0*11.0, 2.5*11.0),
-            (_('x 4'),  int(15*4)  , int(20*4)  , int(20*4)  , int(3*7), 10.0*13.0, 2.5*13.0),
-            (_('Custom'),15,20,20,3,10,2.5),
-            ),
-        CBash_GmstTweak(_('Inventory Quantity Prompt'),
-            _("Number of items in a stack at which point Oblivion prompts for a quantity."),
-            ('iInventoryAskQuantityAt',),
-            ('1',1),
-            ('2',2),
-            ('[3]',3),
-            ('4',4),
-            ('10',10),
-            (_('No Prompt'),99999),
-            (_('Custom'),3),
-            ),
-        CBash_GmstTweak(_('Crime: Trespass Fine'),
-            _("Fine in septims for trespassing."),
-            ('iCrimeGoldTresspass',),
-            ('1',1),
-            ('[5]',5),
-            ('8',8),
-            ('10',10),
-            ('20',20),
-            (_('Custom'),5),
-            ),
-        CBash_GmstTweak(_('Crime: Pickpocketing Fine'),
-            _("Fine in septims for trespassing."),
-            ('iCrimeGoldPickpocket',),
-            ('5',5),
-            ('8',8),
-            ('10',10),
-            ('[25]',25),
-            ('50',50),
-            ('100',100),
-            (_('Custom'),25),
-            ),
-        CBash_GmstTweak(_('Leveled Item Max level difference'),
-            _("Maximum difference to player level for leveled items."),
-            ('iLevItemLevelDifferenceMax',),
-            ('1',1),
-            ('5',5),
-            ('[8]',8),
-            ('10',10),
-            ('20',20),
-            (_('Unlimited'),9999),
-            (_('Custom'),8),
-            ),
-        CBash_GmstTweak(_('Actor Strength Encumbrance Multiplier'),
-            _("Actor's Strength X this = Actor's Encumbrance capacity."),
-            ('fActorStrengthEncumbranceMult',),
-            ('1',1.0),
-            ('3',3.0),
-            ('[5]',5.0),
-            ('8',8.0),
-            ('10',10.0),
-            ('20',20.0),
-            (_('Unlimited'),999999.0),
-            (_('Custom'),5),
-            ),
-        CBash_GmstTweak(_('NPC Blood'),
-            _("NPC Blood Splatter Textures."),
-            ('sBloodTextureDefault', 'sBloodTextureExtra1','sBloodTextureExtra2', 'sBloodParticleDefault', 'sBloodParticleExtra1','sBloodParticleExtra2'),
-            (_('No Blood'),'','','','','',''),
-            (_('Custom'),'','','','','',''),
-            ),
-        CBash_GmstTweak(_('AI: Max Smile Distance'),
-            _("Maximum distance for NPCs to start smiling."),
-            ('fAIMaxSmileDistance',),
-            (_('No Smiles'),0.0),
-            (_('Default (128)'),128),
-            (_('Custom'),128),
-            ),
-        CBash_GmstTweak(_('Drag: Max Moveable Weight'),
-            _("Maximum weight to be able move things with the drag key."),
-            ('fMoveWeightMax',),
-            (_('MovableBodies.esp'),1500.0),
-            (_('[Default (150)]'),150),
-            (_('Custom'),150),
-            ),
-        ],key=lambda a: a.label.lower())
-    #--Config Phase ------------------------------------------------------------
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
+
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
+
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched graphics data as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        break
+                else:
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
+
+# class CBash_KFFZPatcher(CBash_ImportPatcher):
+#     """Merges changes to actor animations."""
+#     name = _('Import Actors: Animations')
+#     text = _("Import Actor animations from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Actors.Anims',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_animations = {}
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         animations = self.id_animations.setdefault(record.fid,[])
+#         animations.extend([anim for anim in record.animations if anim not in animations])
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         if(recordId in self.id_animations and record.animations != self.id_animations[recordId]):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.animations = self.id_animations[recordId]
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Imported Animations: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class NPCAIPackagePatcher(ImportPatcher):
+    """Merges changes to the AI Packages of Actors."""
+    name = _('Import Actors: AIPackages')
+    text = _("Import Actor AIPackage links from source mods.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = ('Actors.AIPackages','Actors.AIPackagesForceAdd')
+
+    #--Patch Phase ------------------------------------------------------------
     def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks:
-            tweak.patchFile = patchFile
-            tweak.eid_count = {}
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcMods = self.getConfigChecked()
+        self.isActive = len(self.srcMods) != 0
+        self.data = {}
+        self.longTypes = set(('CREA','NPC_'))
 
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
+    def initData(self,progress):
+        """Get data from source files."""
         if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-#------------------------------------------------------------------------------
-class NamesTweak_BodyTags(MultiTweakItem):
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Body Part Codes"),
-            _('Sets body part codes used by Armor/Clothes name tweaks. A: Amulet, R: Ring, etc.'),
-            'bodyTags',
-            ('ARGHTCCPBS','ARGHTCCPBS'),
-            ('ABGHINOPSL','ABGHINOPSL'),
-            )
+        OOOandUOP = False
+        # Removed OOO compatability check, as newest OOO will have the packages removed in
+        # favor of the UOP ones anyway.
+        ##if GPath("Oscuro's_Oblivion_Overhaul.esm") in self.srcMods or GPath("Oscuro's_Oblivion_Overhaul.esp") in self.srcMods:
+        ##    if GPath("Unofficial Oblivion Patch.esp") in self.srcMods:
+        ##        OOOandUOP = True
+        longTypes = self.longTypes
+        loadFactory = LoadFactory(False,MreCrea,MreNpc)
+        progress.setFull(len(self.srcMods))
+        cachedMasters = {}
+        data = self.data
+        for index,srcMod in enumerate(self.srcMods):
+            tempData = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            bashTags = srcInfo.getBashTags()
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass in (MreNpc,MreCrea):
+                if recClass.classType not in srcFile.tops: continue
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    tempData[fid] = list(record.aiPackages)
+            for master in reversed(masters):
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for block in (MreNpc, MreCrea):
+                    if block.classType not in srcFile.tops: continue
+                    if block.classType not in masterFile.tops: continue
+                    for record in masterFile.tops[block.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if not fid in tempData: continue
+                        if record.aiPackages == tempData[fid] and not 'Actors.AIPackagesForceAdd' in bashTags:
+                            # if subrecord is identical to the last master then we don't care about older masters.
+                            del tempData[fid]
+                            continue
+                        if fid in data:
+                            if tempData[fid] == data[fid]['merged']: continue
+                        recordData = {'deleted':[],'merged':tempData[fid]}
+                        for pkg in list(record.aiPackages):
+                            if not pkg in tempData[fid]:
+                                recordData['deleted'].append(pkg)
+                        if not fid in data:
+                            data[fid] = recordData
+                        else:
+                            for pkg in recordData['deleted']:
+                                if pkg in data[fid]['merged']:
+                                    data[fid]['merged'].remove(pkg)
+                                data[fid]['deleted'].append(pkg)
+                            if data[fid]['merged'] == []:
+                                for pkg in recordData['merged']:
+                                    if pkg in data[fid]['deleted'] and not 'Actors.AIPackagesForceAdd' in bashTags: continue
+                                    data[fid]['merged'].append(pkg)
+                                continue
+                            for index, pkg in enumerate(recordData['merged']):
+                                if not pkg in data[fid]['merged']: # so needs to be added... (unless deleted that is)
+                                    # find the correct position to add and add.
+                                    if pkg in data[fid]['deleted'] and not 'Actors.AIPackagesForceAdd' in bashTags: continue #previously deleted
+                                    if index == 0:
+                                        data[fid]['merged'].insert(0,pkg) #insert as first item
+                                    elif index == (len(recordData['merged'])-1):
+                                        data[fid]['merged'].append(pkg) #insert as last item
+                                    else: #figure out a good spot to insert it based on next or last recognized item (ugly ugly ugly)
+                                        i = index - 1
+                                        while i >= 0:
+                                            if recordData['merged'][i] in data[fid]['merged']:
+                                                slot = data[fid]['merged'].index(recordData['merged'][i])+1
+                                                data[fid]['merged'].insert(slot, pkg)
+                                                break
+                                            i -= 1
+                                        else:
+                                            i = index + 1
+                                            while i != len(recordData['merged']):
+                                                if recordData['merged'][i] in data[fid]['merged']:
+                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
+                                                    data[fid]['merged'].insert(slot, pkg)
+                                                    break
+                                                i += 1
+                                    continue # Done with this package
+                                elif index == data[fid]['merged'].index(pkg) or (len(recordData['merged'])-index) == (len(data[fid]['merged'])-data[fid]['merged'].index(pkg)): continue #pkg same in both lists.
+                                else: #this import is later loading so we'll assume it is better order
+                                    data[fid]['merged'].remove(pkg)
+                                    if index == 0:
+                                        data[fid]['merged'].insert(0,pkg) #insert as first item
+                                    elif index == (len(recordData['merged'])-1):
+                                        data[fid]['merged'].append(pkg) #insert as last item
+                                    else:
+                                        i = index - 1
+                                        while i >= 0:
+                                            if recordData['merged'][i] in data[fid]['merged']:
+                                                slot = data[fid]['merged'].index(recordData['merged'][i]) + 1
+                                                data[fid]['merged'].insert(slot, pkg)
+                                                break
+                                            i -= 1
+                                        else:
+                                            i = index + 1
+                                            while i != len(recordData['merged']):
+                                                if recordData['merged'][i] in data[fid]['merged']:
+                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
+                                                    data[fid]['merged'].insert(slot, pkg)
+                                                    break
+                                                i += 1
+                        ##if OOOandUOP:
+                        ##    for pkg in recordData['merged']:
+                        ##        if pkg[0] == bolt.Path("Oscuro's_Oblivion_Overhaul.esm"):
+                        ##            if pkg[1] in [12892,12893,12894,12895,23921,23922,23926,40669,40671]:
+                        ##                if pkg in data[fid]['merged']:
+                        ##                    data[fid]['merged'].remove(pkg)
+            progress.plus()
 
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return tuple()
+        return (None,(MreNpc,MreCrea))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return tuple()
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        return
+        return (None,(MreNpc,MreCrea))[self.isActive]
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        patchFile.bodyTags = self.choiceValues[self.chosen][0]
-class CBash_NamesTweak_BodyTags(CBash_MultiTweakItem):
-    scanOrder = 32
-    editOrder = 32
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Body Part Codes"),
-            _('Sets body part codes used by Armor/Clothes name tweaks. A: Amulet, R: Ring, etc.'),
-            'bodyTags',
-            ('ARGHTCCPBS','ARGHTCCPBS'),
-            ('ABGHINOPSL','ABGHINOPSL'),
-            )
+    def scanModFile(self, modFile, progress):
+        """Add record from modFile."""
+        if not self.isActive: return
+        data = self.data
+        mapper = modFile.getLongMapper()
+        modName = modFile.fileInfo.name
+        for type in ('NPC_','CREA'):
+            patchBlock = getattr(self.patchFile,type)
+            for record in getattr(modFile,type).getActiveRecords():
+                fid = mapper(record.fid)
+                if fid in data:
+                    if list(record.aiPackages) != data[fid]['merged']:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def getTypes(self):
-        return []
+    def buildPatch(self,log,progress):
+        """Applies delta to patchfile."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        data = self.data
+        mod_count = {}
+        for type in ('NPC_','CREA'):
+            for record in getattr(self.patchFile,type).records:
+                fid = record.fid
+                if not fid in data: continue
+                changed = False
+                if record.aiPackages != data[fid]['merged']:
+                    record.aiPackages = data[fid]['merged']
+                    changed = True
+                if changed:
+                    keep(record.fid)
+                    mod = record.fid[0]
+                    mod_count[mod] = mod_count.get(mod,0) + 1
+        #--Log
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.srcMods:
+            log("* " +mod.s)
+        log(_("\n=== AI Package Lists Changed: %d") % (sum(mod_count.values()),))
+        for mod in modInfos.getOrdered(mod_count):
+            log('* %s: %3d' % (mod.s,mod_count[mod]))
+
+# class CBash_NPCAIPackagePatcher(CBash_ImportPatcher):
+#     """Merges changes to the AI Packages of Actors."""
+#     name = _('Import Actors: AIPackages')
+#     text = _("Import Actor AIPackage links from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Actors.AIPackages','Actors.AIPackagesForceAdd'))
+#     scanRequiresChecked = False
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.previousPackages = {}
+#         self.mergedPackageList = {}
+#         self.mod_count = {}
+#         # Removed OOO compatability check, as newest OOO will have the packages removed in
+#         # favor of the UOP ones anyway.
+#         ##if ("Oscuro's_Oblivion_Overhaul.esm" in self.srcs or "Oscuro's_Oblivion_Overhaul.esp" in self.srcs
+#         ##    and "Unofficial Oblivion Patch.esp" in self.srcs):
+#         ##    self.OOOandUOP = True
+#         ##else:
+#         ##    self.OOOandUOP = False
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         recordId = record.fid
+#         newPackages = bolt.MemorySet(record.aiPackages)
+#         if recordId not in self.previousPackages:
+#             self.previousPackages[recordId] = {}
+#         self.previousPackages[recordId][modFile.GName] = newPackages
+
+#         if modFile.GName in self.srcs:
+#             masterPackages = self.previousPackages[recordId].get(recordId[0],None)
+#             if masterPackages and not masterPackages ^ newPackages: return
+#             if recordId not in self.mergedPackageList:
+#                 self.mergedPackageList[recordId] = newPackages
+#             mergedPackages = self.mergedPackageList[recordId]
+#             if newPackages == mergedPackages: return #same as the current list, just skip.
+#             for master in reversed(modFile.TES4.masters):
+#                 masterPath = GPath(master)
+#                 masterPackages = self.previousPackages[recordId].get(masterPath,None)
+#                 if masterPackages is None: continue
+
+#                 # Get differences from master
+#                 added = newPackages - masterPackages
+#                 sameButReordered = masterPackages & newPackages
+#                 prevDeleted = bolt.MemorySet(mergedPackages.discarded)
+#                 newDeleted = masterPackages - newPackages
+
+#                 # Merge those changes into mergedPackages
+#                 mergedPackages |= newPackages
+#                 if 'Actors.AIPackagesForceAdd' not in bashTags:
+#                     prevDeleted -= newPackages
+#                 prevDeleted |= newDeleted
+#                 mergedPackages -= prevDeleted
+#                 self.mergedPackageList[recordId] = mergedPackages
+#                 break
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         if recordId in self.mergedPackageList:
+#             mergedPackages = list(self.mergedPackageList[recordId])
+#             ##if self.OOOandUOP:
+#             ##    for pkg in mergedPackages:
+#             ##        if pkg[0] == bolt.Path("Oscuro's_Oblivion_Overhaul.esm"):
+#             ##            if pkg[1] in [12892,12893,12894,12895,23921,23922,23926,40669,40671]:
+#             ##                mergedPackages.remove(pkg)
+#             if(record.aiPackages != mergedPackages):
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     try:
+#                         override.aiPackages = mergedPackages
+#                     except:
+#                         newMergedPackages = []
+#                         for pkg in mergedPackages:
+#                             if not pkg[0] == None: newMergedPackages.append(pkg)
+#                         override.aiPackages = newMergedPackages
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* AI Package Lists Changed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        pass
 #------------------------------------------------------------------------------
-class NamesTweak_Body(MultiTweakItem):
-    """Names tweaker for armor and clothes."""
+class DeathItemPatcher(ImportPatcher):
+    """Merges changes to actor death items."""
+    name = _('Import Actors: Death Items')
+    text = _("Import Actor death items from source mods.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Actors.DeathItem'
 
     #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreRecord.type_class[self.key],)
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_data = {} #--Names keyed by long fid.
+        self.srcClasses = set() #--Record classes actually provided by src mods/files.
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = len(self.sourceMods) != 0
+        #--Type Fields
+        recAttrs_class = self.recAttrs_class = {}
+        for recClass in (MreCrea,MreNpc):
+            recAttrs_class[recClass] = ('deathItem',)
+        #--Needs Longs
+        self.longTypes = set(('CREA','NPC_'))
 
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreRecord.type_class[self.key],)
+    def initData(self,progress):
+        """Get actor death items from source files."""
+        if not self.isActive: return
+        self.classestemp = set()
+        id_data = self.id_data
+        recAttrs_class = self.recAttrs_class
+        loadFactory = LoadFactory(False,*recAttrs_class.keys())
+        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
+        progress.setFull(len(self.sourceMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.sourceMods):
+            temp_id_data = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass,recAttrs in recAttrs_class.iteritems():
+                if recClass.classType not in srcFile.tops: continue
+                self.srcClasses.add(recClass)
+                self.classestemp.add(recClass)
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
         mapper = modFile.getLongMapper()
-        patchBlock = getattr(patchFile,self.key)
-        id_records = patchBlock.id_records
-        for record in getattr(modFile,self.key).getActiveRecords():
-            if record.full and mapper(record.fid) not in id_records:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        format = self.choiceValues[self.chosen][0]
-        showStat = '%02d' in format
-        keep = patchFile.getKeeper()
-        codes = getattr(patchFile,'bodyTags','ARGHTCCPBS')
-        amulet,ring,gloves,head,tail,robe,chest,pants,shoes,shield = [
-            x for x in codes]
-        for record in getattr(patchFile,self.key).records:
-            if not record.full: continue
-            if record.full[0] in '+-=.()[]': continue
-            flags = record.flags
-            if flags.head or flags.hair: type = head
-            elif flags.rightRing or flags.leftRing: type = ring
-            elif flags.amulet: type = amulet
-            elif flags.upperBody and flags.lowerBody: type = robe
-            elif flags.upperBody: type = chest
-            elif flags.lowerBody: type = pants
-            elif flags.hand: type = gloves
-            elif flags.foot: type = shoes
-            elif flags.tail: type = tail
-            elif flags.shield: type = shield
-            else: continue
-            if record.recType == 'ARMO':
-                type += 'LH'[record.flags.heavyArmor]
-            if showStat:
-                record.full = format % (type,record.strength/100) + record.full
-            else:
-                record.full = format % type + record.full
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_NamesTweak_Body(CBash_MultiTweakItem):
-    """Names tweaker for armor and clothes."""
-    scanOrder = 32
-    editOrder = 32
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self,label,tip,key,*choices):
-        CBash_MultiTweakItem.__init__(self,label,tip,key,*choices)
-        self.mod_count = {}
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched actor death item as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            #deprint(recClass,type,type_count[type])
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        break
+                else:
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " + mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.items()):
+            if count: log("* %s: %d" % (type,count))
+# class CBash_DeathItemPatcher(CBash_ImportPatcher):
+#     """Imports actor death items."""
+#     name = _('Import Actors: Death Items')
+#     text = _("Import Actor death items from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Actors.DeathItem',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_deathItem = {}
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         deathitem = record.ConflictDetails(('deathItem',), False)
+#         if deathitem:
+#             self.id_deathItem[record.fid] = deathitem['deathItem']
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#                 #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         if(recordId in self.id_deathItem and record.deathItem != self.id_deathItem[recordId]):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.deathItem = self.id_deathItem[recordId]
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_('* Imported Death Items: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def getTypes(self):
-        return [self.key]
+#------------------------------------------------------------------------------
+class ImportFactions(ImportPatcher):
+    """Import factions to creatures and NPCs."""
+    name = _('Import Factions')
+    text = _("Import factions from source mods/files.")
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    autoKey = 'Factions'
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsNonPlayable: return
-        newFull = record.full
-        if newFull:
-            if record.IsHead or record.IsHair: type = self.head
-            elif record.IsRightRing or record.IsLeftRing: type = self.ring
-            elif record.IsAmulet: type = self.amulet
-            elif record.IsUpperBody and record.IsLowerBody: type = self.robe
-            elif record.IsUpperBody: type = self.chest
-            elif record.IsLowerBody: type = self.pants
-            elif record.IsHand: type = self.gloves
-            elif record.IsFoot: type = self.shoes
-            elif record.IsTail: type = self.tail
-            elif record.IsShield: type = self.shield
-            else: return
-            if record._Type == 'ARMO':
-                type += 'LH'[record.IsHeavyArmor]
-            if self.showStat:
-                newFull = self.format % (type,record.strength/100) + newFull
-            else:
-                newFull = self.format % type + newFull
-            if record.full != newFull:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.full = newFull
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_factions= {} #--Factions keyed by long fid.
+        self.activeTypes = [] #--Types ('CREA','NPC_') of data actually provided by src mods/files.
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* %s Renamed: %d') % (self.key,sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class NamesTweak_Potions(MultiTweakItem):
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Potions"),
-            _('Label potions to sort by type and effect.'),
-            'ALCH',
-            (_('XD Illness'),  '%s '),
-            (_('XD. Illness'), '%s. '),
-            (_('XD - Illness'),'%s - '),
-            (_('(XD) Illness'),'(%s) '),
-            )
+    def initData(self,progress):
+        """Get names from source files."""
+        if not self.isActive: return
+        actorFactions = ActorFactions(aliases=self.patchFile.aliases)
+        progress.setFull(len(self.srcFiles))
+        for srcFile in self.srcFiles:
+            srcPath = GPath(srcFile)
+            patchesDir = dirs['patches'].list()
+            if reModExt.search(srcFile.s):
+                if srcPath not in modInfos: continue
+                srcInfo = modInfos[GPath(srcFile)]
+                actorFactions.readFromMod(srcInfo)
+            else:
+                if srcPath not in patchesDir: continue
+                actorFactions.readFromText(dirs['patches'].join(srcFile))
+            progress.plus()
+        #--Finish
+        id_factions= self.id_factions
+        for type,aFid_factions in actorFactions.type_id_factions.iteritems():
+            if type not in ('CREA','NPC_'): continue
+            self.activeTypes.append(type)
+            for longid,factions in aFid_factions.iteritems():
+                self.id_factions[longid] = factions
+        self.isActive = bool(self.activeTypes)
 
-    #--Config Phase -----------------------------------------------------------
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreAlch,)
+        if not self.isActive: return None
+        return self.activeTypes
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreAlch,)
+        if not self.isActive: return None
+        return [MreRecord.type_class[type] for type in self.activeTypes]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Scan modFile."""
+        if not self.isActive: return
+        id_factions= self.id_factions
+        modName = modFile.fileInfo.name
         mapper = modFile.getLongMapper()
-        patchBlock = patchFile.ALCH
-        id_records = patchBlock.id_records
-        for record in modFile.ALCH.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            record = record.getTypeCopy(mapper)
-            patchBlock.setRecord(record)
+        for type in self.activeTypes:
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            id_records = patchBlock.id_records
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid in id_records: continue
+                if fid not in id_factions: continue
+                patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        format = self.choiceValues[self.chosen][0]
-        hostileEffects = patchFile.getMgefHostiles()
-        keep = patchFile.getKeeper()
-        reOldLabel = re.compile('^(-|X) ')
-        reOldEnd = re.compile(' -$')
-        mgef_school = patchFile.getMgefSchool()
-        for record in patchFile.ALCH.records:
-            if not record.full: continue
-            school = 6 #--Default to 6 (U: unknown)
-            for index,effect in enumerate(record.effects):
-                effectId = effect.name
-                if index == 0:
-                    if effect.scriptEffect:
-                        school = effect.scriptEffect.school
-                    else:
-                        school = mgef_school.get(effectId,6)
-                #--Non-hostile effect?
-                if effect.scriptEffect:
-                    if not effect.scriptEffect.flags.hostile:
-                        isPoison = False
-                        break
-                elif effectId not in hostileEffects:
-                    isPoison = False
-                    break
-            else:
-                isPoison = True
-            full = reOldLabel.sub('',record.full) #--Remove existing label
-            full = reOldEnd.sub('',full)
-            if record.flags.isFood:
-                record.full = '.'+full
-            else:
-                label = ('','X')[isPoison] + 'ACDIMRU'[school]
-                record.full = format % label + full
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+    def buildPatch(self,log,progress):
+        """Make changes to patchfile."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_factions= self.id_factions
+        type_count = {}
+        for type in self.activeTypes:
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid in id_factions:
+                    newFactions = set(id_factions[fid])
+                    curFactions = set((x.faction,x.rank) for x in record.factions)
+                    changed = newFactions - curFactions
+                    if not changed: continue
+                    doKeep = False
+                    for faction,rank in changed:
+                        for entry in record.factions:
+                            if entry.faction == faction:
+                                if entry.rank != rank:
+                                    entry.rank = rank
+                                    doKeep = True
+                                    keep(fid)
+                                break
+                        else:
+                            entry = MelObject()
+                            entry.faction = faction
+                            entry.rank = rank
+                            entry.unused1 = 'ODB'
+                            record.factions.append(entry)
+                            doKeep = True
+                    if doKeep:
+                        record.factions = [x for x in record.factions if x.rank != -1]
+                        type_count[type] += 1
+                        keep(fid)
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods/Files"))
+        for file in self.srcFiles:
+            log("* " +file.s)
+        log(_("\n=== Refactioned Actors"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
 
-class CBash_NamesTweak_Potions(CBash_MultiTweakItem):
-    """Names tweaker for potions."""
-    scanOrder = 32
-    editOrder = 32
-    reOldLabel = re.compile('^(-|X) ')
-    reOldEnd = re.compile(' -$')
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Potions"),
-            _('Label potions to sort by type and effect.'),
-            'ALCH',
-            (_('XD Illness'),  '%s '),
-            (_('XD. Illness'), '%s. '),
-            (_('XD - Illness'),'%s - '),
-            (_('(XD) Illness'),'(%s) '),
-            )
-        self.mod_count = {}
+# class CBash_ImportFactions(CBash_ImportPatcher):
+#     """Import factions to creatures and NPCs."""
+#     name = _('Import Factions')
+#     text = _("Import factions from source mods/files.")
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     autoKey = set(('Factions',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_factions = {}
+#         self.csvId_factions = {}
+#         self.class_mod_count = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         CBash_ImportPatcher.initData(self,type_patchers,progress)
+#         actorFactions = CBash_ActorFactions(aliases=self.patchFile.aliases)
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             if not reModExt.search(srcFile.s):
+#                 if srcPath not in patchesDir: continue
+#                 actorFactions.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+#         #--Finish
+#         csvId_factions = self.csvId_factions
+#         for group,aFid_factions in actorFactions.group_fid_factions.iteritems():
+#             if group not in ('CREA','NPC_'): continue
+#             for fid,factions in aFid_factions.iteritems():
+#                 factions = [faction for faction in factions if faction[0][0] in self.patchFile.loadSet]
+#                 if factions:
+#                     csvId_factions[fid] = factions
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         if modFile.GName == record.fid[0]: return
+#         factions = record.ConflictDetails(('factions_list',))
+#         if factions:
+#             masterRecord = [x for x in self.patchFile.ObCollection.LookupRecords(record.fid)][-1]
+#             masterFactions = masterRecord.factions_list
+#             masterDict = dict((x[0],x[1]) for x in masterFactions)
+#             if record.fid not in self.id_factions:
+#                 # Initialize the factions list with what's in the master record
+#                 self.id_factions[record.fid] = masterDict
+#             # Only add/remove records if different than the master record
+#             thisFactions = factions['factions_list']
+#             masterFids = set([x[0] for x in masterFactions])
+#             thisFids = set([x[0] for x in thisFactions])
+#             removedFids = masterFids - thisFids
+#             addedFids = thisFids - masterFids
+#             # Add new factions
+#             self.id_factions[record.fid].update(dict((x[0],x[1]) for x in thisFactions if x[0] in addedFids and x[0][0] in self.patchFile.loadSet))
+#             # Remove deleted factions
+#             for fid in removedFids:
+#                 self.id_factions[record.fid].pop(fid,None)
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         fid = record.fid
+#         if(fid in self.csvId_factions):
+#             newFactions = set(self.csvId_factions[fid])
+#         elif(fid in self.id_factions):
+#             newFactions = set([(faction,rank) for faction, rank in self.id_factions[fid].iteritems()])
+#         else:
+#             return
+#         curFactions = set([(faction[0],faction[1]) for faction in record.factions_list])
+#         changed = newFactions - curFactions
+#         removed = curFactions - newFactions
+#         if changed or removed:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.factions_list = self.id_factions[fid].items()
+#                 class_mod_count = self.class_mod_count
+#                 class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         for type in class_mod_count.keys():
+#             log(_('* Refactioned %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
-    def getTypes(self):
-        return ['ALCH']
+#------------------------------------------------------------------------------
+class ImportRelations(ImportPatcher):
+    """Import faction relations to factions."""
+    name = _('Import Relations')
+    text = _("Import relations from source mods/files.")
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    autoKey = 'Relations'
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_relations= {} #--[(otherLongid0,disp0,groupCombatReaction0),(...)] = id_relations[mainLongid].
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
 
-        newFull = record.full
-        if newFull:
-            mgef_school = self.patchFile.mgef_school
-            hostileEffects = self.patchFile.hostileEffects
-            school = 6 #--Default to 6 (U: unknown)
-            for index,effect in enumerate(record.effects):
-                effectId = effect.name
-                if index == 0:
-                    if effect.script:
-                        school = effect.school
-                    else:
-                        school = mgef_school.get(effectId,6)
-                #--Non-hostile effect?
-                if effect.script:
-                    if not effect.IsHostile:
-                        isPoison = False
-                        break
-                elif effectId not in hostileEffects:
-                    isPoison = False
-                    break
-            else:
-                isPoison = True
-            newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
-            newFull = self.reOldEnd.sub('',newFull)
-            if record.IsFood:
-                newFull = '.' + newFull
+    def initData(self,progress):
+        """Get names from source files."""
+        if not self.isActive: return
+        factionRelations = FactionRelations(aliases=self.patchFile.aliases)
+        progress.setFull(len(self.srcFiles))
+        for srcFile in self.srcFiles:
+            srcPath = GPath(srcFile)
+            patchesDir = dirs['patches'].list()
+            if reModExt.search(srcFile.s):
+                if srcPath not in modInfos: continue
+                srcInfo = modInfos[GPath(srcFile)]
+                factionRelations.readFromMod(srcInfo)
             else:
-                label = ('','X')[isPoison] + 'ACDIMRU'[school]
-                newFull = self.format % label + newFull
-
-            if record.full != newFull:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.full = newFull
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* %s Renamed: %d') % (self.key,sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class NamesTweak_Scrolls(MultiTweakItem):
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Notes and Scrolls"),
-            _('Mark notes and scrolls to sort separately from books'),
-            'scrolls',
-            (_('~Fire Ball'),  '~'),
-            (_('~D Fire Ball'),  '~%s '),
-            (_('~D. Fire Ball'), '~%s. '),
-            (_('~D - Fire Ball'),'~%s - '),
-            (_('~(D) Fire Ball'),'~(%s) '),
-            ('----','----'),
-            (_('.Fire Ball'),  '.'),
-            (_('.D Fire Ball'),  '.%s '),
-            (_('.D. Fire Ball'), '.%s. '),
-            (_('.D - Fire Ball'),'.%s - '),
-            (_('.(D) Fire Ball'),'.(%s) '),
-            )
+                if srcPath not in patchesDir: continue
+                factionRelations.readFromText(dirs['patches'].join(srcFile))
+            progress.plus()
+        #--Finish
+        for fid, relations in factionRelations.id_relations.iteritems():
+            if fid and (fid[0] is not None and fid[0] in self.patchFile.loadSet):
+                filteredRelations = [relation for relation in relations if relation[0] and (relation[0][0] is not None and relation[0][0] in self.patchFile.loadSet)]
+                if filteredRelations:
+                    self.id_relations[fid] = filteredRelations
 
-    #--Config Phase -----------------------------------------------------------
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        MultiTweakItem.saveConfig(self,configs)
-        rawFormat = self.choiceValues[self.chosen][0]
-        self.orderFormat = ('~.','.~')[rawFormat[0] == '~']
-        self.magicFormat = rawFormat[1:]
+        self.isActive = bool(self.id_relations)
 
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreBook,MreEnch,)
+        return (None,(MreFact,))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreBook,MreEnch)
+        return (None,(MreFact,))[self.isActive]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Scan modFile."""
+        if not self.isActive: return
+        id_relations= self.id_relations
+        modName = modFile.fileInfo.name
         mapper = modFile.getLongMapper()
-        #--Scroll Enchantments
-        if self.magicFormat:
-            patchBlock = patchFile.ENCH
+        for type in ('FACT',):
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
             id_records = patchBlock.id_records
-            for record in modFile.ENCH.getActiveRecords():
-                if mapper(record.fid) in id_records: continue
-                if record.itemType == 0:
-                    record = record.getTypeCopy(mapper)
-                    patchBlock.setRecord(record)
-        #--Books
-        patchBlock = patchFile.BOOK
-        id_records = patchBlock.id_records
-        for record in modFile.BOOK.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.flags.isScroll and not record.flags.isFixed:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
-        orderFormat, magicFormat = self.orderFormat, self.magicFormat
-        keep = patchFile.getKeeper()
-        id_ench = patchFile.ENCH.id_records
-        mgef_school = patchFile.getMgefSchool()
-        for record in patchFile.BOOK.records:
-            if not record.full or not record.flags.isScroll or record.flags.isFixed: continue
-            #--Magic label
-            isEnchanted = bool(record.enchantment)
-            if magicFormat and isEnchanted:
-                school = 6 #--Default to 6 (U: unknown)
-                enchantment = id_ench.get(record.enchantment)
-                if enchantment and enchantment.effects:
-                    effect = enchantment.effects[0]
-                    effectId = effect.name
-                    if effect.scriptEffect:
-                        school = effect.scriptEffect.school
-                    else:
-                        school = mgef_school.get(effectId,6)
-                record.full = reOldLabel.sub('',record.full) #--Remove existing label
-                record.full = magicFormat % 'ACDIMRU'[school] + record.full
-            #--Ordering
-            record.full = orderFormat[isEnchanted] + record.full
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_NamesTweak_Scrolls(CBash_MultiTweakItem):
-    """Names tweaker for scrolls."""
-    scanOrder = 32
-    editOrder = 32
-    reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Notes and Scrolls"),
-            _('Mark notes and scrolls to sort separately from books'),
-            'scrolls',
-            (_('~Fire Ball'),  '~'),
-            (_('~D Fire Ball'),  '~%s '),
-            (_('~D. Fire Ball'), '~%s. '),
-            (_('~D - Fire Ball'),'~%s - '),
-            (_('~(D) Fire Ball'),'~(%s) '),
-            ('----','----'),
-            (_('.Fire Ball'),  '.'),
-            (_('.D Fire Ball'),  '.%s '),
-            (_('.D. Fire Ball'), '.%s. '),
-            (_('.D - Fire Ball'),'.%s - '),
-            (_('.(D) Fire Ball'),'.(%s) '),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['BOOK']
-
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        CBash_MultiTweakItem.saveConfig(self,configs)
-        rawFormat = self.choiceValues[self.chosen][0]
-        self.orderFormat = ('~.','.~')[rawFormat[0] == '~']
-        self.magicFormat = rawFormat[1:]
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid in id_records: continue
+                if fid not in id_relations: continue
+                patchBlock.setRecord(record.getTypeCopy(mapper))
 
-        newFull = record.full
-        if newFull and record.IsScroll and not record.IsFixed:
-            #--Magic label
-            isEnchanted = bool(record.enchantment)
-            magicFormat = self.magicFormat
-            if magicFormat and isEnchanted:
-                school = 6 #--Default to 6 (U: unknown)
-                enchantment = record.enchantment
-                if enchantment:
-                    enchantment = self.patchFile.ObCollection.LookupRecords(enchantment)
-                    if enchantment:
-                        #Get the winning record
-                        enchantment = enchantment[0]
-                        Effects = enchantment.effects
-                    else:
-                        Effects = None
-                    if Effects:
-                        effect = Effects[0]
-                        if effect.script:
-                            school = effect.school
+    def buildPatch(self,log,progress):
+        """Make changes to patchfile."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_relations= self.id_relations
+        type_count = {}
+        for type in ('FACT',):
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid in id_relations:
+                    newRelations = set(id_relations[fid])
+                    curRelations = set((x.faction,x.mod,x.groupCombatReaction) for x in record.relations)
+                    changed = newRelations - curRelations
+                    if not changed: continue
+                    doKeep = False
+                    for faction,disp,groupCombatReaction in changed:
+                        for entry in record.relations:
+                            if entry.faction == faction:
+                                if (entry.mod != disp or entry.groupCombatReaction != groupCombatReaction):
+                                    entry.mod = disp
+                                    entry.groupCombatReaction = groupCombatReaction
+                                    doKeep = True
+                                    keep(fid)
+                                break
                         else:
-                            school = self.patchFile.mgef_school.get(effect.name,6)
-                newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
-                newFull = magicFormat % 'ACDIMRU'[school] + newFull
-            #--Ordering
-            newFull = self.orderFormat[isEnchanted] + newFull
-
-            if record.full != newFull:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.full = newFull
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class NamesTweak_Spells(MultiTweakItem):
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Spells"),
-            _('Label spells to sort by school and level.'),
-            'SPEL',
-            (_('Fire Ball'),  'NOTAGS'),
-            ('----','----'),
-            (_('D Fire Ball'),  '%s '),
-            (_('D. Fire Ball'), '%s. '),
-            (_('D - Fire Ball'),'%s - '),
-            (_('(D) Fire Ball'),'(%s) '),
-            ('----','----'),
-            (_('D2 Fire Ball'),  '%s%d '),
-            (_('D2. Fire Ball'), '%s%d. '),
-            (_('D2 - Fire Ball'),'%s%d - '),
-            (_('(D2) Fire Ball'),'(%s%d) '),
-            )
+                            entry = MelObject()
+                            entry.faction = faction
+                            entry.mod = disp
+                            entry.groupCombatReaction = groupCombatReaction
+                            record.relations.append(entry)
+                            doKeep = True
+                    if doKeep:
+                        type_count[type] += 1
+                        keep(fid)
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods/Files"))
+        for file in self.srcFiles:
+            log("* " +file.s)
+        log(_("\n=== Modified Factions: %d") % type_count['FACT'])
+
+# class CBash_ImportRelations(CBash_ImportPatcher):
+#     """Import faction relations to factions."""
+#     name = _('Import Relations')
+#     text = _("Import relations from source mods/files.")
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     autoKey = set(('Relations',))
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_faction_mod = {}
+#         self.csvFid_faction_mod = {}
+#         self.mod_count = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         CBash_ImportPatcher.initData(self,type_patchers,progress)
+#         factionRelations = CBash_FactionRelations(aliases=self.patchFile.aliases)
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             if not reModExt.search(srcFile.s):
+#                 if srcPath not in patchesDir: continue
+#                 factionRelations.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+#         #--Finish
+#         self.csvFid_faction_mod.update(factionRelations.fid_faction_mod)
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['FACT']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         relations = record.ConflictDetails(('relations_list',),False)
+#         if relations:
+#             self.fid_faction_mod.setdefault(record.fid,{}).update(relations['relations_list'])
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         fid = record.fid
+#         if(fid in self.csvFid_faction_mod):
+#             newRelations = set((faction,mod) for faction,mod in self.csvFid_faction_mod[fid].iteritems() if faction and (faction[0] is not None and faction[0] in self.patchFile.loadSet))
+#         elif(fid in self.fid_faction_mod):
+#             newRelations = set((faction,mod) for faction,mod in self.fid_faction_mod[fid].iteritems() if faction and (faction[0] is not None and faction[0] in self.patchFile.loadSet))
+#         else:
+#             return
+#         curRelations = set(record.relations_list)
+#         changed = newRelations - curRelations
+#         if changed:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 for faction,mod in changed:
+#                     for relation in override.relations:
+#                         if relation.faction == faction:
+#                             relation.mod = mod
+#                             break
+#                     else:
+#                         relation = override.create_relation()
+#                         relation.faction,relation.mod = faction,mod
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Re-Relationed Records: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class ImportScripts(ImportPatcher):
+    """Imports attached scripts on objects."""
+    name = _('Import Scripts')
+    text = _("Import Scripts on containers, plants, misc, weapons etc. from source mods.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Scripts'
 
-    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        return (MreSpel,)
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_data = {} #--Names keyed by long fid.
+        self.srcClasses = set() #--Record classes actually provided by src mods/files.
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = len(self.sourceMods) != 0
+        #--Type Fields
+        recAttrs_class = self.recAttrs_class = {}
+        for recClass in (MreWeap,MreActi,MreAlch,MreArmo,MreBook,MreCont,MreCrea,MreDoor,MreFlor,MreFurn,MreIngr,MreKeym,MreLigh,MreMisc,MreNpc,MreQust,MreTerm,MreTact):
+            recAttrs_class[recClass] = ('script',)
+        self.longTypes = set(('WEAP','ACTI','ALCH','ARMO','BOOK','CONT','CREA','DOOR','FLOR','FURN','INGR','KEYM','LIGH','MISC','NPC_','QUST','TERM','TACT'))
 
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        return (MreSpel,)
+    def initData(self,progress):
+        """Get script links from source files."""
+        if not self.isActive: return
+        self.classestemp = set()
+        id_data = self.id_data
+        recAttrs_class = self.recAttrs_class
+        loadFactory = LoadFactory(False,*recAttrs_class.keys())
+        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
+        progress.setFull(len(self.sourceMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.sourceMods):
+            temp_id_data = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass,recAttrs in recAttrs_class.iteritems():
+                if recClass.classType not in srcFile.tops: continue
+                self.srcClasses.add(recClass)
+                self.classestemp.add(recClass)
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
         mapper = modFile.getLongMapper()
-        patchBlock = patchFile.SPEL
-        id_records = patchBlock.id_records
-        for record in modFile.SPEL.getActiveRecords():
-            if mapper(record.fid) in id_records: continue
-            if record.spellType == 0:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        format = self.choiceValues[self.chosen][0]
-        removeTags = '%s' not in format
-        showLevel = '%d' in format
-        keep = patchFile.getKeeper()
-        reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
-        mgef_school = patchFile.getMgefSchool()
-        for record in patchFile.SPEL.records:
-            if record.spellType != 0 or not record.full: continue
-            school = 6 #--Default to 6 (U: unknown)
-            if record.effects:
-                effect = record.effects[0]
-                effectId = effect.name
-                if effect.scriptEffect:
-                    school = effect.scriptEffect.school
-                else:
-                    school = mgef_school.get(effectId,6)
-            newFull = reOldLabel.sub('',record.full) #--Remove existing label
-            if not removeTags:
-                if showLevel:
-                    newFull = format % ('ACDIMRU'[school],record.level) + newFull
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched scripts link as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        break
                 else:
-                    newFull = format % 'ACDIMRU'[school] + newFull
-            if newFull != record.full:
-                record.full = newFull
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_NamesTweak_Spells(CBash_MultiTweakItem):
-    """Names tweaker for spells."""
-    scanOrder = 32
-    editOrder = 32
-    reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Spells"),
-            _('Label spells to sort by school and level.'),
-            'SPEL',
-            (_('Fire Ball'),  'NOTAGS'),
-            ('----','----'),
-            (_('D Fire Ball'),  '%s '),
-            (_('D. Fire Ball'), '%s. '),
-            (_('D - Fire Ball'),'%s - '),
-            (_('(D) Fire Ball'),'(%s) '),
-            ('----','----'),
-            (_('D2 Fire Ball'),  '%s%d '),
-            (_('D2. Fire Ball'), '%s%d. '),
-            (_('D2 - Fire Ball'),'%s%d - '),
-            (_('(D2) Fire Ball'),'(%s%d) '),
-            )
-        self.mod_count = {}
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        #cleanup to save memory
+        id_data = None
+        #logging
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
 
-    def getTypes(self):
-        return ['SPEL']
+# class CBash_ImportScripts(CBash_ImportPatcher):
+#     """Imports attached scripts on objects."""
+#     name = _('Import Scripts')
+#     text = _("Import Scripts on containers, plants, misc, weapons etc from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Scripts',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_script = {}
+#         self.class_mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['ACTI','ALCH','APPA','ARMO','BOOK','CLOT','CONT','CREA',
+#                 'DOOR','FLOR','FURN','INGR','KEYM','LIGH','LVLC','MISC',
+#                 'NPC_','QUST','SGST','SLGM','WEAP']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         script = record.ConflictDetails(('script',), False)
+#         if script:
+#             # Only save if different from the master record
+#             if record.GName != record.fid[0]:
+#                 history = record.History()
+#                 if history and len(history) > 0:
+#                     masterRecord = history[0]
+#                     if masterRecord.GName == record.fid[0] and masterRecord.script == record.script:
+#                         return # Same
+#             self.id_script[record.fid] = script['script']
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         recordId = record.fid
+#         if(recordId in self.id_script and record.script != self.id_script[recordId]):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.script = self.id_script[recordId]
+#                 class_mod_count = self.class_mod_count
+#                 class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_("\n=== Modified Records"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        CBash_MultiTweakItem.saveConfig(self,configs)
-        self.format = self.choiceValues[self.chosen][0]
-        self.removeTags = '%s' not in self.format
-        self.showLevel = '%d' in self.format
+#------------------------------------------------------------------------------
+class ImportScriptContents(ImportPatcher):
+    """Imports the contents of scripts -- currently only object/mgef scripts."""
+    name = _('Import Script Contents')
+    text = _("Import the actual contents of scripts scripts.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'ScriptContents'
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        newFull = record.full
-        if newFull and record.IsSpell:
-            #--Magic label
-            school = 6 #--Default to 6 (U: unknown)
-            Effects = record.effects
-            if Effects:
-                effect = Effects[0]
-                if effect.script:
-                    school = effect.school
-                else:
-                    school = self.patchFile.mgef_school.get(effect.name,6)
-            newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
-            if not self.removeTags:
-                if self.showLevel:
-                    newFull = self.format % ('ACDIMRU'[school],record.levelType) + newFull
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_data = {} #--Names keyed by long fid.
+        self.srcClasses = set() #--Record classes actually provided by src mods/files.
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = len(self.sourceMods) != 0
+        self.classestemp = set()
+        #--Type Fields
+        recAttrs_class = self.recAttrs_class = {}
+        for recClass in (MreScpt,):
+            recAttrs_class[recClass] = ('numRefs','lastIndex','compiledSize','scriptType','compiled_p','scriptText','vars','references',) # invalid attributes for plain script: SCHR, 4s4I,SCDA,'SLSD','I12sB7s','index', 'SCVR', 'name',
+#        for recClass in (MreInfo,):
+ #           recAttrs_class[recClass] = ('SCHD','schd_p','SCHR','4s4I','numRefs','compiledsize','lastIndex','scriptType','SCDA','compiled_p','SCTX','scriptText','SCRV/SCRO','references',)
+        for recClass in (MreQust,):
+            recAttrs_class[recClass] = ('stages',)# 'SCHD','schd_p','SCHR','4s4I','numRefs','compiledsize','lastIndex','scriptType','SCDA','compiled_p','SCTX','scriptText','SCRV/SCRO','references',)
+        self.longTypes = set(('SCPT','QUST','DIAL','INFO'))
+#        MelGroups('stages',
+#            MelStruct('INDX','h','stage'),
+#            MelGroups('entries',
+#                MelStruct('QSDT','B',(stageFlags,'flags')),
+#                MelConditions(),
+#                MelString('CNAM','text'),
+#                MelStruct('SCHR','4s4I',('unused1',null4),'numRefs','compiledSize','lastIndex','scriptType'),
+#                MelBase('SCDA','compiled_p'),
+#                MelString('SCTX','scriptText'),
+#                MelScrxen('SCRV/SCRO','references')
+#                ),
+
+
+    def initData(self,progress):
+        """Get graphics from source files."""
+        if not self.isActive: return
+        id_data = self.id_data
+        recAttrs_class = self.recAttrs_class
+        loadFactory = LoadFactory(False,*recAttrs_class.keys())
+        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
+        progress.setFull(len(self.sourceMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.sourceMods):
+            temp_id_data = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass,recAttrs in recAttrs_class.iteritems():
+                if recClass.classType not in srcFile.tops: continue
+                self.srcClasses.add(recClass)
+                self.classestemp.add(recClass)
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
                 else:
-                    newFull = self.format % 'ACDIMRU'[school] + newFull
-
-            if record.full != newFull:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.full = newFull
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* Spells Renamed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
 
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched graphics data as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            #deprint(recClass,type,type_count[type])
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        break
+                else:
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        id_data = None
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
+##class CBash_ImportScriptContents(CBash_ImportPatcher):
+##    raise NotImplementedError
 #------------------------------------------------------------------------------
-class NamesTweak_Weapons(MultiTweakItem):
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Weapons"),
-            _('Label ammo and weapons to sort by type and damage.'),
-            'WEAP',
-            (_('B Iron Bow'),  '%s '),
-            (_('B. Iron Bow'), '%s. '),
-            (_('B - Iron Bow'),'%s - '),
-            (_('(B) Iron Bow'),'(%s) '),
-            ('----','----'),
-            (_('B08 Iron Bow'),  '%s%02d '),
-            (_('B08. Iron Bow'), '%s%02d. '),
-            (_('B08 - Iron Bow'),'%s%02d - '),
-            (_('(B08) Iron Bow'),'(%s%02d) '),
-            )
+class ImportInventory(ImportPatcher):
+    """Merge changes to actor inventories."""
+    name = _('Import Inventory')
+    text = _("Merges changes to NPC, creature and container inventories.")
+    autoKey = ('Invent','InventOnly')
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    iiMode = True
 
-    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_deltas = {}
+        self.srcMods = self.getConfigChecked()
+        self.srcMods = [x for x in self.srcMods if (x in modInfos and x in patchFile.allMods)]
+        self.inventOnlyMods = set(x for x in self.srcMods if
+            (x in patchFile.mergeSet and set(('InventOnly','IIM')) & modInfos[x].getBashTags()))
+        self.isActive = bool(self.srcMods)
+        self.masters = set()
+        for srcMod in self.srcMods:
+            self.masters |= set(modInfos[srcMod].header.masters)
+        self.allMods = self.masters | set(self.srcMods)
+        self.mod_id_entries = {}
+        self.touched = set()
+
+    def initData(self,progress):
+        """Get data from source files."""
+        if not self.isActive or not self.srcMods: return
+        loadFactory = LoadFactory(False,'CREA','NPC_','CONT')
+        progress.setFull(len(self.srcMods))
+        for index,srcMod in enumerate(self.srcMods):
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            srcFile.load(True)
+            mapper = srcFile.getLongMapper()
+            for block in (srcFile.CREA, srcFile.NPC_, srcFile.CONT):
+                for record in block.getActiveRecords():
+                    self.touched.add(mapper(record.fid))
+            progress.plus()
+
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreAmmo,MreWeap)
+        return (None,(MreNpc,MreCrea,MreCont))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreAmmo,MreWeap)
+        return (None,(MreNpc,MreCrea,MreCont))[self.isActive]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Add record from modFile."""
+        if not self.isActive: return
+        touched = self.touched
+        id_deltas = self.id_deltas
+        mod_id_entries = self.mod_id_entries
         mapper = modFile.getLongMapper()
-        for blockType in ('AMMO','WEAP'):
-            modBlock = getattr(modFile,blockType)
-            patchBlock = getattr(patchFile,blockType)
-            id_records = patchBlock.id_records
-            for record in modBlock.getActiveRecords():
-                if mapper(record.fid) not in id_records:
-                    record = record.getTypeCopy(mapper)
-                    patchBlock.setRecord(record)
+        modName = modFile.fileInfo.name
+        #--Master or source?
+        if modName in self.allMods:
+            id_entries = mod_id_entries[modName] = {}
+            modFile.convertToLongFids(('NPC_','CREA','CONT'))
+            for type in ('NPC_','CREA','CONT'):
+                for record in getattr(modFile,type).getActiveRecords():
+                    if record.fid in touched:
+                        id_entries[record.fid] = record.items[:]
+        #--Source mod?
+        if modName in self.srcMods:
+            id_entries = {}
+            for master in modFile.tes4.masters:
+                if master in mod_id_entries:
+                    id_entries.update(mod_id_entries[master])
+            for fid,entries in mod_id_entries[modName].iteritems():
+                masterEntries = id_entries.get(fid)
+                if masterEntries is None: continue
+                masterItems = set((x.item,x.owner,x.condition) for x in masterEntries)
+                modItems = set((x.item,x.owner,x.condition) for x in entries)
+                removeItems = masterItems - modItems
+                addItems = modItems - masterItems
+                addEntries = [x for x in entries if (x.item,x.owner,x.condition) in addItems]
+                deltas = self.id_deltas.get(fid)
+                if deltas is None: deltas = self.id_deltas[fid] = []
+                deltas.append((removeItems,addEntries))
+        #--Keep record?
+        if modFile.fileInfo.name not in self.inventOnlyMods:
+            for type in ('NPC_','CREA','CONT'):
+                patchBlock = getattr(self.patchFile,type)
+                id_records = patchBlock.id_records
+                for record in getattr(modFile,type).getActiveRecords():
+                    fid = mapper(record.fid)
+                    if fid in touched and fid not in id_records:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        format = self.choiceValues[self.chosen][0]
-        showStat = '%02d' in format
-        keep = patchFile.getKeeper()
-        for record in patchFile.AMMO.records:
-            if not record.full: continue
-            if record.full[0] in '+-=.()[]': continue
-            if showStat:
-                record.full = format % ('A',record.damage) + record.full
-            else:
-                record.full = format % 'A' + record.full
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
-        for record in patchFile.WEAP.records:
-            if not record.full: continue
-            if showStat:
-                record.full = format % ('CDEFGB'[record.weaponType],record.damage) + record.full
-            else:
-                record.full = format % 'CDEFGB'[record.weaponType] + record.full
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
+    def buildPatch(self,log,progress):
+        """Applies delta to patchfile."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        id_deltas = self.id_deltas
+        mod_count = {}
+        for type in ('NPC_','CREA','CONT'):
+            for record in getattr(self.patchFile,type).records:
+                changed = False
+                deltas = id_deltas.get(record.fid)
+                if not deltas: continue
+                removable = set((x.item,x.owner,x.condition) for x in record.items)
+                for removeItems,addEntries in reversed(deltas):
+                    if removeItems:
+                        #--Skip if some items to be removed have already been removed
+                        if not removeItems.issubset(removable): continue
+                        record.items = [x for x in record.items if (x.item,x.owner,x.condition) not in removeItems]
+                        removable -= removeItems
+                        changed = True
+                    if addEntries:
+                        current = set((x.item,x.owner,x.condition) for x in record.items)
+                        for entry in addEntries:
+                            if (entry.item,entry.owner,entry.condition) not in current:
+                                record.items.append(entry)
+                                changed = True
+                if changed:
+                    keep(record.fid)
+                    mod = record.fid[0]
+                    mod_count[mod] = mod_count.get(mod,0) + 1
         #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_NamesTweak_Weapons(CBash_MultiTweakItem):
-    """Names tweaker for weapons and ammo."""
-    scanOrder = 32
-    editOrder = 32
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Weapons"),
-            _('Label ammo and weapons to sort by type and damage.'),
-            'WEAP',
-            (_('B Iron Bow'),  '%s '),
-            (_('B. Iron Bow'), '%s. '),
-            (_('B - Iron Bow'),'%s - '),
-            (_('(B) Iron Bow'),'(%s) '),
-            ('----','----'),
-            (_('B08 Iron Bow'),  '%s%02d '),
-            (_('B08. Iron Bow'), '%s%02d. '),
-            (_('B08 - Iron Bow'),'%s%02d - '),
-            (_('(B08) Iron Bow'),'(%s%02d) '),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['AMMO','WEAP']
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.srcMods:
+            log("* " +mod.s)
+        log(_("\n=== Inventories Changed: %d") % (sum(mod_count.values()),))
+        for mod in modInfos.getOrdered(mod_count):
+            log('* %s: %3d' % (mod.s,mod_count[mod]))
 
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        CBash_MultiTweakItem.saveConfig(self,configs)
-        self.format = self.choiceValues[self.chosen][0]
-        self.showStat = '%02d' in self.format
+# class CBash_ImportInventory(CBash_ImportPatcher):
+#     """Merge changes to actor inventories."""
+#     name = _('Import Inventory')
+#     text = _("Merges changes to NPC, creature and container inventories.")
+#     autoKey = set(('Invent','InventOnly'))
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     iiMode = True
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_deltas = {}
+#         #should be redundant since this patcher doesn't allow unloaded
+#         #self.srcs = [x for x in self.srcs if (x in modInfos and x in patchFile.allMods)]
+#         self.inventOnlyMods = set(x for x in self.srcs if
+#             (x in patchFile.mergeSet and set(('InventOnly','IIM')) & modInfos[x].getBashTags()))
+#         self.class_mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_','CONT']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         #--Source mod?
+#         masters = record.History()
+#         if not masters: return
+#         masterEntries = []
+#         for masterEntry in masters:
+#             masterEntries.extend(masterEntry.items_list)
+#         entries = record.items_list
+#         masterItems = set(item for item,count in masterEntries)
+#         modItems = set(item for item,count in entries)
+#         removeItems = masterItems - modItems
+#         addItems = modItems - masterItems
+#         addEntries = [(item,count) for item,count in entries if item in addItems]
+#         id_deltas = self.id_deltas
+#         fid = record.fid
+#         deltas = id_deltas.get(fid)
+#         if deltas is None: deltas = id_deltas[fid] = []
+#         deltas.append((removeItems,addEntries))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         deltas = self.id_deltas.get(record.fid)
+#         if not deltas: return
+#         #If only the inventory is imported, the deltas have to be applied to
+#         #whatever record would otherwise be winning
+#         if modFile.GName in self.inventOnlyMods:
+#             conflicts = record.Conflicts()
+#             if conflicts:
+#                 #If this isn't actually the winning record, use it.
+#                 #This could be the case if a record was already copied into the patch
+#                 if conflicts[0] != record:
+#                     record = conflicts[0]
+#                 #Otherwise, use the previous one.
+#                 else:
+#                     record = conflicts[1]
+
+#         removable = set(entry.item for entry in record.items)
+#         changed = False
+#         for removeItems,addEntries in reversed(deltas):
+#             items = record.items_list
+#             if removeItems:
+#                 #--Skip if some items to be removed have already been removed
+#                 if not removeItems.issubset(removable): continue
+#                 items = [(item,count) for item,count in items if item not in removeItems]
+#                 removable -= removeItems
+#                 changed = True
+#             if addEntries:
+#                 current = set(item for item,count in items)
+#                 for item,count in addEntries:
+#                     if item not in current:
+#                         items.append((item,count))
+#                         changed = True
+#         if changed:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 try:
+#                     override.items_list = items
+#                 except AttributeError:
+#                     override.items_list = [item for item in items if item[0][0]]
+#                 class_mod_count = self.class_mod_count
+#                 class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         for type in class_mod_count.keys():
+#             log(_('* %s Inventories Changed: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
+#------------------------------------------------------------------------------
+class ImportActorsSpells(ImportPatcher):
+    """Merges changes to the spells lists of Actors."""
+    name = _('Import Actors: Spells')
+    text = _("Merges changes to NPC and creature spell lists.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = ('Actors.Spells','Actors.SpellsForceAdd')
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        newFull = record.full
-        if newFull:
-            if record._Type == 'AMMO':
-                if newFull[0] in '+-=.()[]': return
-                type = 6
-            else:
-                type = record.weaponType
-            if self.showStat:
-                newFull = self.format % ('CDEFGBA'[type],record.damage) + newFull
-            else:
-                newFull = self.format % 'CDEFGBA'[type] + newFull
-            if record.full != newFull:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.full = newFull
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class NamesTweak_Dwarven(MultiTweakItem):
-    reDwarf  = re.compile(r'\b(d|D)(?:warven|warf)\b')
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        self.activeTypes = ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
-                            'CLAS','CLOT','CONT','CREA','DOOR',
-                            'ENCH','EYES','FACT','FLOR','FURN','GMST',
-                            'HAIR','INGR','KEYM','LIGH','LSCR','MGEF',
-                            'MISC','NPC_','QUST','RACE','SCPT','SGST',
-                            'SKIL','SLGM','SPEL','WEAP']
-        MultiTweakItem.__init__(self,_("Lore Friendly Names: Dwarven -> Dwemer"),
-            _('Rename any thing that is named X Dwarven or Dwarven X to Dwemer X/X Dwemer to follow lore better.'),
-            'Dwemer',
-            (('Lore Friendly Names: Dwarven -> Dwemer'),  'Dwemer'),
-            )
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcMods = self.getConfigChecked()
+        self.isActive = len(self.srcMods) != 0
+        self.data = {}
+        self.longTypes = set(('CREA','NPC_'))
+
+    def initData(self,progress):
+        """Get data from source files."""
+        if not self.isActive: return
+        longTypes = self.longTypes
+        loadFactory = LoadFactory(False,MreCrea,MreNpc)
+        progress.setFull(len(self.srcMods))
+        cachedMasters = {}
+        data = self.data
+        for index,srcMod in enumerate(self.srcMods):
+            tempData = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            bashTags = srcInfo.getBashTags()
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass in (MreNpc,MreCrea):
+                if recClass.classType not in srcFile.tops: continue
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    tempData[fid] = list(record.spells)
+            for master in reversed(masters):
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for block in (MreNpc, MreCrea):
+                    if block.classType not in srcFile.tops: continue
+                    if block.classType not in masterFile.tops: continue
+                    for record in masterFile.tops[block.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if not fid in tempData: continue
+                        if record.spells == tempData[fid] and not 'Actors.SpellsForceAdd' in bashTags:
+                            # if subrecord is identical to the last master then we don't care about older masters.
+                            del tempData[fid]
+                            continue
+                        if fid in data:
+                            if tempData[fid] == data[fid]['merged']: continue
+                        recordData = {'deleted':[],'merged':tempData[fid]}
+                        for spell in list(record.spells):
+                            if not spell in tempData[fid]:
+                                recordData['deleted'].append(spell)
+                        if not fid in data:
+                            data[fid] = recordData
+                        else:
+                            for spell in recordData['deleted']:
+                                if spell in data[fid]['merged']:
+                                    data[fid]['merged'].remove(spell)
+                                data[fid]['deleted'].append(spell)
+                            if data[fid]['merged'] == []:
+                                for spell in recordData['merged']:
+                                    if spell in data[fid]['deleted'] and not 'Actors.SpellsForceAdd' in bashTags: continue
+                                    data[fid]['merged'].append(spell)
+                                continue
+                            for index, spell in enumerate(recordData['merged']):
+                                if not spell in data[fid]['merged']: # so needs to be added... (unless deleted that is)
+                                    # find the correct position to add and add.
+                                    if spell in data[fid]['deleted'] and not 'Actors.SpellsForceAdd' in bashTags: continue #previously deleted
+                                    if index == 0:
+                                        data[fid]['merged'].insert(0,spell) #insert as first item
+                                    elif index == (len(recordData['merged'])-1):
+                                        data[fid]['merged'].append(spell) #insert as last item
+                                    else: #figure out a good spot to insert it based on next or last recognized item (ugly ugly ugly)
+                                        i = index - 1
+                                        while i >= 0:
+                                            if recordData['merged'][i] in data[fid]['merged']:
+                                                slot = data[fid]['merged'].index(recordData['merged'][i])+1
+                                                data[fid]['merged'].insert(slot, spell)
+                                                break
+                                            i -= 1
+                                        else:
+                                            i = index + 1
+                                            while i != len(recordData['merged']):
+                                                if recordData['merged'][i] in data[fid]['merged']:
+                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
+                                                    data[fid]['merged'].insert(slot, spell)
+                                                    break
+                                                i += 1
+                                    continue # Done with this package
+                                elif index == data[fid]['merged'].index(spell) or (len(recordData['merged'])-index) == (len(data[fid]['merged'])-data[fid]['merged'].index(spell)): continue #spell same in both lists.
+                                else: #this import is later loading so we'll assume it is better order
+                                    data[fid]['merged'].remove(spell)
+                                    if index == 0:
+                                        data[fid]['merged'].insert(0,spell) #insert as first item
+                                    elif index == (len(recordData['merged'])-1):
+                                        data[fid]['merged'].append(spell) #insert as last item
+                                    else:
+                                        i = index - 1
+                                        while i >= 0:
+                                            if recordData['merged'][i] in data[fid]['merged']:
+                                                slot = data[fid]['merged'].index(recordData['merged'][i]) + 1
+                                                data[fid]['merged'].insert(slot, spell)
+                                                break
+                                            i -= 1
+                                        else:
+                                            i = index + 1
+                                            while i != len(recordData['merged']):
+                                                if recordData['merged'][i] in data[fid]['merged']:
+                                                    slot = data[fid]['merged'].index(recordData['merged'][i])
+                                                    data[fid]['merged'].insert(slot, spell)
+                                                    break
+                                                i += 1
+            progress.plus()
 
-    #--Config Phase -----------------------------------------------------------
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
-                MreClas,MreClot,MreCont,MreCrea,MreDoor,
-                MreEnch,MreEyes,MreFact,MreFlor,MreFurn,MreGmst,
-                MreHair,MreIngr,MreKeym,MreLigh,MreLscr,MreMgef,
-                MreMisc,MreNpc ,MreQust,MreRace,MreScpt,MreSgst,
-                MreSkil,MreSlgm,MreSpel,MreWeap)
+        return (None,(MreNpc,MreCrea))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
-                MreClas,MreClot,MreCont,MreCrea,MreDoor,
-                MreEnch,MreEyes,MreFact,MreFlor,MreFurn,MreGmst,
-                MreHair,MreIngr,MreKeym,MreLigh,MreLscr,MreMgef,
-                MreMisc,MreNpc ,MreQust,MreRace,MreScpt,MreSgst,
-                MreSkil,MreSlgm,MreSpel,MreWeap)
+        return (None,(MreNpc,MreCrea))[self.isActive]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Add record from modFile."""
+        if not self.isActive: return
+        data = self.data
         mapper = modFile.getLongMapper()
-        for blockType in self.activeTypes:
-            if blockType not in modFile.tops: continue
-            modBlock = getattr(modFile,blockType)
-            patchBlock = getattr(patchFile,blockType)
-            id_records = patchBlock.id_records
-            for record in modBlock.getActiveRecords():
-                if mapper(record.fid) not in id_records:
-                    record = record.getTypeCopy(mapper)
-                    patchBlock.setRecord(record)
+        modName = modFile.fileInfo.name
+        for type in ('NPC_','CREA'):
+            patchBlock = getattr(self.patchFile,type)
+            for record in getattr(modFile,type).getActiveRecords():
+                fid = mapper(record.fid)
+                if fid in data:
+                    if list(record.spells) != data[fid]['merged']:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def buildPatch(self,log,progress,patchFile):
-        count = {}
-        keep = patchFile.getKeeper()
-        reDwarf = self.reDwarf
-        for type in self.activeTypes:
-            if type not in patchFile.tops: continue
-            for record in patchFile.tops[type].records:
+    def buildPatch(self,log,progress):
+        """Applies delta to patchfile."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        data = self.data
+        mod_count = {}
+        for type in ('NPC_','CREA'):
+            for record in getattr(self.patchFile,type).records:
+                fid = record.fid
+                if not fid in data: continue
                 changed = False
-                if hasattr(record, 'full'):
-                    changed = reDwarf.search(record.full or '')
-                if not changed:
-                    if hasattr(record, 'effects'):
-                        Effects = record.effects
-                        for effect in Effects:
-                            try:
-                                changed = reDwarf.search(effect.scriptEffect.full or '')
-                            except AttributeError:
-                                continue
-                            if changed: break
-                if not changed:
-                    if hasattr(record, 'text'):
-                        changed = reDwarf.search(record.text or '')
-                if not changed:
-                    if hasattr(record, 'description'):
-                        changed = reDwarf.search(record.description or '')
-                if not changed:
-                    if type == 'GMST' and record.eid[0] == 's':
-                        changed = reDwarf.search(record.value or '')
-                if not changed:
-                    if hasattr(record, 'stages'):
-                        Stages = record.stages
-                        for stage in Stages:
-                            for entry in stage.entries:
-                                changed = reDwarf.search(entry.text or '')
-                                if changed: break
-                if not changed:
-                    if type == 'SKIL':
-                        changed = reDwarf.search(record.apprentice or '')
-                        if not changed:
-                            changed = reDwarf.search(record.journeyman or '')
-                        if not changed:
-                            changed = reDwarf.search(record.expert or '')
-                        if not changed:
-                            changed = reDwarf.search(record.master or '')
+                mergedSpells = sorted(data[fid]['merged'])
+                if sorted(list(record.spells)) != mergedSpells:
+                    record.spells = mergedSpells
+                    changed = True
                 if changed:
-                    if hasattr(record, 'full'):
-                        newString = record.full
-                        if record:
-                            record.full = reDwarf.sub(r'\1wemer', newString)
-                    if hasattr(record, 'effects'):
-                        Effects = record.effects
-                        for effect in Effects:
-                            try:
-                                newString = effect.scriptEffect.full
-                            except AttributeError:
-                                continue
-                            if newString:
-                                effect.scriptEffect.full = reDwarf.sub(r'\1wemer', newString)
-                    if hasattr(record, 'text'):
-                        newString = record.text
-                        if newString:
-                            record.text = reDwarf.sub(r'\1wemer', newString)
-                    if hasattr(record, 'description'):
-                        newString = record.description
-                        if newString:
-                            record.description = reDwarf.sub(r'\1wemer', newString)
-                    if type == 'GMST' and record.eid[0] == 's':
-                        newString = record.value
-                        if newString:
-                            record.value = reDwarf.sub(r'\1wemer', newString)
-                    if hasattr(record, 'stages'):
-                        Stages = record.stages
-                        for stage in Stages:
-                            for entry in stage.entries:
-                                newString = entry.text
-                                if newString:
-                                    entry.text = reDwarf.sub(r'\1wemer', newString)
-                    if type == 'SKIL':
-                        newString = record.apprentice
-                        if newString:
-                            record.apprentice = reDwarf.sub(r'\1wemer', newString)
-                        newString = record.journeyman
-                        if newString:
-                            record.journeyman = reDwarf.sub(r'\1wemer', newString)
-                        newString = record.expert
-                        if newString:
-                            record.expert = reDwarf.sub(r'\1wemer', newString)
-                        newString = record.master
-                        if newString:
-                            record.master = reDwarf.sub(r'\1wemer', newString)
-
                     keep(record.fid)
-                    srcMod = record.fid[0]
-                    count[srcMod] = count.get(srcMod,0) + 1
+                    mod = record.fid[0]
+                    mod_count[mod] = mod_count.get(mod,0) + 1
         #--Log
-        log(_('* %s: %d') % (self.label,sum(count.values())))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_NamesTweak_Dwarven(CBash_MultiTweakItem):
-    """Names tweaker for dwarven->dwemer."""
-    scanOrder = 32
-    editOrder = 32
-    reDwarf  = re.compile(r'\b(d|D)(?:warven|warf)\b')
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Lore Friendly Names: Dwarven -> Dwemer"),
-            _('Rename anything that is named X Dwarven or Dwarven X to Dwemer X/X Dwemer to follow lore better.'),
-            'Dwemer',
-            (('Lore Friendly Names: Dwarven -> Dwemer'),  'Dwemer'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
-                'CELL','CLAS','CLOT','CONT','CREA','DOOR',
-                'ENCH','EYES','FACT','FLOR','FURN','GMST',
-                'HAIR','INGR','KEYM','LIGH','LSCR','MGEF',
-                'MISC','NPC_','QUST','RACE','SCPT','SGST',
-                'SKIL','SLGM','SPEL','WEAP']
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.srcMods:
+            log("* " +mod.s)
+        log(_("\n=== Spell Lists Changed: %d") % (sum(mod_count.values()),))
+        for mod in modInfos.getOrdered(mod_count):
+            log('* %s: %3d' % (mod.s,mod_count[mod]))
+# class CBash_ImportActorsSpells(CBash_ImportPatcher):
+#     """Merges changes to the spells lists of Actors."""
+#     name = _('Import Actors: Spells')
+#     text = _("Merges changes to NPC and creature spell lists.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Actors.Spells','Actors.SpellsForceAdd'))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_spells = {}
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CREA','NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         curData = {'deleted':[],'merged':[]}
+#         curspells = record.spells
+# ##            print curspells
+#         parentRecords = record.History()
+#         if parentRecords:
+#             if parentRecords[-1].spells != curspells or 'Actors.SpellsForceAdd' in bashTags:
+#                 for spell in parentRecords[-1].spells:
+#                     if spell not in curspells:
+#                         curData['deleted'].append(spell)
+#             curData['merged'] = curspells
+#             if not record.fid in self.id_spells:
+#                 self.id_spells[record.fid] = curData
+#             else:
+#                 id_spells = self.id_spells[record.fid]
+#                 for spell in curData['deleted']:
+#                     if spell in id_spells['merged']:
+#                         id_spells['merged'].remove(spell)
+#                     id_spells['deleted'].append(spell)
+#                 for spell in curData['merged']:
+#                     if spell in id_spells['merged']: continue #don't want to add 20 copies of the spell afterall
+#                     if not spell in id_spells['deleted'] or 'Actors.SpellsForceAdd' in bashTags:
+#                         id_spells['merged'].append(spell)
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         mergedSpells = self.id_spells.get(recordId,None)
+#         if mergedSpells:
+#             if sorted(record.spells) != sorted(mergedSpells['merged']):
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.spells = mergedSpells['merged']
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_('* Imported Spell Lists: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def saveConfig(self,configs):
-        """Save config to configs dictionary."""
-        CBash_MultiTweakItem.saveConfig(self,configs)
-        self.format = self.choiceValues[self.chosen][0]
-        self.showStat = '%02d' in self.format
+#------------------------------------------------------------------------------
+#------------------------------------------------------------------------------
+class NamesPatcher(ImportPatcher):
+    """Merged leveled lists mod file."""
+    name = _('Import Names')
+    text = _("Import names from source mods/files.")
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    autoRe = re.compile(r"^Fallout3.esm$",re.I)
+    autoKey = 'Names'
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        changed = False
-        if hasattr(record, 'full'):
-            changed = self.reDwarf.search(record.full or '')
-        if not changed:
-            if hasattr(record, 'effects'):
-                Effects = record.effects
-                for effect in Effects:
-                    changed = self.reDwarf.search(effect.full or '')
-                    if changed: break
-        if not changed:
-            if hasattr(record, 'text'):
-                changed = self.reDwarf.search(record.text or '')
-        if not changed:
-            if hasattr(record, 'description'):
-                changed = self.reDwarf.search(record.description or '')
-        if not changed:
-            if record._Type == 'GMST' and record.eid[0] == 's':
-                changed = self.reDwarf.search(record.value or '')
-        if not changed:
-            if hasattr(record, 'stages'):
-                Stages = record.stages
-                for stage in Stages:
-                    for entry in stage.entries:
-                        changed = self.reDwarf.search(entry.text or '')
-                        if changed: break
-##                        compiled = entry.compiled_p
-##                        if compiled:
-##                            changed = self.reDwarf.search(struct.pack('B' * len(compiled), *compiled) or '')
-##                            if changed: break
-##                        changed = self.reDwarf.search(entry.scriptText or '')
-##                        if changed: break
-##        if not changed:
-##            if hasattr(record, 'scriptText'):
-##                changed = self.reDwarf.search(record.scriptText or '')
-##                if not changed:
-##                    compiled = record.compiled_p
-##                    changed = self.reDwarf.search(struct.pack('B' * len(compiled), *compiled) or '')
-        if not changed:
-            if record._Type == 'SKIL':
-                changed = self.reDwarf.search(record.apprentice or '')
-                if not changed:
-                    changed = self.reDwarf.search(record.journeyman or '')
-                if not changed:
-                    changed = self.reDwarf.search(record.expert or '')
-                if not changed:
-                    changed = self.reDwarf.search(record.master or '')
-
-        #Could support DIAL/INFO as well, but skipping since they're often voiced as well
-        if changed:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                if hasattr(override, 'full'):
-                    newString = override.full
-                    if newString:
-                        override.full = self.reDwarf.sub(r'\1wemer', newString)
-
-                if hasattr(override, 'effects'):
-                    Effects = override.effects
-                    for effect in Effects:
-                        newString = effect.full
-                        if newString:
-                            effect.full = self.reDwarf.sub(r'\1wemer', newString)
-
-                if hasattr(override, 'text'):
-                    newString = override.text
-                    if newString:
-                        override.text = self.reDwarf.sub(r'\1wemer', newString)
-
-                if hasattr(override, 'description'):
-                    newString = override.description
-                    if newString:
-                        override.description = self.reDwarf.sub(r'\1wemer', newString)
-
-                if override._Type == 'GMST' and override.eid[0] == 's':
-                    newString = override.value
-                    if newString:
-                        override.value = self.reDwarf.sub(r'\1wemer', newString)
-
-                if hasattr(override, 'stages'):
-                    Stages = override.stages
-                    for stage in Stages:
-                        for entry in stage.entries:
-                            newString = entry.text
-                            if newString:
-                                entry.text = self.reDwarf.sub(r'\1wemer', newString)
-##                            newString = entry.compiled_p
-##                            if newString:
-##                                nSize = len(newString)
-##                                newString = self.reDwarf.sub(r'\1wemer', struct.pack('B' * nSize, *newString))
-##                                nSize = len(newString)
-##                                entry.compiled_p = struct.unpack('B' * nSize, newString)
-##                                entry.compiledSize = nSize
-##                            newString = entry.scriptText
-##                            if newString:
-##                                entry.scriptText = self.reDwarf.sub(r'\1wemer', newString)
-##
-
-##                if hasattr(override, 'scriptText'):
-##                    newString = override.compiled_p
-##                    if newString:
-##                        nSize = len(newString)
-##                        newString = self.reDwarf.sub(r'\1wemer', struct.pack('B' * nSize, *newString))
-##                        nSize = len(newString)
-##                        override.compiled_p = struct.unpack('B' * nSize, newString)
-##                        override.compiledSize = nSize
-##                    newString = override.scriptText
-##                    if newString:
-##                        override.scriptText = self.reDwarf.sub(r'\1wemer', newString)
-
-                if override._Type == 'SKIL':
-                    newString = override.apprentice
-                    if newString:
-                        override.apprentice = self.reDwarf.sub(r'\1wemer', newString)
-
-                    newString = override.journeyman
-                    if newString:
-                        override.journeyman = self.reDwarf.sub(r'\1wemer', newString)
-
-                    newString = override.expert
-                    if newString:
-                        override.expert = self.reDwarf.sub(r'\1wemer', newString)
-
-                    newString = override.master
-                    if newString:
-                        override.master = self.reDwarf.sub(r'\1wemer', newString)
-
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== %s' % self.label)
-        log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_full = {} #--Names keyed by long fid.
+        self.id_sname = {} #--Short names keyed by long fid.
+        self.activeTypes = [] #--Types ('ALCH', etc.) of data actually provided by src mods/files.
+        self.skipTypes = [] #--Unknown types that were skipped.
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
 
-#------------------------------------------------------------------------------
-class NamesTweaker(MultiTweaker):
-    """Tweaks record full names in various ways."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Tweak Names')
-    text = _("Tweak object names in various ways such as lore friendlyness or show type/quality.")
-    tweaks = sorted([
-        NamesTweak_Body(_("Armor"),_("Rename armor to sort by type."),'ARMO',
-            (_('BL Leather Boots'),  '%s '),
-            (_('BL. Leather Boots'), '%s. '),
-            (_('BL - Leather Boots'),'%s - '),
-            (_('(BL) Leather Boots'),'(%s) '),
-            ('----','----'),
-            (_('BL02 Leather Boots'),  '%s%02d '),
-            (_('BL02. Leather Boots'), '%s%02d. '),
-            (_('BL02 - Leather Boots'),'%s%02d - '),
-            (_('(BL02) Leather Boots'),'(%s%02d) '),
-            ),
-        NamesTweak_Body(_("Clothes"),_("Rename clothes to sort by type."),'CLOT',
-            (_('P Grey Trousers'),  '%s '),
-            (_('P. Grey Trousers'), '%s. '),
-            (_('P - Grey Trousers'),'%s - '),
-            (_('(P) Grey Trousers'),'(%s) '),
-            ),
-        NamesTweak_Potions(),
-        NamesTweak_Scrolls(),
-        NamesTweak_Spells(),
-        NamesTweak_Weapons(),
-        NamesTweak_Dwarven(),
-        ],key=lambda a: a.label.lower())
-    tweaks.insert(0,NamesTweak_BodyTags())
+    def initData(self,progress):
+        """Get names from source files."""
+        if not self.isActive: return
+        fullNames = FullNames(aliases=self.patchFile.aliases)
+        progress.setFull(len(self.srcFiles))
+        for srcFile in self.srcFiles:
+            srcPath = GPath(srcFile)
+            patchesDir = dirs['patches'].list()
+            if reModExt.search(srcFile.s):
+                if srcPath not in modInfos: continue
+                srcInfo = modInfos[GPath(srcFile)]
+                fullNames.readFromMod(srcInfo)
+            else:
+                if srcPath not in patchesDir: continue
+                fullNames.readFromText(dirs['patches'].join(srcFile))
+            progress.plus()
+        #--Finish
+        id_full = self.id_full
+        id_sname = self.id_sname
+        knownTypes = set(MreRecord.type_class.keys())
+        for type,id_name in fullNames.type_id_name.iteritems():
+            if type not in knownTypes:
+                self.skipTypes.append(type)
+                continue
+            self.activeTypes.append(type)
+            for longid,(eid,name) in id_name.iteritems():
+                if name != 'NO NAME':
+                    id_full[longid] = name
+        self.isActive = bool(self.activeTypes)
 
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
         if not self.isActive: return None
-        classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
+        return [MreRecord.type_class[type] for type in self.activeTypes]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
         if not self.isActive: return None
-        classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
+        return [MreRecord.type_class[type] for type in self.activeTypes]
 
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Scan modFile."""
         if not self.isActive: return
-        for tweak in self.enabledTweaks:
-            tweak.scanModFile(modFile,progress,self.patchFile)
+        id_full = self.id_full
+        id_sname = self.id_sname
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        for type in self.activeTypes:
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            id_records = patchBlock.id_records
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid in id_records: continue
+                if fid not in id_full: continue
+                if record.full != id_full[fid] or (hasattr(record, 'shortName') and record.shortName != id_sname.get(fid, None)):
+                    patchBlock.setRecord(record.getTypeCopy(mapper))
 
     def buildPatch(self,log,progress):
-        """Applies individual clothes tweaks."""
+        """Make changes to patchfile."""
         if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(log,progress,self.patchFile)
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_full = self.id_full
+        id_sname = self.id_sname
+        type_count = {}
+        for type in self.activeTypes:
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                changed = False
+                if fid in id_full and record.full != id_full[fid]:
+                    record.full = id_full[fid]
+                    changed = True
+                if fid in id_sname and record.shortName != id_sname[fid]:
+                    record.shortName = id_sname[fid]
+                    changed = True
+                if changed:
+                    keep(fid)
+                    type_count[type] += 1
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods/Files"))
+        for file in self.srcFiles:
+            log("* " +file.s)
+        log(_("\n=== Renamed Items"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
 
-class CBash_NamesTweaker(CBash_MultiTweaker):
-    """Tweaks record full names in various ways."""
-    scanOrder = 32
-    editOrder = 32
-    name = _('Tweak Names')
-    text = _("Tweak object names in various ways such as lore friendlyness or show type/quality.")
-    tweaks = sorted([
-        CBash_NamesTweak_Body(_("Armor"),_("Rename armor to sort by type."),'ARMO',
-            (_('BL Leather Boots'),  '%s '),
-            (_('BL. Leather Boots'), '%s. '),
-            (_('BL - Leather Boots'),'%s - '),
-            (_('(BL) Leather Boots'),'(%s) '),
-            ('----','----'),
-            (_('BL02 Leather Boots'),  '%s%02d '),
-            (_('BL02. Leather Boots'), '%s%02d. '),
-            (_('BL02 - Leather Boots'),'%s%02d - '),
-            (_('(BL02) Leather Boots'),'(%s%02d) '),
-            ),
-        CBash_NamesTweak_Body(_("Clothes"),_("Rename clothes to sort by type."),'CLOT',
-            (_('P Grey Trousers'),  '%s '),
-            (_('P. Grey Trousers'), '%s. '),
-            (_('P - Grey Trousers'),'%s - '),
-            (_('(P) Grey Trousers'),'(%s) '),
-            ),
-        CBash_NamesTweak_Potions(),
-        CBash_NamesTweak_Scrolls(),
-        CBash_NamesTweak_Spells(),
-        CBash_NamesTweak_Weapons(),
-        CBash_NamesTweak_Dwarven(),
-        ],key=lambda a: a.label.lower())
-    tweaks.insert(0,CBash_NamesTweak_BodyTags())
-    #--Config Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks[1:]:
-            tweak.patchFile = patchFile
-        bodyTagPatcher = self.tweaks[0]
-        patchFile.bodyTags = bodyTagPatcher.choiceValues[bodyTagPatcher.chosen][0]
-        patchFile.indexMGEFs = True
+# class CBash_NamesPatcher(CBash_ImportPatcher):
+#     """Import names from source mods/files."""
+#     name = _('Import Names')
+#     text = _("Import names from source mods/files.")
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     autoRe = re.compile(r"^Oblivion.esm$",re.I)
+#     autoKey = set(('Names',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_full = {}
+#         self.csvId_full = {}
+#         self.class_mod_count = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         CBash_ImportPatcher.initData(self,type_patchers,progress)
+#         fullNames = CBash_FullNames(aliases=self.patchFile.aliases)
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             if not reModExt.search(srcFile.s):
+#                 if srcPath not in patchesDir: continue
+#                 fullNames.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+
+#         #--Finish
+#         csvId_full = self.csvId_full
+#         for group,fid_name in fullNames.group_fid_name.iteritems():
+#             if group not in validTypes: continue
+#             for fid,(eid,name) in fid_name.iteritems():
+#                 if name != 'NO NAME':
+#                     csvId_full[fid] = name
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ["CLAS","FACT","HAIR","EYES","RACE","MGEF","ENCH",
+#                 "SPEL","BSGN","ACTI","APPA","ARMO","BOOK","CLOT",
+#                 "CONT","DOOR","INGR","LIGH","MISC","FLOR","FURN",
+#                 "WEAP","AMMO","NPC_","CREA","SLGM","KEYM","ALCH",
+#                 "SGST","WRLD","CELL","DIAL","QUST"]
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         full = record.ConflictDetails(('full',),False)
+#         if full:
+#             self.id_full[record.fid] = full['full']
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         full = self.id_full.get(recordId, None)
+#         full = self.csvId_full.get(recordId, full)
+#         if(full and record.full != full):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.full = full
+#                 class_mod_count = self.class_mod_count
+#                 class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods/Files"))
+#         for file in self.srcs:
+#             log("* " +file.s)
+#         log(_("\n=== Renamed Items"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for tweak in self.enabledTweaks:
-            for type in tweak.getTypes():
-                type_patchers.setdefault(type,[]).append(tweak)
-            tweak.format = tweak.choiceValues[tweak.chosen][0]
-            if isinstance(tweak, CBash_NamesTweak_Body):
-                tweak.showStat = '%02d' in tweak.format
-                tweak.codes = getattr(self.patchFile,'bodyTags','ARGHTCCPBS')
-                tweak.amulet,tweak.ring,tweak.gloves,tweak.head,tweak.tail,tweak.robe,tweak.chest,tweak.pants,tweak.shoes,tweak.shield = [
-                    x for x in tweak.codes]
+#------------------------------------------------------------------------------
+class NpcFacePatcher(ImportPatcher):
+    """NPC Faces patcher, for use with Project Beauty or similar mods."""
+    name = _('Import NPC Faces')
+    text = _("Import NPC face/eyes/hair from source mods. For use with Project Beauty, FaceMe and similar mods.")
+    autoRe = re.compile(r"^(Project Beauty|PB MMM|FaceMe).*\.es[mp]$",re.I)
+    autoKey = ('NpcFaces','NpcFacesForceFullImport','Npc.HairOnly','Npc.EyesOnly')
 
     #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-#------------------------------------------------------------------------------
-class BasalNPCTweaker(MultiTweakItem):
-    """Base for all NPC tweakers"""
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.faceData = {}
+        self.faceMods = self.getConfigChecked()
+        self.isActive = len(self.faceMods) != 0
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        # Override this segment with real info.
-        MultiTweakItem.__init__(self,_("Title"),
-            _('Description'),
-            'Ignored',
-            ('1.0',  '1.0'),
-            )
+    def initData(self,progress):
+        """Get faces from Project Beauty files."""
+        if not self.isActive: return
+        faceData = self.faceData
+        loadFactory = LoadFactory(False,MreNpc)
+        progress.setFull(len(self.faceMods))
+        cachedMasters = {}
+        for index,faceMod in enumerate(self.faceMods):
+            if faceMod not in modInfos: continue
+            temp_faceData = {}
+            faceInfo = modInfos[faceMod]
+            faceFile = ModFile(faceInfo,loadFactory)
+            masters = faceInfo.header.masters
+            bashTags = faceInfo.getBashTags()
+            faceFile.load(True)
+            faceFile.convertToLongFids(('NPC_',))
+            for npc in faceFile.NPC_.getActiveRecords():
+                if npc.fid[0] in self.patchFile.loadSet:
+                    attrs, fidattrs = [],[]
+                    if 'Npc.HairOnly' in bashTags:
+                        fidattrs += ['hair']
+                        attrs = ['hairLength','hairRed','hairBlue','hairGreen']
+                    if 'Npc.EyesOnly' in bashTags: fidattrs += ['eye']
+                    if fidattrs:
+                        attr_fidvalue = dict((attr,npc.__getattribute__(attr)) for attr in fidattrs)
+                    else:
+                        attr_fidvalue = dict((attr,npc.__getattribute__(attr)) for attr in ('eye','hair'))
+                    for fidvalue in attr_fidvalue.values():
+                        if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
+                            #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+                            mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+                            mod_skipcount[faceMod] = mod_skipcount.setdefault(faceMod, 0) + 1
+                            break
+                    else:
+                        if not fidattrs: temp_faceData[npc.fid] = dict((attr,npc.__getattribute__(attr)) for attr in ('fggs_p','fgga_p','fgts_p','hairLength','hairRed','hairBlue','hairGreen','unused3','headParts'))
+                        else: temp_faceData[npc.fid] = dict((attr,npc.__getattribute__(attr)) for attr in attrs)
+                        temp_faceData[npc.fid].update(attr_fidvalue)
+            if 'NpcFacesForceFullImport' in bashTags:
+                for fid in temp_faceData:
+                    faceData[fid] = temp_faceData[fid]
+            else:
+                for master in masters:
+                    if not master in modInfos: continue # or break filter mods
+                    if master in cachedMasters:
+                        masterFile = cachedMasters[master]
+                    else:
+                        masterInfo = modInfos[master]
+                        masterFile = ModFile(masterInfo,loadFactory)
+                        masterFile.load(True)
+                        masterFile.convertToLongFids(('NPC_',))
+                        cachedMasters[master] = masterFile
+                    mapper = masterFile.getLongMapper()
+                    if 'NPC_' not in masterFile.tops: continue
+                    for npc in masterFile.NPC_.getActiveRecords():
+                        if npc.fid not in temp_faceData: continue
+                        for attr, value in temp_faceData[npc.fid].iteritems():
+                            if value == npc.__getattribute__(attr): continue
+                            if npc.fid not in faceData: faceData[npc.fid] = dict()
+                            try:
+                                faceData[npc.fid][attr] = temp_faceData[npc.fid][attr]
+                            except KeyError:
+                                faceData[npc.fid].setdefault(attr,value)
+            progress.plus()
 
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreNpc,)
+        return (None,(MreNpc,))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreNpc,)
+        return (None,(MreNpc,))[self.isActive]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Add lists from modFile."""
+        modName = modFile.fileInfo.name
+        if not self.isActive or modName in self.faceMods or 'NPC_' not in modFile.tops:
+            return
         mapper = modFile.getLongMapper()
-        patchRecords = patchFile.NPC_
-        for record in modFile.NPC_.getActiveRecords():
-            record = record.getTypeCopy(mapper)
-            patchRecords.setRecord(record)
+        faceData,patchNpcs = self.faceData,self.patchFile.NPC_
+        modFile.convertToLongFids(('NPC_',))
+        for npc in modFile.NPC_.getActiveRecords():
+            if npc.fid in faceData:
+                patchNpcs.setRecord(npc)
+
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        faceData, count = self.faceData, 0
+        for npc in self.patchFile.NPC_.records:
+            if npc.fid in faceData:
+                changed = False
+                for attr, value in faceData[npc.fid].iteritems():
+                    if value != npc.__getattribute__(attr):
+                        npc.__setattr__(attr,value)
+                        changed = True
+                if changed:
+                    npc.setChanged()
+                    keep(npc.fid)
+                    count += 1
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.faceMods:
+            log("* " +mod.s)
+        log(_("\n=== Faces Patched: %d") % count)
+
+# class CBash_NpcFacePatcher(CBash_ImportPatcher):
+#     """NPC Faces patcher, for use with TNR or similar mods."""
+#     name = _('Import NPC Faces')
+#     text = _("Import NPC face/eyes/hair from source mods. For use with TNR and similar mods.")
+#     autoRe = re.compile(r"^TNR .*.esp$",re.I)
+#     autoKey = set(('NpcFaces','NpcFacesForceFullImport','Npc.HairOnly','Npc.EyesOnly'))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_face = {}
+#         ##Can't allow merging from unloaded mods if fids are involved. Might end up with a dependency on that mod.
+#         ##self.faceData = ('fggs_p','fgga_p','fgts_p','eye','hair','hairLength','hairRed','hairBlue','hairGreen','fnam')
+#         self.faceData = ('fggs_p','fgga_p','fgts_p','hairLength','hairRed','hairBlue','hairGreen','fnam')
+#         self.faceFidData = ('eye','hair')
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['NPC_']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         if 'NpcFacesForceFullImport' in bashTags:
+#             face = {}
+#             for attr in self.faceFidData:
+#                 face[attr] = getattr(record,attr)
+#             for fidvalue in face.values():
+#                 if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
+#                     #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+#                     mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+#                     mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
+#                     return
+#             for attr in self.faceData:
+#                 face[attr] = getattr(record,attr)
+#             self.id_face[record.fid] = face
+#         else:
+#             fidattrs, attrs = [], []
+#             if 'Npc.HairOnly' in bashTags:
+#                 fidattrs += ['hair']
+#                 attrs =['hairLength','hairRed','hairBlue','hairGreen']
+#             if 'Npc.EyesOnly' in bashTags: fidattrs += ['eye']
+#             if fidattrs:
+#                 attr_fidvalue = record.ConflictDetails(fidattrs, False)
+#             else:
+#                 attr_fidvalue = record.ConflictDetails(self.faceFidData, False)
+#             for fidvalue in attr_fidvalue.values():
+#                 if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
+#                     #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+#                     mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+#                     mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
+#                     return
+#             fid = record.fid
+#             # Only save if different from the master record
+#             if record.GName != fid[0]:
+#                 history = record.History()
+#                 if history and len(history) > 0:
+#                     masterRecord = history[0]
+#                     if masterRecord.GName == record.fid[0]:
+#                         same = True
+#                         for attr in (attrs + fidattrs) or (self.faceFidData + self.faceData):
+#                             if getattr(masterRecord,attr) != getattr(record,attr):
+#                                 same = False
+#                                 break
+#                         if same:
+#                             return
+#             self.id_face.setdefault(fid,{}).update(attr_fidvalue)
+#             if fidattrs:
+#                 self.id_face.setdefault(fid,{}).update(record.ConflictDetails(attrs, False))
+#             else:
+#                 self.id_face.setdefault(fid,{}).update(record.ConflictDetails(self.faceData, False))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         prev_face_value = self.id_face.get(recordId,None)
+#         if prev_face_value:
+#             cur_face_value = dict((attr,getattr(record,attr)) for attr in prev_face_value)
+#             if cur_face_value != prev_face_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_face_value.iteritems():
+#                         setattr(override,attr,value)
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_('* Faces Patched: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        # override this section too!
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.NPC_.records:
-            continue
-        #--Log suggestions:
-        #log.setHeader(_('===TITLE'))
-        #log(_('* %d X Tweaked') % (sum(count.values()),))
-        #for srcMod in modInfos.getOrdered(count.keys()):
-        #    log('  * %s: %d' % (srcMod.s,count[srcMod]))
 #------------------------------------------------------------------------------
-class BasalCreatureTweaker(MultiTweakItem):
-    """Base for all Creature tweakers"""
+class RoadImporter(ImportPatcher):
+    """Imports roads."""
+    name = _('Import Roads')
+    text = _("Import roads from source mods.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Roads'
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        # Override this segment with real info.
-        MultiTweakItem.__init__(self,_("Title"),
-            _('Description'),
-            'Ignored',
-            ('1.0',  '1.0'),
-            )
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = bool(self.sourceMods)
+        self.world_road = {}
+
+    def initData(self,progress):
+        """Get cells from source files."""
+        if not self.isActive: return
+        loadFactory = LoadFactory(False,MreCell,MreWrld,MreRoad)
+        progress.setFull(len(self.sourceMods))
+        for srcMod in self.sourceMods:
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            srcFile.load(True)
+            srcFile.convertToLongFids(('WRLD','ROAD'))
+            for worldBlock in srcFile.WRLD.worldBlocks:
+                if worldBlock.road:
+                    worldId = worldBlock.world.fid
+                    road = worldBlock.road.getTypeCopy()
+                    self.world_road[worldId] = road
+        self.isActive = bool(self.world_road)
 
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreCrea,)
+        return (None,(MreCell,MreWrld,MreRoad))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreCrea,)
-
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        mapper = modFile.getLongMapper()
-        patchRecords = patchFile.CREA
-        for record in modFile.CREA.getActiveRecords():
-            record = record.getTypeCopy(mapper)
-            patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        # override this section too!
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.CREA.records:
-            continue
-        #--Log suggestions:
-        #log.setHeader(_('===TITLE'))
-        #log(_('* %d X Tweaked') % (sum(count.values()),))
-        #for srcMod in modInfos.getOrdered(count.keys()):
-        #    log('  * %s: %d' % (srcMod.s,count[srcMod]))
-#------------------------------------------------------------------------------
-class MAONPCSkeletonPatcher(BasalNPCTweaker):
-    """Changes all NPCs to use the right Mayu's Animation Overhaul Skeleton for use with MAO."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Mayu's Animation Overhaul Skeleton Tweaker"),
-            _('Changes all (modded and vanilla) NPCs to use the MAO skeletons.  Not compatible with VORB.  Note: ONLY use if you have MAO installed.'),
-            'MAO Skeleton',
-            (_('All NPCs'), 0),
-            (_('Only Female NPCs'), 1),
-            (_('Only Male NPCs'), 2),
-            )
+        return (None,(MreCell,MreWrld,MreRoad))[self.isActive]
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.NPC_.records:
-            if self.choiceValues[self.chosen][0] == 1 and not record.flags.female: continue
-            elif self.choiceValues[self.chosen][0] == 2 and record.flags.female: continue
-            if record.fid == (GPath('Oblivion.esm'),0x000007): continue #skip player record
-            try:
-                oldModPath = record.model.modPath
-            except AttributeError: #for freaking weird esps with NPC's with no skeleton assigned to them(!)
-                continue
-            newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonBeast.nif"
-            try:
-                if oldModPath.lower() == r'characters\_male\skeletonsesheogorath.nif':
-                    newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonSESheogorath.nif"
-            except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
-                pass
-            if newModPath != oldModPath:
-                record.model.modPath = newModPath
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===MAO Skeleton Setter'))
-        log(_('* %d Skeletons Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+    def scanModFile(self, modFile, progress):
+        """Add lists from modFile."""
+        if not self.isActive or 'WRLD' not in modFile.tops: return
+        patchWorlds = self.patchFile.WRLD
+        modFile.convertToLongFids(('CELL','WRLD','ROAD'))
+        for worldBlock in modFile.WRLD.worldBlocks:
+            if worldBlock.road:
+                worldId = worldBlock.world.fid
+                road = worldBlock.road.getTypeCopy()
+                patchWorlds.setWorld(worldBlock.world)
+                patchWorlds.id_worldBlocks[worldId].road = road
 
-class CBash_MAONPCSkeletonPatcher(CBash_MultiTweakItem):
-    """Changes all NPCs to use the right Mayu's Animation Overhaul Skeleton for use with MAO."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("MAO Skeleton Setter")
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        worldsPatched = set()
+        for worldBlock in self.patchFile.WRLD.worldBlocks:
+            worldId = worldBlock.world.fid
+            curRoad = worldBlock.road
+            newRoad = self.world_road.get(worldId)
+            if newRoad and (not curRoad or curRoad.points_p != newRoad.points_p
+                or curRoad.connections_p != newRoad.connections_p
+                ):
+                worldBlock.road = newRoad
+                keep(worldId)
+                keep(newRoad.fid)
+                worldsPatched.add((worldId[0].s,worldBlock.world.eid))
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Worlds Patched"))
+        for modWorld in sorted(worldsPatched):
+            log('* %s: %s' % modWorld)
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Mayu's Animation Overhaul Skeleton Tweaker"),
-            _('Changes all (modded and vanilla) NPCs to use the MAO skeletons.  Not compatible with VORB.  Note: ONLY use if you have MAO installed.'),
-            'MAO Skeleton',
-            (_('All NPCs'),  0),
-            (_('Only Female NPCs'),  1),
-            (_('Only Male NPCs'),  2),
-            )
-        self.mod_count = {}
-        self.playerFid = (GPath('Oblivion.esm'), 0x000007)
+# class CBash_RoadImporter(CBash_ImportPatcher):
+#     """Imports roads."""
+#     name = _('Import Roads')
+#     text = _("Import roads from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Roads',))
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     #The regular patch routine doesn't allow merging of world records. The CBash patch routine does.
+#     #So, allowUnloaded isn't needed for this patcher to work. The same functionality could be gained by merging the tagged record.
+#     #It is needed however so that the regular patcher and the CBash patcher have the same behavior.
+#     #The regular patcher has to allow unloaded mods because it can't otherwise force the road record to be merged
+#     #This isn't standard behavior for import patchers, but consistency between patchers is more important.
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_ROAD = {}
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['ROADS']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         self.id_ROAD[record.fid] = record
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         #If a previous road was scanned, and it is replaced by a new road
+#         curRoad = record
+#         newRoad = self.id_ROAD.get(recordId, None)
+#         if newRoad:
+#             #Roads and pathgrids are complex records...
+#             #No good way to tell if the roads are equal.
+#             #A direct comparison can prove equality, but not inequality
+#             if curRoad.pgrp_list == newRoad.pgrp_list and curRoad.pgrr_list == newRoad.pgrr_list:
+#                 return
+#             #So some records that are actually equal won't pass the above test and end up copied over
+#             #Bloats the patch a little, but won't hurt anything.
+#             if newRoad.fid[0] in self.patchFile.loadSet:
+#                 copyRoad = newRoad #Copy the new road over
+#             elif curRoad and curRoad.fid[0] in self.patchFile.loadSet:
+#                 copyRoad = curRoad #Copy the current road over (it's formID is acceptable)
+#             else:
+#                 #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+#                 mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+#                 mod_skipcount[modFile.GName] = mod_skipcount.setdefault(modFile.GName, 0) + 1
+#                 return
+
+#             parent = self.patchFile.ObCollection.LookupRecords(copyRoad.Parent.fid)
+#             override = parent[0].CopyAsOverride(self.patchFile) #Copies the winning parent world over if needed
+#             if override:
+#                 override = copyRoad.CopyAsOverride(self.patchFile) #Copies the road over
+#                 if override:
+#                     #Copy the new road values into the override (in case the CopyAsOverride returned a record pre-existing in the patch file)
+#                     for copyattr in newRoad.copyattrs:
+#                         setattr(override, copyattr, getattr(newRoad, copyattr))
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Roads Imported: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def getTypes(self):
-        return ['NPC_']
+#------------------------------------------------------------------------------
+class SoundPatcher(ImportPatcher):
+    """Imports sounds from source mods into patch."""
+    name = _('Import Sounds')
+    text = _("Import sounds (from Magic Effects, Containers, Activators, Lights, Weathers and Doors) from source mods.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Sound'
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.fid != self.playerFid: #skip player record
-            if self.choiceValues[self.chosen][0] == 1 and record.IsMale: return
-            elif self.choiceValues[self.chosen][0] == 2 and record.IsFemale: return
-            oldModPath = record.modPath
-            newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonBeast.nif"
-            try:
-                if oldModPath == r'characters\_male\skeletonsesheogorath.nif': #modPaths do case insensitive comparisons by default
-                    newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonSESheogorath.nif"
-            except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
-                pass
-            if newModPath != oldModPath:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.modPath = newModPath
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class VORB_NPCSkeletonPatcher(BasalNPCTweaker):
-    """Changes all NPCs to use the diverse skeleton for different look."""
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("VadersApp's Oblivion Real Bodies Skeleton Tweaker"),
-            _("Changes all (modded and vanilla) NPCs to use diverse skeletons for different look.  Not compatible with MAO, Requires VadersApp's Oblivion Real Bodies."),
-            'VORB',
-            (_('All NPCs'), 0),
-            (_('Only Female NPCs'), 1),
-            (_('Only Male NPCs'), 2),
-            )
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired.  Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-
-        #--Some setup
-        skeletonDir = bosh.dirs['mods'].join('Meshes','Characters','_male')
-        modSkeletonDir = GPath('Characters').join('_male')
-
-        if skeletonDir.exists():
-            # construct skeleton mesh collections
-            # skeletonList gets files that match the pattern "skel_*.nif", but not "skel_special_*.nif"
-            # skeletonSetSpecial gets files that match "skel_special_*.nif"
-            skeletonList = [x for x in skeletonDir.list() if x.csbody.startswith('skel_') and not x.csbody.startswith('skel_special_') and x.cext == '.nif']
-            skeletonSetSpecial = set((x for x in skeletonDir.list() if x.csbody.startswith('skel_special_') and x.cext == '.nif'))
-
-            if len(skeletonList) > 0:
-                femaleOnly = self.choiceValues[self.chosen][0] == 1
-                maleOnly = self.choiceValues[self.chosen][0] == 2
-                playerFid = (GPath('Oblivion.esm'),0x000007)
-
-                for record in patchFile.NPC_.records:
-                    # skip records (male only, female only, player)
-                    if femaleOnly and not record.flags.female: continue
-                    elif maleOnly and record.flags.female: continue
-                    if record.fid == playerFid: continue
-                    try:
-                        oldModPath = record.model.modPath
-                    except AttributeError:  # for freaking weird esps with NPC's with no skeleton assigned to them(!)
-                        continue
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_data = {} #--Names keyed by long fid.
+        self.srcClasses = set() #--Record classes actually provided by src mods/files.
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = len(self.sourceMods) != 0
+        self.classestemp = set()
+        #--Type Fields
+        recAttrs_class = self.recAttrs_class = {}
+        for recClass in (MreMgef,):
+            recAttrs_class[recClass] = ('castingSound','boltSound','hitSound','areaSound')
+        for recClass in (MreActi,):
+            recAttrs_class[recClass] = ('soundLooping','soundActivation')
+        for recClass in (MreLigh,MreTact):
+            recAttrs_class[recClass] = ('sound',)
+        for recClass in (MreWthr,):
+            recAttrs_class[recClass] = ('sounds',)
+        for recClass in (MreCont,):
+            recAttrs_class[recClass] = ('soundOpen','soundClose')
+        for recClass in (MreDoor,):
+            recAttrs_class[recClass] = ('soundOpen','soundClose','soundLoop')
+        for recClass in (MreExpl,MreIpct,):
+            recAttrs_class[recClass] = ('soundLevel','sound1','sound2')
+        for recClass in (MreProj,):
+            recAttrs_class[recClass] = ('sound','soundCountDown','soundDisable','soundLevel')
+        for recClass in (MreAspc,):
+            recAttrs_class[recClass] = ('soundLooping','useSoundFromRegion','environmentType')
+        for recClass in (MreWeap,):
+            recAttrs_class[recClass] = ('soundGunShot3D','soundGunShot2D','soundGunShot3DLooping','soundLevel')
+        #--Needs Longs
+        self.longTypes = set(('MGEF','ACTI','TACT','LIGH','WTHR','CONT','DOOR','EXPL','IPCT','PROJ','ASPC','WEAP','REGN'))
 
-                    specialSkelMesh = "skel_special_%X.nif" % record.fid[1]
-                    if specialSkelMesh in skeletonSetSpecial:
-                        newModPath = modSkeletonDir.join(specialSkelMesh)
-                    else:
-                        random.seed(record.fid)
-                        randomNumber = random.randint(1, len(skeletonList))-1
-                        newModPath = modSkeletonDir.join(skeletonList[randomNumber])
+    def initData(self,progress):
+        """Get sounds from source files."""
+        if not self.isActive: return
+        id_data = self.id_data
+        recAttrs_class = self.recAttrs_class
+        loadFactory = LoadFactory(False,*recAttrs_class.keys())
+        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
+        progress.setFull(len(self.sourceMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.sourceMods):
+            temp_id_data = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass,recAttrs in recAttrs_class.iteritems():
+                if recClass.classType not in srcFile.tops: continue
+                self.srcClasses.add(recClass)
+                self.classestemp.add(recClass)
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
 
-                    if newModPath != oldModPath:
-                        record.model.modPath = newModPath.s
-                        keep(record.fid)
-                        srcMod = record.fid[0]
-                        count[srcMod] = count.get(srcMod,0) + 1
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
 
-        #--Log
-        log.setHeader(_("===VadersApp's Oblivion Real Bodies"))
-        log(_('* %d Skeletons Tweaked') % sum(count.values()))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s, count[srcMod]))
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched sound data as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            #deprint(recClass,type,type_count[type])
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        break
+                else:
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        id_data = None
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
 
-class CBash_VORB_NPCSkeletonPatcher(CBash_MultiTweakItem):
-    """Changes all NPCs to use the diverse skeletons for different look."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("VORB Skeleton Setter")
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("VadersApp's Oblivion Real Bodies Skeleton Tweaker"),
-            _("Changes all (modded and vanilla) NPCs to use diverse skeletons for different look.  Not compatible with MAO, Requires VadersApp's Oblivion Real Bodies."),
-            'VORB',
-            (_('All NPCs'),  0),
-            (_('Only Female NPCs'),  1),
-            (_('Only Male NPCs'),  2),
-            )
-        self.mod_count = {}
-        self.modSkeletonDir = GPath('Characters').join('_male')
-        self.playerFid = (GPath('Oblivion.esm'), 0x000007)
-        self.skeletonList = None
-        self.skeletonSetSpecial = None
-
-    def initSkeletonCollections(self):
-        """ construct skeleton mesh collections
-            skeletonList gets files that match the pattern "skel_*.nif", but not "skel_special_*.nif"
-            skeletonSetSpecial gets files that match "skel_special_*.nif" """
-        # Since bosh.dirs hasn't been populated when __init__ executes, we do this here
-        if not self.skeletonList is None:
-            return
-        self.skeletonList = []
-        skeletonDir = bosh.dirs['mods'].join('Meshes', 'Characters', '_male')
-        if skeletonDir.exists():
-            self.skeletonList = [x for x in skeletonDir.list() if x.csbody.startswith('skel_') and not x.csbody.startswith('skel_special_') and x.cext == '.nif']
-            self.skeletonSetSpecial = set((x for x in skeletonDir.list() if x.csbody.startswith('skel_special_') and x.cext == '.nif'))
+# class CBash_SoundPatcher(CBash_ImportPatcher):
+#     """Imports sounds from source mods into patch."""
+#     name = _('Import Sounds')
+#     text = _("Import sounds (from Activators, Containers, Creatures, Doors, Lights, Magic Effects and Weathers) from source mods.")
+#     tip = text
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Sound',))
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_attr_value = {}
+#         self.class_mod_count = {}
+#         class_attrs = self.class_attrs = {}
+#         class_attrs['ACTI'] = ('sound',)
+#         class_attrs['CONT'] = ('soundOpen','soundClose')
+#         class_attrs['CREA'] = ('footWeight','inheritsSoundsFrom','sounds_list')
+#         class_attrs['DOOR'] = ('soundOpen','soundClose','soundLoop')
+#         class_attrs['LIGH'] = ('sound',)
+#         class_attrs['MGEF'] = ('castingSound','boltSound','hitSound','areaSound')
+# ##        class_attrs['REGN'] = ('sound','sounds_list')
+#         class_attrs['WTHR'] = ('sounds_list',)
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['ACTI','CONT','CREA','DOOR','LIGH','MGEF','WTHR']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[record._Type]))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         prev_attr_value = self.fid_attr_value.get(recordId,None)
+#         if prev_attr_value:
+#             cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
+#             if cur_attr_value != prev_attr_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_attr_value.iteritems():
+#                         setattr(override,attr,value)
+#                     class_mod_count = self.class_mod_count
+#                     class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods"))
+#         for mod in self.srcs:
+#             log("* " +mod.s)
+#         log(_("\n=== Modified Records"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
-    def getTypes(self):
-        return ['NPC_']
+#------------------------------------------------------------------------------
+class StatsPatcher(ImportPatcher):
+    """Import stats from mod file."""
+    scanOrder = 28
+    editOrder = 28 #--Run ahead of bow patcher
+    name = _('Import Stats')
+    text = _("Import stats from any pickupable items from source mods/files.")
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = 'Stats'
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.fid == self.playerFid: return #skip player record
-        elif self.choiceValues[self.chosen][0] == 1 and record.IsMale: return
-        elif self.choiceValues[self.chosen][0] == 2 and record.IsFemale: return
-        self.initSkeletonCollections()
-        if len(self.skeletonList) == 0: return
-
-        try:
-            oldModPath = record.modPath.lower()
-        except AttributeError:  # for freaking weird esps with NPC's with no skeleton assigned to them(!)
-            pass
-
-        specialSkelMesh = "skel_special_%X.nif" % record.fid[1]
-        if specialSkelMesh in self.skeletonSetSpecial:
-            newModPath = self.modSkeletonDir.join(specialSkelMesh)
-        else:
-            random.seed(record.fid)
-            randomNumber = random.randint(1, len(self.skeletonList))-1
-            newModPath = self.modSkeletonDir.join(self.skeletonList[randomNumber])
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
+        #--To be filled by initData
+        self.fid_attr_value = {} #--Stats keyed by long fid.
+        self.activeTypes = [] #--Types ('ARMO', etc.) of data actually provided by src mods/files.
+        self.class_attrs = {}
 
-        if newModPath.cs != oldModPath:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.modPath = newModPath.s
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
+    def initData(self,progress):
+        """Get stats from source files."""
+        if not self.isActive: return
+        itemStats = ItemStats(aliases=self.patchFile.aliases)
+        progress.setFull(len(self.srcFiles))
+        for srcFile in self.srcFiles:
+            srcPath = GPath(srcFile)
+            patchesDir = dirs['patches'].list()
+            if reModExt.search(srcFile.s):
+                if srcPath not in modInfos: continue
+                srcInfo = modInfos[GPath(srcFile)]
+                itemStats.readFromMod(srcInfo)
+            else:
+                if srcPath not in patchesDir: continue
+                itemStats.readFromText(dirs['patches'].join(srcFile))
+            progress.plus()
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class VanillaNPCSkeletonPatcher(MultiTweakItem):
-    """Changes all NPCs to use the vanilla beast race skeleton."""
+        #--Finish
+        for group,nId_attr_value in itemStats.class_fid_attr_value.iteritems():
+            self.activeTypes.append(group)
+            for id, attr_value in nId_attr_value.iteritems():
+                del attr_value['eid']
+            self.fid_attr_value.update(nId_attr_value)
+            self.class_attrs[group] = itemStats.class_attrs[group][1:]
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Vanilla Beast Skeleton Tweaker"),
-            _('Avoids bug if an NPC is a beast race but has the regular skeleton.nif selected.'),
-            'Vanilla Skeleton',
-            ('1.0',  '1.0'),
-            )
+        self.isActive = bool(self.activeTypes)
 
-    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreNpc,)
+        if not self.isActive: return None
+        return [MreRecord.type_class[type] for type in self.activeTypes]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreNpc,)
+        if not self.isActive: return None
+        return [MreRecord.type_class[type] for type in self.activeTypes]
 
-    def scanModFile(self,modFile,progress,patchFile):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
+    def scanModFile(self, modFile, progress):
+        """Add affected items to patchFile."""
+        if not self.isActive: return
+        fid_attr_value = self.fid_attr_value
         mapper = modFile.getLongMapper()
-        patchRecords = patchFile.NPC_
-        for record in modFile.NPC_.getActiveRecords():
-            record = record.getTypeCopy(mapper)
-            if not record.model: continue #for freaking weird esps with NPC's with no skeleton assigned to them(!)
-            model = record.model.modPath
-            if model.lower() == r'characters\_male\skeleton.nif':
-                patchRecords.setRecord(record)
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        newModPath = r"Characters\_Male\SkeletonBeast.nif"
-        for record in patchFile.NPC_.records:
-            try:
-                oldModPath = record.model.modPath
-            except AttributeError: #for freaking weird esps with NPC's with no skeleton assigned to them(!)
-                continue
-            try:
-                if oldModPath.lower() != r'characters\_male\skeleton.nif':
-                    continue
-            except AttributeError: #in case oldModPath was None. Try/Except has no overhead if exception isn't thrown.
-                pass
-            if newModPath != oldModPath:
-                record.model.modPath = newModPath
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===Vanilla Beast Skeleton'))
-        log(_('* %d Skeletons Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_VanillaNPCSkeletonPatcher(CBash_MultiTweakItem):
-    """Changes all NPCs to use the vanilla beast race skeleton."""
-    scanOrder = 31 #Run before MAO
-    editOrder = 31
-    name = _("Vanilla Beast Skeleton")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Vanilla Beast Skeleton Tweaker"),
-            _('Avoids bug if an NPC is a beast race but has the regular skeleton.nif selected.'),
-            'Vanilla Skeleton',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['NPC_']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        oldModPath = record.modPath
-        newModPath = r"Characters\_Male\SkeletonBeast.nif"
-        try:
-            if oldModPath != r'characters\_male\skeleton.nif': #modPaths do case insensitive comparisons by default
-                return
-        except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
-            pass
-        if newModPath != oldModPath:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.modPath = newModPath
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class RedguardNPCPatcher(BasalNPCTweaker):
-    """Changes all Redguard NPCs texture symetry for Better Redguard Compatibility."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Redguard FGTS Nuller"),
-            _('Nulls FGTS of all Redguard NPCs - for compatibility with Better Redguards.'),
-            'RedguardFGTSPatcher',
-            ('1.0',  '1.0'),
-            )
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.NPC_.records:
-            if not record.race: continue
-            if record.race[1] == 0x00d43:
-                record.fgts_p = '\x00'*200
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===Redguard FGTS Patcher'))
-        log(_('* %d Redguard NPCs Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_RedguardNPCPatcher(CBash_MultiTweakItem):
-    """Changes all Redguard NPCs texture symmetry for Better Redguard Compatibility."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Redguard FGTS Patcher")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Redguard FGTS Nuller"),
-            _('Nulls FGTS of all Redguard NPCs - for compatibility with Better Redguards.'),
-            'RedguardFGTSPatcher',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-        self.redguardId = (GPath('Oblivion.esm'),0x00000D43)
-
-    def getTypes(self):
-        return ['NPC_']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.race == self.redguardId: #Only affect npc's with the Redguard race
-            oldFGTS_p = record.fgts_p
-            newFGTS_p = [0x00] * 200
-            if newFGTS_p != oldFGTS_p:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.fgts_p = newFGTS_p
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Redguard NPCs Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class NoBloodCreaturesPatcher(BasalCreatureTweaker):
-    """Set all creatures to have no blood records."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("No Bloody Creatures"),
-            _("Set all creatures to have no blood records, will have pretty much no effect when used with MMM since the MMM blood uses a different system."),
-            'No bloody creatures',
-            ('1.0',  '1.0'),
-            )
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        for record in patchFile.CREA.records:
-            if record.bloodDecalPath or record.bloodSprayPath:
-                record.bloodDecalPath = None
-                record.bloodSprayPath = None
-                record.flags.noBloodSpray = True
-                record.flags.noBloodDecal = True
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===No Bloody Creatures'))
-        log(_('* %d Creatures Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_NoBloodCreaturesPatcher(CBash_MultiTweakItem):
-    """Set all creatures to have no blood records."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("No Bloody Creatures")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("No Bloody Creatures"),
-            _("Set all creatures to have no blood records, will have pretty much no effect when used with MMM since the MMM blood uses a different system."),
-            'No bloody creatures',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CREA']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.bloodDecalPath or record.bloodSprayPath:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.bloodDecalPath = None
-                override.bloodSprayPath = None
-                override.IsNoBloodSpray = True
-                override.IsNoBloodDecal = True
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AsIntendedImpsPatcher(BasalCreatureTweaker):
-    """Set all imps to have the Bethesda imp spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
-    reImpModPath  = re.compile(r'(imp(?!erial)|gargoyle)\\.',re.I)
-    reImp  = re.compile(r'(imp(?!erial)|gargoyle)',re.I)
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_('As Intended: Imps'),
-            _("Set imps to have the unassigned Bethesda Imp Spells as discovered by the UOP team and made into a mod by Tejon."),
-            'vicious imps!',
-            (_('All imps'), 'all'),
-            (_('Only fullsize imps'), 'big'),
-            (_('Only implings'), 'small'),
-            )
+        for group in self.activeTypes:
+            if group not in modFile.tops: continue
+            attrs = self.class_attrs[group]
+            patchBlock = getattr(self.patchFile,group)
+            id_records = patchBlock.id_records
+            for record in getattr(modFile,group).getActiveRecords():
+                longid = record.fid
+                if not record.longFids: longid = mapper(longid)
+                if longid in id_records: continue
+                itemStats = fid_attr_value.get(longid,None)
+                if not itemStats: continue
+                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
+                if oldValues != itemStats:
+                    patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        spell = (GPath('Oblivion.esm'), 0x02B53F)
-        reImp  = self.reImp
-        reImpModPath = self.reImpModPath
-        for record in patchFile.CREA.records:
-            try:
-                oldModPath = record.model.modPath
-            except AttributeError:
-                continue
-            if not reImpModPath.search(oldModPath or ''): continue
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        if not self.isActive: return
+        patchFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        fid_attr_value = self.fid_attr_value
+        allCounts = []
+        for group in self.activeTypes:
+            if group not in patchFile.tops: continue
+            attrs = self.class_attrs[group]
+            count,counts = 0,{}
+            for record in patchFile.tops[group].records:
+                fid = record.fid
+                itemStats = fid_attr_value.get(fid,None)
+                if not itemStats: continue
+                oldValues = dict(zip(attrs,map(record.__getattribute__,attrs)))
+                if oldValues != itemStats:
+                    for attr, value in itemStats.iteritems():
+                        setattr(record,attr,value)
+                    keep(fid)
+                    count += 1
+                    counts[fid[0]] = 1 + counts.get(fid[0],0)
+            allCounts.append((group,count,counts))
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods/Files"))
+        for file in self.srcFiles:
+            log("* " +file.s)
+        log(_("\n=== Modified Stats"))
+        for type,count,counts in allCounts:
+            if not count: continue
+            typeName = {'ALCH':_('Ingestibles'),'AMMO':_('Ammo'),'ARMO':_('Armor'),'ARMA':_('Armor Addon'),'INGR':_('Ingr'),'MISC':_('Misc'),'WEAP':_('Weapons'),'LIGH':_('Lights'),'KEYM':_('Keys'),'BOOK':_('Books')}[type]
+            log("* %s: %d" % (typeName,count))
+            for modName in sorted(counts):
+                log("  * %s: %d" % (modName.s,counts[modName]))
 
-            for bodyPart in record.bodyParts:
-                if reImp.search(bodyPart):
-                    break
-            else:
-                continue
-            if record.baseScale < 0.4:
-                if 'big' in self.choiceValues[self.chosen]:
-                    continue
-            elif 'small' in self.choiceValues[self.chosen]:
-                continue
-            if spell not in record.spells:
-                record.spells.append(spell)
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===As Intended: Imps'))
-        log(_('* %d Imps Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_AsIntendedImpsPatcher(CBash_MultiTweakItem):
-    """Set all imps to have the Bethesda imp spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("As Intended: Imps")
-    reImpModPath  = re.compile(r'(imp(?!erial)|gargoyle)\\.',re.I)
-    reImp  = re.compile(r'(imp(?!erial)|gargoyle)',re.I)
+# class CBash_StatsPatcher(CBash_ImportPatcher):
+#     """Import stats from mod file."""
+#     scanOrder = 28
+#     editOrder = 28 #--Run ahead of bow patcher
+#     name = _('Import Stats')
+#     text = _("Import stats from any pickupable items from source mods/files.")
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Stats',))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.fid_attr_value = {}
+#         self.csvFid_attr_value = {}
+#         self.class_attrs = CBash_ItemStats.class_attrs
+#         self.class_mod_count = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         CBash_ImportPatcher.initData(self,type_patchers,progress)
+#         itemStats = CBash_ItemStats(aliases=self.patchFile.aliases)
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             if not reModExt.search(srcFile.s):
+#                 if srcFile not in patchesDir: continue
+#                 itemStats.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+
+#         #--Finish
+#         for group,nId_attr_value in itemStats.class_fid_attr_value.iteritems():
+#             if group not in validTypes: continue
+#             self.csvFid_attr_value.update(nId_attr_value)
+
+#         for group in self.getTypes():
+#              type_patchers.setdefault(group,[]).append(self)
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return self.class_attrs.keys()
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         self.fid_attr_value.setdefault(record.fid,{}).update(record.ConflictDetails(self.class_attrs[record._Type], False))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         prev_attr_value = self.fid_attr_value.get(recordId, None)
+#         prev_attr_value = self.csvFid_attr_value.get(recordId, prev_attr_value)
+#         if prev_attr_value:
+#             cur_attr_value = dict((attr,getattr(record,attr)) for attr in prev_attr_value)
+#             if cur_attr_value != prev_attr_value:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_attr_value.iteritems():
+#                         setattr(override,attr,value)
+#                     class_mod_count = self.class_mod_count
+#                     class_mod_count.setdefault(record._Type,{})[modFile.GName] = class_mod_count.setdefault(record._Type,{}).get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         class_mod_count = self.class_mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("=== Source Mods/Files"))
+#         for file in self.srcs:
+#             log("* " +file.s)
+#         log(_("\n=== Imported Stats"))
+#         for type in class_mod_count.keys():
+#             log(_('* Modified %s Records: %d') % (type,sum(class_mod_count[type].values()),))
+#             for srcMod in modInfos.getOrdered(class_mod_count[type].keys()):
+#                 log('  * %s: %d' % (srcMod.s,class_mod_count[type][srcMod]))
+#         self.class_mod_count = {}
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_('As Intended: Imps'),
-            _("Set imps to have the unassigned Bethesda Imp Spells as discovered by the UOP team and made into a mod by Tejon."),
-            'vicious imps!',
-            (_('All imps'), 'all'),
-            (_('Only fullsize imps'), 'big'),
-            (_('Only implings'), 'small'),
-            )
-        self.mod_count = {}
-        self.spell = (GPath('Oblivion.esm'), 0x02B53F)
 
-    def getTypes(self):
-        return ['CREA']
+#------------------------------------------------------------------------------
+class SpellsPatcher(ImportPatcher):
+    """Import spell changes from mod files."""
+    scanOrder = 29
+    editOrder = 29 #--Run ahead of bow patcher
+    name = _('Import Spell Stats')
+    text = _("Import stats from any spells from source mods/files.")
+    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = ('Spells','SpellStats')
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if not self.reImpModPath.search(record.modPath or ''): return
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcFiles = self.getConfigChecked()
+        self.isActive = bool(self.srcFiles)
+        #--To be filled by initData
+        self.id_stat = {} #--Stats keyed by long fid.
+        self.attrs = None #set in initData
 
-        reImp  = self.reImp
-        for bodyPart in record.bodyParts:
-            if reImp.search(bodyPart):
-                break
-        else:
-            return
-        if record.baseScale < 0.4:
-            if 'big' in self.choiceValues[self.chosen]:
-                return
-        elif 'small' in self.choiceValues[self.chosen]:
+    def initData(self,progress):
+        """Get stats from source files."""
+        if not self.isActive: return
+        spellStats = SpellRecords(aliases=self.patchFile.aliases)
+        self.attrs = spellStats.attrs
+        progress.setFull(len(self.srcFiles))
+        for srcFile in self.srcFiles:
+            srcPath = GPath(srcFile)
+            patchesDir = dirs['patches'].list()
+            if reModExt.search(srcFile.s):
+                if srcPath not in modInfos: continue
+                srcInfo = modInfos[GPath(srcFile)]
+                spellStats.readFromMod(srcInfo)
+            else:
+                if srcPath not in patchesDir: continue
+                spellStats.readFromText(dirs['patches'].join(srcFile))
+            progress.plus()
+        #--Finish
+        self.id_stat.update(spellStats.fid_stats)
+        self.isActive = bool(self.id_stat)
+
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        if not self.isActive: return None
+        return [MreSpel]
+
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        if not self.isActive: return None
+        return [MreSpel]
+
+    def scanModFile(self, modFile, progress):
+        """Add affected items to patchFile."""
+        if not self.isActive or 'SPEL' not in modFile.tops:
             return
-        spells = record.spells
-        newSpell = self.spell
-        if newSpell not in spells:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                spells.append(newSpell)
-                override.spells = spells
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
+        id_stat = self.id_stat
+        mapper = modFile.getLongMapper()
+        attrs = self.attrs
+        patchBlock = self.patchFile.SPEL
+        id_records = patchBlock.id_records
+        for record in modFile.SPEL.getActiveRecords():
+            fid = record.fid
+            if not record.longFids: fid = mapper(fid)
+            if fid in id_records: continue
+            spellStats = id_stat.get(fid)
+            if not spellStats: continue
+            oldValues = [getattr_deep(record, attr) for attr in attrs]
+            if oldValues != spellStats:
+                patchBlock.setRecord(record.getTypeCopy(mapper))
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Imps Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class AsIntendedBoarsPatcher(BasalCreatureTweaker):
-    """Set all imps to have the Bethesda boar spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
-    reBoarModPath  = re.compile(r'(boar)\\.',re.I)
-    reBoar  = re.compile(r'(boar)',re.I)
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        if not self.isActive: return
+        patchFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_stat = self.id_stat
+        allCounts = []
+        attrs = self.attrs
+        count,counts = 0,{}
+        for record in patchFile.SPEL.records:
+            fid = record.fid
+            spellStats = id_stat.get(fid)
+            if not spellStats: continue
+            oldValues = [getattr_deep(record, attr) for attr in attrs]
+            if oldValues == spellStats: continue
+            for attr,value in zip(attrs,spellStats):
+                setattr_deep(record,attr,value)
+            keep(fid)
+            count += 1
+            counts[fid[0]] = 1 + counts.get(fid[0],0)
+        allCounts.append(('SPEL',count,counts))
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods/Files"))
+        for file in self.srcFiles:
+            log("* " +file.s)
+        log(_("\n=== Modified Stats"))
+        for type,count,counts in allCounts:
+            if not count: continue
+            typeName = {'SPEL':_('Spells'),}[type]
+            log("* %s: %d" % (typeName,count))
+            for modName in sorted(counts):
+                log("  * %s: %d" % (modName.s,counts[modName]))
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_('As Intended: Boars'),
-            _("Set boars to have the unassigned Bethesda Boar Spells as discovered by the UOP team and made into a mod by Tejon."),
-            'vicious boars!',
-            ('1.0',  '1.0'),
-            )
 
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        spell = (GPath('Oblivion.esm'), 0x02B54E)
-        keep = patchFile.getKeeper()
-        reBoar  = self.reBoar
-        reBoarModPath = self.reBoarModPath
-        for record in patchFile.CREA.records:
-            try:
-                oldModPath = record.model.modPath
-            except AttributeError:
-                continue
-            if not reBoarModPath.search(oldModPath or ''): continue
+# class CBash_SpellsPatcher(CBash_ImportPatcher):
+#     """Import spell changes from mod files."""
+#     scanOrder = 29
+#     editOrder = 29 #--Run ahead of bow patcher
+#     name = _('Import Spell Stats')
+#     text = _("Import stats from any spells from source mods/files.")
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Spells','SpellStats'))
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ImportPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.id_stats = {}
+#         self.csvId_stats = {}
+#         self.mod_count = {}
+#         self.attrs = None #set in initData
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         CBash_ImportPatcher.initData(self,type_patchers,progress)
+#         spellStats = CBash_SpellRecords(aliases=self.patchFile.aliases)
+#         self.attrs = spellStats.attrs
+#         progress.setFull(len(self.srcs))
+#         patchesDir = dirs['patches'].list()
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             if not reModExt.search(srcFile.s):
+#                 if srcPath not in patchesDir: continue
+#                 spellStats.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+#         #--Finish
+#         self.csvId_stats.update(spellStats.fid_stats)
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['SPEL']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         self.id_stats.setdefault(record.fid,{}).update(record.ConflictDetails(self.attrs))
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+
+#         recordId = record.fid
+#         prev_values = self.id_stats.get(recordId, None)
+#         prev_values = self.csvId_stats.get(recordId, prev_values)
+#         if prev_values:
+#             rec_values = dict((attr,getattr(record,attr)) for attr in prev_values)
+#             if rec_values != prev_values:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for attr, value in prev_values.iteritems():
+#                         setattr(override,attr,value)
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Modified SPEL Stats: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class DestructiblePatcher(ImportPatcher):
+    """Merges changes to destructible records to work with Destruction Environment mod."""
+    name = _("Import Destructible")
+    text = _("Merges changes to destructible records.\n\nWill have to use if Destruction Environment mod is installed and active.")
+    tip = text
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = ('Destructible','Destructable')
 
-            for bodyPart in record.bodyParts:
-                if reBoar.search(bodyPart):
-                    break
-            else:
-                continue
-            if spell not in record.spells:
-                record.spells.append(spell)
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===As Intended: Boars'))
-        log(_('* %d Boars Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.id_data = {} #--Names keyed by long fid.
+        self.srcClasses = set() #--Record classes actually provided by src mods/files.
+        self.sourceMods = self.getConfigChecked()
+        self.isActive = len(self.sourceMods) != 0
+        self.classestemp = set()
+        #--Type Fields
+        recAttrs_class = self.recAttrs_class = {}
+        recFidAttrs_class = self.recFidAttrs_class = {}
+        for recClass in (MreActi,MreAlch,MreAmmo,MreBook,MreCont,MreCrea,MreDoor,MreFurn,MreKeym,MreMisc,MreNpc,MreWeap,MreProj,MreMstt,MreTerm,MreTact):
+            recAttrs_class[recClass] = ('destructible',)
+        self.longTypes = set(('ACTI','ALCH','AMMO','BOOK','CONT','CREA','DOOR','FURN','KEYM','MISC','NPC','WEAP','PROJ','MSTT','TERM','TACT'))
+
+    def initData(self,progress):
+        """Get graphics from source files."""
+        if not self.isActive: return
+        id_data = self.id_data
+        recAttrs_class = self.recAttrs_class
+        loadFactory = LoadFactory(False,*recAttrs_class.keys())
+        longTypes = self.longTypes & set(x.classType for x in self.recAttrs_class)
+        progress.setFull(len(self.sourceMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.sourceMods):
+            temp_id_data = {}
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            masters = srcInfo.header.masters
+            srcFile.load(True)
+            srcFile.convertToLongFids(longTypes)
+            mapper = srcFile.getLongMapper()
+            for recClass,recAttrs in recAttrs_class.iteritems():
+                if recClass.classType not in srcFile.tops: continue
+                self.srcClasses.add(recClass)
+                self.classestemp.add(recClass)
+                recFidAttrs = self.recFidAttrs_class.get(recClass, None)
+                for record in srcFile.tops[recClass.classType].getActiveRecords():
+                    fid = mapper(record.fid)
+                    if recFidAttrs:
+                        attr_fidvalue = dict((attr,record.__getattribute__(attr)) for attr in recFidAttrs)
+                        for fidvalue in attr_fidvalue.values():
+                            if fidvalue and (fidvalue[0] is None or fidvalue[0] not in self.patchFile.loadSet):
+                                #Ignore the record. Another option would be to just ignore the attr_fidvalue result
+                                mod_skipcount = self.patchFile.patcher_mod_skipcount.setdefault(self.name,{})
+                                mod_skipcount[srcMod] = mod_skipcount.setdefault(srcMod, 0) + 1
+                                break
+                        else:
+                            temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+                            temp_id_data[fid].update(attr_fidvalue)
+                    else:
+                        temp_id_data[fid] = dict((attr,record.__getattribute__(attr)) for attr in recAttrs)
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    masterFile.convertToLongFids(longTypes)
+                    cachedMasters[master] = masterFile
+                mapper = masterFile.getLongMapper()
+                for recClass,recAttrs in recAttrs_class.iteritems():
+                    if recClass.classType not in masterFile.tops: continue
+                    if recClass not in self.classestemp: continue
+                    for record in masterFile.tops[recClass.classType].getActiveRecords():
+                        fid = mapper(record.fid)
+                        if fid not in temp_id_data: continue
+                        for attr, value in temp_id_data[fid].iteritems():
+                            if value == record.__getattribute__(attr): continue
+                            else:
+                                if fid not in id_data: id_data[fid] = dict()
+                                try:
+                                    id_data[fid][attr] = temp_id_data[fid][attr]
+                                except KeyError:
+                                    id_data[fid].setdefault(attr,value)
+            progress.plus()
+        temp_id_data = None
+        self.longTypes = self.longTypes & set(x.classType for x in self.srcClasses)
+        self.isActive = bool(self.srcClasses)
+
+    def scanModFile(self, modFile, progress):
+        """Scan mod file against source data."""
+        if not self.isActive: return
+        id_data = self.id_data
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        if self.longTypes:
+            modFile.convertToLongFids(self.longTypes)
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            patchBlock = getattr(self.patchFile,type)
+            for record in modFile.tops[type].getActiveRecords():
+                fid = record.fid
+                if not record.longFids: fid = mapper(fid)
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if record.__getattribute__(attr) != value:
+                        patchBlock.setRecord(record.getTypeCopy(mapper))
+                        break
 
-class CBash_AsIntendedBoarsPatcher(CBash_MultiTweakItem):
-    """Set all imps to have the Bethesda boar spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("As Intended: Boars")
-    reBoarModPath  = re.compile(r'(boar)\\.',re.I)
-    reBoar  = re.compile(r'(boar)',re.I)
+    def buildPatch(self,log,progress):
+        """Merge last version of record with patched destructible data as needed."""
+        if not self.isActive: return
+        modFile = self.patchFile
+        keep = self.patchFile.getKeeper()
+        id_data = self.id_data
+        type_count = {}
+        for recClass in self.srcClasses:
+            type = recClass.classType
+            if type not in modFile.tops: continue
+            type_count[type] = 0
+            for record in modFile.tops[type].records:
+                fid = record.fid
+                if fid not in id_data: continue
+                for attr,value in id_data[fid].iteritems():
+                    if isinstance(record.__getattribute__(attr),str) and isinstance(value, str):
+                        if record.__getattribute__(attr).lower() != value.lower():
+                            break
+                        continue
+                    elif attr == 'model':
+                        try:
+                            if record.__getattribute__(attr).modPath.lower() != value.modPath.lower():
+                                break
+                            continue
+                        except:
+                            break #assume they are not equal (ie they aren't __both__ NONE)
+                    if record.__getattribute__(attr) != value:
+                        break
+                else:
+                    continue
+                for attr,value in id_data[fid].iteritems():
+                    record.__setattr__(attr,value)
+                keep(fid)
+                type_count[type] += 1
+        id_data = None
+        log.setHeader('= '+self.__class__.name)
+        log(_("=== Source Mods"))
+        for mod in self.sourceMods:
+            log("* " +mod.s)
+        log(_("\n=== Modified Records"))
+        for type,count in sorted(type_count.iteritems()):
+            if count: log("* %s: %d" % (type,count))
+
+##class CBash_DestructiblePatcher(CBash_ImportPatcher):
+##    raise NotImplementedError
+# Patchers: 30 ----------------------------------------------------------------
+#------------------------------------------------------------------------------
+# class AssortedTweak_ArmorShows(MultiTweakItem):
+#     """Fix armor to show amulets/rings."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key):
+#         MultiTweakItem.__init__(self,label,tip,key)
+#         self.hidesBit = {'armorShowsRings':16,'armorShowsAmulets':17}[key]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreArmo,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreArmo,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.ARMO
+#         hidesBit = self.hidesBit
+#         for record in modFile.ARMO.getActiveRecords():
+#             if record.flags[hidesBit] and not record.flags.notPlayable:
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         hidesBit = self.hidesBit
+#         for record in patchFile.ARMO.records:
+#             if record.flags[hidesBit] and not record.flags.notPlayable:
+#                 record.flags[hidesBit] = False
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader('=== '+self.label)
+#         log(_('* Armor Pieces Tweaked: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_ArmorShows(CBash_MultiTweakItem):
+#     """Fix armor to show amulets/rings."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Armor Tweaks')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key):
+#         CBash_MultiTweakItem.__init__(self,label,tip,key)
+#         self.hideFlag = {'armorShowsRings':'IsHideRings','armorShowsAmulets':'IsHideAmulets'}[key]
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['ARMO']
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if record.IsNonPlayable:
+#             return
+
+#         if (getattr(record, self.hideFlag)):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 setattr(override, self.hideFlag, False)
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         log.setHeader('=== '+self.label)
+#         log(_('* Armor Pieces Tweaked: %d') % (sum(self.mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(self.mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,self.mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_ClothingShows(MultiTweakItem):
+#     """Fix robes, gloves and the like to show amulets/rings."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key):
+#         MultiTweakItem.__init__(self,label,tip,key)
+#         self.hidesBit = {'ClothingShowsRings':16,'ClothingShowsAmulets':17}[key]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreClot,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreClot,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.CLOT
+#         hidesBit = self.hidesBit
+#         for record in modFile.CLOT.getActiveRecords():
+#             if record.flags[hidesBit] and not record.flags.notPlayable:
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         hidesBit = self.hidesBit
+#         for record in patchFile.CLOT.records:
+#             if record.flags[hidesBit] and not record.flags.notPlayable:
+#                 record.flags[hidesBit] = False
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader('=== '+self.label)
+#         log(_('* Clothing Pieces Tweaked: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_ClothingShows(CBash_MultiTweakItem):
+#     """Fix robes, gloves and the like to show amulets/rings."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Clothing Tweaks')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key):
+#         CBash_MultiTweakItem.__init__(self,label,tip,key)
+#         self.hideFlag = {'ClothingShowsRings':'IsHideRings','ClothingShowsAmulets':'IsHideAmulets'}[key]
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CLOT']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if record.IsNonPlayable:
+#             return
+#         if (getattr(record, self.hideFlag)):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 setattr(override, self.hideFlag, False)
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.label)
+#         log(_('* Clothing Pieces Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_BowReach(MultiTweakItem):
+#     """Fix bows to have reach = 1.0."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Bow Reach Fix"),
+#             _('Fix bows with zero reach. (Zero reach causes CTDs.)'),
+#             'BowReach',
+#             ('1.0',  '1.0'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreWeap,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreWeap,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.WEAP
+#         for record in modFile.WEAP.getActiveRecords():
+#             if record.weaponType == 5 and record.reach <= 0:
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.WEAP.records:
+#             if record.weaponType == 5 and record.reach <= 0:
+#                 record.reach = 1
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Bow Reach Fix'))
+#         log(_('* Bows fixed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_BowReach(CBash_MultiTweakItem):
+#     """Fix bows to have reach = 1.0."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Bow Reach Fix')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Bow Reach Fix"),
+#             _('Fix bows with zero reach. (Zero reach causes CTDs.)'),
+#             'BowReach',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['WEAP']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if (record.IsBow and record.reach <= 0):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.reach = 1.0
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Bow Reach Fix'))
+#         log(_('* Bows fixed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_ConsistentRings(MultiTweakItem):
+#     """Sets rings to all work on same finger."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Right Hand Rings"),
+#             _('Fixes rings to unequip consistently by making them prefer the right hand.'),
+#             'ConsistentRings',
+#             ('1.0',  '1.0'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreClot,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreClot,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.CLOT
+#         for record in modFile.CLOT.getActiveRecords():
+#             if record.flags.leftRing:
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.CLOT.records:
+#             if record.flags.leftRing:
+#                 record.flags.leftRing = False
+#                 record.flags.rightRing = True
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Right Hand Rings'))
+#         log(_('* Rings fixed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_AssortedTweak_ConsistentRings(CBash_MultiTweakItem):
+#     """Sets rings to all work on same finger."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Right Hand Rings')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Right Hand Rings"),
+#             _('Fixes rings to unequip consistently by making them prefer the right hand.'),
+#             'ConsistentRings',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CLOT']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsLeftRing:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.IsLeftRing = False
+#                 override.IsRightRing = True
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Right Hand Rings'))
+#         log(_('* Rings fixed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_ClothingPlayable(MultiTweakItem):
+#     """Sets all clothes to playable"""
+#     reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)|(?:ghostly immobility)|(?:corspe)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("All Clothing Playable"),
+#             _('Sets all clothing to be playable.'),
+#             'PlayableClothing',
+#             ('1.0',  '1.0'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreClot,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreClot,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.CLOT
+#         for record in modFile.CLOT.getActiveRecords():
+#             if record.flags.notPlayable:
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         reSkip = self.reSkip
+#         for record in patchFile.CLOT.records:
+#             if record.flags.notPlayable:
+#                 full = record.full
+#                 if not full: continue
+#                 if record.script: continue
+#                 if reSkip.search(full): continue #probably truly shouldn't be playable
+#                 #If only the right ring and no other body flags probably a token that wasn't zeroed (which there are a lot of).
+#                 if record.flags.leftRing != 0 or record.flags.foot != 0 or record.flags.hand != 0 or record.flags.amulet != 0 or record.flags.lowerBody != 0 or record.flags.upperBody != 0 or record.flags.head != 0 or record.flags.hair != 0 or record.flags.tail != 0:
+#                     record.flags.notPlayable = 0
+#                     keep(record.fid)
+#                     srcMod = record.fid[0]
+#                     count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Playable Clothes'))
+#         log(_('* Clothes set as playable: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_ClothingPlayable(CBash_MultiTweakItem):
+#     """Sets all clothes to playable"""
+#     scanOrder = 29 #Run before the show clothing tweaks
+#     editOrder = 29
+#     name = _('Playable Clothes')
+#     reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)|(?:ghostly immobility)|(?:corspe)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("All Clothing Playable"),
+#             _('Sets all clothing to be playable.'),
+#             'PlayableClothing',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CLOT']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsNonPlayable:
+#             full = record.full
+#             if not full: return
+#             if record.script: return
+#             if self.reSkip.search(full): return #probably truly shouldn't be playable
+#             #If only the right ring and no other body flags probably a token that wasn't zeroed (which there are a lot of).
+#             if record.IsLeftRing or record.IsFoot or record.IsHand or record.IsAmulet or record.IsLowerBody or record.IsUpperBody or record.IsHead or record.IsHair or record.IsTail:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.IsNonPlayable = False
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Playable Clothes'))
+#         log(_('* Clothes set as playable: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+class AssortedTweak_ArmorPlayable(MultiTweakItem):
+    """Sets all armors to be playable"""
+    reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)',re.I)
 
     #--Config Phase -----------------------------------------------------------
     def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_('As Intended: Boars'),
-            _("Set boars to have the unassigned Bethesda Boar Spells as discovered by the UOP team and made into a mod by Tejon."),
-            'vicious boars!',
+        MultiTweakItem.__init__(self,_("All Armor Playable"),
+            _('Sets all armor to be playable.'),
+            'PlayableArmor',
             ('1.0',  '1.0'),
             )
-        self.mod_count = {}
-        self.spell = (GPath('Oblivion.esm'), 0x02B54E)
-
-    def getTypes(self):
-        return ['CREA']
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if not self.reBoarModPath.search(record.modPath or ''): return
-
-        reBoar  = self.reBoar
-        for bodyPart in record.bodyParts:
-            if reBoar.search(bodyPart):
-                break
-        else:
-            return
-
-        spells = record.spells
-        newSpell = self.spell
-        if newSpell not in spells:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                spells.append(newSpell)
-                override.spells = spells
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreArmo,)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Boars Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class SWALKNPCAnimationPatcher(BasalNPCTweaker):
-    """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreArmo,)
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Sexy Walk for female NPCs"),
-            _("Changes all female NPCs to use Mur Zuk's Sexy Walk - Requires Mur Zuk's Sexy Walk animation file."),
-            'Mur Zuk SWalk',
-            ('1.0',  '1.0'),
-            )
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        patchRecords = patchFile.ARMO
+        for record in modFile.ARMO.getActiveRecords():
+            if record.generalFlags.notPlayable:
+                record = record.getTypeCopy(mapper)
+                patchRecords.setRecord(record)
 
     def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
         count = {}
         keep = patchFile.getKeeper()
-        for record in patchFile.NPC_.records:
-            if record.flags.female == 1:
-                record.animations = record.animations + ['0sexywalk01.kf']
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
+        reSkip = self.reSkip
+        for record in patchFile.ARMO.records:
+            if record.generalFlags.notPlayable:
+                full = record.full
+                if not full: continue
+                if record.script: continue
+                if reSkip.search(full): continue #probably truly shouldn't be playable
+                # We only want to set playable if the record has at least one body flag... otherwise most likely a token.
+                if record.bipedFlags.head != 0 or record.bipedFlags.hair != 0 or record.bipedFlags.upperBody != 0 or record.bipedFlags.leftHand != 0 or record.bipedFlags.rightHand != 0 or record.bipedFlags.weapon != 0 or record.bipedFlags.backpack != 0 or record.bipedFlags.necklace != 0 or record.bipedFlags.headband != 0 or record.bipedFlags.hat != 0 or record.bipedFlags.eyeGlasses != 0 or record.bipedFlags.noseRing != 0 or record.bipedFlags.earrings != 0 or record.bipedFlags.mask != 0 or record.bipedFlags.choker != 0 or record.bipedFlags.mouthObject != 0 or record.bipedFlags.bodyAddOn1 != 0 or record.bipedFlags.bodyAddOn2 != 0 or record.bipedFlags.bodyAddOn3 != 0:
+                    record.generalFlags.notPlayable = 0
+                    keep(record.fid)
+                    srcMod = record.fid[0]
+                    count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        log.setHeader(_('===SWalk for Female NPCs'))
-        log(_('* %d NPCs Tweaked') % (sum(count.values()),))
+        log.setHeader(_('=== Playable Armor'))
+        log(_('* Armor pieces set as playable: %d') % (sum(count.values()),))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_SWALKNPCAnimationPatcher(CBash_MultiTweakItem):
-    """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Sexy Walk for female NPCs")
+# class CBash_AssortedTweak_ArmorPlayable(CBash_MultiTweakItem):
+#     """Sets all armors to be playable"""
+#     scanOrder = 29 #Run before the show armor tweaks
+#     editOrder = 29
+#     name = _('Playable Armor')
+#     reSkip = re.compile(r'(?:mark)|(?:token)|(?:willful)|(?:see.*me)|(?:werewolf)|(?:no wings)|(?:tsaesci tail)|(?:widget)|(?:dummy)',re.I)
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("All Armor Playable"),
+#             _('Sets all armor to be playable.'),
+#             'PlayableArmor',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['ARMO']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsNonPlayable:
+#             full = record.full
+#             if not full: return
+#             if record.script: return
+#             if self.reSkip.search(full): return #probably truly shouldn't be playable
+#             #If no body flags are set it is probably a token.
+#             if record.IsLeftRing or record.IsRightRing or record.IsFoot or record.IsHand or record.IsAmulet or record.IsLowerBody or record.IsUpperBody or record.IsHead or record.IsHair or record.IsTail or record.IsShield:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.IsNonPlayable = False
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Playable Armor'))
+#         log(_('* Armor pieces set as playable: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_DarnBooks(MultiTweakItem):
+#     """DarNifies books."""
+#     scanOrder = 32
+#     editOrder = 32
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("DarNified Books"),
+#             _('Books will be reformatted for DarN UI.'),
+#             'DarnBooks',
+#             ('default',  'default'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreBook,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreBook,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.BOOK
+#         id_records = patchBlock.id_records
+#         for record in modFile.BOOK.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if not record.enchantment:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         reColor = re.compile(r'<font color="?([a-fA-F0-9]+)"?>',re.I+re.M)
+#         reTagInWord = re.compile(r'([a-z])<font face=1>',re.M)
+#         reFont1 = re.compile(r'(<?<font face=1( ?color=[0-9a-zA]+)?>)+',re.I+re.M)
+#         reDiv = re.compile(r'<div',re.I+re.M)
+#         reFont = re.compile(r'<font',re.I+re.M)
+#         keep = patchFile.getKeeper()
+#         reHead2 = re.compile(r'^(<<|\^\^|>>|)==\s*(\w[^=]+?)==\s*\r\n',re.M)
+#         reHead3 = re.compile(r'^(<<|\^\^|>>|)===\s*(\w[^=]+?)\r\n',re.M)
+#         reBold = re.compile(r'(__|\*\*|~~)')
+#         reAlign = re.compile(r'^(<<|\^\^|>>)',re.M)
+#         align_text = {'^^':'center','<<':'left','>>':'right'}
+#         self.inBold = False
+#         def replaceBold(mo):
+#             self.inBold = not self.inBold
+#             str = '<font face=3 color=%s>' % ('444444','440000')[self.inBold]
+#             return str
+#         def replaceAlign(mo):
+#             return '<div align=%s>' % align_text[mo.group(1)]
+#         for record in patchFile.BOOK.records:
+#             if record.text and not record.enchantment:
+#                 text = record.text
+#                 if reHead2.match(text):
+#                     inBold = False
+#                     text = reHead2.sub(r'\1<font face=1 color=220000>\2<font face=3 color=444444>\r\n',text)
+#                     text = reHead3.sub(r'\1<font face=3 color=220000>\2<font face=3 color=444444>\r\n',text)
+#                     text = reAlign.sub(replaceAlign,text)
+#                     text = reBold.sub(replaceBold,text)
+#                     text = re.sub(r'\r\n',r'<br>\r\n',text)
+#                 else:
+#                     maColor = reColor.search(text)
+#                     if maColor:
+#                         color = maColor.group(1)
+#                     elif record.flags.isScroll:
+#                         color = '000000'
+#                     else:
+#                         color = '444444'
+#                     fontFace = '<font face=3 color='+color+'>'
+#                     text = reTagInWord.sub(r'\1',text)
+#                     text.lower()
+#                     if reDiv.search(text) and not reFont.search(text):
+#                         text = fontFace+text
+#                     else:
+#                         text = reFont1.sub(fontFace,text)
+#                 if text != record.text:
+#                     record.text = text
+#                     keep(record.fid)
+#                     srcMod = record.fid[0]
+#                     count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader('=== '+self.label)
+#         log(_('* Books DarNified: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_DarnBooks(CBash_MultiTweakItem):
+#     """DarNifies books."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Books DarNified')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("DarNified Books"),
+#             _('Books will be reformatted for DarN UI.'),
+#             'DarnBooks',
+#             ('default',  'default'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['BOOK']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         def replaceBold(mo):
+#             self.inBold = not self.inBold
+#             str = '<font face=3 color=%s>' % ('444444','440000')[self.inBold]
+#             return str
+#         def replaceAlign(mo):
+#             return '<div align=%s>' % align_text[mo.group(1)]
+
+#         if record.text and not record.enchantment:
+#             text = record.text
+
+#             reColor = re.compile(r'<font color="?([a-fA-F0-9]+)"?>',re.I+re.M)
+#             reTagInWord = re.compile(r'([a-z])<font face=1>',re.M)
+#             reFont1 = re.compile(r'(<?<font face=1( ?color=[0-9a-zA]+)?>)+',re.I+re.M)
+#             reDiv = re.compile(r'<div',re.I+re.M)
+#             reFont = re.compile(r'<font',re.I+re.M)
+#             reHead2 = re.compile(r'^(<<|\^\^|>>|)==\s*(\w[^=]+?)==\s*\r\n',re.M)
+#             reHead3 = re.compile(r'^(<<|\^\^|>>|)===\s*(\w[^=]+?)\r\n',re.M)
+#             reBold = re.compile(r'(__|\*\*|~~)')
+#             reAlign = re.compile(r'^(<<|\^\^|>>)',re.M)
+#             align_text = {'^^':'center','<<':'left','>>':'right'}
+#             self.inBold = False
+#             if reHead2.match(text):
+#                 text = reHead2.sub(r'\1<font face=1 color=220000>\2<font face=3 color=444444>\r\n',text)
+#                 text = reHead3.sub(r'\1<font face=3 color=220000>\2<font face=3 color=444444>\r\n',text)
+#                 text = reAlign.sub(replaceAlign,text)
+#                 text = reBold.sub(replaceBold,text)
+#                 text = re.sub(r'\r\n',r'<br>\r\n',text)
+#             else:
+#                 maColor = reColor.search(text)
+#                 if maColor:
+#                     color = maColor.group(1)
+#                 elif record.IsScroll:
+#                     color = '000000'
+#                 else:
+#                     color = '444444'
+#                 fontFace = '<font face=3 color='+color+'>'
+#                 text = reTagInWord.sub(r'\1',text)
+#                 text.lower()
+#                 if reDiv.search(text) and not reFont.search(text):
+#                     text = fontFace+text
+#                 else:
+#                     text = reFont1.sub(fontFace,text)
+#             if text != record.text:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.text = text
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.label)
+#         log(_('* Books DarNified: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class AssortedTweak_FogFix(MultiTweakItem):
+    """Fix fog in cell to be non-zero."""
 
     #--Config Phase -----------------------------------------------------------
     def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Sexy Walk for female NPCs"),
-            _("Changes all female NPCs to use Mur Zuk's Sexy Walk - Requires Mur Zuk's Sexy Walk animation file."),
-            'Mur Zuk SWalk',
-            ('1.0',  '1.0'),
+        MultiTweakItem.__init__(self,_("Nvidia Fog Fix"),
+            _('Fix fog related Nvidia black screen problems.'),
+            'FogFix',
+            ('0.0001',  '0.0001'),
             )
-        self.mod_count = {}
-        self.playerFid = (GPath('Oblivion.esm'), 0x000007)
-
-    def getTypes(self):
-        return ['NPC_']
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.fid != self.playerFid: #skip player record
-            if record.IsFemale:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.animations = override.animations + ['0sexywalk01.kf']
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreCell,MreWrld)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* NPCs Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class RWALKNPCAnimationPatcher(BasalNPCTweaker):
-    """Changes all female NPCs to use Mur Zuk's Real Walk."""
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreCell,MreWrld)
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_("Real Walk for female NPCs"),
-            _("Changes all female NPCs to use Mur Zuk's Real Walk - Requires Mur Zuk's Real Walk animation file."),
-            'Mur Zuk RWalk',
-            ('1.0',  '1.0'),
-            )
+    def scanModFile(self, modFile, progress,patchFile):
+        """Add lists from modFile."""
+        if 'CELL' not in modFile.tops: return
+        patchCells = patchFile.CELL
+        modFile.convertToLongFids(('CELL',))
+        for cellBlock in modFile.CELL.cellBlocks:
+            cell = cellBlock.cell
+            if not (cell.fogNear or cell.fogFar or cell.fogClip):
+                patchCells.setCell(cell)
 
     def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
+        """Adds merged lists to patchfile."""
         keep = patchFile.getKeeper()
-        for record in patchFile.NPC_.records:
-            if record.flags.female == 1:
-                record.animations = record.animations + ['0realwalk01.kf']
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
+        count = {}
+        for cellBlock in patchFile.CELL.cellBlocks:
+            for cellBlock in patchFile.CELL.cellBlocks:
+                cell = cellBlock.cell
+                if not (cell.fogNear or cell.fogFar or cell.fogClip):
+                    cell.fogNear = 0.0001
+                    keep(cell.fid)
+                    count.setdefault(cell.fid[0],0)
+                    count[cell.fid[0]] += 1
         #--Log
-        log.setHeader(_('===RWalk for Female NPCs'))
-        log(_('* %d NPCs Tweaked') % (sum(count.values()),))
+        log.setHeader(_('=== Nvidia Fog Fix'))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_RWALKNPCAnimationPatcher(CBash_MultiTweakItem):
-    """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Real Walk for female NPCs")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Real Walk for female NPCs"),
-            _("Changes all female NPCs to use Mur Zuk's Real Walk - Requires Mur Zuk's Real Walk animation file."),
-            'Mur Zuk RWalk',
-            ('1.0',  '1.0'),
-            )
-        self.mod_count = {}
-        self.playerFid = (GPath('Oblivion.esm'), 0x000007)
 
-    def getTypes(self):
-        return ['NPC_']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.fid != self.playerFid: #skip player record
-            if record.IsFemale:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.animations = override.animations + ['0realwalk01.kf']
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+# class CBash_AssortedTweak_FogFix(CBash_MultiTweakItem):
+#     """Fix fog in cell to be non-zero."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Nvidia Fog Fix')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Nvidia Fog Fix"),
+#             _('Fix fog related Nvidia black screen problems.'),
+#             'FogFix',
+#             ('0.0001',  '0.0001'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CELL'] #or 'CELLS' to also affect worldspaces. Don't think it's a problem in those cells though.
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if not (record.fogNear or record.fogFar or record.fogClip):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.fogNear = 0.0001
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Nvidia Fog Fix'))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* NPCs Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
 #------------------------------------------------------------------------------
-class QuietFeetPatcher(BasalCreatureTweaker):
-    """Removes 'foot' sounds from all/specified creatures - like the mod by the same name but works on all modded creatures."""
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_('Quiet Feet'),
-            _("Removes all/some 'foot' sounds from creatures; on some computers can have a significant performance boost."),
-            'silent n sneaky!',
-            (_('All Creature Foot Sounds'), 'all'),
-            (_('Only 4 Legged Creature Foot Sounds'), 'partial'),
-            (_('Only Mount Foot Sounds'), 'mounts'),
-            )
-
-    def buildPatch(self,log,progress,patchFile):
-        """Edits patch file as desired. Will write to log."""
-        count = {}
-        keep = patchFile.getKeeper()
-        chosen = self.choiceValues[self.chosen][0]
-        for record in patchFile.CREA.records:
-            sounds = record.sounds
-            if chosen == 'all':
-                sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
-            elif chosen == 'partial':
-                for sound in record.sounds:
-                    if sound.type in [2,3]:
-                        sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
-                        break
-            else: #really is: "if chosen == 'mounts':", but less cpu to do it as else.
-                if record.creatureType == 4:
-                    sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
-            if sounds != record.sounds:
-                record.sounds = sounds
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===Quite Feet'))
-        log(_('* %d Creatures Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_QuietFeetPatcher(CBash_MultiTweakItem):
-    """Removes 'foot' sounds from all/specified creatures - like the mod by the same name but works on all modded creatures."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Quiet Feet")
+class AssortedTweak_NoLightFlicker(MultiTweakItem):
+    """Remove light flickering for low end machines."""
 
     #--Config Phase -----------------------------------------------------------
     def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_('Quiet Feet'),
-            _("Removes all/some 'foot' sounds from creatures; on some computers can have a significant performance boost."),
-            'silent n sneaky!',
-            (_('All Creature Foot Sounds'), 'all'),
-            (_('Only 4 Legged Creature Foot Sounds'), 'partial'),
-            (_('Only Mount Foot Sounds'), 'mounts'),
+        MultiTweakItem.__init__(self,_("No Light Flicker"),
+            _('Remove flickering from lights. For use on low-end machines.'),
+            'NoLightFlicker',
+            ('1.0',  '1.0'),
             )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CREA']
+        self.flags = flags = MreLigh._flags()
+        flags.flickers = flags.flickerSlow = flags.pulse = flags.pulseSlow = True
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        chosen = self.choiceValues[self.chosen][0]
-        #equality operator not implemented for ObCREARecord.Sound class, so use the list version instead
-        sounds_list = record.sounds_list
-        #0 = IsLeftFoot, 1 = IsRightFoot, 2 = IsLeftBackFoot, 3 = IsRightBackFoot
-        if chosen == 'all':
-            sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
-        elif chosen == 'partial':
-            for sound in record.sounds:
-                if sound.soundType in [2,3]:
-                    sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
-                    break
-        else: ##if chosen == 'mounts':
-            if record.IsHorse:
-                sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
-        if sounds_list != record.sounds_list:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.sounds_list = sounds_list
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreLigh,)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class IrresponsibleCreaturesPatcher(BasalCreatureTweaker):
-    """Sets responsibility to 0 for all/specified creatures - like the mod by the name of Irresponsible Horses but works on all modded creatures."""
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreLigh,)
 
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        MultiTweakItem.__init__(self,_('Irresponsible Creatures'),
-            _("Sets responsibility to 0 for all/specified creatures - so they can't report you for crimes."),
-            'whatbadguarddogs',
-            (_('All Creatures'), 'all'),
-            (_('Only Horses'), 'mounts'),
-            )
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        flickerFlags = self.flags
+        mapper = modFile.getLongMapper()
+        patchRecords = patchFile.LIGH
+        for record in modFile.LIGH.getActiveRecords():
+            if record.flags & flickerFlags:
+                record = record.getTypeCopy(mapper)
+                patchRecords.setRecord(record)
 
     def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
         count = {}
+        flickerFlags = self.flags
+        notFlickerFlags = ~flickerFlags
         keep = patchFile.getKeeper()
-        chosen = self.choiceValues[self.chosen][0]
-        for record in patchFile.CREA.records:
-            if record.responsibility == 0: return
-            if chosen == 'all':
-                record.responsibility = 0
+        for record in patchFile.LIGH.records:
+            if int(record.flags & flickerFlags):
+                record.flags &= notFlickerFlags
                 keep(record.fid)
                 srcMod = record.fid[0]
                 count[srcMod] = count.get(srcMod,0) + 1
-            else: #really is: "if chosen == 'mounts':", but less cpu to do it as else.
-                if record.creatureType == 4:
-                    record.responsibility = 0
-                    keep(record.fid)
-                    srcMod = record.fid[0]
-                    count[srcMod] = count.get(srcMod,0) + 1
-        #--Log
-        log.setHeader(_('===Irresponsible Creatures'))
-        log(_('* %d Creatures Tweaked') % (sum(count.values()),))
-        for srcMod in modInfos.getOrdered(count.keys()):
-            log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_IrresponsibleCreaturesPatcher(CBash_MultiTweakItem):
-    """Sets responsibility to 0 for all/specified creatures - like the mod by the name of Irresponsible Horses but works on all modded creatures."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Irresponsible Creatures")
-
-    #--Config Phase -----------------------------------------------------------
-    def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_('Irresponsible Creatures'),
-            _("Sets responsibility to 0 for all/specified creatures - so they can't report you for crimes."),
-            'whatbadguarddogs',
-            (_('All Creatures'), 'all'),
-            (_('Only Horses'), 'mounts'),
-            )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['CREA']
+        #--Log
+        log.setHeader(_('=== No Light Flicker'))
+        log(_('* Lights unflickered: %d') % (sum(count.values()),))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
 
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.responsibility == 0: return
-        if self.choiceValues[self.chosen][0] == 'mounts' and not record.IsHorse: return
-        override = record.CopyAsOverride(self.patchFile)
-        if override:
-            override.responsibility = 0
-            mod_count = self.mod_count
-            mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-            record.UnloadRecord()
-            record._ModID, record._RecordID = override._ModID, override._RecordID
+# class CBash_AssortedTweak_NoLightFlicker(CBash_MultiTweakItem):
+#     """Remove light flickering for low end machines."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('No Light Flicker')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("No Light Flicker"),
+#             _('Remove flickering from lights. For use on low-end machines.'),
+#             'NoLightFlicker',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['LIGH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if (record.IsFlickers or record.IsFlickerSlow or record.IsPulse or record.IsPulseSlow):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.IsFlickers = False
+#                 override.IsFlickerSlow = False
+#                 override.IsPulse = False
+#                 override.IsPulseSlow = False
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== No Light Flicker'))
+#         log(_('* Lights unflickered: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_PotionWeight(MultiTweakItem):
+#     """Reweighs standard potions down to 0.1."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Reweigh: Potions (Maximum)"),
+#             _('Potion weight will be capped.'),
+#             'MaximumPotionWeight',
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreAlch,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreAlch,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.ALCH
+#         id_records = patchBlock.id_records
+#         for record in modFile.ALCH.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.weight > maxWeight and record.weight < 1:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.ALCH.records:
+#             if record.weight > maxWeight and record.weight < 1 and not ('SEFF',0) in record.getEffects():
+#                 record.weight = maxWeight
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Reweigh: Potions (Maximum)'))
+#         log(_('Potions set to maximum weight of %f') % maxWeight)
+#         log(_('* Potions Reweighed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_PotionWeight(CBash_MultiTweakItem):
+#     """Reweighs standard potions down to 0.1."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Reweigh: Potions (Maximum)")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Reweigh: Potions (Maximum)"),
+#             _('Potion weight will be capped.'),
+#             'MaximumPotionWeight',
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0.0),
+#             )
+#         self.mod_count = {}
+#         self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+
+#     def getTypes(self):
+#         return ['ALCH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         SEFFValue = self.SEFFValue
+#         if (record.weight > maxWeight and record.weight < 1.0):
+#             for effect in record.effects:
+#                 if effect.name == SEFFValue: #name actually returns a UINT32 or MGEFCode
+#                     return
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = maxWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Reweigh: Potions (Maximum)'))
+#         log(_('Potions set to maximum weight of %f') % self.choiceValues[self.chosen][0])
+#         log(_('* Potions Reweighed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_IngredientWeight(MultiTweakItem):
+#     """Reweighs standard ingredients down to 0.1."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Reweigh: Ingredients"),
+#             _('Ingredient weight will be capped.'),
+#             'MaximumIngredientWeight',
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreIngr,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreIngr,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.INGR
+#         id_records = patchBlock.id_records
+#         for record in modFile.INGR.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.weight > maxWeight:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.INGR.records:
+#             if record.weight > maxWeight:
+#                 record.weight = maxWeight
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Reweigh: Ingredients'))
+#         log(_('Ingredients set to maximum weight of %f') % maxWeight)
+#         log(_('* Ingredients Reweighed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_IngredientWeight(CBash_MultiTweakItem):
+#     """Reweighs standard ingredients down to 0.1."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Reweigh: Ingredients')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Reweigh: Ingredients"),
+#             _('Ingredient weight will be capped.'),
+#             'MaximumIngredientWeight',
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0.0),
+#             )
+#         self.mod_count = {}
+#         self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+
+#     def getTypes(self):
+#         return ['INGR']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         SEFFValue = self.SEFFValue
+
+#         if record.weight > maxWeight:
+#             for effect in record.effects:
+#                 if effect.name == SEFFValue: #name actually returns a UINT32 or MGEFCode
+#                     return
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = maxWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Reweigh: Ingredients'))
+#         log(_('Ingredients set to maximum weight of %f') % self.choiceValues[self.chosen][0])
+#         log(_('* Ingredients Reweighed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_PotionWeightMinimum(MultiTweakItem):
+#     """Reweighs any potions up to 4."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Reweigh: Potions (Minimum)"),
+#             _('Potion weight will be floored.'),
+#             'MinimumPotionWeight',
+#             (_('1'),  1),
+#             (_('2'),  2),
+#             (_('3'),  3),
+#             (_('4'),  4),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreAlch,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreAlch,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         minWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.ALCH
+#         id_records = patchBlock.id_records
+#         for record in modFile.ALCH.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.weight < minWeight:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         minWeight = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.ALCH.records:
+#             if record.weight < minWeight:
+#                 record.weight = minWeight
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Reweigh: Potions (Minimum)'))
+#         log(_('Potions set to minimum weight of %f') % minWeight)
+#         log(_('* Potions Reweighed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_PotionWeightMinimum(CBash_MultiTweakItem):
+#     """Reweighs any potions up to 4."""
+#     scanOrder = 33 #Have it run after the max weight for consistent results
+#     editOrder = 33
+#     name = _('Reweigh: Potions (Minimum)')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Reweigh: Potions (Minimum)"),
+#             _('Potion weight will be floored.'),
+#             'MinimumPotionWeight',
+#             (_('1'),  1),
+#             (_('2'),  2),
+#             (_('3'),  3),
+#             (_('4'),  4),
+#             (_('Custom'),0.0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['ALCH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         minWeight = self.choiceValues[self.chosen][0]
+#         if (record.weight < minWeight):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = minWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Reweigh: Potions (Minimum)'))
+#         log(_('Potions set to minimum weight of %f') % self.choiceValues[self.chosen][0])
+#         log(_('* Potions Reweighed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_StaffWeight(MultiTweakItem):
+#     """Reweighs staffs."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Reweigh: Staffs"),
+#             _('Staff weight will be capped.'),
+#             'StaffWeight',
+#             (_('1'),  1),
+#             (_('2'),  2),
+#             (_('3'),  3),
+#             (_('4'),  4),
+#             (_('5'),  5),
+#             (_('6'),  6),
+#             (_('7'),  7),
+#             (_('8'),  8),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreWeap,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreWeap,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.WEAP
+#         id_records = patchBlock.id_records
+#         for record in modFile.WEAP.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.weaponType == 4 and record.weight > maxWeight:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.WEAP.records:
+#             if record.weaponType == 4 and record.weight > maxWeight:
+#                 record.weight = maxWeight
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Reweigh: Staffs'))
+#         log(_('Staffs set to maximum weight of %f') % maxWeight)
+#         log(_('* Staffs Reweighed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_StaffWeight(CBash_MultiTweakItem):
+#     """Reweighs staffs."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Reweigh: Staffs')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Reweigh: Staffs"),
+#             _('Staff weight will be capped.'),
+#             'StaffWeight',
+#             (_('1'),  1.0),
+#             (_('2'),  2.0),
+#             (_('3'),  3.0),
+#             (_('4'),  4.0),
+#             (_('5'),  5.0),
+#             (_('6'),  6.0),
+#             (_('7'),  7.0),
+#             (_('8'),  8.0),
+#             (_('Custom'),0.0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['WEAP']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         maxWeight = self.choiceValues[self.chosen][0]
+
+#         if (record.IsStaff and record.weight > maxWeight):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = maxWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Reweigh: Staffs'))
+#         log(_('Staffs set to maximum weight of %f') % self.choiceValues[self.chosen][0])
+#         log(_('* Staffs Reweighed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_ArrowWeight(MultiTweakItem):
+#     """Reweighs standard arrows down to 0."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Reweigh: Arrows"),
+#             _('Arrow weights will be capped.'),
+#             'MaximumArrowWeight',
+#             (_('0'),    0),
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0.0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreAmmo,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreAmmo,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.AMMO
+#         id_records = patchBlock.id_records
+#         for record in modFile.AMMO.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.weight > maxWeight:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.AMMO.records:
+#             if record.weight > maxWeight:
+#                 record.weight = maxWeight
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Reweigh: Arrows'))
+#         log(_('Arrows set to maximum weight of %f') % maxWeight)
+#         log(_('* Arrows Reweighed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_ArrowWeight(CBash_MultiTweakItem):
+#     """Reweighs standard arrows down to 0.1."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Reweigh: Arrows')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Reweigh: Arrows"),
+#             _('Arrow weights will be capped.'),
+#             'MaximumArrowWeight',
+#             (_('0'), 0.0),
+#             (_('0.1'),  0.1),
+#             (_('0.2'),  0.2),
+#             (_('0.4'),  0.4),
+#             (_('0.6'),  0.6),
+#             (_('Custom'),0.0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['AMMO']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         maxWeight = self.choiceValues[self.chosen][0]
+
+#         if record.weight > maxWeight:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = maxWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Reweigh: Arrows'))
+#         log(_('Arrows set to maximum weight of %f') % self.choiceValues[self.chosen][0])
+#         log(_('* Arrows Reweighed: %d') % (sum(mod_count.values())))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_ScriptEffectSilencer(MultiTweakItem):
+#     """Silences and invisibleates the Script Effect."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Magic: Script Effect Silencer"),
+#             _('Script Effect will be silenced and have no graphics.'),
+#             'SilentScriptEffect',
+#             (_('0'),    0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreMgef,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreMgef,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.MGEF
+#         id_records = patchBlock.id_records
+#         modFile.convertToLongFids(('MGEF',))
+#         for record in modFile.MGEF.getActiveRecords():
+#             fid = record.fid
+#             if not record.longFids: fid = mapper(fid)
+#             if fid in id_records: continue
+#             if record.eid != 'SEFF': continue
+#             patchBlock.setRecord(record.getTypeCopy(mapper))
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         nullRef = (GPath('Oblivion.esm'),0)
+#         silentattrs = {
+#             'model' : None,
+#             'projectileSpeed' : 9999,
+#             'light' : nullRef,
+#             'effectShader' : nullRef,
+#             'enchantEffect' : nullRef,
+#             'castingSound' : nullRef,
+#             'boltSound' : nullRef,
+#             'hitSound' : nullRef,
+#             'areaSound' : nullRef}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.MGEF.records:
+#             if record.eid != 'SEFF' or not record.longFids: continue
+#             record.flags.noHitEffect = True
+#             for attr in silentattrs:
+#                 if getattr(record,attr) != silentattrs[attr]:
+#                     setattr(record,attr,silentattrs[attr])
+#                     keep(record.fid)
+#         #--Log
+#         log.setHeader(_('=== Magic: Script Effect Silencer'))
+#         log(_('Script Effect silenced.'))
+# class CBash_AssortedTweak_ScriptEffectSilencer(CBash_MultiTweakItem):
+#     """Reweighs standard arrows down to 0.1."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Magic: Script Effect Silencer')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Magic: Script Effect Silencer"),
+#              _('Script Effect will be silenced and have no graphics.'),
+#             'SilentScriptEffect',
+#             (_('0'),    0),
+#             )
+#         self.attrs = ['modPath','modb','modt_p','projectileSpeed','light','effectShader',
+#                       'enchantEffect','castingSound','boltSound','hitSound','areaSound',
+#                       'IsNoHitEffect']
+#         self.newValues = [None,None,None,9999,None,None,None,None,None,None,None,True]
+
+#     def getTypes(self):
+#         return ['MGEF']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.eid == 'SEFF':
+#             attrs = self.attrs
+#             newValues = self.newValues
+#             oldValues = map(record.__getattribute__, attrs)
+#             if oldValues != newValues:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     map(override.__setattr__, attrs, newValues)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         log.setHeader(_('=== Magic: Script Effect Silencer'))
+#         log(_('Script Effect silenced.'))
+#------------------------------------------------------------------------------
+# class AssortedTweak_HarvestChance(MultiTweakItem):
+#     """Sets Harvest Chances."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Harvest Chance"),
+#             _('Harvest chances on all plants will be set to the chosen percentage.'),
+#             'HarvestChance',
+#             (_('10%'),  10),
+#             (_('20%'),  20),
+#             (_('30%'),  30),
+#             (_('40%'),  40),
+#             (_('50%'),  50),
+#             (_('60%'),  60),
+#             (_('70%'),  70),
+#             (_('80%'),  80),
+#             (_('90%'),  90),
+#             (_('100%'), 100),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreFlor,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreFlor,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         chance = self.choiceValues[self.chosen][0]
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.FLOR
+#         id_records = patchBlock.id_records
+#         for record in modFile.FLOR.getActiveRecords():
+#             if record.eid.startswith('Nirnroot'): continue #skip Nirnroots
+#             if mapper(record.fid) in id_records: continue
+#             for attr in ['spring','summer','fall','winter']:
+#                 if getattr(record,attr) != chance:
+#                     record = record.getTypeCopy(mapper)
+#                     patchBlock.setRecord(record)
+#                     break
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         chance = self.choiceValues[self.chosen][0]
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.FLOR.records:
+#             record.spring,record.summer,record.fall,record.winter = chance, chance, chance, chance
+#             keep(record.fid)
+#             srcMod = record.fid[0]
+#             count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Harvest Chance'))
+#         log(_('* Harvest Chances Changed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_HarvestChance(CBash_MultiTweakItem):
+#     """Adjust Harvest Chances."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Harvest Chance')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Harvest Chance"),
+#             _('Harvest chances on all plants will be set to the chosen percentage.'),
+#             'HarvestChance',
+#             (_('10%'),  10),
+#             (_('20%'),  20),
+#             (_('30%'),  30),
+#             (_('40%'),  40),
+#             (_('50%'),  50),
+#             (_('60%'),  60),
+#             (_('70%'),  70),
+#             (_('80%'),  80),
+#             (_('90%'),  90),
+#             (_('100%'), 100),
+#             (_('Custom'),0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['FLOR']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         chance = self.choiceValues[self.chosen][0]
+#         if record.eid.startswith('Nirnroot'): return #skip Nirnroots
+#         for attr in ['spring','summer','fall','winter']:
+#             if getattr(record,attr) != chance:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.spring,override.summer,override.fall,override.winter = chance, chance, chance, chance
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+#                 break
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Harvest Chance'))
+#         log(_('* Harvest Chances Changed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
 #------------------------------------------------------------------------------
-class BiggerOrcsandNords(MultiTweakItem):
-    """Adjusts the Orc and Nord race records to be taller/heavier."""
+class AssortedTweak_WindSpeed(MultiTweakItem):
+    """Disables WTHR winds."""
 
     #--Config Phase -----------------------------------------------------------
     def __init__(self):
-        MultiTweakItem.__init__(self,_("Bigger Nords and Orcs"),
-            _('Adjusts the Orc and Nord race records to be taller/heavier - to be more lore friendly.'),
-            'BiggerOrcsandNords',
-            #('Example',(Nordmaleheight,NordFheight,NordMweight,NordFweight,Orcmaleheight,OrcFheight,OrcMweight,OrcFweight))
-            ('Bigger Nords and Orcs', ((1.09,1.09,1.13,1.06),(1.09,1.09,1.13,1.0))),
-            ('MMM Resized Races', ((1.08,1.07,1.28,1.19),(1.09,1.06,1.36,1.3))),
-            ('RBP', ((1.075,1.06,1.20,1.125),(1.06,1.045,1.275,1.18)))
+        MultiTweakItem.__init__(self,_("Disable Wind"),
+            _('Disables the wind on all weathers.'),
+            'windSpeed',
+            (_('Disable'),  0),
             )
 
     #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreRace,)
+        return (MreWthr,)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreRace,)
+        return (MreWthr,)
 
     def scanModFile(self,modFile,progress,patchFile):
         """Scans specified mod file to extract info. May add record to patch mod,
         but won't alter it."""
         mapper = modFile.getLongMapper()
-        patchRecords = patchFile.RACE
-        for record in modFile.RACE.getActiveRecords():
-            if not record.full: continue
-            if not 'orc' in record.full.lower() and not 'nord' in record.full.lower(): continue
-            record = record.getTypeCopy(mapper)
-            patchRecords.setRecord(record)
+        patchBlock = patchFile.WTHR
+        id_records = patchBlock.id_records
+        for record in modFile.WTHR.getActiveRecords():
+            if mapper(record.fid) in id_records: continue
+            if record.windSpeed != 0:
+                record = record.getTypeCopy(mapper)
+                patchBlock.setRecord(record)
 
     def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
         count = {}
         keep = patchFile.getKeeper()
-        for record in patchFile.RACE.records:
-            if not record.full: continue
-            if 'nord' in record.full.lower():
-                for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][0]):
-                    setattr(record,attr,value)
-                keep(record.fid)
-                srcMod = record.fid[0]
-                count[srcMod] = count.get(srcMod,0) + 1
-                continue
-            elif 'orc' in record.full.lower():
-                for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][1]):
-                    setattr(record,attr,value)
+        for record in patchFile.WTHR.records:
+            if record.windSpeed != 0:
+                record.windSpeed = 0
                 keep(record.fid)
                 srcMod = record.fid[0]
                 count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        log.setHeader(_('===Bigger Nords and Orcs'))
-        log(_('* %d Races tweaked.') % (sum(count.values()),))
+        log.setHeader(_('=== Disable Wind'))
+        log(_('* Winds Disabled: %d') % (sum(count.values()),))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_BiggerOrcsandNords(CBash_MultiTweakItem):
-    """Changes all Redguard NPCs texture symmetry for Better Redguard Compatibility."""
-    scanOrder = 32
-    editOrder = 32
-    name = _("Bigger Nords and Orcs")
 
+# class CBash_AssortedTweak_WindSpeed(CBash_MultiTweakItem):
+#     """Disables Weather winds."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Disable Wind')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Disable Wind"),
+#             _('Disables the wind on all weathers.'),
+#             'windSpeed',
+#             (_('Disable'),  0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['WTHR']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.windSpeed != 0:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.windSpeed = 0
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Disable Wind'))
+#         log(_('* Winds Disabled: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class AssortedTweak_SetCastWhenUsedEnchantmentCosts(MultiTweakItem):
+#     """Sets Cast When Used Enchantment number of uses."""
+# #info: 'itemType','chargeAmount','enchantCost'
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Number of uses for pre-enchanted weapons and staffs"),
+#             _('The charge amount and cast cost will be edited so that all enchanted weapons and staffs have the amount of uses specified. Cost will be rounded up to 1 (unless set to unlimited) so number of uses may not exactly match for all weapons.'),
+#             'Number of uses:',
+#             (_('1'), 1),
+#             (_('5'), 5),
+#             (_('10'), 10),
+#             (_('20'), 20),
+#             (_('30'), 30),
+#             (_('40'), 40),
+#             (_('50'), 50),
+#             (_('80'), 80),
+#             (_('100'), 100),
+#             (_('250'), 250),
+#             (_('500'), 500),
+#             (_('Unlimited'), 0),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreEnch,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreEnch,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.ENCH
+#         id_records = patchBlock.id_records
+#         for record in modFile.ENCH.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.itemType in [1,2]:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.ENCH.records:
+#             if record.itemType in [1,2]:
+#                 uses = self.choiceValues[self.chosen][0]
+#                 cost = uses
+#                 if uses != 0:
+#                     cost = max(record.chargeAmount/uses,1)
+#                 record.enchantCost = cost
+#                 record.chargeAmount = cost * uses
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Set Enchantment Number of Uses'))
+#         log(_('* Enchantments set: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_SetCastWhenUsedEnchantmentCosts(CBash_MultiTweakItem):
+#     """Sets Cast When Used Enchantment number of uses."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Set Enchantment Number of Uses')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Number of uses for pre-enchanted weapons and staffs"),
+#             _('The charge amount and cast cost will be edited so that all enchanted weapons and staffs have the amount of uses specified. Cost will be rounded up to 1 (unless set to unlimited) so number of uses may not exactly match for all weapons.'),
+#             'Number of uses:',
+#             (_('1'), 1),
+#             (_('5'), 5),
+#             (_('10'), 10),
+#             (_('20'), 20),
+#             (_('30'), 30),
+#             (_('40'), 40),
+#             (_('50'), 50),
+#             (_('80'), 80),
+#             (_('100'), 100),
+#             (_('250'), 250),
+#             (_('500'), 500),
+#             (_('Unlimited'), 0),
+#             (_('Custom'),0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['ENCH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+
+#         if (record.IsStaff or record.IsWeapon):
+#             uses = self.choiceValues[self.chosen][0]
+#             cost = uses
+#             if uses != 0:
+#                 cost = max(record.chargeAmount/uses,1)
+#             amount = cost * uses
+#             if record.enchantCost != cost or record.chargeAmount != amount:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.enchantCost = cost
+#                     override.chargeAmount = amount
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Set Enchantment Number of Uses'))
+#         log(_('* Enchantments set: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_DefaultIcons(MultiTweakItem):
+#     """Sets a default icon for any records that don't have any icon assigned."""
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         self.activeTypes = ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
+#                             'CLAS','CLOT','FACT','INGR','KEYM','LIGH',
+#                             'MISC','QUST','SGST','SLGM','WEAP']
+#         MultiTweakItem.__init__(self,_("Default Icons"),
+#             _("Sets a default icon for any records that don't have any icon assigned"),
+#             'icons',
+#             (_('1'), 1),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
+#                 MreClas,MreClot,MreFact,MreIngr,MreKeym,MreLigh,
+#                 MreMisc,MreQust,MreSgst,MreSlgm,MreWeap)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
+#                 MreClas,MreClot,MreFact,MreIngr,MreKeym,MreLigh,
+#                 MreMisc,MreQust,MreSgst,MreSlgm,MreWeap)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         for blockType in self.activeTypes:
+#             if blockType not in modFile.tops: continue
+#             modBlock = getattr(modFile,blockType)
+#             patchBlock = getattr(patchFile,blockType)
+#             id_records = patchBlock.id_records
+#             for record in modBlock.getActiveRecords():
+#                 if mapper(record.fid) not in id_records:
+#                     record = record.getTypeCopy(mapper)
+#                     patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for type in self.activeTypes:
+#             if type not in patchFile.tops: continue
+#             for record in patchFile.tops[type].records:
+#                 changed = False
+#                 try:
+#                     if record.icon: continue
+#                 except:
+#                     try:
+#                         if record.maleIcon or record.femaleIcon: continue
+#                         if record.flags.notPlayable: continue
+#                     except: continue
+#                 if type == 'ALCH':
+#                     record.icon = r"Clutter\Potions\IconPotion01.dds"
+#                     changed = True
+#                 elif type == 'AMMO':
+#                     record.icon = r"Weapons\IronArrow.dds"
+#                     changed = True
+#                 elif type == 'APPA':
+#                     record.icon = r"Clutter\IconMortarPestle.dds"
+#                     changed = True
+#                 elif type == 'AMMO':
+#                     record.icon = r"Weapons\IronArrow.dds"
+#                     changed = True
+#                 elif type == 'ARMO':
+#                     #choose based on body flags:
+#                     if record.flags.upperBody != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Cuirass.dds"
+#                         record.femaleIcon = r"Armor\Iron\F\Cuirass.dds"
+#                         changed = True
+#                     elif record.flags.lowerBody != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Greaves.dds"
+#                         record.femaleIcon = r"Armor\Iron\F\Greaves.dds"
+#                         changed = True
+#                     elif record.flags.head != 0 or record.flags.hair != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Helmet.dds"
+#                         changed = True
+#                     elif record.flags.hand != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Gauntlets.dds"
+#                         record.femaleIcon = r"Armor\Iron\F\Gauntlets.dds"
+#                         changed = True
+#                     elif record.flags.foot != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Boots.dds"
+#                         changed = True
+#                     elif record.flags.shield != 0:
+#                         record.maleIcon = r"Armor\Iron\M\Shield.dds"
+#                         changed = True
+#                     else: #Default icon, probably a token or somesuch
+#                         record.maleIcon = r"Armor\Iron\M\Shield.dds"
+#                         changed = True
+#                 elif type in ['BOOK','BSGN','CLAS']: #just a random book icon for class/birthsign as well.
+#                     record.icon = r"Clutter\iconbook%d.dds" % (random.randint(1,13))
+#                     changed = True
+#                 elif type == 'CLOT':
+#                     #choose based on body flags:
+#                     if record.flags.upperBody != 0:
+#                         record.maleIcon = r"Clothes\MiddleClass\01\M\Shirt.dds"
+#                         record.femaleIcon = r"Clothes\MiddleClass\01\F\Shirt.dds"
+#                         changed = True
+#                     elif record.flags.lowerBody != 0:
+#                         record.maleIcon = r"Clothes\MiddleClass\01\M\Pants.dds"
+#                         record.femaleIcon = r"Clothes\MiddleClass\01\F\Pants.dds"
+#                         changed = True
+#                     elif record.flags.head or record.flags.hair:
+#                         record.maleIcon = r"Clothes\MythicDawnrobe\hood.dds"
+#                         changed = True
+#                     elif record.flags.hand != 0:
+#                         record.maleIcon = r"Clothes\LowerClass\Jail\M\JailShirtHandcuff.dds"
+#                         changed = True
+#                     elif record.flags.foot != 0:
+#                         record.maleIcon = r"Clothes\MiddleClass\01\M\Shoes.dds"
+#                         record.femaleIcon = r"Clothes\MiddleClass\01\F\Shoes.dds"
+#                         changed = True
+#                     elif record.flags.leftRing or record.flags.rightRing:
+#                         record.maleIcon = r"Clothes\Ring\RingNovice.dds"
+#                         changed = True
+#                     else: #amulet
+#                         record.maleIcon = r"Clothes\Amulet\AmuletSilver.dds"
+#                         changed = True
+#                 elif type == 'FACT':
+#                     #todo
+#                     changed = True
+#                 elif type == 'INGR':
+#                     record.icon = r"Clutter\IconSeeds.dds"
+#                     changed = True
+#                 elif type == 'KEYM':
+#                     record.icon = [r"Clutter\Key\Key.dds",r"Clutter\Key\Key02.dds"][random.randint(0,1)]
+#                     changed = True
+#                 elif type == 'LIGH':
+#                     record.icon = r"Lights\IconTorch02.dds"
+#                     changed = True
+#                 elif type == 'MISC':
+#                     record.icon = r"Clutter\Soulgems\AzurasStar.dds"
+#                     changed = True
+#                 elif type == 'QUST':
+#                     if not record.stages: continue
+#                     record.icon = r"Quest\icon_miscellaneous.dds"
+#                     changed = True
+#                 elif type == 'SGST':
+#                     record.icon = r"IconSigilStone.dds"
+#                     changed = True
+#                 elif type == 'SLGM':
+#                     record.icon = r"Clutter\Soulgems\AzurasStar.dds"
+#                     changed = True
+#                 elif type == 'WEAP':
+#                     if record.type == 0:
+#                         record.icon = r"Weapons\IronDagger.dds"
+#                     elif record.type == 1:
+#                         record.icon = r"Weapons\IronClaymore.dds"
+#                     elif record.type == 2:
+#                         record.icon = r"Weapons\IronMace.dds"
+#                     elif record.type == 3:
+#                         record.icon = r"Weapons\IronBattleAxe.dds"
+#                     elif record.type == 4:
+#                         record.icon = r"Weapons\Staff.dds"
+#                     elif record.type == 5:
+#                         record.icon = r"Weapons\IronBow.dds"
+#                     else: #Should never reach this point
+#                         record.icon = r"Weapons\IronDagger.dds"
+#                     changed = True
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log(_('* %s: %d') % (self.label,sum(count.values())))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_DefaultIcons(CBash_MultiTweakItem):
+#     """Sets a default icon for any records that don't have any icon assigned."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Default Icons')
+#     type_defaultIcon = {
+#                 'ALCH': r"Clutter\Potions\IconPotion01.dds",
+#                 'AMMO': r"Weapons\IronArrow.dds",
+#                 'APPA': r"Clutter\IconMortarPestle.dds",
+#                 'AMMO': r"Weapons\IronArrow.dds",
+#                 'ARMO': ((r"Armor\Iron\M\Cuirass.dds",r"Armor\Iron\F\Cuirass.dds"),
+#                          (r"Armor\Iron\M\Greaves.dds",r"Armor\Iron\F\Greaves.dds"),
+#                          (r"Armor\Iron\M\Helmet.dds",),
+#                          (r"Armor\Iron\M\Gauntlets.dds",r"Armor\Iron\F\Gauntlets.dds"),
+#                          (r"Armor\Iron\M\Boots.dds",),
+#                          (r"Armor\Iron\M\Shield.dds",),
+#                          (r"Armor\Iron\M\Shield.dds",), #Default Armor icon
+#                          ),
+#                 'BOOK': r"Clutter\iconbook%d.dds",
+#                 'BSGN': r"Clutter\iconbook%d.dds",
+#                 'CLAS': r"Clutter\iconbook%d.dds",
+#                 'CLOT': ((r"Clothes\MiddleClass\01\M\Shirt.dds",r"Clothes\MiddleClass\01\F\Shirt.dds"),
+#                          (r"Clothes\MiddleClass\01\M\Pants.dds",r"Clothes\MiddleClass\01\F\Pants.dds"),
+#                          (r"Clothes\MythicDawnrobe\hood.dds",),
+#                          (r"Clothes\LowerClass\Jail\M\JailShirtHandcuff.dds",),
+#                          (r"Clothes\MiddleClass\01\M\Shoes.dds",r"Clothes\MiddleClass\01\F\Shoes.dds"),
+#                          (r"Clothes\Ring\RingNovice.dds",),
+#                          (r"Clothes\Amulet\AmuletSilver.dds",),
+#                          ),
+# ##                'FACT': r"", ToDo
+#                 'INGR': r"Clutter\IconSeeds.dds",
+#                 'KEYM': (r"Clutter\Key\Key.dds",r"Clutter\Key\Key02.dds"),
+#                 'LIGH': r"Lights\IconTorch02.dds",
+#                 'MISC': r"Clutter\Soulgems\AzurasStar.dds",
+#                 'QUST': r"Quest\icon_miscellaneous.dds",
+#                 'SGST': r"IconSigilStone.dds",
+#                 'SLGM': r"Clutter\Soulgems\AzurasStar.dds",
+#                 'WEAP': (r"Weapons\IronDagger.dds",
+#                          r"Weapons\IronClaymore.dds",
+#                          r"Weapons\IronMace.dds",
+#                          r"Weapons\IronBattleAxe.dds",
+#                          r"Weapons\Staff.dds",
+#                          r"Weapons\IronBow.dds",
+#                          ),
+#                 }
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Default Icons"),
+#             _("Sets a default icon for any records that don't have any icon assigned"),
+#             'icons',
+#             (_('1'), 1),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return [_type for _type in self.type_defaultIcon.keys()]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if getattr(record, 'iconPath', None): return
+#         if getattr(record, 'maleIconPath', None): return
+#         if getattr(record, 'femaleIconPath', None): return
+#         if record._Type == 'LIGH' and not record.IsCanTake: return
+#         if record._Type == 'QUST' and not record.stages: return
+#         if record._Type in ['ARMO','CLOT'] and not record.IsPlayable: return
+
+#         override = record.CopyAsOverride(self.patchFile)
+#         if override:
+#             icons = self.type_defaultIcon[override._Type]
+#             if isinstance(icons, tuple):
+#                 if override._Type == 'ARMO':
+#                     #choose based on body flags:
+#                     if override.IsUpperBody:
+#                         icons = icons[0]
+#                     elif override.IsLowerBody:
+#                         icons = icons[1]
+#                     elif override.IsHead or record.IsHair:
+#                         icons = icons[2]
+#                     elif override.IsHand:
+#                         icons = icons[3]
+#                     elif override.IsFoot:
+#                         icons = icons[4]
+#                     elif override.IsShield:
+#                         icons = icons[5]
+#                     else: #default icon, probably a token or somesuch
+#                         icons = icons[6]
+#                 elif override._Type == 'CLOT':
+#                     #choose based on body flags:
+#                     if override.IsUpperBody:
+#                         icons = icons[0]
+#                     elif override.IsLowerBody:
+#                         icons = icons[1]
+#                     elif override.IsHead or record.IsHair:
+#                         icons = icons[2]
+#                     elif override.IsHand:
+#                         icons = icons[3]
+#                     elif override.IsFoot:
+#                         icons = icons[4]
+#                     elif override.IsLeftRing or override.IsRightRing:
+#                         icons = icons[5]
+#                     else:
+#                         icons = icons[6]
+#                 elif override._Type == 'KEYM':
+#                     icons = icons[random.randint(0,1)]
+#                 elif override._Type == 'WEAP':
+#                     #choose based on weapon type:
+#                     try:
+#                         icons = icons[override.weaponType]
+#                     except IndexError: #just in case
+#                         icons = icons[0]
+#             else:
+#                 if override._Type in ['BOOK','BSGN','CLAS']: #just a random book icon for class/birthsign as well.
+#                     icons = icons % (random.randint(1,13))
+
+#             try:
+#                 if isinstance(icons, tuple):
+#                     if len(icons) == 1:
+#                         override.maleIconPath = icons[0]
+#                     else:
+#                         override.maleIconPath, override.femaleIconPath = icons
+#                 else:
+#                     override.iconPath = icons
+#             except ValueError, error:
+#                 print override._Type
+#                 print icons
+#                 print error
+#                 print self.patchFile.ObCollection.Debug_DumpModFiles()
+#                 raise error
+#             mod_count = self.mod_count
+#             mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#             record.UnloadRecord()
+#             record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Default Icons'))
+#         log(_('* Default Icons set: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+class AssortedTweak_SetSoundAttenuationLevels(MultiTweakItem):
+    """Sets Cast When Used Enchantment number of uses."""
     #--Config Phase -----------------------------------------------------------
     def __init__(self):
-        CBash_MultiTweakItem.__init__(self,_("Bigger Nords and Orcs"),
-            _('Adjusts the Orc and Nord race records to be taller/heavier - to be more lore friendly.'),
-            'BiggerOrcsand Nords',
-            #('Example',(Nordmaleheight,NordFheight,NordMweight,NordFweight,Orcmaleheight,OrcFheight,OrcMweight,OrcFweight))
-            ('Bigger Nords and Orcs', ((1.09,1.09,1.13,1.06),(1.09,1.09,1.13,1.0))),
-            ('MMM Resized Races', ((1.08,1.07,1.28,1.19),(1.09,1.06,1.36,1.3))),
-            ('RBP', ((1.075,1.06,1.20,1.125),(1.06,1.045,1.275,1.18)))
+        MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels"),
+            _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume.'),
+            'Attenuation%:',
+            (_('0%'), 0),
+            (_('5%'), 5),
+            (_('10%'), 10),
+            (_('20%'), 20),
+            (_('50%'), 50),
+            (_('80%'), 80),
+            (_('Custom'),0),
             )
-        self.mod_count = {}
-
-    def getTypes(self):
-        return ['RACE']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if not record.full: return
-        if 'nord' in record.full.lower():
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][0]):
-                    setattr(override,attr,value)
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-                return
-        elif 'orc' in record.full.lower():
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][1]):
-                    setattr(override,attr,value)
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-                return
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('=== '+self.__class__.name)
-        log(_('* Races tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-#------------------------------------------------------------------------------
-class TweakActors(MultiTweaker):
-    """Sets Creature stuff or NPC Skeletons, Animations or other settings to better work with mods or avoid bugs."""
-    name = _('Tweak Actors')
-    text = _("Tweak NPC and Creatures records in specified ways.")
-    tweaks = sorted([
-        VORB_NPCSkeletonPatcher(),
-        MAONPCSkeletonPatcher(),
-        VanillaNPCSkeletonPatcher(),
-        RedguardNPCPatcher(),
-        NoBloodCreaturesPatcher(),
-        AsIntendedImpsPatcher(),
-        AsIntendedBoarsPatcher(),
-        QuietFeetPatcher(),
-        IrresponsibleCreaturesPatcher(),
-        BiggerOrcsandNords(),
-        RWALKNPCAnimationPatcher(),
-        SWALKNPCAnimationPatcher(),
-        ],key=lambda a: a.label.lower())
 
     #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        if not self.isActive: return None
-        classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
+        return (MreSoun,)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        if not self.isActive: return None
-        classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
-        return sum(classTuples,tuple())
+        return (MreSoun,)
 
-    def scanModFile(self,modFile,progress):
+    def scanModFile(self,modFile,progress,patchFile):
         """Scans specified mod file to extract info. May add record to patch mod,
         but won't alter it."""
-        if not self.isActive: return
-        for tweak in self.enabledTweaks:
-            tweak.scanModFile(modFile,progress,self.patchFile)
-
-    def buildPatch(self,log,progress):
-        """Applies individual tweaks."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatch(log,progress,self.patchFile)
-
+        mapper = modFile.getLongMapper()
+        patchBlock = patchFile.SOUN
+        id_records = patchBlock.id_records
+        for record in modFile.SOUN.getActiveRecords():
+            if mapper(record.fid) in id_records: continue
+            if record.staticAtten:
+                record = record.getTypeCopy(mapper)
+                patchBlock.setRecord(record)
 
-class CBash_TweakActors(CBash_MultiTweaker):
-    """Sets Creature stuff or NPC Skeletons, Animations or other settings to better work with mods or avoid bugs."""
-    name = _('Tweak Actors')
-    text = _("Tweak NPC and Creatures records in specified ways.")
-    tweaks = sorted([
-        CBash_VORB_NPCSkeletonPatcher(),
-        CBash_MAONPCSkeletonPatcher(),
-        CBash_VanillaNPCSkeletonPatcher(),
-        CBash_RedguardNPCPatcher(),
-        CBash_NoBloodCreaturesPatcher(),
-        CBash_AsIntendedImpsPatcher(),
-        CBash_AsIntendedBoarsPatcher(),
-        CBash_QuietFeetPatcher(),
-        CBash_IrresponsibleCreaturesPatcher(),
-        CBash_BiggerOrcsandNords(),
-        CBash_RWALKNPCAnimationPatcher(),
-        CBash_SWALKNPCAnimationPatcher(),
-        ],key=lambda a: a.label.lower())
-    #--Config Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        for tweak in self.tweaks:
-            tweak.patchFile = patchFile
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        count = {}
+        keep = patchFile.getKeeper()
+        for record in patchFile.SOUN.records:
+            if record.staticAtten:
+                record.staticAtten = record.staticAtten*self.choiceValues[self.chosen][0]/100
+                keep(record.fid)
+                srcMod = record.fid[0]
+                count[srcMod] = count.get(srcMod,0) + 1
+        #--Log
+        log.setHeader(_('=== Set Sound Attenuation Levels'))
+        log(_('* Sounds Modified: %d') % (sum(count.values()),))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
 
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        log.setHeader('= '+self.__class__.name,True)
-        for tweak in self.enabledTweaks:
-            tweak.buildPatchLog(log)
-# Patchers: 40 ----------------------------------------------------------------
-class SpecialPatcher:
-    """Provides default group, scan and edit orders."""
-    group = _('Special')
-    scanOrder = 40
-    editOrder = 40
+# class CBash_AssortedTweak_SetSoundAttenuationLevels(CBash_MultiTweakItem):
+#     """Sets Cast When Used Enchantment number of uses."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Set Sound Attenuation Levels')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels"),
+#             _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume.'),
+#             'Attenuation%:',
+#             (_('0%'), 0),
+#             (_('5%'), 5),
+#             (_('10%'), 10),
+#             (_('20%'), 20),
+#             (_('50%'), 50),
+#             (_('80%'), 80),
+#             (_('Custom'),0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['SOUN']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+
+#         if record.staticAtten:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                     override.staticAtten = override.staticAtten*self.choiceValues[self.chosen][0]/100
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Set Sound Attenuation Levels'))
+#         log(_('* Sounds modified: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(MultiTweakItem):
+#     """Sets Cast When Used Enchantment number of uses."""
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels: Nirnroots Only"),
+#             _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume. This one only affects Nirnroots.'),
+#             'Nirnroot Attenuation%:',
+#             (_('0%'), 0),
+#             (_('5%'), 5),
+#             (_('10%'), 10),
+#             (_('20%'), 20),
+#             (_('50%'), 50),
+#             (_('80%'), 80),
+#             (_('Custom'),0),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreSoun,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreSoun,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.SOUN
+#         id_records = patchBlock.id_records
+#         for record in modFile.SOUN.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.staticAtten and 'nirnroot' in record.eid.lower():
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.SOUN.records:
+#             if record.staticAtten and 'nirnroot' in record.eid.lower():
+#                 record.staticAtten = record.staticAtten*self.choiceValues[self.chosen][0]/100
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Set Sound Attenuation Levels: Nirnroots Only'))
+#         log(_('* Sounds Modified: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(CBash_MultiTweakItem):
+#     """Sets Cast When Used Enchantment number of uses."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Set Sound Attenuation Levels: Nirnroots Only')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Set Sound Attenuation Levels: Nirnroots Only"),
+#             _('The sound attenution levels will be set to tweak%*current level, thereby increasing (or decreasing) the sound volume. This one only affects Nirnroots.'),
+#             'Nirnroot Attenuation%:',
+#             (_('0%'), 0),
+#             (_('5%'), 5),
+#             (_('10%'), 10),
+#             (_('20%'), 20),
+#             (_('50%'), 50),
+#             (_('80%'), 80),
+#             (_('Custom'),0),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['SOUN']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+
+#         if record.staticAtten and 'nirnroot' in record.eid.lower() :
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                     override.staticAtten = override.staticAtten*self.choiceValues[self.chosen][0]/100
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Set Sound Attenuation Levels: Nirnroots Only'))
+#         log(_('* Sounds modified: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AssortedTweak_FactioncrimeGoldMultiplier(MultiTweakItem):
+#     """Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Faction crime Gold Multiplier Fix"),
+#             _('Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0.'),
+#             'FactioncrimeGoldMultiplier',
+#             ('1.0',  '1.0'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreFact,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreFact,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.FACT
+#         for record in modFile.FACT.getActiveRecords():
+#             if not isinstance(record.crimeGoldMultiplier,float):
+#                 record = record.getTypeCopy(mapper)
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.FACT.records:
+#             if not isinstance(record.crimeGoldMultiplier,float):
+#                 record.crimeGoldMultiplier = 1.0
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('=== Faction crime Gold Multiplier Fix'))
+#         log(_('* Factions fixed: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AssortedTweak_FactioncrimeGoldMultiplier(CBash_MultiTweakItem):
+#     """Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Faction crime Gold Multiplier Fix')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Faction crime Gold Multiplier Fix"),
+#             _('Fix factions with unset crimeGoldMultiplier to have a crimeGoldMultiplier of 1.0.'),
+#             'FactioncrimeGoldMultiplier',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['FACT']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if not isinstance(record.crimeGoldMultiplier,float):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.crimeGoldMultiplier = 1.0
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== Faction crime Gold Multiplier Fix'))
+#         log(_('* Factions fixed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.count = {}
 
 #------------------------------------------------------------------------------
-class AlchemicalCatalogs(SpecialPatcher,Patcher):
-    """Updates COBL alchemical catalogs."""
-    name = _('Cobl Catalogs')
-    text = _("Update COBL's catalogs of alchemical ingredients and effects.\n\nWill only run if Cobl Main.esm is loaded.")
+class AssortedTweak_LightFadeValueFix(MultiTweakItem):
+    """Sets light fade value when not set to 1.0."""
 
     #--Config Phase -----------------------------------------------------------
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = (GPath('COBL Main.esm') in loadMods)
-        self.id_ingred = {}
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("No Light Fade Value Fix"),
+            _("Sets Light's Fade values to default of 1.0 if not set."),
+            'NoLightFadeValueFix',
+            ('1.0',  '1.0'),
+            )
 
+    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        if not self.isActive: return tuple()
-        return (MreIngr,)
+        return (MreLigh,)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        if not self.isActive: return tuple()
-        return (MreBook,)
+        return (MreLigh,)
 
-    def scanModFile(self,modFile,progress):
+    def scanModFile(self,modFile,progress,patchFile):
         """Scans specified mod file to extract info. May add record to patch mod,
         but won't alter it."""
-        if not self.isActive: return
-        id_ingred = self.id_ingred
         mapper = modFile.getLongMapper()
-        for record in modFile.INGR.getActiveRecords():
-            if not record.full: continue #--Ingredient must have name!
-            effects = record.getEffects()
-            if not ('SEFF',0) in effects:
-                id_ingred[mapper(record.fid)] = (record.eid, record.full, effects)
+        patchRecords = patchFile.LIGH
+        for record in modFile.LIGH.getActiveRecords():
+            if not isinstance(record.fade,float):
+                record = record.getTypeCopy(mapper)
+                patchRecords.setRecord(record)
 
-    def buildPatch(self,log,progress):
+    def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
-        if not self.isActive: return
-        #--Setup
-        mgef_name = self.patchFile.getMgefName()
-        for mgef in mgef_name:
-            mgef_name[mgef] = re.sub(_('(Attribute|Skill)'),'',mgef_name[mgef])
-        actorEffects = bush.genericAVEffects
-        actorNames = bush.actorValues
-        keep = self.patchFile.getKeeper()
-        #--Book generatator
-        def getBook(objectId,eid,full,value,iconPath,modelPath,modb_p):
-            book = MreBook(('BOOK',0,0,0,0))
-            book.longFids = True
-            book.changed = True
-            book.eid = eid
-            book.full = Encode(full, 'mbcs')
-            book.value = value
-            book.weight = 0.2
-            book.fid = keep((GPath('Cobl Main.esm'),objectId))
-            book.text = '<div align="left"><font face=3 color=4444>'
-            book.text += Encode(_("Salan's Catalog of %s\r\n\r\n") % full, 'mbcs')
-            book.iconPath = iconPath
-            book.model = book.getDefault('model')
-            book.model.modPath = modelPath
-            book.model.modb_p = modb_p
-            book.modb = book
-            self.patchFile.BOOK.setRecord(book)
-            return book
-        #--Ingredients Catalog
-        id_ingred = self.id_ingred
-        iconPath,modPath,modb_p = ('Clutter\IconBook9.dds','Clutter\Books\Octavo02.NIF','\x03>@A')
-        for (num,objectId,full,value) in bush.ingred_alchem:
-            book = getBook(objectId,'cobCatAlchemIngreds'+`num`,full,value,iconPath,modPath,modb_p)
-            buff = stringBuffer()
-            buff.write(book.text)
-            for eid,full,effects in sorted(id_ingred.values(),key=lambda a: a[1].lower()):
-                buff.write(full+'\r\n')
-                for mgef,actorValue in effects[:num]:
-                    effectName = Encode(mgef_name[mgef],'mbcs')
-                    if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
-                    buff.write('  '+effectName+'\r\n')
-                buff.write('\r\n')
-            book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
-        #--Get Ingredients by Effect
-        effect_ingred = {}
-        for fid,(eid,full,effects) in id_ingred.iteritems():
-            for index,(mgef,actorValue) in enumerate(effects):
-                effectName = Encode(mgef_name[mgef],'mbcs')
-                if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
-                if effectName not in effect_ingred: effect_ingred[effectName] = []
-                effect_ingred[effectName].append((index,full))
-        #--Effect catalogs
-        iconPath,modPath,modb_p = ('Clutter\IconBook7.dds','Clutter\Books\Octavo01.NIF','\x03>@A')
-        for (num,objectId,full,value) in bush.effect_alchem:
-            book = getBook(objectId,'cobCatAlchemEffects'+`num`,full,value,iconPath,modPath,modb_p)
-            buff = stringBuffer()
-            buff.write(book.text)
-            for effectName in sorted(effect_ingred.keys()):
-                effects = [indexFull for indexFull in effect_ingred[effectName] if indexFull[0] < num]
-                if effects:
-                    buff.write(effectName+'\r\n')
-                    for (index,full) in sorted(effects,key=lambda a: a[1].lower()):
-                        exSpace = ('',' ')[index == 0]
-                        buff.write(' '+`index + 1`+exSpace+' '+full+'\r\n')
-                    buff.write('\r\n')
-            book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
+        count = {}
+        keep = patchFile.getKeeper()
+        for record in patchFile.LIGH.records:
+            if not isinstance(record.fade,float):
+                record.fade = 1.0
+                keep(record.fid)
+                srcMod = record.fid[0]
+                count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        log.setHeader('= '+self.__class__.name)
-        log(_('* Ingredients Cataloged: %d') % (len(id_ingred),))
-        log(_('* Effects Cataloged: %d') % (len(effect_ingred)))
+        log.setHeader(_('=== No Light Fade Value Fix'))
+        log(_('* Lights with fade values added: %d') % (sum(count.values()),))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
 
-class CBash_AlchemicalCatalogs(SpecialPatcher,CBash_Patcher):
-    """Updates COBL alchemical catalogs."""
-    name = _('Cobl Catalogs')
-    text = _("Update COBL's catalogs of alchemical ingredients and effects.\n\nWill only run if Cobl Main.esm is loaded.")
-    unloadedText = ""
-    srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
+# class CBash_AssortedTweak_LightFadeValueFix(CBash_MultiTweakItem):
+#     """Remove light flickering for low end machines."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('No Light Fade Value Fix')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("No Light Fade Value Fix"),
+#             _("Sets Light's Fade values to default of 1.0 if not set."),
+#             'NoLightFadeValueFix',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['LIGH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if not isinstance(record.fade,float):
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.fade = 1.0
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader(_('=== No Light Fade Value Fix'))
+#         log(_('* Lights with fade values added: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+class AssortedTweak_GunsUseISAnimation(MultiTweakItem):
+    """Set all guns to use ironsight animation."""
 
     #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = GPath('Cobl Main.esm') in loadMods
-        if not self.isActive: return
-        patchFile.indexMGEFs = True
-        self.id_ingred = {}
-        self.effect_ingred = {}
-        self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
-        self.DebugPrintOnce = 0
-
-    def getTypes(self):
-        return ['INGR']
-
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if (record.full):
-            SEFFValue = self.SEFFValue
-            for effect in record.effects:
-                if effect.name == SEFFValue:
-                    return
-            self.id_ingred[record.fid] = (record.eid, record.full, record.effects_list)
-
-    def finishPatch(self,patchFile,progress):
-        """Edits the bashed patch file directly."""
-        subProgress = SubProgress(progress)
-        subProgress.setFull(len(bush.effect_alchem) + len(bush.ingred_alchem))
-        pstate = 0
-        #--Setup
-        try:
-            coblMod = patchFile.ObCollection.LookupModFile('Cobl Main.esm')
-        except KeyError, error:
-            print "CBash_AlchemicalCatalogs:finishPatch"
-            print error[0]
-            return
-
-        mgef_name = patchFile.mgef_name.copy()
-        for mgef in mgef_name:
-            mgef_name[mgef] = re.sub(_('(Attribute|Skill)'),'',mgef_name[mgef])
-        actorEffects = bush.genericAVEffects
-        actorNames = bush.actorValues
-        #--Book generator
-        def getBook(patchFile, objectId):
-            book = coblMod.LookupRecord((GPath('Cobl Main.esm'),objectId))
-            #There have been reports of this patcher failing, hence the sanity checks
-            if book:
-                if book.recType != 'BOOK':
-                    print PrintFormID(fid)
-                    print patchFile.ObCollection.Debug_DumpModFiles()
-                    print book
-                    raise StateError(_("Cobl Catalogs: Unable to lookup book record in Cobl Main.esm!"))
-                book = book.CopyAsOverride(self.patchFile)
-                if not book:
-                    print PrintFormID(fid)
-                    print patchFile.ObCollection.Debug_DumpModFiles()
-                    print book
-                    book = coblMod.LookupRecord((GPath('Cobl Main.esm'),objectId))
-                    print book
-                    print book.text
-                    print
-                    raise StateError(_("Cobl Catalogs: Unable to create book!"))
-            return book
-        #--Ingredients Catalog
-        id_ingred = self.id_ingred
-        for (num,objectId,full,value) in bush.ingred_alchem:
-            subProgress(pstate, _("Cataloging Ingredients...\n%s") % full)
-            pstate += 1
-            book = getBook(patchFile, objectId)
-            if not book: continue
-            buff = stringBuffer()
-            buff.write('<div align="left"><font face=3 color=4444>' + Encode(_("Salan's Catalog of %s\r\n\r\n") % full,'mbcs'))
-            for eid,full,effects_list in sorted(id_ingred.values(),key=lambda a: a[1].lower()):
-                buff.write(Encode(full,'mbcs')+'\r\n')
-                for effect in effects_list[:num]:
-                    mgef = effect[0] #name field
-                    try:
-                        effectName = mgef_name[mgef]
-                    except KeyError:
-                        if not self.DebugPrintOnce:
-                            self.DebugPrintOnce = 1
-                            deprint(patchFile.ObCollection.Debug_DumpModFiles())
-                            deprint()
-                            deprint('mgef_name:', mgef_name)
-                            deprint()
-                            deprint('mgef:', mgef)
-                            deprint()
-                        if mgef in bush.mgef_name:
-                            deprint('mgef found in bush.mgef_name')
-                            effectName = re.sub(_('(Attribute|Skill)'),'',bush.mgef_name[mgef])
-                        else:
-                            deprint('mgef not found in bush.mgef_name')
-                            effectName = 'Unknown Effect'
-                    effectName = Encode(effectName,'mbcs')
-                    if mgef in actorEffects: effectName += Encode(actorNames[effect[5]],'mbcs') #actorValue field
-                    buff.write('  '+effectName+'\r\n')
-                buff.write('\r\n')
-            book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
-        #--Get Ingredients by Effect
-        effect_ingred = self.effect_ingred = {}
-        for fid,(eid,full,effects_list) in id_ingred.iteritems():
-            for index,effect in enumerate(effects_list):
-                mgef, actorValue = effect[0], effect[5]
-                try:
-                    effectName = mgef_name[mgef]
-                except KeyError:
-                    if not self.DebugPrintOnce:
-                        self.DebugPrintOnce = 1
-                        deprint(patchFile.ObCollection.Debug_DumpModFiles())
-                        deprint()
-                        deprint(mgef_name)
-                        deprint()
-                    if mgef in bush.mgef_name:
-                        deprint('mgef found in bush.mgef_name')
-                        effectName = re.sub(_('(Attribute|Skill)'),'',bush.mgef_name[mgef])
-                    else:
-                        deprint('mgef not found in bush.mgef_name')
-                        effectName = 'Unknown Effect'
-                effectName = Encode(effectName,'mbcs')
-                if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
-                effect_ingred.setdefault(effectName, []).append((index,full))
-        #--Effect catalogs
-        for (num,objectId,full,value) in bush.effect_alchem:
-            subProgress(pstate, _("Cataloging Effects...\n%s") % full)
-            book = getBook(patchFile,objectId)
-            buff = stringBuffer()
-            buff.write('<div align="left"><font face=3 color=4444>' + Encode(_("Salan's Catalog of %s\r\n\r\n") % full, 'mbcs'))
-            for effectName in sorted(effect_ingred.keys()):
-                effects = [indexFull for indexFull in effect_ingred[effectName] if indexFull[0] < num]
-                if effects:
-                    buff.write(effectName+'\r\n')
-                    for (index,full) in sorted(effects,key=lambda a: a[1].lower()):
-                        exSpace = ('',' ')[index == 0]
-                        buff.write(' '+`index + 1`+exSpace+' '+full+'\r\n')
-                    buff.write('\r\n')
-            book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
-            pstate += 1
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        id_ingred = self.id_ingred
-        effect_ingred = self.effect_ingred
-        log.setHeader('= '+self.__class__.name)
-        log(_('* Ingredients Cataloged: %d') % (len(id_ingred),))
-        log(_('* Effects Cataloged: %d') % (len(effect_ingred)))
-#------------------------------------------------------------------------------
-class CoblExhaustion(SpecialPatcher,ListPatcher):
-    """Modifies most Greater power to work with Cobl's power exhaustion feature."""
-    name = _('Cobl Exhaustion')
-    text = _("Modify greater powers to use Cobl's Power Exhaustion feature.\n\nWill only run if Cobl Main v1.66 (or higher) is active.")
-    autoKey = 'Exhaust'
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("All Guns Use Ironsight Animation"),
+            _('Remove "Don\'t use 1st person IS animation" flag from all guns.'),
+            'GunsUseIronSight',
+            ('1.0',  '1.0'),
+            )
 
-    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.cobl = GPath('Cobl Main.esm')
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles) and (self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.65)
-        self.id_exhaustion = {}
-
-    def readFromText(self,textPath):
-        """Imports type_id_name from specified text file."""
-        aliases = self.patchFile.aliases
-        id_exhaustion = self.id_exhaustion
-        textPath = GPath(textPath)
-        ins = bolt.CsvReader(textPath)
-        reNum = re.compile(r'\d+')
-        for fields in ins:
-            if len(fields) < 4 or fields[1][:2] != '0x' or not reNum.match(fields[3]): continue
-            mod,objectIndex,eid,time = fields[:4]
-            mod = GPath(mod)
-            longid = (aliases.get(mod,mod),int(objectIndex[2:],16))
-            id_exhaustion[longid] = int(time)
-        ins.close()
-
-    def initData(self,progress):
-        """Get names from source files."""
-        if not self.isActive: return
-        progress.setFull(len(self.srcFiles))
-        for srcFile in self.srcFiles:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if srcPath not in patchesDir: continue
-            self.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        if not self.isActive: return tuple()
-        return (MreSpel,)
+        return (MreWeap,)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        if not self.isActive: return tuple()
-        return (MreSpel,)
+        return (MreWeap,)
 
-    def scanModFile(self,modFile,progress):
+    def scanModFile(self,modFile,progress,patchFile):
         """Scans specified mod file to extract info. May add record to patch mod,
         but won't alter it."""
-        if not self.isActive: return
         mapper = modFile.getLongMapper()
-        patchRecords = self.patchFile.SPEL
-        for record in modFile.SPEL.getActiveRecords():
-            if not record.spellType == 2: continue
-            record = record.getTypeCopy(mapper)
-            if record.fid in self.id_exhaustion:
+        patchRecords = patchFile.WEAP
+        for record in modFile.WEAP.getActiveRecords():
+            if record.dnamFlags1.dontUse1stPersonISAnimations:
+                record = record.getTypeCopy(mapper)
                 patchRecords.setRecord(record)
 
-    def buildPatch(self,log,progress):
+    def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
-        if not self.isActive: return
         count = {}
-        exhaustId = (self.cobl,0x05139B)
-        keep = self.patchFile.getKeeper()
-        for record in self.patchFile.SPEL.records:
-            #--Skip this one?
-            duration = self.id_exhaustion.get(record.fid,0)
-            if not (duration and record.spellType == 2): continue
-            isExhausted = False
-            for effect in record.effects:
-                if effect.name == 'SEFF' and effect.scriptEffect.script == exhaustId:
-                    duration = 0
-                    break
-            if not duration: continue
-            #--Okay, do it
-            record.full = '+'+record.full
-            record.spellType = 3 #--Lesser power
-            effect = record.getDefault('effects')
-            effect.name = 'SEFF'
-            effect.duration = duration
-            scriptEffect = record.getDefault('effects.scriptEffect')
-            scriptEffect.full = _("Power Exhaustion")
-            scriptEffect.script = exhaustId
-            scriptEffect.school = 2
-            scriptEffect.visual = null4
-            scriptEffect.flags.hostile = False
-            effect.scriptEffect = scriptEffect
-            record.effects.append(effect)
-            keep(record.fid)
-            srcMod = record.fid[0]
-            count[srcMod] = count.get(srcMod,0) + 1
+        keep = patchFile.getKeeper()
+        for record in patchFile.WEAP.records:
+            if record.dnamFlags1.dontUse1stPersonISAnimations:
+                if (record.etype == 1 or record.etype == 2) and record.dnamFlags1.hasScope == 0:
+                    record.dnamFlags1.dontUse1stPersonISAnimations = 0
+                    keep(record.fid)
+                    srcMod = record.fid[0]
+                    count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        log.setHeader('= '+self.__class__.name)
-        log(_('* Powers Tweaked: %d') % (sum(count.values()),))
+        log.setHeader(_('=== Use Ironsight Animation'))
+        log(_('* Guns set to use ironsight: %d') % (sum(count.values()),))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('  * %s: %d' % (srcMod.s,count[srcMod]))
-class CBash_CoblExhaustion(SpecialPatcher,CBash_ListPatcher):
-    """Modifies most Greater power to work with Cobl's power exhaustion feature."""
-    name = _('Cobl Exhaustion')
-    text = _("Modify greater powers to use Cobl's Power Exhaustion feature.\n\nWill only run if Cobl Main v1.66 (or higher) is active.")
-    autoKey = set(('Exhaust',))
-    defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
-    unloadedText = ""
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.cobl = GPath('Cobl Main.esm')
-        self.isActive = (self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.65)
-        self.id_exhaustion = {}
-        self.mod_count = {}
-        self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-             type_patchers.setdefault(type,[]).append(self)
-        progress.setFull(len(self.srcs))
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if srcPath not in patchesDir: continue
-            self.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
-    def getTypes(self):
-        return ['SPEL']
 
-    def readFromText(self,textPath):
-        """Imports type_id_name from specified text file."""
-        aliases = self.patchFile.aliases
-        id_exhaustion = self.id_exhaustion
-        textPath = GPath(textPath)
-        ins = bolt.CsvReader(textPath)
-        reNum = re.compile(r'\d+')
-        for fields in ins:
-            if len(fields) < 4 or fields[1][:2] != '0x' or not reNum.match(fields[3]): continue
-            mod,objectIndex,eid,time = fields[:4]
-            mod = GPath(mod)
-            longid = (aliases.get(mod,mod),int(objectIndex[2:],16))
-            id_exhaustion[longid] = int(time)
-        ins.close()
+#------------------------------------------------------------------------------
+class AssortedTweaker(MultiTweaker):
+    """Tweaks assorted stuff. Sub-tweaks behave like patchers themselves."""
+    scanOrder = 32
+    editOrder = 32
+    name = _('Tweak Assorted')
+    text = _("Tweak various records in miscellaneous ways.")
+    tweaks = sorted([
+        AssortedTweak_GunsUseISAnimation(),
+        AssortedTweak_ArmorPlayable(),
+        AssortedTweak_FogFix(),
+        AssortedTweak_NoLightFlicker(),
+        AssortedTweak_WindSpeed(),
+        AssortedTweak_SetSoundAttenuationLevels(),
+        AssortedTweak_LightFadeValueFix(),
+        ],key=lambda a: a.label.lower())
 
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if (record.spellType == 2):
-            #--Skip this one?
-            duration = self.id_exhaustion.get(record.fid,0)
-            if not duration: return
-            for effect in record.effects:
-                if effect.name == self.SEFFValue and effect.script == (self.cobl,0x05139B):
-                    return
-            #--Okay, do it
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                override.full = '+'+override.full
-                override.spellType = 3 #--Lesser power
-                effect = override.create_effect()
-                effect.name = 'SEFF'
-                effect.duration = duration
-                effect.full = _("Power Exhaustion")
-                effect.script = (self.cobl,0x05139B)
-                effect.school = 2
-                effect.visual = null4
-                effect.IsHostile = False
-
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        if not self.isActive: return None
+        classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
+        return sum(classTuples,tuple())
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        if not self.isActive: return None
+        classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
+        return sum(classTuples,tuple())
+
+    def scanModFile(self,modFile,progress):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
         if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= '+self.__class__.name)
-        log(_('* Powers Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+        for tweak in self.enabledTweaks:
+            tweak.scanModFile(modFile,progress,self.patchFile)
 
-#------------------------------------------------------------------------------
-class ListsMerger(SpecialPatcher,ListPatcher):
-    """Merged leveled lists mod file."""
-    scanOrder = 45
-    editOrder = 45
-    name = _('Leveled Lists')
-    text = _("Merges changes to leveled lists from ACTIVE/MERGED MODS ONLY.\n\nAdvanced users may override Relev/Delev tags for any mod (active or inactive) using the list below.")
-    tip = _("Merges changes to leveled lists from all active mods.")
-    choiceMenu = ('Auto','----','Delev','Relev') #--List of possible choices for each config item. Item 0 is default.
-    autoKey = ('Delev','Relev')
-    forceAuto = False
-    forceItemCheck = True #--Force configChecked to True for all items
-    iiMode = True
-    selectCommands = False
+    def buildPatch(self,log,progress):
+        """Applies individual clothes tweaks."""
+        if not self.isActive: return
+        log.setHeader('= '+self.__class__.name,True)
+        for tweak in self.enabledTweaks:
+            tweak.buildPatch(log,progress,self.patchFile)
 
-    #--Static------------------------------------------------------------------
-    @staticmethod
-    def getDefaultTags():
-        tags = {}
-        for fileName in ('Leveled Lists.csv','My Leveled Lists.csv'):
-            textPath = dirs['patches'].join(fileName)
-            if textPath.exists():
-                reader = bolt.CsvReader(textPath)
-                for fields in reader:
-                    if len(fields) < 2 or not fields[0] or fields[1] not in ('DR','R','D','RD',''): continue
-                    tags[GPath(fields[0])] = fields[1]
-                reader.close()
-        return tags
+# class CBash_AssortedTweaker(CBash_MultiTweaker):
+#     """Tweaks assorted stuff. Sub-tweaks behave like patchers themselves."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Tweak Assorted')
+#     text = _("Tweak various records in miscellaneous ways.")
+#     tweaks = sorted([
+#         CBash_AssortedTweak_ArmorShows(_("Armor Shows Amulets"),
+#             _("Prevents armor from hiding amulets."),
+#             'armorShowsAmulets',
+#             ),
+#         CBash_AssortedTweak_ArmorShows(_("Armor Shows Rings"),
+#             _("Prevents armor from hiding rings."),
+#             'armorShowsRings',
+#             ),
+#         CBash_AssortedTweak_ClothingShows(_("Clothing Shows Amulets"),
+#             _("Prevents Clothing from hiding amulets."),
+#             'ClothingShowsAmulets',
+#             ),
+#         CBash_AssortedTweak_ClothingShows(_("Clothing Shows Rings"),
+#             _("Prevents Clothing from hiding rings."),
+#             'ClothingShowsRings',
+#             ),
+#         CBash_AssortedTweak_ArmorPlayable(),
+#         CBash_AssortedTweak_ClothingPlayable(),
+#         CBash_AssortedTweak_BowReach(),
+#         CBash_AssortedTweak_ConsistentRings(),
+#         CBash_AssortedTweak_DarnBooks(),
+#         CBash_AssortedTweak_FogFix(),
+#         CBash_AssortedTweak_NoLightFlicker(),
+#         CBash_AssortedTweak_PotionWeight(),
+#         CBash_AssortedTweak_PotionWeightMinimum(),
+#         CBash_AssortedTweak_StaffWeight(),
+#         CBash_AssortedTweak_SetCastWhenUsedEnchantmentCosts(),
+#         CBash_AssortedTweak_HarvestChance(),
+#         CBash_AssortedTweak_WindSpeed(),
+#         CBash_AssortedTweak_IngredientWeight(),
+#         CBash_AssortedTweak_ArrowWeight(),
+#         CBash_AssortedTweak_ScriptEffectSilencer(),
+#         CBash_AssortedTweak_DefaultIcons(),
+#         CBash_AssortedTweak_SetSoundAttenuationLevels(),
+#         CBash_AssortedTweak_SetSoundAttenuationLevels_NirnrootOnly(),
+#         CBash_AssortedTweak_FactioncrimeGoldMultiplier(),
+#         CBash_AssortedTweak_LightFadeValueFix(),
+#         ],key=lambda a: a.label.lower())
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         for tweak in self.tweaks:
+#             tweak.patchFile = patchFile
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatchLog(log)
 
-    #--Config Phase -----------------------------------------------------------
-    def getChoice(self,item):
-        """Get default config choice."""
-        choice = self.configChoices.get(item)
-        if not isinstance(choice,set): choice = set(('Auto',))
-        if 'Auto' in choice:
-            if item in modInfos:
-                choice = set(('Auto',))
-                bashTags = modInfos[item].getBashTags()
-                for key in ('Delev','Relev'):
-                    if key in bashTags: choice.add(key)
-        self.configChoices[item] = choice
-        return choice
+#------------------------------------------------------------------------------
+class GlobalsTweak(MultiTweakItem):
+    """set a global to specified value"""
+    #--Patch Phase ------------------------------------------------------------
+    def buildPatch(self,patchFile,keep,log):
+        """Build patch."""
+        value = self.choiceValues[self.chosen][0]
+        for record in patchFile.GLOB.records:
+            if record.eid.lower() == self.key:
+                if record.value != value:
+                    record.value = value
+                    keep(record.fid)
+        log('* %s set to: %4.2f' % (self.label,value))
+# class CBash_GlobalsTweak(CBash_MultiTweakItem):
+#     """Sets a global to specified value"""
+#     scanOrder = 29
+#     editOrder = 29
+#     #--Config Phase -----------------------------------------------------------
+#     def getTypes(self):
+#         return ['GLOB']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if (record.eid == self.key): #eid is case insensitive on comparisons by default
+#             value = self.value = self.choiceValues[self.chosen][0]
+#             if record.value != value:
+#                 self.count = 1
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.value = float(value) #Globals are always stored as floats, regardless of what the CS says
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         if self.count:
+#             log('  * %s set to: %4.2f' % (self.label,self.value))
 
-    def getItemLabel(self,item):
-        """Returns label for item to be used in list"""
-        choice = map(itemgetter(0),self.configChoices.get(item,tuple()))
-        if isinstance(item,bolt.Path): item = item.s
-        if choice:
-            return '%s [%s]' % (item,''.join(sorted(choice)))
-        else:
-            return item
+#------------------------------------------------------------------------------
+class GlobalsTweaker(MultiTweaker):
+    """Select values to set various globals to."""
+    scanOrder = 29
+    editOrder = 29
+    name = _('Globals')
+    text = _("Set globals to various values")
+    tweaks = sorted([
+        GlobalsTweak(_("Timescale"),
+            _("Timescale will be set to:"),
+            'timescale',
+            (_('1'),1),
+            (_('8'),8),
+            (_('10'),10),
+            (_('12'),12),
+            (_('18'),18),
+            (_('24'),24),
+            (_('[30]'),30),
+            (_('40'),40),
+            (_('Custom'),0),
+            ),
+        ],key=lambda a: a.label.lower())
 
     #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.srcMods = set(self.getConfigChecked()) & set(loadMods)
-        self.listTypes = ('LVLC','LVLI','LVSP')
-        self.type_list = dict([(type,{}) for type in self.listTypes])
-        self.masterItems = {}
-        self.mastersScanned = set()
-        self.levelers = None #--Will initialize later
-        self.empties = set()
-        OverhaulCompat = False
-        OOOMods = set([GPath("Oscuro's_Oblivion_Overhaul.esm"),GPath("Oscuro's_Oblivion_Overhaul.esp")])
-        FransMods = set([GPath("Francesco's Leveled Creatures-Items Mod.esm"),GPath("Francesco.esp")])
-        WCMods = set([GPath("Oblivion Warcry.esp"),GPath("Oblivion Warcry EV.esp")])
-        TIEMods = set([GPath("TIE.esp")])
-        if GPath("Unofficial Oblivion Patch.esp") in self.srcMods:
-            if (OOOMods|WCMods) & self.srcMods:
-                OverhaulCompat = True
-            elif FransMods & self.srcMods:
-                if TIEMods & self.srcMods:
-                    pass
-                else:
-                    OverhaulCompat = True
-        if OverhaulCompat:
-            self.OverhaulUOPSkips = set([
-                (GPath('Oblivion.esm'),x) for x in [
-                    0x03AB5D,   # VendorWeaponBlunt
-                    0x03C7F1,   # LL0LootWeapon0Magic4Dwarven100
-                    0x03C7F2,   # LL0LootWeapon0Magic7Ebony100
-                    0x03C7F3,   # LL0LootWeapon0Magic5Elven100
-                    0x03C7F4,   # LL0LootWeapon0Magic6Glass100
-                    0x03C7F5,   # LL0LootWeapon0Magic3Silver100
-                    0x03C7F7,   # LL0LootWeapon0Magic2Steel100
-                    0x03E4D2,   # LL0NPCWeapon0MagicClaymore100
-                    0x03E4D3,   # LL0NPCWeapon0MagicClaymoreLvl100
-                    0x03E4DA,   # LL0NPCWeapon0MagicWaraxe100
-                    0x03E4DB,   # LL0NPCWeapon0MagicWaraxeLvl100
-                    0x03E4DC,   # LL0NPCWeapon0MagicWarhammer100
-                    0x03E4DD,   # LL0NPCWeapon0MagicWarhammerLvl100
-                    0x0733EA,   # ArenaLeveledHeavyShield,
-                    0x0C7615,   # FGNPCWeapon0MagicClaymoreLvl100
-                    0x181C66,   # SQ02LL0NPCWeapon0MagicClaymoreLvl100
-                    0x053877,   # LL0NPCArmor0MagicLightGauntlets100
-                    0x053878,   # LL0NPCArmor0MagicLightBoots100
-                    0x05387A,   # LL0NPCArmor0MagicLightCuirass100
-                    0x053892,   # LL0NPCArmor0MagicLightBootsLvl100
-                    0x053893,   # LL0NPCArmor0MagicLightCuirassLvl100
-                    0x053894,   # LL0NPCArmor0MagicLightGauntletsLvl100
-                    0x053D82,   # LL0LootArmor0MagicLight5Elven100
-                    0x053D83,   # LL0LootArmor0MagicLight6Glass100
-                    0x052D89,   # LL0LootArmor0MagicLight4Mithril100
-                    ]
-                ])
-        else:
-            self.OverhaulUOPSkips = set()
-
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (MreLvlc,MreLvli,MreLvsp)
+        return (None,(MreGlob,))[self.isActive]
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (MreLvlc,MreLvli,MreLvsp)
+        return (None,(MreGlob,))[self.isActive]
 
-    def scanModFile(self, modFile, progress):
-        """Add lists from modFile."""
-        #--Level Masters (complete initialization)
-        if self.levelers == None:
-            allMods = set(self.patchFile.allMods)
-            self.levelers = [leveler for leveler in self.getConfigChecked() if leveler in allMods]
-            self.delevMasters = set()
-            for leveler in self.levelers:
-                self.delevMasters.update(modInfos[leveler].header.masters)
-        #--Begin regular scan
-        modName = modFile.fileInfo.name
-        modFile.convertToLongFids(self.listTypes)
-        #--PreScan for later Relevs/Delevs?
-        if modName in self.delevMasters:
-            for type in self.listTypes:
-                for levList in getattr(modFile,type).getActiveRecords():
-                    masterItems = self.masterItems.setdefault(levList.fid,{})
-                    masterItems[modName] = set([entry.listId for entry in levList.entries])
-            self.mastersScanned.add(modName)
-        #--Relev/Delev setup
-        configChoice = self.configChoices.get(modName,tuple())
-        isRelev = ('Relev' in configChoice)
-        isDelev = ('Delev' in configChoice)
-        #--Scan
-        for type in self.listTypes:
-            levLists = self.type_list[type]
-            newLevLists = getattr(modFile,type)
-            for newLevList in newLevLists.getActiveRecords():
-                listId = newLevList.fid
-                if listId in self.OverhaulUOPSkips and modName == 'Unofficial Oblivion Patch.esp':
-                    levLists[listId].mergeOverLast = True
-                    continue
-                isListOwner = (listId[0] == modName)
-                #--Items, delevs and relevs sets
-                newLevList.items = items = set([entry.listId for entry in newLevList.entries])
-                if not isListOwner:
-                    #--Relevs
-                    newLevList.relevs = (set(),items.copy())[isRelev]
-                    #--Delevs: all items in masters minus current items
-                    newLevList.delevs = delevs = set()
-                    if isDelev:
-                        id_masterItems = self.masterItems.get(newLevList.fid)
-                        if id_masterItems:
-                            for masterName in modFile.tes4.masters:
-                                if masterName in id_masterItems:
-                                    delevs |= id_masterItems[masterName]
-                            delevs -= items
-                            newLevList.items |= delevs
-                #--Cache/Merge
-                if isListOwner:
-                    levList = copy.deepcopy(newLevList)
-                    levList.mergeSources = []
-                    levLists[listId] = levList
-                elif listId not in levLists:
-                    levList = copy.deepcopy(newLevList)
-                    levList.mergeSources = [modName]
-                    levLists[listId] = levList
-                else:
-                    levLists[listId].mergeWith(newLevList,modName)
+    def scanModFile(self,modFile,progress):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        if not self.isActive or 'GLOB' not in modFile.tops: return
+        mapper = modFile.getLongMapper()
+        patchRecords = self.patchFile.GLOB
+        id_records = patchRecords.id_records
+        for record in modFile.GLOB.getActiveRecords():
+            if record.flags1.deleted: continue
+            if mapper(record.fid) in id_records: continue
+            if record.eid is None: continue
+            for tweak in self.enabledTweaks:
+                if record.eid.lower() == tweak.key:
+                    record = record.getTypeCopy(mapper)
+                    patchRecords.setRecord(record)
+                    break
 
     def buildPatch(self,log,progress):
-        """Adds merged lists to patchfile."""
+        """Applies individual clothes tweaks."""
+        if not self.isActive: return
         keep = self.patchFile.getKeeper()
-        #--Relevs/Delevs List
-        log.setHeader('= '+self.__class__.name,True)
-        log.setHeader(_('=== Delevelers/Relevelers'))
-        for leveler in (self.levelers or []):
-            log('* '+self.getItemLabel(leveler))
-        #--Save to patch file
-        for label, type in ((_('Creature'),'LVLC'), (_('Item'),'LVLI'), (_('Spell'),'LVSP')):
-            log.setHeader(_('=== Merged %s Lists') % label)
-            patchBlock = getattr(self.patchFile,type)
-            levLists = self.type_list[type]
-            for record in sorted(levLists.values(),key=attrgetter('eid')):
-                if not record.mergeOverLast: continue
-                fid = keep(record.fid)
-                patchBlock.setRecord(levLists[fid])
-                log('* '+record.eid)
-                for mod in record.mergeSources:
-                    log('  * ' + self.getItemLabel(mod))
-        #--Discard empty sublists
-        for label, type in ((_('Creature'),'LVLC'), (_('Item'),'LVLI'), (_('Spell'),'LVSP')):
-            patchBlock = getattr(self.patchFile,type)
-            levLists = self.type_list[type]
-            #--Empty lists
-            empties = []
-            sub_supers = dict((x,[]) for x in levLists.keys())
-            for record in sorted(levLists.values()):
-                listId = record.fid
-                if not record.items:
-                    empties.append(listId)
+        log.setHeader('= '+self.__class__.name)
+        for tweak in self.enabledTweaks:
+            tweak.buildPatch(self.patchFile,keep,log)
+
+# class CBash_GlobalsTweaker(CBash_MultiTweaker):
+#     """Select values to set various globals to."""
+#     scanOrder = 29
+#     editOrder = 29
+#     name = _('Globals')
+#     text = _("Set globals to various values")
+#     tweaks = sorted([
+#         CBash_GlobalsTweak(_("Timescale"),
+#             _("Timescale will be set to:"),
+#             'timescale',
+#             (_('1'),1),
+#             (_('8'),8),
+#             (_('10'),10),
+#             (_('12'),12),
+#             (_('18'),18),
+#             (_('24'),24),
+#             (_('[30]'),30),
+#             (_('40'),40),
+#             (_('Custom'),0),
+#             ),
+#         ],key=lambda a: a.label.lower())
+
+#     #--Config Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         for tweak in self.tweaks:
+#             tweak.patchFile = patchFile
+#             tweak.count = 0
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatchLog(log)
+
+
+#------------------------------------------------------------------------------
+# class ClothesTweak(MultiTweakItem):
+#     flags = {
+#         'hoods':   1<<1,
+#         'shirts':  1<<2,
+#         'pants':   1<<3,
+#         'gloves':  1<<4,
+#         'amulets': 1<<8,
+#         'rings2':  1<<16,
+#         'amulets2': 1<<17,
+#         #--Multi
+#         'robes':   (1<<2) + (1<<3),
+#         'rings':   (1<<6) + (1<<7),
+#         }
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key,*choices):
+#         MultiTweakItem.__init__(self,label,tip,key,*choices)
+#         typeKey = key[:key.find('.')]
+#         self.orTypeFlags = typeKey == 'rings'
+#         self.typeFlags = self.__class__.flags[typeKey]
+
+#     def isMyType(self,record):
+#         """Returns true to save record for late processing."""
+#         if record.flags.notPlayable: return False #--Ignore non-playable items.
+#         recTypeFlags = int(record.flags) & 0xFFFF
+#         myTypeFlags = self.typeFlags
+#         return (
+#             (recTypeFlags == myTypeFlags) or
+#             (self.orTypeFlags and (recTypeFlags & myTypeFlags == recTypeFlags))
+#             )
+# class CBash_ClothesTweak(CBash_MultiTweakItem):
+#     flags = {
+#         'hoods':    0x00000002,
+#         'shirts':   0x00000004,
+#         'pants':    0x00000008,
+#         'gloves':   0x00000010,
+#         'amulets':  0x00000100,
+#         'rings2':   0x00010000,
+#         'amulets2': 0x00020000,
+#         #--Multi
+#         'robes':    0x0000000C,
+#         'rings':    0x000000C0,
+#         }
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key,*choices):
+#         CBash_MultiTweakItem.__init__(self,label,tip,key,*choices)
+#         typeKey = key[:key.find('.')]
+#         self.orTypeFlags = typeKey == 'rings'
+#         self.typeFlags = self.__class__.flags[typeKey]
+
+#     def isMyType(self,record):
+#         """Returns true to save record for late processing."""
+#         recTypeFlags = int(record.flags) & 0xFFFF
+#         myTypeFlags = self.typeFlags
+#         return ((recTypeFlags == myTypeFlags) or
+#                 (self.orTypeFlags and (recTypeFlags & myTypeFlags == recTypeFlags)))
+#------------------------------------------------------------------------------
+# class ClothesTweak_MaxWeight(ClothesTweak):
+#     """Enforce a max weight for specified clothes."""
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatch(self,patchFile,keep,log):
+#         """Build patch."""
+#         tweakCount = 0
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         superWeight = max(10,5*maxWeight) #--Guess is intentionally overweight
+#         for record in patchFile.CLOT.records:
+#             weight = record.weight
+#             if self.isMyType(record) and weight > maxWeight and weight < superWeight:
+#                 record.weight = maxWeight
+#                 keep(record.fid)
+#                 tweakCount += 1
+#         log('* %s: [%4.2f]: %d' % (self.label,maxWeight,tweakCount))
+
+
+# class CBash_ClothesTweak_MaxWeight(CBash_ClothesTweak):
+#     """Enforce a max weight for specified clothes."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Reweigh Clothes')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key,*choices):
+#         CBash_ClothesTweak.__init__(self,label,tip,key,*choices)
+#         self.matchFlags = {'amulets.maxWeight':('IsAmulet',),
+#                          'rings.maxWeight':('IsRightRing','IsLeftRing'),
+#                          'hoods.maxWeight':('IsHair',)
+#                          }[key]
+#         self.mod_count = {}
+
+
+#     def getTypes(self):
+#         return ['CLOT']
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsNonPlayable:
+#             return
+
+#         maxWeight = self.choiceValues[self.chosen][0]
+
+#         if (record.weight > maxWeight) and self.isMyType(record):
+#             for attr in self.matchFlags:
+#                 if(getattr(record, attr)):
+#                     break
+#             else:
+#                 return
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.weight = maxWeight
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         maxWeight = self.choiceValues[self.chosen][0]
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* Clothes Reweighed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: [%4.2f]: %d' % (srcMod.s,maxWeight,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class ClothesTweak_Unblock(ClothesTweak):
+#     """Unlimited rings, amulets."""
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key,*choices):
+#         ClothesTweak.__init__(self,label,tip,key,*choices)
+#         self.unblockFlags = self.__class__.flags[key[key.rfind('.')+1:]]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatch(self,patchFile,keep,log):
+#         """Build patch."""
+#         tweakCount = 0
+#         for record in patchFile.CLOT.records:
+#             if self.isMyType(record) and int(record.flags & self.unblockFlags):
+#                 record.flags &= ~self.unblockFlags
+#                 keep(record.fid)
+#                 tweakCount += 1
+#         log('* %s: %d' % (self.label,tweakCount))
+# class CBash_ClothesTweak_Unblock(CBash_ClothesTweak):
+#     """Unlimited rings, amulets."""
+#     scanOrder = 31
+#     editOrder = 31
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key):
+#         CBash_ClothesTweak.__init__(self,label,tip,key)
+#         self.hideFlags = {'amulets.unblock.amulets':('IsAmulet',),
+#                          'robes.show.amulets2':('IsHideAmulets',),
+#                          'rings.unblock.rings':('IsRightRing','IsLeftRing'),
+#                          'gloves.unblock.rings2':('IsHideRings',),
+#                          'robes.unblock.pants':('IsLowerBody',)
+#                          }[key]
+#         self.mod_count = {}
+
+
+#     def getTypes(self):
+#         return ['CLOT']
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsNonPlayable:
+#             return
+
+#         if self.isMyType(record):
+#             for flag in self.hideFlags:
+#                 if(getattr(record, flag)):
+#                     break
+#             else:
+#                 return
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 for attr in self.hideFlags:
+#                     setattr(override, attr, False)
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         log.setHeader('=== '+self.label)
+#         log(_('* Clothing Pieces Tweaked: %d') % (sum(self.mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(self.mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,self.mod_count[srcMod]))
+#         self.mod_count = {}
+
+# #------------------------------------------------------------------------------
+# class ClothesTweaker(MultiTweaker):
+#     """Patches clothes in miscellaneous ways."""
+#     scanOrder = 31
+#     editOrder = 31
+#     name = _('Tweak Clothes')
+#     text = _("Tweak clothing weight and blocking.")
+#     tweaks = sorted([
+#         ClothesTweak_Unblock(_("Unlimited Amulets"),
+#             _("Wear unlimited number of amulets - but they won't display."),
+#             'amulets.unblock.amulets'),
+#         ClothesTweak_Unblock(_("Unlimited Rings"),
+#             _("Wear unlimited number of rings - but they won't display."),
+#             'rings.unblock.rings'),
+#         ClothesTweak_Unblock(_("Gloves Show Rings"),
+#             _("Gloves will always show rings. (Conflicts with Unlimited Rings.)"),
+#             'gloves.unblock.rings2'),
+#         ClothesTweak_Unblock(_("Robes Show Pants"),
+#             _("Robes will allow pants, greaves, skirts - but they'll clip."),
+#             'robes.unblock.pants'),
+#         ClothesTweak_Unblock(_("Robes Show Amulets"),
+#             _("Robes will always show amulets. (Conflicts with Unlimited Amulets.)"),
+#             'robes.show.amulets2'),
+#         ClothesTweak_MaxWeight(_("Max Weight Amulets"),
+#             _("Amulet weight will be capped."),
+#             'amulets.maxWeight',
+#             (_('0.0'),0),
+#             (_('0.1'),0.1),
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('Custom'),0),
+#             ),
+#         ClothesTweak_MaxWeight(_("Max Weight Rings"),
+#             _('Ring weight will be capped.'),
+#             'rings.maxWeight',
+#             (_('0.0'),0),
+#             (_('0.1'),0.1),
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('Custom'),0),
+#             ),
+#         ClothesTweak_MaxWeight(_("Max Weight Hoods"),
+#             _('Hood weight will be capped.'),
+#             'hoods.maxWeight',
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('1.0'),1.0),
+#             (_('Custom'),0),
+#             ),
+#         ],key=lambda a: a.label.lower())
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (None,(MreClot,))[self.isActive]
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (None,(MreClot,))[self.isActive]
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive or 'CLOT' not in modFile.tops: return
+#         mapper = modFile.getLongMapper()
+#         patchRecords = self.patchFile.CLOT
+#         id_records = patchRecords.id_records
+#         for record in modFile.CLOT.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             for tweak in self.enabledTweaks:
+#                 if tweak.isMyType(record):
+#                     record = record.getTypeCopy(mapper)
+#                     patchRecords.setRecord(record)
+#                     break
+
+#     def buildPatch(self,log,progress):
+#         """Applies individual clothes tweaks."""
+#         if not self.isActive: return
+#         keep = self.patchFile.getKeeper()
+#         log.setHeader('= '+self.__class__.name)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatch(self.patchFile,keep,log)
+# class CBash_ClothesTweaker(CBash_MultiTweaker):
+#     """Patches clothes in miscellaneous ways."""
+#     scanOrder = 31
+#     editOrder = 31
+#     name = _('Tweak Clothes')
+#     text = _("Tweak clothing weight and blocking.")
+#     tweaks = sorted([
+#         CBash_ClothesTweak_Unblock(_("Unlimited Amulets"),
+#             _("Wear unlimited number of amulets - but they won't display."),
+#             'amulets.unblock.amulets'),
+#         CBash_ClothesTweak_Unblock(_("Unlimited Rings"),
+#             _("Wear unlimited number of rings - but they won't display."),
+#             'rings.unblock.rings'),
+#         CBash_ClothesTweak_Unblock(_("Gloves Show Rings"),
+#             _("Gloves will always show rings. (Conflicts with Unlimited Rings.)"),
+#             'gloves.unblock.rings2'),
+#         CBash_ClothesTweak_Unblock(_("Robes Show Pants"),
+#             _("Robes will allow pants, greaves, skirts - but they'll clip."),
+#             'robes.unblock.pants'),
+#         CBash_ClothesTweak_Unblock(_("Robes Show Amulets"),
+#             _("Robes will always show amulets. (Conflicts with Unlimited Amulets.)"),
+#             'robes.show.amulets2'),
+#         CBash_ClothesTweak_MaxWeight(_("Max Weight Amulets"),
+#             _("Amulet weight will be capped."),
+#             'amulets.maxWeight',
+#             (_('0.0'),0.0),
+#             (_('0.1'),0.1),
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('Custom'),0.0),
+#             ),
+#         CBash_ClothesTweak_MaxWeight(_("Max Weight Rings"),
+#             _('Ring weight will be capped.'),
+#             'rings.maxWeight',
+#             (_('0.0'),0.0),
+#             (_('0.1'),0.1),
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('Custom'),0.0),
+#             ),
+#         CBash_ClothesTweak_MaxWeight(_("Max Weight Hoods"),
+#             _('Hood weight will be capped.'),
+#             'hoods.maxWeight',
+#             (_('0.2'),0.2),
+#             (_('0.5'),0.5),
+#             (_('1.0'),1.0),
+#             (_('Custom'),0.0),
+#             ),
+#         ],key=lambda a: a.label.lower())
+
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         for tweak in self.tweaks:
+#             tweak.patchFile = patchFile
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatchLog(log)
+
+#------------------------------------------------------------------------------
+class GmstTweak(MultiTweakItem):
+    #--Patch Phase ------------------------------------------------------------
+    def buildPatch(self,patchFile,keep,log):
+        """Build patch."""
+        eids = ((self.key,),self.key)[isinstance(self.key,tuple)]
+        for eid,value in zip(eids,self.choiceValues[self.chosen]):
+            if value < 0:
+                deprint("GMST float value can't be a negative number - currently %s - skipping setting GMST." % value)
+                return
+            for record in patchFile.GMST.records:
+                if record.eid.lower() == eid.lower():
+                    if record.value != value:
+                        record.value = value
+                        keep(record.fid)
+                    break
+            else:
+                gmst = MreGmst(('GMST',0,0,0,0,0))
+                gmst.eid,gmst.value,gmst.longFids = eid,value,True
+                fid = gmst.fid = keep(gmst.getGMSTFid())
+                patchFile.GMST.setRecord(gmst)
+        if len(self.choiceLabels) > 1:
+            if self.choiceLabels[self.chosen].startswith('Custom'):
+                if isinstance(self.choiceValues[self.chosen][0],(str,unicode)):
+                    log('* %s: %s %s' % (self.label,self.choiceLabels[self.chosen],self.choiceValues[self.chosen][0]))
                 else:
-                    subLists = [x for x in record.items if x in sub_supers]
-                    for subList in subLists:
-                        sub_supers[subList].append(listId)
-            #--Clear empties
-            removed = set()
-            cleaned = set()
-            while empties:
-                empty = empties.pop()
-                if empty not in sub_supers: continue
-                for super in sub_supers[empty]:
-                    record = levLists[super]
-                    record.entries = [x for x in record.entries if x.listId != empty]
-                    record.items.remove(empty)
-                    patchBlock.setRecord(record)
-                    if not record.items:
-                        empties.append(super)
-                    cleaned.add(record.eid)
-                    removed.add(levLists[empty].eid)
-                    keep(super)
-            log.setHeader(_('=== Empty %s Sublists') % label)
-            for eid in sorted(removed,key=string.lower):
-                log('* '+eid)
-            log.setHeader(_('=== Empty %s Sublists Removed') % label)
-            for eid in sorted(cleaned,key=string.lower):
-                log('* '+eid)
+                    log('* %s: %s %4.2f' % (self.label,self.choiceLabels[self.chosen],self.choiceValues[self.chosen][0]))
+            else: log('* %s: %s' % (self.label,self.choiceLabels[self.chosen]))
+        else:
+            log('* ' + self.label)
 
-class CBash_ListsMerger(SpecialPatcher,CBash_ListPatcher):
-    """Merged leveled lists mod file."""
-    scanOrder = 45
-    editOrder = 45
-    name = _('Leveled Lists')
-    text = _("Merges changes to leveled lists from ACTIVE/MERGED MODS ONLY.\n\nAdvanced users may override Relev/Delev tags for any mod (active or inactive) using the list below.")
-    tip = _("Merges changes to leveled lists from all active mods.")
-    choiceMenu = ('Auto','----','Delev','Relev') #--List of possible choices for each config item. Item 0 is default.
-    autoKey = set(('Delev','Relev'))
-    forceAuto = False
-    forceItemCheck = True #--Force configChecked to True for all items
-    iiMode = True
-    selectCommands = False
-    allowUnloaded = False
-    scanRequiresChecked = False
-    applyRequiresChecked = False
+class CBash_GmstTweak(CBash_MultiTweakItem):
+    """Sets a gmst to specified value"""
+    scanOrder = 29
+    editOrder = 29
+    #--Config Phase -----------------------------------------------------------
+    def getTypes(self):
+        return ['GMST']
+
+    #--Patch Phase ------------------------------------------------------------
+    def apply(self,modFile,record,bashTags):
+        """Edits patch file as desired. """
+        values = self.values = self.choiceValues[self.chosen]
+        recEid = record.eid
+        for eid,value in zip(self.key,values):
+            if eid == recEid:
+                newValue = value
+                break
+        else:
+            return
+        if recEid.startswith("f") and type(newValue) != float:
+            deprint("converting custom value to float for GMST %s: %s" % (recEid, newValue))
+            newValue = float(newValue)
+        if record.value != newValue:
+            self.eid_count[eid] = 1
+            if newValue < 0:
+                deprint("GMST float value can't be a negative number - currently %s - skipping setting GMST" % newValue)
+                return
+            override = record.CopyAsOverride(self.patchFile)
+            if override:
+                override.value = newValue
+                record.UnloadRecord()
+                record._ModID, record._RecordID = override._ModID, override._RecordID
+
+    def finishPatch(self,patchFile,progress):
+        """Edits the bashed patch file directly."""
+        subProgress = SubProgress(progress)
+        values = self.values = self.choiceValues[self.chosen]
+        subProgress.setFull(max(len(values),1))
+        pstate = 0
+        for eid,value in zip(self.key,values):
+            subProgress(pstate, _("Finishing GMST Tweaks..."))
+            if not self.eid_count.get(eid,0):
+                self.eid_count[eid] = 1
+                record = patchFile.create_GMST(eid)
+                if not record:
+                    print eid
+                    print patchFile.ObCollection.Debug_DumpModFiles()
+                    for conflict in patchFile.ObCollection.LookupRecords(eid, False):
+                        print conflict.ModName
+                    raise StateError(_("Tweak Settings: Unable to create GMST!"))
+                if eid.startswith("f") and type(value) != float:
+                    deprint("converting custom value to float for GMST %s: %s" % (eid, value))
+                    value = float(value)
+                record.value = value
+            pstate += 1
+
+    def buildPatchLog(self,log):
+        """Will write to log."""
+        #--Log
+        if len(self.choiceLabels) > 1:
+            if self.choiceLabels[self.chosen].startswith('Custom'):
+                if isinstance(self.values[0],(str,unicode)):
+                    log('  * %s: %s %s' % (self.label,self.choiceLabels[self.chosen],self.values[0]))
+                else:
+                    log('  * %s: %s %4.2f' % (self.label,self.choiceLabels[self.chosen],self.values[0]))
+            else: log('  * %s: %s' % (self.label,self.choiceLabels[self.chosen]))
+        else:
+            log('  * ' + self.label)
+
+#------------------------------------------------------------------------------
+class GmstTweaker(MultiTweaker):
+    """Tweaks miscellaneous gmsts in miscellaneous ways."""
+    scanOrder = 29
+    editOrder = 29
+    name = _('Tweak Settings')
+    text = _("Tweak game settings.")
+    tweaks = sorted([
+        GmstTweak(_('Camera: Chase Distance'),
+            _("Distance camera can be moved away from PC using mouse wheel."),
+            ('fVanityModeWheelMax', 'fChase3rdPersonZUnitsPerSecond'),
+            (_('x 1.5'),600.0*1.5, 800.0*1.5),
+            (_('x 2'),  600.0*2.0, 800.0*2),
+            (_('x 3'),  600.0*3.0, 800.0*3),
+            (_('x 5'),  600.0*5.0, 800.0*5),
+            (_('x 10'), 600.0*10,  5000),
+            (_('Custom'),600,      800),
+            ),
+        GmstTweak(_('Compass: POI Recognition'),
+            _("Distance at which POI markers begin to show on compass."),
+            ('iMapMarkerVisibleDistance',),
+            (_('x 0.05'),1000),
+            (_('x 0.25'),5000),
+            (_('x 0.50'),10000),
+            (_('x 0.75'),15000),
+            (_('Custom (base 1200)'),1200),
+            ),
+        GmstTweak(_('Essential NPC Unconsciousness'),
+            _("Time which essential NPCs stay unconscious."),
+            ('fEssentialDeathTime',),
+            (_('[10 Seconds]'),10.0),
+            (_('20 Seconds'),20.0),
+            (_('30 Seconds'),30.0),
+            (_('1 Minute'),60.0),
+            (_('1 1/2 Minutes'),1.5*60.0),
+            (_('2 Minutes'),2*60.0),
+            (_('3 Minutes'),3*60.0),
+            (_('5 Minutes'),5*60.0),
+            (_('Custom (in seconds)'),10),
+            ),
+        GmstTweak(_('Jump Higher'),
+            _("Height player can jump to."),
+            ('fJumpHeightMin',),
+            (_('x 1.1'),64.0*1.1),
+            (_('x 1.2'),64.0*1.2),
+            (_('x 1.4'),64.0*1.4),
+            (_('x 1.6'),64.0*1.6),
+            (_('x 1.8'),64.0*1.8),
+            (_('x 2.0'),64.0*2.0),
+            (_('x 3.0'),64.0*3.0),
+            (_('Custom'),64),
+            ),
+        GmstTweak(_('Camera: PC Death Time'),
+            _("Time after player's death before reload menu appears."),
+            ('fPlayerDeathReloadTime',),
+            (_('15 Seconds'),15.0),
+            (_('30 Seconds'),30.0),
+            (_('1 Minute'),60.0),
+            (_('5 Minute'),300.0),
+            (_('Unlimited'),9999999.0),
+            (_('Custom'),15),
+            ),
+        GmstTweak(_('Cell Respawn Time'),
+            _("Time before unvisited cell respawns. But longer times increase save sizes."),
+            ('iHoursToRespawnCell',),
+            (_('1 Day'),24*1),
+            (_('[3 Days]'),24*3),
+            (_('5 Days'),24*5),
+            (_('10 Days'),24*10),
+            (_('20 Days'),24*20),
+            (_('1 Month'),24*30),
+            (_('6 Months'),24*182),
+            (_('1 Year'),24*365),
+            (_('Custom (in hours)'),72),
+            ),
+        GmstTweak(_('Cost Multiplier: Repair'),
+            _("Cost factor for repairing items."),
+            ('fItemRepairCostMult',),
+            ('1.0',1.0),
+            ('1.25',1.25),
+            ('1.5',1.5),
+            ('1.75',1.75),
+            ('[2.0]',2.0),
+            ('2.5',2.5),
+            ('3.0',3.0),
+            (_('Custom'),2.0),
+            ),
+        GmstTweak(_('Combat: Max Actors'),
+            _("Maximum number of actors that can actively be in combat with the player."),
+            ('iNumberActorsInCombatPlayer',),
+            ('[10]',10),
+            ('15',15),
+            ('20',20),
+            ('30',30),
+            ('40',40),
+            ('50',50),
+            ('80',80),
+            (_('Custom'),10),
+            ),
+        GmstTweak(_('AI: Max Active Actors'),
+            _("Maximum actors whose AI can be active. Must be higher than Combat: Max Actors"),
+            ('iAINumberActorsComplexScene',),
+            ('20',20),
+            ('[25]',25),
+            ('30',30),
+            ('35',35),
+            (_('MMM Default: 40'),40),
+            ('50',50),
+            ('60',60),
+            ('100',100),
+            (_('Custom'),25),
+            ),
+        GmstTweak(_('Companions: Max Number'),
+            _("Maximum number of actors following the player"),
+            ('iNumberActorsAllowedToFollowPlayer',),
+            ('2',2),
+            ('4',4),
+            ('[6]',6),
+            ('8',8),
+            ('10',10),
+            (_('Custom'),6),
+            ),
+        GmstTweak(_('AI: Max Dead Actors'),
+            _("Maximum number of dead actors allowed before they're removed."),
+            ('iRemoveExcessDeadCount', 'iRemoveExcessDeadTotalActorCount','iRemoveExcessDeadComplexTotalActorCount',
+             'iRemoveExcessDeadComplexCount', 'fRemoveExcessDeadTime','fRemoveExcessComplexDeadTime'),
+            (_('[x 1]'),int(15*1)  , int(20*1)  , int(20*1)  , int(3*1), 10.0*1.0, 2.5*1.0),
+            (_('x 1.5'),int(15*1.5), int(20*1.5), int(20*1.5), int(3*2), 10.0*3.0, 2.5*3.0),
+            (_('x 2'),  int(15*2)  , int(20*2)  , int(20*2)  , int(3*3), 10.0*5.0, 2.5*5.0),
+            (_('x 2.5'),int(15*2.5), int(20*2.5), int(20*2.5), int(3*4), 10.0*7.0, 2.5*7.0),
+            (_('x 3'),  int(15*3)  , int(20*3)  , int(20*3)  , int(3*5), 10.0*9.0, 2.5*9.0),
+            (_('x 3.5'),int(15*3.5), int(20*3.5), int(20*3.5), int(3*6), 10.0*11.0, 2.5*11.0),
+            (_('x 4'),  int(15*4)  , int(20*4)  , int(20*4)  , int(3*7), 10.0*13.0, 2.5*13.0),
+            (_('Custom'),15,20,20,3,10,2.5),
+            ),
+        GmstTweak(_('Inventory Quantity Prompt'),
+            _("Number of items in a stack at which point Fallout prompts for a quantity."),
+            ('iInventoryAskQuantityAt',),
+            ('1',1),
+            ('2',2),
+            ('[3]',3),
+            ('4',4),
+            ('10',10),
+            (_('No Prompt'),99999),
+            (_('Custom'),3),
+            ),
+        GmstTweak(_('Gore: Combat Dismember Part Chance'),
+            _("The chance that body parts will be dismembered."),
+            ('iCombatDismemberPartChance',),
+            ('0',0),
+            ('25',25),
+            ('[50]',50),
+            ('80',80),
+            ('100',100),
+            (_('Custom'),50),
+            ),
+        GmstTweak(_('Gore: Combat Explode Part Chance'),
+            _("The chance that body parts will be explode."),
+            ('iCombatExplodePartChance',),
+            ('0',0),
+            ('25',25),
+            ('50',50),
+            ('[75]',75),
+            ('100',100),
+            (_('Custom'),75),
+            ),
+        GmstTweak(_('Leveled Item Max level difference'),
+            _("Maximum difference to player level for leveled items."),
+            ('iLevItemLevelDifferenceMax',),
+            ('1',1),
+            ('5',5),
+            ('[8]',8),
+            ('10',10),
+            ('20',20),
+            (_('Unlimited'),9999),
+            (_('Custom'),8),
+            ),
+        GmstTweak(_('Movement Base Speed'),
+            _("Base Movement speed."),
+            ('fMoveBaseSpeed',),
+            ('[77.0]',77.0),
+            ('90.0',90.0),
+            (_('Custom'),77.0),
+            ),
+        GmstTweak(_('Movement Sneak Multiplier'),
+            _("Movement speed is multiplied by this when the actor is sneaking."),
+            ('fMoveSneakMult',),
+            ('[0.57]',0.57),
+            ('0.66',0.66),
+            (_('Custom'),0.57),
+            ),
+        GmstTweak(_('Combat: Player Damage Multiplier in VATS'),
+            _("Multiplier of damage that player receives in VATS."),
+            ('fVATSPlayerDamageMult',),
+            (_('0.10'),0.1),
+            (_('0.25'),0.25),
+            (_('0.50'),0.5),
+            (_('[0.75]'),0.75),
+            (_('1.00'),1.0),
+            (_('Custom'),0.75),
+            ),
+        GmstTweak(_('Combat: Auto Aim Fix'),
+            _("Increase Auto Aim settings to a level at which Snipers can benefit from them."),
+            ('fAutoAimMaxDistance', 'fAutoAimScreenPercentage', 'fAutoAimMaxDegrees', 'fAutoAimMissRatioLow', 'fAutoAimMissRatioHigh', 'fAutoAimMaxDegreesMiss'),
+            (_('Harder'),50000.00, -180.00, 1.10, 1.00, 1.30, 3.00),
+            ),
+        GmstTweak(_('PipBoy Light Keypress-Delay'),
+            _("Seconds of delay until the PipBoy Light switches on."),
+            ('fPlayerPipBoyLightTimer',),
+            (_('0.3'),0.3),
+            (_('0.4'),0.4),
+            (_('0.5'),0.5),
+            (_('0.6'),0.6),
+            (_('0.7'),0.7),
+            (_('[0.8]'),0.8),
+            (_('1.0'),1.0),
+            (_('Custom'),0.8),
+            ),
+        GmstTweak(_('VATS Playback Delay'),
+            _("Seconds of delay after the VATS Camera finished playback."),
+            ('fVATSPlaybackDelay',),
+            (_('0.01'),0.01),
+            (_('0.05'),0.05),
+            (_('0.10'),0.1),
+            (_('[0.17]'),0.17),
+            (_('0.25'),0.25),
+            (_('Custom'),0.17),
+            ),
+        GmstTweak(_('NPC-Death XP Threshold (Followers)'),
+            _("Percentage of total damage you have to inflict in order to get XP"),
+            ('iXPDeathRewardHealthThreshold',),
+            (_('0%'),0),
+            (_('25%'),25),
+            (_('[40%]'),40),
+            (_('50%'),50),
+            (_('75%'),75),
+            (_('Custom'),40),
+            ),
+        GmstTweak(_('Hacking: Maximum Number of words'),
+            _("The maximum number of words appearing in the terminal hacking mini-game."),
+            ('iHackingMaxWords',),
+            (_('1'),1),
+            (_('4'),4),
+            (_('8'),8),
+            (_('12'),12),
+            (_('16'),16),
+            (_('[20]'),20),
+            (_('Custom'),20),
+            ),
+        GmstTweak(_('Shell Camera Distance'),
+            _("Maximum distance at which gun arisings (shell case, particle, decal) show from camera."),
+            ('fGunParticleCameraDistance', 'fGunShellCameraDistance', 'fGunDecalCameraDistance'),
+            (_('x 1.5'),2048.0*1.5, 512.0*1.5, 2048.0*1.5),
+            (_('x 2'),  2048.0*2.0, 512.0*2.0, 2048.0*2.0),
+            (_('x 3'),  2048.0*3.0, 512.0*3.0, 2048.0*3.0),
+            (_('x 4'),  2048.0*4.0, 512.0*4.0, 2048.0*4.0),
+            (_('x 5'),  2048.0*5.0, 512.0*5.0, 2048.0*5.0),
+            (_('Custom'),2048, 512, 2048),
+            ),
+        GmstTweak(_('Shell Litter Time'),
+            _("Time before shell cases fade away from cells."),
+            ('fGunShellLifetime',),
+            (_('[10 Seconds]'),10),
+            (_('20 Seconds'),20),
+            (_('30 Seconds'),30),
+            (_('1 Minute'),60),
+            (_('3 Minutes'),60*3),
+            (_('5 Minutes'),60*5),
+            (_('Custom (in seconds)'),10),
+            ),
+        GmstTweak(_('Shell Litter Count'),
+            _("Maximum number of debris (shell case, etc) allowed in cell."),
+            ('iDebrisMaxCount',),
+            (_('[50]'),50),
+            (_('100'),100),
+            (_('500'),500),
+            (_('1000'),1000),
+            (_('3000'),3000),
+            (_('Custom'),50),
+            ),
+        GmstTweak(_('Terminal Speed Adjustment'),
+            _("The display speed at the time of terminal hacking."),
+            ('iHackingDumpRate','iHackingInputRate','iHackingOutputRate','iHackingFlashOffDuration','iHackingFlashOnDuration','iComputersDisplayRateMenus','iComputersDisplayRateNotes'),
+            (_('x 2'),1000,40,134,250,375,300,300),
+            (_('x 4'),2000,80,268,125,188,600,600),
+            (_('[x 6]'),3000,120,402,83,126,900,900),
+            (_('Custom'),3000,120,402,83,126,900,900),
+            ),
+        GmstTweak(_('Drag: Max Moveable Weight'),
+            _("Maximum weight to be able move things with the drag key."),
+            ('fMoveWeightMax',),
+            (_('1500'),1500.0),
+            (_('[Default (150)]'),150),
+            (_('Custom'),150),
+            ),
+        ],key=lambda a: a.label.lower())
+    #--Patch Phase ------------------------------------------------------------
+    def getReadClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (None,(MreGmst,))[self.isActive]
 
-    #--Static------------------------------------------------------------------
-    @staticmethod
-    def getDefaultTags():
-        tags = {}
-        for fileName in ('Leveled Lists.csv','My Leveled Lists.csv'):
-            textPath = dirs['patches'].join(fileName)
-            if textPath.exists():
-                reader = bolt.CsvReader(textPath)
-                for fields in reader:
-                    if len(fields) < 2 or not fields[0] or fields[1] not in ('DR','R','D','RD',''): continue
-                    tags[GPath(fields[0])] = fields[1]
-                reader.close()
-        return tags
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (None,(MreGmst,))[self.isActive]
 
-    #--Config Phase -----------------------------------------------------------
-    def getChoice(self,item):
-        """Get default config choice."""
-        choice = self.configChoices.get(item)
-        if not isinstance(choice,set): choice = set(('Auto',))
-        if 'Auto' in choice:
-            if item in modInfos:
-                choice = set(('Auto',))
-                bashTags = modInfos[item].getBashTags()
-                for key in ('Delev','Relev'):
-                    if key in bashTags: choice.add(key)
-        self.configChoices[item] = choice
-        return choice
+    def scanModFile(self,modFile,progress):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        if not self.isActive or 'GMST' not in modFile.tops: return
+        mapper = modFile.getLongMapper()
+        patchRecords = self.patchFile.GMST
+        id_records = patchRecords.id_records
+        for record in modFile.GMST.getActiveRecords():
+            if mapper(record.fid) in id_records: continue
+            record = record.getTypeCopy(mapper)
+            patchRecords.setRecord(record)
 
-    def getItemLabel(self,item):
-        """Returns label for item to be used in list"""
-        choice = map(itemgetter(0),self.configChoices.get(item,tuple()))
-        if isinstance(item,bolt.Path): item = item.s
-        if choice:
-            return '%s [%s]' % (item,''.join(sorted(choice)))
-        else:
-            return item
+    def buildPatch(self,log,progress):
+        """Edits patch file as desired. Will write to log."""
+        if not self.isActive: return
+        keep = self.patchFile.getKeeper()
+        log.setHeader('= '+self.__class__.name)
+        for tweak in self.enabledTweaks:
+            tweak.buildPatch(self.patchFile,keep,log)
 
+class CBash_GmstTweaker(CBash_MultiTweaker):
+    """Tweaks miscellaneous gmsts in miscellaneous ways."""
+    name = _('Tweak Settings')
+    text = _("Tweak game settings.")
+    tweaks = sorted([
+        CBash_GmstTweak(_('Camera: Chase Distance'),
+            _("Distance camera can be moved away from PC using mouse wheel."),
+            ('fVanityModeWheelMax', 'fChase3rdPersonZUnitsPerSecond'),
+            (_('x 1.5'),600.0*1.5, 800.0*1.5),
+            (_('x 2'),  600.0*2.0, 800.0*2),
+            (_('x 3'),  600.0*3.0, 800.0*3),
+            (_('x 5'),  600.0*5.0, 800.0*5),
+            (_('x 10'), 600.0*10,  5000),
+            (_('Custom'),600,      800),
+            ),
+        CBash_GmstTweak(_('Compass: POI Recognition'),
+            _("Distance at which POI markers begin to show on compass."),
+            ('iMapMarkerVisibleDistance',),
+            (_('x 0.05'),1000),
+            (_('x 0.25'),5000),
+            (_('x 0.50'),10000),
+            (_('x 0.75'),15000),
+            (_('Custom (base 1200)'),1200),
+            ),
+        CBash_GmstTweak(_('Essential NPC Unconsciousness'),
+            _("Time which essential NPCs stay unconscious."),
+            ('fEssentialDeathTime',),
+            (_('[10 Seconds]'),10.0),
+            (_('20 Seconds'),20.0),
+            (_('30 Seconds'),30.0),
+            (_('1 Minute'),60.0),
+            (_('1 1/2 Minutes'),1.5*60.0),
+            (_('2 Minutes'),2*60.0),
+            (_('3 Minutes'),3*60.0),
+            (_('5 Minutes'),5*60.0),
+            (_('Custom (in seconds)'),10),
+            ),
+        CBash_GmstTweak(_('Jump Higher'),
+            _("Height player can jump to."),
+            ('fJumpHeightMin',),
+            (_('x 1.1'),64.0*1.1),
+            (_('x 1.2'),64.0*1.2),
+            (_('x 1.4'),64.0*1.4),
+            (_('x 1.6'),64.0*1.6),
+            (_('x 1.8'),64.0*1.8),
+            (_('x 2.0'),64.0*2.0),
+            (_('x 3.0'),64.0*3.0),
+            (_('Custom'),64),
+            ),
+        CBash_GmstTweak(_('Camera: PC Death Time'),
+            _("Time after player's death before reload menu appears."),
+            ('fPlayerDeathReloadTime',),
+            (_('15 Seconds'),15.0),
+            (_('30 Seconds'),30.0),
+            (_('1 Minute'),60.0),
+            (_('5 Minute'),300.0),
+            (_('Unlimited'),9999999.0),
+            (_('Custom'),15),
+            ),
+        CBash_GmstTweak(_('Cell Respawn Time'),
+            _("Time before unvisited cell respawns. But longer times increase save sizes."),
+            ('iHoursToRespawnCell',),
+            (_('1 Day'),24*1),
+            (_('[3 Days]'),24*3),
+            (_('5 Days'),24*5),
+            (_('10 Days'),24*10),
+            (_('20 Days'),24*20),
+            (_('1 Month'),24*30),
+            (_('6 Months'),24*182),
+            (_('1 Year'),24*365),
+            (_('Custom (in hours)'),72),
+            ),
+        CBash_GmstTweak(_('Cost Multiplier: Repair'),
+            _("Cost factor for repairing items."),
+            ('fItemRepairCostMult',),
+            ('1.0',1.0),
+            ('1.25',1.25),
+            ('1.5',1.5),
+            ('1.75',1.75),
+            ('[2.0]',2.0),
+            ('2.5',2.5),
+            ('3.0',3.0),
+            (_('Custom'),2.0),
+            ),
+        CBash_GmstTweak(_('Combat: Max Actors'),
+            _("Maximum number of actors that can actively be in combat with the player."),
+            ('iNumberActorsInCombatPlayer',),
+            ('[10]',10),
+            ('15',15),
+            ('20',20),
+            ('30',30),
+            ('40',40),
+            ('50',50),
+            ('80',80),
+            (_('Custom'),10),
+            ),
+        CBash_GmstTweak(_('AI: Max Active Actors'),
+            _("Maximum actors whose AI can be active. Must be higher than Combat: Max Actors"),
+            ('iAINumberActorsComplexScene',),
+            ('20',20),
+            ('[25]',25),
+            ('30',30),
+            ('35',35),
+            (_('MMM Default: 40'),40),
+            ('50',50),
+            ('60',60),
+            ('100',100),
+            (_('Custom'),25),
+            ),
+        CBash_GmstTweak(_('Companions: Max Number'),
+            _("Maximum number of actors following the player"),
+            ('iNumberActorsAllowedToFollowPlayer',),
+            ('2',2),
+            ('4',4),
+            ('[6]',6),
+            ('8',8),
+            ('10',10),
+            (_('Custom'),6),
+            ),
+        CBash_GmstTweak(_('AI: Max Dead Actors'),
+            _("Maximum number of dead actors allowed before they're removed."),
+            ('iRemoveExcessDeadCount', 'iRemoveExcessDeadTotalActorCount','iRemoveExcessDeadComplexTotalActorCount',
+             'iRemoveExcessDeadComplexCount', 'fRemoveExcessDeadTime','fRemoveExcessComplexDeadTime'),
+            (_('[x 1]'),int(15*1)  , int(20*1)  , int(20*1)  , int(3*1), 10.0*1.0, 2.5*1.0),
+            (_('x 1.5'),int(15*1.5), int(20*1.5), int(20*1.5), int(3*2), 10.0*3.0, 2.5*3.0),
+            (_('x 2'),  int(15*2)  , int(20*2)  , int(20*2)  , int(3*3), 10.0*5.0, 2.5*5.0),
+            (_('x 2.5'),int(15*2.5), int(20*2.5), int(20*2.5), int(3*4), 10.0*7.0, 2.5*7.0),
+            (_('x 3'),  int(15*3)  , int(20*3)  , int(20*3)  , int(3*5), 10.0*9.0, 2.5*9.0),
+            (_('x 3.5'),int(15*3.5), int(20*3.5), int(20*3.5), int(3*6), 10.0*11.0, 2.5*11.0),
+            (_('x 4'),  int(15*4)  , int(20*4)  , int(20*4)  , int(3*7), 10.0*13.0, 2.5*13.0),
+            (_('Custom'),15,20,20,3,10,2.5),
+            ),
+        CBash_GmstTweak(_('Inventory Quantity Prompt'),
+            _("Number of items in a stack at which point Fallout prompts for a quantity."),
+            ('iInventoryAskQuantityAt',),
+            ('1',1),
+            ('2',2),
+            ('[3]',3),
+            ('4',4),
+            ('10',10),
+            (_('No Prompt'),99999),
+            (_('Custom'),3),
+            ),
+        CBash_GmstTweak(_('Gore: Combat Dismember Part Chance'),
+            _("The chance that body parts will be dismembered."),
+            ('iCombatDismemberPartChance',),
+            ('0',0),
+            ('25',25),
+            ('[50]',50),
+            ('80',80),
+            ('100',100),
+            (_('Custom'),50),
+            ),
+        CBash_GmstTweak(_('Gore: Combat Explode Part Chance'),
+            _("The chance that body parts will be explode."),
+            ('iCombatExplodePartChance',),
+            ('0',0),
+            ('25',25),
+            ('50',50),
+            ('[75]',75),
+            ('100',100),
+            (_('Custom'),75),
+            ),
+        CBash_GmstTweak(_('Leveled Item Max level difference'),
+            _("Maximum difference to player level for leveled items."),
+            ('iLevItemLevelDifferenceMax',),
+            ('1',1),
+            ('5',5),
+            ('[8]',8),
+            ('10',10),
+            ('20',20),
+            (_('Unlimited'),9999),
+            (_('Custom'),8),
+            ),
+        CBash_GmstTweak(_('Movement Base Speed'),
+            _("Base Movement speed."),
+            ('fMoveBaseSpeed',),
+            ('[77.0]',77.0),
+            ('90.0',90.0),
+            (_('Custom'),77.0),
+            ),
+        CBash_GmstTweak(_('Movement Sneak Multiplier'),
+            _("Movement speed is multiplied by this when the actor is sneaking."),
+            ('fMoveSneakMult',),
+            ('[0.57]',0.57),
+            ('0.66',0.66),
+            (_('Custom'),0.57),
+            ),
+        CBash_GmstTweak(_('Combat: Player Damage Multiplier in VATS'),
+            _("Multiplier of damage that player receives in VATS."),
+            ('fVATSPlayerDamageMult',),
+            (_('0.10'),0.1),
+            (_('0.25'),0.25),
+            (_('0.50'),0.5),
+            (_('[0.75]'),0.75),
+            (_('1.00'),1.0),
+            (_('Custom'),0.75),
+            ),
+        CBash_GmstTweak(_('Combat: Auto Aim Fix'),
+            _("Increase Auto Aim settings to a level at which Snipers can benefit from them."),
+            ('fAutoAimMaxDistance', 'fAutoAimScreenPercentage', 'fAutoAimMaxDegrees', 'fAutoAimMissRatioLow', 'fAutoAimMissRatioHigh', 'fAutoAimMaxDegreesMiss'),
+            (_('Harder'),50000.00, -180.00, 1.10, 1.00, 1.30, 3.00),
+            ),
+        CBash_GmstTweak(_('PipBoy Light Keypress-Delay'),
+            _("Seconds of delay until the PipBoy Light switches on."),
+            ('fPlayerPipBoyLightTimer',),
+            (_('0.3'),0.3),
+            (_('0.4'),0.4),
+            (_('0.5'),0.5),
+            (_('0.6'),0.6),
+            (_('0.7'),0.7),
+            (_('[0.8]'),0.8),
+            (_('1.0'),1.0),
+            (_('Custom'),0.8),
+            ),
+        CBash_GmstTweak(_('VATS Playback Delay'),
+            _("Seconds of delay after the VATS Camera finished playback."),
+            ('fVATSPlaybackDelay',),
+            (_('0.01'),0.01),
+            (_('0.05'),0.05),
+            (_('0.10'),0.1),
+            (_('[0.17]'),0.17),
+            (_('0.25'),0.25),
+            (_('Custom'),0.17),
+            ),
+        CBash_GmstTweak(_('NPC-Death XP Threshold (Followers)'),
+            _("Percentage of total damage you have to inflict in order to get XP"),
+            ('iXPDeathRewardHealthThreshold',),
+            (_('0%'),0),
+            (_('25%'),25),
+            (_('[40%]'),40),
+            (_('50%'),50),
+            (_('75%'),75),
+            (_('Custom'),40),
+            ),
+        CBash_GmstTweak(_('Hacking: Maximum Number of words'),
+            _("The maximum number of words appearing in the terminal hacking mini-game."),
+            ('iHackingMaxWords',),
+            (_('1'),1),
+            (_('4'),4),
+            (_('8'),8),
+            (_('12'),12),
+            (_('16'),16),
+            (_('[20]'),20),
+            (_('Custom'),20),
+            ),
+        CBash_GmstTweak(_('Shell Camera Distance'),
+            _("Maximum distance at which gun arisings (shell case, particle, decal) show from camera."),
+            ('fGunParticleCameraDistance', 'fGunShellCameraDistance', 'fGunDecalCameraDistance'),
+            (_('x 1.5'),2048.0*1.5, 512.0*1.5, 2048.0*1.5),
+            (_('x 2'),  2048.0*2.0, 512.0*2.0, 2048.0*2.0),
+            (_('x 3'),  2048.0*3.0, 512.0*3.0, 2048.0*3.0),
+            (_('x 4'),  2048.0*4.0, 512.0*4.0, 2048.0*4.0),
+            (_('x 5'),  2048.0*5.0, 512.0*5.0, 2048.0*5.0),
+            (_('Custom'),2048, 512, 2048),
+            ),
+        CBash_GmstTweak(_('Shell Litter Time'),
+            _("Time before shell cases fade away from cells."),
+            ('fGunShellLifetime',),
+            (_('[10 Seconds]'),10),
+            (_('20 Seconds'),20),
+            (_('30 Seconds'),30),
+            (_('1 Minute'),60),
+            (_('3 Minutes'),60*3),
+            (_('5 Minutes'),60*5),
+            (_('Custom (in seconds)'),10),
+            ),
+        CBash_GmstTweak(_('Shell Litter Count'),
+            _("Maximum number of debris (shell case, etc) allowed in cell."),
+            ('iDebrisMaxCount',),
+            (_('[50]'),50),
+            (_('100'),100),
+            (_('500'),500),
+            (_('1000'),1000),
+            (_('3000'),3000),
+            (_('Custom'),50),
+            ),
+        CBash_GmstTweak(_('Terminal Speed Adjustment'),
+            _("The display speed at the time of terminal hacking."),
+            ('iHackingDumpRate','iHackingInputRate','iHackingOutputRate','iHackingFlashOffDuration','iHackingFlashOnDuration','iComputersDisplayRateMenus','iComputersDisplayRateNotes'),
+            (_('x 2'),1000,40,134,250,375,300,300),
+            (_('x 4'),2000,80,268,125,188,600,600),
+            (_('[x 6]'),3000,120,402,83,126,900,900),
+            (_('Custom'),3000,120,402,83,126,900,900),
+            ),
+        CBash_GmstTweak(_('Drag: Max Moveable Weight'),
+            _("Maximum weight to be able move things with the drag key."),
+            ('fMoveWeightMax',),
+            (_('1500'),1500.0),
+            (_('[Default (150)]'),150),
+            (_('Custom'),150),
+            ),
+        ],key=lambda a: a.label.lower())
+    #--Config Phase ------------------------------------------------------------
     def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = True
-        self.id_delevs = {}
-        self.id_list = {}
-        self.id_attrs = {}
-        self.mod_count = {}
-        self.empties = set()
-        importMods = set(self.srcs) & set(loadMods)
-        OverhaulCompat = False
-        OOOMods = set([GPath("Oscuro's_Oblivion_Overhaul.esm"),GPath("Oscuro's_Oblivion_Overhaul.esp")])
-        FransMods = set([GPath("Francesco's Leveled Creatures-Items Mod.esm"),GPath("Francesco.esp")])
-        WCMods = set([GPath("Oblivion Warcry.esp"),GPath("Oblivion Warcry EV.esp")])
-        TIEMods = set([GPath("TIE.esp")])
-        if GPath("Unofficial Oblivion Patch.esp") in importMods:
-            if (OOOMods|WCMods) & importMods:
-                OverhaulCompat = True
-            elif FransMods & importMods:
-                if TIEMods & importMods:
-                    pass
-                else:
-                    OverhaulCompat = True
-        if OverhaulCompat:
-            self.OverhaulUOPSkips = set([
-                (GPath('Oblivion.esm'),x) for x in [
-                    0x03AB5D,   # VendorWeaponBlunt
-                    0x03C7F1,   # LL0LootWeapon0Magic4Dwarven100
-                    0x03C7F2,   # LL0LootWeapon0Magic7Ebony100
-                    0x03C7F3,   # LL0LootWeapon0Magic5Elven100
-                    0x03C7F4,   # LL0LootWeapon0Magic6Glass100
-                    0x03C7F5,   # LL0LootWeapon0Magic3Silver100
-                    0x03C7F7,   # LL0LootWeapon0Magic2Steel100
-                    0x03E4D2,   # LL0NPCWeapon0MagicClaymore100
-                    0x03E4D3,   # LL0NPCWeapon0MagicClaymoreLvl100
-                    0x03E4DA,   # LL0NPCWeapon0MagicWaraxe100
-                    0x03E4DB,   # LL0NPCWeapon0MagicWaraxeLvl100
-                    0x03E4DC,   # LL0NPCWeapon0MagicWarhammer100
-                    0x03E4DD,   # LL0NPCWeapon0MagicWarhammerLvl100
-                    0x0733EA,   # ArenaLeveledHeavyShield,
-                    0x0C7615,   # FGNPCWeapon0MagicClaymoreLvl100
-                    0x181C66,   # SQ02LL0NPCWeapon0MagicClaymoreLvl100
-                    0x053877,   # LL0NPCArmor0MagicLightGauntlets100
-                    0x053878,   # LL0NPCArmor0MagicLightBoots100
-                    0x05387A,   # LL0NPCArmor0MagicLightCuirass100
-                    0x053892,   # LL0NPCArmor0MagicLightBootsLvl100
-                    0x053893,   # LL0NPCArmor0MagicLightCuirassLvl100
-                    0x053894,   # LL0NPCArmor0MagicLightGauntletsLvl100
-                    0x053D82,   # LL0LootArmor0MagicLight5Elven100
-                    0x053D83,   # LL0LootArmor0MagicLight6Glass100
-                    0x052D89,   # LL0LootArmor0MagicLight4Mithril100
-                    ]
-                ])
-        else:
-            self.OverhaulUOPSkips = set()
+        self.patchFile = patchFile
+        for tweak in self.tweaks:
+            tweak.patchFile = patchFile
+            tweak.eid_count = {}
 
-    def getTypes(self):
-        return ['LVLC','LVLI','LVSP']
     #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        recordId = record.fid
-        if recordId in self.OverhaulUOPSkips and modFile.GName == GPath('Unofficial Oblivion Patch.esp'):
-            return
-        if recordId not in self.id_list:
-            #['level', 'listId', 'count']
-            self.id_list[recordId] = record.entries_list #[(entry.listId, entry.level, entry.count) for entry in record.entries]
-            self.id_attrs[recordId] = [record.chanceNone, record.script, record.template, (record.flags or 0)]
-        else:
-            mergedList = self.id_list[recordId]
-            configChoice = self.configChoices.get(modFile.GName,tuple())
-            isRelev = 'Relev' in configChoice
-            isDelev = 'Delev' in configChoice
-            delevs = self.id_delevs.setdefault(recordId, set())
-            curItems = set([entry.listId for entry in record.entries])
-            if isRelev:
-                #Can add and set the level/count of items, but not delete items
-                #Ironically, the first step is to delete items that the list will add right back
-                #This is an easier way to update level/count than actually checking if they need changing
-
-                #Filter out any records that may have their level/count updated
-                mergedList = [entry for entry in mergedList if entry[1] not in curItems] #entry[1] = listId
-                #Add any new records as well as any that were filtered out
-                mergedList += record.entries_list
-                #Remove the added items from the deleveled list
-                delevs -= curItems
-                self.id_attrs[recordId] = [record.chanceNone, record.script, record.template, (record.flags or 0)]
-            else:
-                #Can add new items, but can't change existing ones
-                items = set([entry[1] for entry in mergedList]) #entry[1] = listId
-                mergedList += [entry for entry in record.entries_list if entry[1] not in items] #entry[1] = listId
-                mergedAttrs = self.id_attrs[recordId]
-                self.id_attrs[recordId] = [record.chanceNone or mergedAttrs[0], record.script or mergedAttrs[1], record.template or mergedAttrs[2], (record.flags or 0) | mergedAttrs[3]]
-            #--Delevs: all items in masters minus current items
-            if isDelev:
-                deletedItems = set([entry.listId for master in record.History() for entry in master.entries]) - curItems
-                delevs |= deletedItems
-
-            #Remove any items that were deleveled
-            mergedList = [entry for entry in mergedList if entry[1] not in delevs] #entry[1] = listId
-            self.id_list[recordId] = mergedList
-            self.id_delevs[recordId] = delevs
+    def buildPatchLog(self,log):
+        """Will write to log."""
+        if not self.isActive: return
+        log.setHeader('= '+self.__class__.name,True)
+        for tweak in self.enabledTweaks:
+            tweak.buildPatchLog(log)
 
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        recordId = record.fid
-        merged = recordId in self.id_list
-        if merged:
-            self.scan(modFile,record,bashTags)
-            mergedList = self.id_list[recordId]
-            mergedAttrs = self.id_attrs[recordId]
-            newList = record.entries_list
-            newAttrs = [record.chanceNone, record.script, record.template, (record.flags or 0)]
-        #Can't tell if any sublists are actually empty until they've all been processed/merged
-        #So every level list gets copied into the patch, so that they can be checked after the regular patch process
-        #They'll get deleted from the patch there as needed.
-        override = record.CopyAsOverride(self.patchFile)
-        if override:
-            record.UnloadRecord()
-            record._ModID, record._RecordID = override._ModID, override._RecordID
-            if merged and (sorted(newList, key=itemgetter(1)) != sorted(mergedList, key=itemgetter(1)) or newAttrs != mergedAttrs):
-                mod_count = self.mod_count
-                mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                override.chanceNone, override.script, override.template, override.flags = mergedAttrs
-                try:
-                    override.entries_list = mergedList
-                except:
-                    newMergedList = []
-                    for entry in mergedList:
-                        fid = entry[1]
-                        if not fid:
-                            deprint("WARNING: LeveledList with FormID ('%s',%06X) in '%s' has a malformed entry %s." % (record.fid[0],record.fid[1],record.GName,fid))
-                            continue
-                        if fid[0] == None: continue
-                        newMergedList.append(entry)
-                    override.entries_list = newMergedList
+#------------------------------------------------------------------------------
+class NamesTweak_BodyTags(MultiTweakItem):
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("Body Part Codes"),
+            _('Sets body part codes used by Armor/Clothes name tweaks. H: Head, A: Armor, etc.'),
+            'bodyTags',
+            ('HAGPBFE','HAGPBFE'),
+            ('HBGPEFE','HBGPEFE'),
+            )
 
-    def finishPatch(self,patchFile, progress):
-        """Edits the bashed patch file directly."""
-        if self.empties is None: return
-        subProgress = SubProgress(progress)
-        subProgress.setFull(len(self.getTypes()))
-        pstate = 0
-        #Clean up any empty sublists
-        empties = self.empties
-        emptiesAdd = empties.add
-        emptiesDiscard = empties.discard
-        for type in self.getTypes():
-            subProgress(pstate, _("Looking for empty %s sublists...\n") % type)
-            #Remove any empty sublists
-            madeChanges = True
-            while madeChanges:
-                madeChanges = False
-                oldEmpties = empties.copy()
-                for record in getattr(patchFile,type):
-                    recordId = record.fid
-                    items = set([entry.listId for entry in record.entries])
-                    if items:
-                        emptiesDiscard(recordId)
-                    else:
-                        emptiesAdd(recordId)
-                    toRemove = empties & items
-                    if toRemove:
-                        madeChanges = True
-                        cleanedEntries = [entry for entry in record.entries if entry.listId not in toRemove]
-                        record.entries = cleanedEntries
-                        if cleanedEntries:
-                            emptiesDiscard(recordId)
-                        else:
-                            emptiesAdd(recordId)
-                if oldEmpties != empties:
-                    oldEmpties = empties.copy()
-                    madeChanges = True
-
-            #Remove any identical to master lists, except those that were merged into the patch
-            for record in getattr(patchFile,type):
-                conflicts = record.Conflicts()
-                numConflicts = len(conflicts)
-                if numConflicts:
-                    curConflict = 1 #Conflict at 0 will be the patchfile. No sense comparing it to itself.
-                    #Find the first conflicting record that wasn't merged
-                    while curConflict < numConflicts:
-                        prevRecord = conflicts[curConflict]
-                        if prevRecord.GName not in patchFile.mergeSet:
-                            break
-                        curConflict += 1
-                    else:
-                        continue
-                    #If the record in the patchfile matches the previous non-merged record, delete it.
-                    #Ordering doesn't matter, hence the conversion to sets
-                    if set(prevRecord.entries_list) == set(record.entries_list) and [record.chanceNone, record.script, record.template, record.flags] == [prevRecord.chanceNone, prevRecord.script, prevRecord.template, prevRecord.flags]:
-                        record.DeleteRecord()
-            pstate += 1
-        self.empties = None
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return tuple()
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Modified LVL: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
-
-#------------------------------------------------------------------------------
-class MFactMarker(SpecialPatcher,ListPatcher):
-    """Mark factions that player can acquire while morphing."""
-    name = _('Morph Factions')
-    text = _("Mark factions that player can acquire while morphing.\n\nRequires Cobl 1.28 and Wrye Morph or similar.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = 'MFact'
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return tuple()
 
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.id_info = {} #--Morphable factions keyed by fid
-        self.srcFiles = self.getConfigChecked()
-        self.isActive = bool(self.srcFiles) and GPath("Cobl Main.esm") in modInfos.ordered
-        self.mFactLong = (GPath("Cobl Main.esm"),0x33FB)
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        return
 
-    def initData(self,progress):
-        """Get names from source files."""
-        if not self.isActive: return
-        aliases = self.patchFile.aliases
-        id_info = self.id_info
-        for srcFile in self.srcFiles:
-            textPath = dirs['patches'].join(srcFile)
-            if not textPath.exists(): continue
-            ins = bolt.CsvReader(textPath)
-            for fields in ins:
-                if len(fields) < 6 or fields[1][:2] != '0x':
-                    continue
-                mod,objectIndex = fields[:2]
-                mod = GPath(mod)
-                longid = (aliases.get(mod,mod),int(objectIndex,0))
-                morphName = fields[4].strip()
-                rankName = fields[5].strip()
-                if not morphName: continue
-                if not rankName: rankName = _('Member')
-                id_info[longid] = (morphName,rankName)
-            ins.close()
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        patchFile.bodyTags = self.choiceValues[self.chosen][0]
+# class CBash_NamesTweak_BodyTags(CBash_MultiTweakItem):
+#     scanOrder = 32
+#     editOrder = 32
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Body Part Codes"),
+#             _('Sets body part codes used by Armor/Clothes name tweaks. H: Head, A: Armor, etc.'),
+#             'bodyTags',
+#             ('HAGPBFE','HAGPBFE'),
+#             ('HBGPEFE','HBGPEFE'),
+#             )
+
+#     def getTypes(self):
+#         return []
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         pass
+#------------------------------------------------------------------------------
+class NamesTweak_Body(MultiTweakItem):
+    """Names tweaker for armor and clothes."""
 
+    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (None,(MreFact,))[self.isActive]
+        return (MreRecord.type_class[self.key],)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (None,(MreFact,))[self.isActive]
+        return (MreRecord.type_class[self.key],)
 
-    def scanModFile(self, modFile, progress):
-        """Scan modFile."""
-        if not self.isActive: return
-        id_info = self.id_info
-        modName = modFile.fileInfo.name
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
         mapper = modFile.getLongMapper()
-        patchBlock = self.patchFile.FACT
-        if modFile.fileInfo.name == GPath("Cobl Main.esm"):
-            modFile.convertToLongFids(('FACT',))
-            record = modFile.FACT.getRecord(self.mFactLong)
-            if record:
-                patchBlock.setRecord(record.getTypeCopy())
-        for record in modFile.FACT.getActiveRecords():
-            fid = record.fid
-            if not record.longFids: fid = mapper(fid)
-            if fid in id_info:
-                patchBlock.setRecord(record.getTypeCopy(mapper))
+        patchBlock = getattr(patchFile,self.key)
+        id_records = patchBlock.id_records
+        for record in getattr(modFile,self.key).getActiveRecords():
+            if record.full and mapper(record.fid) not in id_records:
+                record = record.getTypeCopy(mapper)
+                patchBlock.setRecord(record)
 
-    def buildPatch(self,log,progress):
-        """Make changes to patchfile."""
-        if not self.isActive: return
-        mFactLong = self.mFactLong
-        id_info = self.id_info
-        modFile = self.patchFile
-        keep = self.patchFile.getKeeper()
-        changed = {}
-        mFactable = []
-        for record in modFile.FACT.getActiveRecords():
-            if record.fid not in id_info: continue
-            if record.fid == mFactLong: continue
-            mFactable.append(record.fid)
-            #--Update record if it doesn't have an existing relation with mFactLong
-            if mFactLong not in [relation.faction for relation in record.relations]:
-                record.flags.hiddenFromPC = False
-                relation = record.getDefault('relations')
-                relation.faction = mFactLong
-                relation.mod = 10
-                record.relations.append(relation)
-                mname,rankName = id_info[record.fid]
-                record.full = mname
-                if not record.ranks:
-                    record.ranks = [record.getDefault('ranks')]
-                for rank in record.ranks:
-                    if not rank.male: rank.male = rankName
-                    if not rank.female: rank.female = rank.male
-                    if not rank.insigniaPath:
-                        rank.insigniaPath = r'Menus\Stats\Cobl\generic%02d.dds' % rank.rank
-                keep(record.fid)
-                mod = record.fid[0]
-                changed[mod] = changed.setdefault(mod,0) + 1
-        #--MFact record
-        record = modFile.FACT.getRecord(mFactLong)
-        if record:
-            relations = record.relations
-            del relations[:]
-            for faction in mFactable:
-                relation = record.getDefault('relations')
-                relation.faction = faction
-                relation.mod = 10
-                relations.append(relation)
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        count = {}
+        format = self.choiceValues[self.chosen][0]
+        showStat = '%02d' in format
+        keep = patchFile.getKeeper()
+        codes = getattr(patchFile,'bodyTags','HAGPBFE')
+        head,body,gloves,pipboy,backpack,fancy,accessory = [
+            x for x in codes]
+        for record in getattr(patchFile,self.key).records:
+            if not record.full: continue
+            if record.full[0] in '+-=()[]<>': continue
+            flags = record.bipedFlags
+            if flags.upperBody: type = body
+            elif flags.head or flags.hair or flags.headband or flags.hat: type = head
+            elif flags.leftHand or flags.rightHand: type = gloves
+            elif flags.necklace or flags.eyeGlasses or flags.noseRing or flags.earrings or flags.mask or flags.choker or flags.mouthObject: type = fancy
+            elif flags.backpack: type = backpack
+            elif flags.bodyAddOn1 or flags.bodyAddOn2 or flags.bodyAddOn3: type = accessory
+            elif flags.pipboy: type = pipboy
+            else: continue
+            if record.recType == 'ARMO':
+                if record.generalFlags.powerArmor: type += 'P'
+                if record.generalFlags.heavyArmor: type += 'H'
+            if showStat:
+                record.full = format % (type,record.ar/100) + record.full
+            else:
+                record.full = format % type + record.full
             keep(record.fid)
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcFiles:
-            log("* " +file.s)
-        log(_("\n=== Morphable Factions"))
-        for mod in sorted(changed):
-            log("* %s: %d" % (mod.s,changed[mod]))
-
-class CBash_MFactMarker(SpecialPatcher,CBash_ListPatcher):
-    """Mark factions that player can acquire while morphing."""
-    name = _('Morph Factions')
-    text = _("Mark factions that player can acquire while morphing.\n\nRequires Cobl 1.28 and Wrye Morph or similar.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('MFact',))
-    unloadedText = ""
-
+            srcMod = record.fid[0]
+            count[srcMod] = count.get(srcMod,0) + 1
+        #--Log
+        log(_('* %s: %d') % (self.label,sum(count.values())))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_NamesTweak_Body(CBash_MultiTweakItem):
+#     """Names tweaker for armor and clothes."""
+#     scanOrder = 32
+#     editOrder = 32
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self,label,tip,key,*choices):
+#         CBash_MultiTweakItem.__init__(self,label,tip,key,*choices)
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return [self.key]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsNonPlayable: return
+#         newFull = record.full
+#         if newFull:
+#             if record.IsHead or record.IsHair: type = self.head
+#             elif record.IsRightRing or record.IsLeftRing: type = self.ring
+#             elif record.IsAmulet: type = self.amulet
+#             elif record.IsUpperBody and record.IsLowerBody: type = self.robe
+#             elif record.IsUpperBody: type = self.chest
+#             elif record.IsLowerBody: type = self.pants
+#             elif record.IsHand: type = self.gloves
+#             elif record.IsFoot: type = self.shoes
+#             elif record.IsTail: type = self.tail
+#             elif record.IsShield: type = self.shield
+#             else: return
+#             if record._Type == 'ARMO':
+#                 type += 'LH'[record.IsHeavyArmor]
+#             if self.showStat:
+#                 newFull = self.format % (type,record.strength/100) + newFull
+#             else:
+#                 newFull = self.format % type + newFull
+#             if record.full != newFull:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.full = newFull
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* %s Renamed: %d') % (self.key,sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+class NamesTweak_Potions(MultiTweakItem):
     #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        if not self.isActive: return
-        self.cobl = GPath('Cobl Main.esm')
-        self.isActive = self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.27
-        self.id_info = {} #--Morphable factions keyed by fid
-        self.mFactLong = (self.cobl,0x33FB)
-        self.mod_count = {}
-        self.mFactable = set()
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-             type_patchers.setdefault(type,[]).append(self)
-        progress.setFull(len(self.srcs))
-        for srcFile in self.srcs:
-            srcPath = GPath(srcFile)
-            patchesDir = dirs['patches'].list()
-            if srcPath not in patchesDir: continue
-            self.readFromText(dirs['patches'].join(srcFile))
-            progress.plus()
-
-    def getTypes(self):
-        return ['FACT']
-
-    def readFromText(self,textPath):
-        """Imports id_info from specified text file."""
-        aliases = self.patchFile.aliases
-        id_info = self.id_info
-        textPath = GPath(textPath)
-        if not textPath.exists(): return
-        ins = bolt.CsvReader(textPath)
-        for fields in ins:
-            if len(fields) < 6 or fields[1][:2] != '0x':
-                continue
-            mod,objectIndex = fields[:2]
-            mod = GPath(mod)
-            longid = (aliases.get(mod,mod),int(objectIndex,0))
-            morphName = fields[4].strip()
-            rankName = fields[5].strip()
-            if not morphName: continue
-            if not rankName: rankName = _('Member')
-            id_info[longid] = (morphName,rankName)
-        ins.close()
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("Ingestibles"),
+            _('Label ingestibles to sort by type. C: Chems, F: Food, S: Stimpack, A: Alcohol.'),
+            'ALCH',
+            (_('F Radroach Meat'),  '%s '),
+            (_('F. Radroach Meat'), '%s. '),
+            (_('F - Radroach Meat'),'%s - '),
+            (_('(F) Radroach Meat'),'(%s) '),
+            )
 
+    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        id_info = self.id_info
-        recordId = record.fid
-        mFactLong = self.mFactLong
-        if recordId in id_info and recordId != mFactLong:
-            self.mFactable.add(recordId)
-            if mFactLong not in [relation.faction for relation in record.relations]:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.IsHiddenFromPC = False
-                    relation = override.create_relation()
-                    relation.faction = mFactLong
-                    relation.mod = 10
-                    mname,rankName = id_info[recordId]
-                    override.full = mname
-                    ranks = override.ranks
-                    if not ranks:
-                        ranks = [override.create_rank()]
-                    for rank in ranks:
-                        if not rank.male: rank.male = rankName
-                        if not rank.female: rank.female = rank.male
-                        if not rank.insigniaPath:
-                            rank.insigniaPath = r'Menus\Stats\Cobl\generic%02d.dds' % rank.rank
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def finishPatch(self,patchFile,progress):
-        """Edits the bashed patch file directly."""
-        mFactable = self.mFactable
-        if not mFactable: return
-        subProgress = SubProgress(progress)
-        subProgress.setFull(max(len(mFactable),1))
-        pstate = 0
-        try:
-            coblMod = patchFile.ObCollection.LookupModFile(self.cobl.s)
-        except KeyError, error:
-            print "CBash_MFactMarker:finishPatch"
-            print error[0]
-            return
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreAlch,)
 
-        record = coblMod.LookupRecord(self.mFactLong)
-        if record.recType != 'FACT':
-            print PrintFormID(mFactLong)
-            print patchFile.ObCollection.Debug_DumpModFiles()
-            print record
-            raise StateError(_("Cobl Morph Factions: Unable to lookup morphable faction record in Cobl Main.esm!"))
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreAlch,)
 
-        override = record.CopyAsOverride(patchFile)
-        if override:
-            override.relations = None
-            pstate = 0
-            for faction in mFactable:
-                subProgress(pstate, _("Marking Morphable Factions...\n"))
-                relation = override.create_relation()
-                relation.faction = faction
-                relation.mod = 10
-                pstate += 1
-        mFactable.clear()
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        patchBlock = patchFile.ALCH
+        id_records = patchBlock.id_records
+        for record in modFile.ALCH.getActiveRecords():
+            if mapper(record.fid) in id_records: continue
+            record = record.getTypeCopy(mapper)
+            patchBlock.setRecord(record)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        count = {}
+        format = self.choiceValues[self.chosen][0]
+        keep = patchFile.getKeeper()
+        for record in patchFile.ALCH.records:
+            if not record.full: continue
+            if record.full[0] in '+-=()[]<>': continue
+            if not record.etype in range(10,14): continue
+            label = 'CSFA'[record.etype-10]
+            record.full = format % label + record.full
+            keep(record.fid)
+            srcMod = record.fid[0]
+            count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        mod_count = self.mod_count
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods/Files"))
-        for file in self.srcs:
-            log("* " +file.s)
-        log(_("\n=== Morphable Factions"))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log("* %s: %d" % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+        log(_('* %s: %d') % (self.label,sum(count.values())))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_NamesTweak_Potions(CBash_MultiTweakItem):
+#     """Names tweaker for potions."""
+#     scanOrder = 32
+#     editOrder = 32
+#     reOldLabel = re.compile('^(-|X) ')
+#     reOldEnd = re.compile(' -$')
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Potions"),
+#             _('Label potions to sort by type and effect.'),
+#             'ALCH',
+#             (_('XD Illness'),  '%s '),
+#             (_('XD. Illness'), '%s. '),
+#             (_('XD - Illness'),'%s - '),
+#             (_('(XD) Illness'),'(%s) '),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['ALCH']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+
+#         newFull = record.full
+#         if newFull:
+#             mgef_school = self.patchFile.mgef_school
+#             hostileEffects = self.patchFile.hostileEffects
+#             school = 6 #--Default to 6 (U: unknown)
+#             for index,effect in enumerate(record.effects):
+#                 effectId = effect.name
+#                 if index == 0:
+#                     if effect.script:
+#                         school = effect.school
+#                     else:
+#                         school = mgef_school.get(effectId,6)
+#                 #--Non-hostile effect?
+#                 if effect.script:
+#                     if not effect.IsHostile:
+#                         isPoison = False
+#                         break
+#                 elif effectId not in hostileEffects:
+#                     isPoison = False
+#                     break
+#             else:
+#                 isPoison = True
+#             newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
+#             newFull = self.reOldEnd.sub('',newFull)
+#             if record.IsFood:
+#                 newFull = '.' + newFull
+#             else:
+#                 label = ('','X')[isPoison] + 'ACDIMRU'[school]
+#                 newFull = self.format % label + newFull
+
+#             if record.full != newFull:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.full = newFull
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* %s Renamed: %d') % (self.key,sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class NamesTweak_Scrolls(MultiTweakItem):
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Notes and Scrolls"),
+#             _('Mark notes and scrolls to sort separately from books'),
+#             'scrolls',
+#             (_('~Fire Ball'),  '~'),
+#             (_('~D Fire Ball'),  '~%s '),
+#             (_('~D. Fire Ball'), '~%s. '),
+#             (_('~D - Fire Ball'),'~%s - '),
+#             (_('~(D) Fire Ball'),'~(%s) '),
+#             ('----','----'),
+#             (_('.Fire Ball'),  '.'),
+#             (_('.D Fire Ball'),  '.%s '),
+#             (_('.D. Fire Ball'), '.%s. '),
+#             (_('.D - Fire Ball'),'.%s - '),
+#             (_('.(D) Fire Ball'),'.(%s) '),
+#             )
+
+#     #--Config Phase -----------------------------------------------------------
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         MultiTweakItem.saveConfig(self,configs)
+#         rawFormat = self.choiceValues[self.chosen][0]
+#         self.orderFormat = ('~.','.~')[rawFormat[0] == '~']
+#         self.magicFormat = rawFormat[1:]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreBook,MreEnch,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreBook,MreEnch)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         #--Scroll Enchantments
+#         if self.magicFormat:
+#             patchBlock = patchFile.ENCH
+#             id_records = patchBlock.id_records
+#             for record in modFile.ENCH.getActiveRecords():
+#                 if mapper(record.fid) in id_records: continue
+#                 if record.itemType == 0:
+#                     record = record.getTypeCopy(mapper)
+#                     patchBlock.setRecord(record)
+#         #--Books
+#         patchBlock = patchFile.BOOK
+#         id_records = patchBlock.id_records
+#         for record in modFile.BOOK.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.flags.isScroll and not record.flags.isFixed:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
+#         orderFormat, magicFormat = self.orderFormat, self.magicFormat
+#         keep = patchFile.getKeeper()
+#         id_ench = patchFile.ENCH.id_records
+#         mgef_school = patchFile.getMgefSchool()
+#         for record in patchFile.BOOK.records:
+#             if not record.full or not record.flags.isScroll or record.flags.isFixed: continue
+#             #--Magic label
+#             isEnchanted = bool(record.enchantment)
+#             if magicFormat and isEnchanted:
+#                 school = 6 #--Default to 6 (U: unknown)
+#                 enchantment = id_ench.get(record.enchantment)
+#                 if enchantment and enchantment.effects:
+#                     effect = enchantment.effects[0]
+#                     effectId = effect.name
+#                     if effect.scriptEffect:
+#                         school = effect.scriptEffect.school
+#                     else:
+#                         school = mgef_school.get(effectId,6)
+#                 record.full = reOldLabel.sub('',record.full) #--Remove existing label
+#                 record.full = magicFormat % 'ACDIMRU'[school] + record.full
+#             #--Ordering
+#             record.full = orderFormat[isEnchanted] + record.full
+#             keep(record.fid)
+#             srcMod = record.fid[0]
+#             count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log(_('* %s: %d') % (self.label,sum(count.values())))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_NamesTweak_Scrolls(CBash_MultiTweakItem):
+#     """Names tweaker for scrolls."""
+#     scanOrder = 32
+#     editOrder = 32
+#     reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Notes and Scrolls"),
+#             _('Mark notes and scrolls to sort separately from books'),
+#             'scrolls',
+#             (_('~Fire Ball'),  '~'),
+#             (_('~D Fire Ball'),  '~%s '),
+#             (_('~D. Fire Ball'), '~%s. '),
+#             (_('~D - Fire Ball'),'~%s - '),
+#             (_('~(D) Fire Ball'),'~(%s) '),
+#             ('----','----'),
+#             (_('.Fire Ball'),  '.'),
+#             (_('.D Fire Ball'),  '.%s '),
+#             (_('.D. Fire Ball'), '.%s. '),
+#             (_('.D - Fire Ball'),'.%s - '),
+#             (_('.(D) Fire Ball'),'.(%s) '),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['BOOK']
+
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         CBash_MultiTweakItem.saveConfig(self,configs)
+#         rawFormat = self.choiceValues[self.chosen][0]
+#         self.orderFormat = ('~.','.~')[rawFormat[0] == '~']
+#         self.magicFormat = rawFormat[1:]
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+
+#         newFull = record.full
+#         if newFull and record.IsScroll and not record.IsFixed:
+#             #--Magic label
+#             isEnchanted = bool(record.enchantment)
+#             magicFormat = self.magicFormat
+#             if magicFormat and isEnchanted:
+#                 school = 6 #--Default to 6 (U: unknown)
+#                 enchantment = record.enchantment
+#                 if enchantment:
+#                     enchantment = self.patchFile.ObCollection.LookupRecords(enchantment)
+#                     if enchantment:
+#                         #Get the winning record
+#                         enchantment = enchantment[0]
+#                         Effects = enchantment.effects
+#                     else:
+#                         Effects = None
+#                     if Effects:
+#                         effect = Effects[0]
+#                         if effect.script:
+#                             school = effect.school
+#                         else:
+#                             school = self.patchFile.mgef_school.get(effect.name,6)
+#                 newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
+#                 newFull = magicFormat % 'ACDIMRU'[school] + newFull
+#             #--Ordering
+#             newFull = self.orderFormat[isEnchanted] + newFull
+
+#             if record.full != newFull:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.full = newFull
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class NamesTweak_Spells(MultiTweakItem):
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Spells"),
+#             _('Label spells to sort by school and level.'),
+#             'SPEL',
+#             (_('Fire Ball'),  'NOTAGS'),
+#             ('----','----'),
+#             (_('D Fire Ball'),  '%s '),
+#             (_('D. Fire Ball'), '%s. '),
+#             (_('D - Fire Ball'),'%s - '),
+#             (_('(D) Fire Ball'),'(%s) '),
+#             ('----','----'),
+#             (_('D2 Fire Ball'),  '%s%d '),
+#             (_('D2. Fire Ball'), '%s%d. '),
+#             (_('D2 - Fire Ball'),'%s%d - '),
+#             (_('(D2) Fire Ball'),'(%s%d) '),
+#             )
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreSpel,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreSpel,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchBlock = patchFile.SPEL
+#         id_records = patchBlock.id_records
+#         for record in modFile.SPEL.getActiveRecords():
+#             if mapper(record.fid) in id_records: continue
+#             if record.spellType == 0:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         format = self.choiceValues[self.chosen][0]
+#         removeTags = '%s' not in format
+#         showLevel = '%d' in format
+#         keep = patchFile.getKeeper()
+#         reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
+#         mgef_school = patchFile.getMgefSchool()
+#         for record in patchFile.SPEL.records:
+#             if record.spellType != 0 or not record.full: continue
+#             school = 6 #--Default to 6 (U: unknown)
+#             if record.effects:
+#                 effect = record.effects[0]
+#                 effectId = effect.name
+#                 if effect.scriptEffect:
+#                     school = effect.scriptEffect.school
+#                 else:
+#                     school = mgef_school.get(effectId,6)
+#             newFull = reOldLabel.sub('',record.full) #--Remove existing label
+#             if not removeTags:
+#                 if showLevel:
+#                     newFull = format % ('ACDIMRU'[school],record.level) + newFull
+#                 else:
+#                     newFull = format % 'ACDIMRU'[school] + newFull
+#             if newFull != record.full:
+#                 record.full = newFull
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log(_('* %s: %d') % (self.label,sum(count.values())))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_NamesTweak_Spells(CBash_MultiTweakItem):
+#     """Names tweaker for spells."""
+#     scanOrder = 32
+#     editOrder = 32
+#     reOldLabel = re.compile('^(\([ACDIMR]\d\)|\w{3,6}:) ')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Spells"),
+#             _('Label spells to sort by school and level.'),
+#             'SPEL',
+#             (_('Fire Ball'),  'NOTAGS'),
+#             ('----','----'),
+#             (_('D Fire Ball'),  '%s '),
+#             (_('D. Fire Ball'), '%s. '),
+#             (_('D - Fire Ball'),'%s - '),
+#             (_('(D) Fire Ball'),'(%s) '),
+#             ('----','----'),
+#             (_('D2 Fire Ball'),  '%s%d '),
+#             (_('D2. Fire Ball'), '%s%d. '),
+#             (_('D2 - Fire Ball'),'%s%d - '),
+#             (_('(D2) Fire Ball'),'(%s%d) '),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['SPEL']
+
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         CBash_MultiTweakItem.saveConfig(self,configs)
+#         self.format = self.choiceValues[self.chosen][0]
+#         self.removeTags = '%s' not in self.format
+#         self.showLevel = '%d' in self.format
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         newFull = record.full
+#         if newFull and record.IsSpell:
+#             #--Magic label
+#             school = 6 #--Default to 6 (U: unknown)
+#             Effects = record.effects
+#             if Effects:
+#                 effect = Effects[0]
+#                 if effect.script:
+#                     school = effect.school
+#                 else:
+#                     school = self.patchFile.mgef_school.get(effect.name,6)
+#             newFull = self.reOldLabel.sub('',newFull) #--Remove existing label
+#             if not self.removeTags:
+#                 if self.showLevel:
+#                     newFull = self.format % ('ACDIMRU'[school],record.levelType) + newFull
+#                 else:
+#                     newFull = self.format % 'ACDIMRU'[school] + newFull
+
+#             if record.full != newFull:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.full = newFull
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* Spells Renamed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
 #------------------------------------------------------------------------------
-class PowerExhaustion(SpecialPatcher,Patcher):
-    """Modifies most Greater power to work with Wrye's Power Exhaustion mod."""
-    name = _('Power Exhaustion')
-    text = _("Modify greater powers to work with Power Exhaustion mod.\n\nWill only run if Power Exhaustion mod is installed and active.")
+class NamesTweak_Weapons(MultiTweakItem):
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("Weapons"),
+            _('Label ammo and weapons to sort by type and damage.'),
+            'WEAP',
+            (_('S BB Gun'),  '%s '),
+            (_('S. BB Gun'), '%s. '),
+            (_('S - BB Gun'),'%s - '),
+            (_('(S) BB Gun'),'(%s) '),
+            ('----','----'),
+            (_('S10 BB Gun'),  '%s%02d '),
+            (_('S10. BB Gun'), '%s%02d. '),
+            (_('S10 - BB Gun'),'%s%02d - '),
+            (_('(S10) BB Gun'),'(%s%02d) '),
+            )
 
     #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = (GPath('Power Exhaustion.esp') in loadMods)
-        self.id_exhaustion = bush.id_exhaustion
-
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        if not self.isActive: return tuple()
-        return (MreSpel,)
+        return (MreWeap,)
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        if not self.isActive: return tuple()
-        return (MreSpel,)
+        return (MreWeap,)
 
-    def scanModFile(self,modFile,progress):
+    def scanModFile(self,modFile,progress,patchFile):
         """Scans specified mod file to extract info. May add record to patch mod,
         but won't alter it."""
-        if not self.isActive: return
         mapper = modFile.getLongMapper()
-        patchRecords = self.patchFile.SPEL
-        for record in modFile.SPEL.getActiveRecords():
-            if not record.spellType == 2: continue
-            record = record.getTypeCopy(mapper)
-            if record.fid in self.id_exhaustion or ('FOAT',5) in record.getEffects():
-                patchRecords.setRecord(record)
-                continue
+        for blockType in ('WEAP',):
+            modBlock = getattr(modFile,blockType)
+            patchBlock = getattr(patchFile,blockType)
+            id_records = patchBlock.id_records
+            for record in modBlock.getActiveRecords():
+                if mapper(record.fid) not in id_records:
+                    record = record.getTypeCopy(mapper)
+                    patchBlock.setRecord(record)
 
-    def buildPatch(self,log,progress):
+    def buildPatch(self,log,progress,patchFile):
         """Edits patch file as desired. Will write to log."""
-        if not self.isActive: return
         count = {}
-        exhaustId = (GPath('Power Exhaustion.esp'),0xCE7)
-        keep = self.patchFile.getKeeper()
-        for record in self.patchFile.SPEL.records:
-            #--Skip this one?
-            if record.spellType != 2: continue
-            if record.fid not in self.id_exhaustion and ('FOAT',5) not in record.getEffects():
-                continue
-            newEffects = []
-            duration = self.id_exhaustion.get(record.fid,0)
-            for effect in record.effects:
-                if effect.name == 'FOAT' and effect.actorValue == 5 and effect.magnitude == 1:
-                    duration = effect.duration
-                else:
-                    newEffects.append(effect)
-            if not duration: continue
-            record.effects = newEffects
-            #--Okay, do it
-            record.full = '+'+record.full
-            record.spellType = 3 #--Lesser power
-            effect = record.getDefault('effects')
-            effect.name = 'SEFF'
-            effect.duration = duration
-            scriptEffect = record.getDefault('effects.scriptEffect')
-            scriptEffect.full = _("Power Exhaustion")
-            scriptEffect.script = exhaustId
-            scriptEffect.school = 2
-            scriptEffect.visual = null4
-            scriptEffect.flags.hostile = False
-            effect.scriptEffect = scriptEffect
-            record.effects.append(effect)
+        format = self.choiceValues[self.chosen][0]
+        showStat = '%02d' in format
+        keep = patchFile.getKeeper()
+        codes = getattr(patchFile,'weaponTags','BESMUTL')
+        for record in patchFile.WEAP.records:
+            if not record.full: continue
+            if record.full[0] in '+-=()[]<>': continue
+            if not record.etype in range(0,7): continue
+            type = codes[record.etype]
+            if showStat:
+                record.full = format % (type,record.damage) + record.full
+            else:
+                record.full = format % type + record.full
             keep(record.fid)
             srcMod = record.fid[0]
             count[srcMod] = count.get(srcMod,0) + 1
         #--Log
-        log.setHeader(_('= Power Exhaustion'))
-        log(_('* Powers Tweaked: %d') % (sum(count.values()),))
+        log(_('* %s: %d') % (self.label,sum(count.values())))
         for srcMod in modInfos.getOrdered(count.keys()):
             log('  * %s: %d' % (srcMod.s,count[srcMod]))
-
-class CBash_PowerExhaustion(SpecialPatcher,CBash_Patcher):
-    """Modifies most Greater power to work with Wrye's Power Exhaustion mod."""
-    name = _('Power Exhaustion')
-    text = _("Modify greater powers to work with Power Exhaustion mod.\n\nWill only run if Power Exhaustion mod is installed and active.")
-
+# class CBash_NamesTweak_Weapons(CBash_MultiTweakItem):
+#     """Names tweaker for weapons and ammo."""
+#     scanOrder = 32
+#     editOrder = 32
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Weapons"),
+#             _('Label ammo and weapons to sort by type and damage.'),
+#             'WEAP',
+#             (_('B Iron Bow'),  '%s '),
+#             (_('B. Iron Bow'), '%s. '),
+#             (_('B - Iron Bow'),'%s - '),
+#             (_('(B) Iron Bow'),'(%s) '),
+#             ('----','----'),
+#             (_('B08 Iron Bow'),  '%s%02d '),
+#             (_('B08. Iron Bow'), '%s%02d. '),
+#             (_('B08 - Iron Bow'),'%s%02d - '),
+#             (_('(B08) Iron Bow'),'(%s%02d) '),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['AMMO','WEAP']
+
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         CBash_MultiTweakItem.saveConfig(self,configs)
+#         self.format = self.choiceValues[self.chosen][0]
+#         self.showStat = '%02d' in self.format
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         newFull = record.full
+#         if newFull:
+#             if record._Type == 'AMMO':
+#                 if newFull[0] in '+-=.()[]': return
+#                 type = 6
+#             else:
+#                 type = record.weaponType
+#             if self.showStat:
+#                 newFull = self.format % ('CDEFGBA'[type],record.damage) + newFull
+#             else:
+#                 newFull = self.format % 'CDEFGBA'[type] + newFull
+#             if record.full != newFull:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.full = newFull
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class NamesTweak_Dwarven(MultiTweakItem):
+#     reDwarf  = re.compile(r'\b(d|D)(?:warven|warf)\b')
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         self.activeTypes = ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
+#                             'CLAS','CLOT','CONT','CREA','DOOR',
+#                             'ENCH','EYES','FACT','FLOR','FURN','GMST',
+#                             'HAIR','INGR','KEYM','LIGH','LSCR','MGEF',
+#                             'MISC','NPC_','QUST','RACE','SCPT','SGST',
+#                             'SKIL','SLGM','SPEL','WEAP']
+#         MultiTweakItem.__init__(self,_("Lore Friendly Names: Dwarven -> Dwemer"),
+#             _('Rename any thing that is named X Dwarven or Dwarven X to Dwemer X/X Dwemer to follow lore better.'),
+#             'Dwemer',
+#             (('Lore Friendly Names: Dwarven -> Dwemer'),  'Dwemer'),
+#             )
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
+#                 MreClas,MreClot,MreCont,MreCrea,MreDoor,
+#                 MreEnch,MreEyes,MreFact,MreFlor,MreFurn,MreGmst,
+#                 MreHair,MreIngr,MreKeym,MreLigh,MreLscr,MreMgef,
+#                 MreMisc,MreNpc ,MreQust,MreRace,MreScpt,MreSgst,
+#                 MreSkil,MreSlgm,MreSpel,MreWeap)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreAlch,MreAmmo,MreAppa,MreArmo,MreBook,MreBsgn,
+#                 MreClas,MreClot,MreCont,MreCrea,MreDoor,
+#                 MreEnch,MreEyes,MreFact,MreFlor,MreFurn,MreGmst,
+#                 MreHair,MreIngr,MreKeym,MreLigh,MreLscr,MreMgef,
+#                 MreMisc,MreNpc ,MreQust,MreRace,MreScpt,MreSgst,
+#                 MreSkil,MreSlgm,MreSpel,MreWeap)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         for blockType in self.activeTypes:
+#             if blockType not in modFile.tops: continue
+#             modBlock = getattr(modFile,blockType)
+#             patchBlock = getattr(patchFile,blockType)
+#             id_records = patchBlock.id_records
+#             for record in modBlock.getActiveRecords():
+#                 if mapper(record.fid) not in id_records:
+#                     record = record.getTypeCopy(mapper)
+#                     patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         reDwarf = self.reDwarf
+#         for type in self.activeTypes:
+#             if type not in patchFile.tops: continue
+#             for record in patchFile.tops[type].records:
+#                 changed = False
+#                 if hasattr(record, 'full'):
+#                     changed = reDwarf.search(record.full or '')
+#                 if not changed:
+#                     if hasattr(record, 'effects'):
+#                         Effects = record.effects
+#                         for effect in Effects:
+#                             try:
+#                                 changed = reDwarf.search(effect.scriptEffect.full or '')
+#                             except AttributeError:
+#                                 continue
+#                             if changed: break
+#                 if not changed:
+#                     if hasattr(record, 'text'):
+#                         changed = reDwarf.search(record.text or '')
+#                 if not changed:
+#                     if hasattr(record, 'description'):
+#                         changed = reDwarf.search(record.description or '')
+#                 if not changed:
+#                     if type == 'GMST' and record.eid[0] == 's':
+#                         changed = reDwarf.search(record.value or '')
+#                 if not changed:
+#                     if hasattr(record, 'stages'):
+#                         Stages = record.stages
+#                         for stage in Stages:
+#                             for entry in stage.entries:
+#                                 changed = reDwarf.search(entry.text or '')
+#                                 if changed: break
+#                 if not changed:
+#                     if type == 'SKIL':
+#                         changed = reDwarf.search(record.apprentice or '')
+#                         if not changed:
+#                             changed = reDwarf.search(record.journeyman or '')
+#                         if not changed:
+#                             changed = reDwarf.search(record.expert or '')
+#                         if not changed:
+#                             changed = reDwarf.search(record.master or '')
+#                 if changed:
+#                     if hasattr(record, 'full'):
+#                         newString = record.full
+#                         if record:
+#                             record.full = reDwarf.sub(r'\1wemer', newString)
+#                     if hasattr(record, 'effects'):
+#                         Effects = record.effects
+#                         for effect in Effects:
+#                             try:
+#                                 newString = effect.scriptEffect.full
+#                             except AttributeError:
+#                                 continue
+#                             if newString:
+#                                 effect.scriptEffect.full = reDwarf.sub(r'\1wemer', newString)
+#                     if hasattr(record, 'text'):
+#                         newString = record.text
+#                         if newString:
+#                             record.text = reDwarf.sub(r'\1wemer', newString)
+#                     if hasattr(record, 'description'):
+#                         newString = record.description
+#                         if newString:
+#                             record.description = reDwarf.sub(r'\1wemer', newString)
+#                     if type == 'GMST' and record.eid[0] == 's':
+#                         newString = record.value
+#                         if newString:
+#                             record.value = reDwarf.sub(r'\1wemer', newString)
+#                     if hasattr(record, 'stages'):
+#                         Stages = record.stages
+#                         for stage in Stages:
+#                             for entry in stage.entries:
+#                                 newString = entry.text
+#                                 if newString:
+#                                     entry.text = reDwarf.sub(r'\1wemer', newString)
+#                     if type == 'SKIL':
+#                         newString = record.apprentice
+#                         if newString:
+#                             record.apprentice = reDwarf.sub(r'\1wemer', newString)
+#                         newString = record.journeyman
+#                         if newString:
+#                             record.journeyman = reDwarf.sub(r'\1wemer', newString)
+#                         newString = record.expert
+#                         if newString:
+#                             record.expert = reDwarf.sub(r'\1wemer', newString)
+#                         newString = record.master
+#                         if newString:
+#                             record.master = reDwarf.sub(r'\1wemer', newString)
+
+#                     keep(record.fid)
+#                     srcMod = record.fid[0]
+#                     count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log(_('* %s: %d') % (self.label,sum(count.values())))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_NamesTweak_Dwarven(CBash_MultiTweakItem):
+#     """Names tweaker for dwarven->dwemer."""
+#     scanOrder = 32
+#     editOrder = 32
+#     reDwarf  = re.compile(r'\b(d|D)(?:warven|warf)\b')
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Lore Friendly Names: Dwarven -> Dwemer"),
+#             _('Rename anything that is named X Dwarven or Dwarven X to Dwemer X/X Dwemer to follow lore better.'),
+#             'Dwemer',
+#             (('Lore Friendly Names: Dwarven -> Dwemer'),  'Dwemer'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['ALCH','AMMO','APPA','ARMO','BOOK','BSGN',
+#                 'CELL','CLAS','CLOT','CONT','CREA','DOOR',
+#                 'ENCH','EYES','FACT','FLOR','FURN','GMST',
+#                 'HAIR','INGR','KEYM','LIGH','LSCR','MGEF',
+#                 'MISC','NPC_','QUST','RACE','SCPT','SGST',
+#                 'SKIL','SLGM','SPEL','WEAP']
+
+#     def saveConfig(self,configs):
+#         """Save config to configs dictionary."""
+#         CBash_MultiTweakItem.saveConfig(self,configs)
+#         self.format = self.choiceValues[self.chosen][0]
+#         self.showStat = '%02d' in self.format
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         changed = False
+#         if hasattr(record, 'full'):
+#             changed = self.reDwarf.search(record.full or '')
+#         if not changed:
+#             if hasattr(record, 'effects'):
+#                 Effects = record.effects
+#                 for effect in Effects:
+#                     changed = self.reDwarf.search(effect.full or '')
+#                     if changed: break
+#         if not changed:
+#             if hasattr(record, 'text'):
+#                 changed = self.reDwarf.search(record.text or '')
+#         if not changed:
+#             if hasattr(record, 'description'):
+#                 changed = self.reDwarf.search(record.description or '')
+#         if not changed:
+#             if record._Type == 'GMST' and record.eid[0] == 's':
+#                 changed = self.reDwarf.search(record.value or '')
+#         if not changed:
+#             if hasattr(record, 'stages'):
+#                 Stages = record.stages
+#                 for stage in Stages:
+#                     for entry in stage.entries:
+#                         changed = self.reDwarf.search(entry.text or '')
+#                         if changed: break
+# ##                        compiled = entry.compiled_p
+# ##                        if compiled:
+# ##                            changed = self.reDwarf.search(struct.pack('B' * len(compiled), *compiled) or '')
+# ##                            if changed: break
+# ##                        changed = self.reDwarf.search(entry.scriptText or '')
+# ##                        if changed: break
+# ##        if not changed:
+# ##            if hasattr(record, 'scriptText'):
+# ##                changed = self.reDwarf.search(record.scriptText or '')
+# ##                if not changed:
+# ##                    compiled = record.compiled_p
+# ##                    changed = self.reDwarf.search(struct.pack('B' * len(compiled), *compiled) or '')
+#         if not changed:
+#             if record._Type == 'SKIL':
+#                 changed = self.reDwarf.search(record.apprentice or '')
+#                 if not changed:
+#                     changed = self.reDwarf.search(record.journeyman or '')
+#                 if not changed:
+#                     changed = self.reDwarf.search(record.expert or '')
+#                 if not changed:
+#                     changed = self.reDwarf.search(record.master or '')
+
+#         #Could support DIAL/INFO as well, but skipping since they're often voiced as well
+#         if changed:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 if hasattr(override, 'full'):
+#                     newString = override.full
+#                     if newString:
+#                         override.full = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if hasattr(override, 'effects'):
+#                     Effects = override.effects
+#                     for effect in Effects:
+#                         newString = effect.full
+#                         if newString:
+#                             effect.full = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if hasattr(override, 'text'):
+#                     newString = override.text
+#                     if newString:
+#                         override.text = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if hasattr(override, 'description'):
+#                     newString = override.description
+#                     if newString:
+#                         override.description = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if override._Type == 'GMST' and override.eid[0] == 's':
+#                     newString = override.value
+#                     if newString:
+#                         override.value = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if hasattr(override, 'stages'):
+#                     Stages = override.stages
+#                     for stage in Stages:
+#                         for entry in stage.entries:
+#                             newString = entry.text
+#                             if newString:
+#                                 entry.text = self.reDwarf.sub(r'\1wemer', newString)
+# ##                            newString = entry.compiled_p
+# ##                            if newString:
+# ##                                nSize = len(newString)
+# ##                                newString = self.reDwarf.sub(r'\1wemer', struct.pack('B' * nSize, *newString))
+# ##                                nSize = len(newString)
+# ##                                entry.compiled_p = struct.unpack('B' * nSize, newString)
+# ##                                entry.compiledSize = nSize
+# ##                            newString = entry.scriptText
+# ##                            if newString:
+# ##                                entry.scriptText = self.reDwarf.sub(r'\1wemer', newString)
+# ##
+
+# ##                if hasattr(override, 'scriptText'):
+# ##                    newString = override.compiled_p
+# ##                    if newString:
+# ##                        nSize = len(newString)
+# ##                        newString = self.reDwarf.sub(r'\1wemer', struct.pack('B' * nSize, *newString))
+# ##                        nSize = len(newString)
+# ##                        override.compiled_p = struct.unpack('B' * nSize, newString)
+# ##                        override.compiledSize = nSize
+# ##                    newString = override.scriptText
+# ##                    if newString:
+# ##                        override.scriptText = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 if override._Type == 'SKIL':
+#                     newString = override.apprentice
+#                     if newString:
+#                         override.apprentice = self.reDwarf.sub(r'\1wemer', newString)
+
+#                     newString = override.journeyman
+#                     if newString:
+#                         override.journeyman = self.reDwarf.sub(r'\1wemer', newString)
+
+#                     newString = override.expert
+#                     if newString:
+#                         override.expert = self.reDwarf.sub(r'\1wemer', newString)
+
+#                     newString = override.master
+#                     if newString:
+#                         override.master = self.reDwarf.sub(r'\1wemer', newString)
+
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== %s' % self.label)
+#         log(_('* Items Renamed: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class NamesTweak_SortInventory(MultiTweakItem):
     #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = (GPath('Power Exhaustion.esp') in loadMods)
-        if not self.isActive: return
-        self.id_exhaustion = bush.id_exhaustion
-        self.mod_count = {}
-        self.exhaustId = (GPath('Power Exhaustion.esp'),0xCE7)
-        self.FOATValue = cast('FOAT', POINTER(c_ulong)).contents.value
-        self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("Sort Inventory"),
+            _('Sort item by category in barter and container screens.'),
+            'sortInventory',
+            # weapon,armor,stimpak,chem,food/drink,ammo
+            (_('Chem>Ammo>Weapon>Armor>Food>Misc'),3,2,6,5,1,4),
+            (_('Ammo>Chem>Weapon>Armor>Food>Misc'),3,2,5,4,1,6),
+            )
 
-    def getTypes(self):
-        return ['SPEL']
+    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired. """
-        if record.IsPower:
-            recordId = record.fid
-            id_exhaustion = self.id_exhaustion
-            FOATValue = self.FOATValue
-            Effects = record.effects_list
-            newEffects = []
-            duration = id_exhaustion.get(recordId,0)
-            for effect in Effects:
-                if effect[0] == FOATValue and effect[5] == 5 and effect[1] == 1:
-                    duration = effect[3]
-                else:
-                    newEffects.append(effect)
-            if duration:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.effects_list = newEffects
-                    #--Okay, do it
-                    override.full = '+'+override.full
-                    override.spellType = 3 #--Lesser power
-                    effect = override.create_effect()
-                    effect.name = self.SEFFValue
-                    effect.duration = duration
-                    effect.full = _("Power Exhaustion")
-                    effect.script = self.exhaustId
-                    effect.school = 2
-                    effect.visual = None
-                    effect.IsHostile = False
-
-                    mod_count = self.mod_count
-                    mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreAmmo,MreWeap,MreArmo,MreAlch)
 
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_count = self.mod_count
-        log.setHeader('= ' +self.__class__.name)
-        log(_('* Powers Tweaked: %d') % (sum(mod_count.values()),))
-        for srcMod in modInfos.getOrdered(mod_count.keys()):
-            log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
-        self.mod_count = {}
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreAmmo,MreWeap,MreArmo,MreAlch)
 
-#------------------------------------------------------------------------------
-class RacePatcher(SpecialPatcher,ListPatcher):
-    """Merged leveled lists mod file."""
-    name = _('Race Records')
-    text = _("Merge race eyes, hair, body, voice from ACTIVE AND/OR MERGED mods. Any non-active, non-merged mods in the following list will be IGNORED.\n\nEven if none of the below mods are checked, this will sort hairs and eyes and attempt to remove googly eyes from all active mods. It will also randomly assign hairs and eyes to npcs that are otherwise missing them.")
-    tip = _("Merge race eyes, hair, body, voice from mods.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = ('Hair','Eyes-D','Eyes-R','Eyes-E','Eyes','Body-M','Body-F',
-        'Body-Size-M','Body-Size-F','Voice-M','Voice-F','R.Relations','R.Teeth',
-        'R.Mouth','R.Ears', 'R.Head','R.Attributes-F', 'R.Attributes-M',
-        'R.Skills', 'R.Description','R.AddSpells', 'R.ChangeSpells')
-    forceAuto = True
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        for blockType in ('AMMO','WEAP','ARMO','ALCH'):
+            modBlock = getattr(modFile,blockType)
+            patchBlock = getattr(patchFile,blockType)
+            id_records = patchBlock.id_records
+            for record in modBlock.getActiveRecords():
+                if mapper(record.fid) not in id_records:
+                    record = record.getTypeCopy(mapper)
+                    patchBlock.setRecord(record)
+
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        count = {}
+        cntWeap,cntArmo,cntStim,cntChem,cntFood,cntAmmo = self.choiceValues[self.chosen]
+        keep = patchFile.getKeeper()
+        reHead = re.compile(r"^\x07*")
+        for cnt,type in ((cntWeap,'WEAP'),(cntArmo,'ARMO'),(cntAmmo,'AMMO')):
+            for record in getattr(patchFile,type).records:
+                if not record.full: continue
+                if record.full[0] in '+-=[]<>': continue
+                record.full = reHead.sub('\x07' * cnt, record.full)
+                keep(record.fid)
+                srcMod = record.fid[0]
+                count[srcMod] = count.get(srcMod,0) + 1
+        for record in patchFile.ALCH.records:
+            if not record.full: continue
+            if record.full[0] in '+-=[]<>': continue
+            if not record.etype in range(10,14): continue
+            if record.etype == 10:   # chems
+                record.full = reHead.sub('\x07' * cntChem, record.full)
+            elif record.etype == 11: # stimpak
+                record.full = reHead.sub('\x07' * cntStim, record.full)
+            else:                    # food/alcohol
+                record.full = reHead.sub('\x07' * cntFood, record.full)
+            keep(record.fid)
+            srcMod = record.fid[0]
+            count[srcMod] = count.get(srcMod,0) + 1
+        #--Log
+        log(_('* %s: %d') % (self.label,sum(count.values())))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
 
+class NamesTweak_AmmoWeight(MultiTweakItem):
     #--Config Phase -----------------------------------------------------------
-    def getAutoItems(self):
-        """Returns list of items to be used for automatic configuration."""
-        autoItems = []
-        autoRe = self.__class__.autoRe
-        autoKey = set(self.__class__.autoKey)
-        for modInfo in modInfos.data.values():
-            if autoRe.match(modInfo.name.s) or (autoKey & set(modInfo.getBashTags())):
-                if modInfo.mtime > PatchFile.patchTime: continue
-                autoItems.append(modInfo.name)
-        return autoItems
+    def __init__(self):
+        MultiTweakItem.__init__(self,_("Append Ammo Weight"),
+            _("Append ammo weight of FWE to tail of the ammo name."),
+            'AmmoWeight',
+            (_('BB (WG 0.01)'), ' (WG %s.%s)'),
+            (_('BB (0.01)'), ' (%s.%s)'),
+            )
 
+    #--Config Phase -----------------------------------------------------------
     #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.raceData = {} #--Race eye meshes, hair,eyes
-        self.tempRaceData = {}
-        #--Restrict srcMods to active/merged mods.
-        self.srcMods = [x for x in self.getConfigChecked() if x in patchFile.allSet]
-        self.isActive = True #--Always enabled to support eye filtering
-        self.bodyKeys = set(('TailModel','UpperBodyPath','LowerBodyPath','HandPath','FootPath','TailPath'))
-        self.sizeKeys = set(('Height','Weight'))
-        self.raceAttributes = set(('Strength','Intelligence','Willpower','Agility','Speed','Endurance','Personality','Luck'))
-        self.raceSkills = set(('skill1','skill1Boost','skill2','skill2Boost','skill3','skill3Boost','skill4','skill4Boost','skill5','skill5Boost','skill6','skill6Boost','skill7','skill7Boost'))
-        self.eyeKeys = set(('Eyes-D','Eyes-R','Eyes-E','Eyes'))
-        #--Mesh tuple for each defined eye. Derived from race records.
-        defaultMesh = (r'characters\imperial\eyerighthuman.nif', r'characters\imperial\eyelefthuman.nif')
-        self.eye_mesh = {}
-        self.scanTypes = set(('RACE','EYES','HAIR','NPC_'))
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreAmmo,MreFlst)
 
-    def initData(self,progress):
-        """Get data from source files."""
-        if not self.isActive or not self.srcMods: return
-        loadFactory = LoadFactory(False,MreRace)
-        progress.setFull(len(self.srcMods))
-        cachedMasters = {}
-        for index,srcMod in enumerate(self.srcMods):
-            if srcMod not in modInfos: continue
-            srcInfo = modInfos[srcMod]
-            srcFile = ModFile(srcInfo,loadFactory)
-            srcFile.load(True)
-            masters = srcInfo.header.masters
-            bashTags = srcInfo.getBashTags()
-            if 'RACE' not in srcFile.tops: continue
-            srcFile.convertToLongFids(('RACE',))
-            self.tempRaceData = {} #so as not to carry anything over!
-            if 'R.ChangeSpells' in bashTags and 'R.AddSpells' in bashTags:
-                raise BoltError(_('WARNING mod %s has both R.AddSpells and R.ChangeSpells tags - only one of those tags should be on a mod at one time') % (srcMod.s))
-            for race in srcFile.RACE.getActiveRecords():
-                tempRaceData = self.tempRaceData.setdefault(race.fid,{})
-                raceData = self.raceData.setdefault(race.fid,{})
-                if 'Hair' in bashTags:
-                    raceHair = raceData.setdefault('hairs',[])
-                    for hair in race.hairs:
-                        if hair not in raceHair: raceHair.append(hair)
-                if self.eyeKeys & bashTags:
-                    tempRaceData['rightEye'] = race.rightEye
-                    tempRaceData['leftEye'] = race.leftEye
-                    raceEyes = raceData.setdefault('eyes',[])
-                    for eye in race.eyes:
-                        if eye not in raceEyes: raceEyes.append(eye)
-                if 'Voice-M' in bashTags:
-                    tempRaceData['maleVoice'] = race.maleVoice
-                if 'Voice-F' in bashTags:
-                    tempRaceData['femaleVoice'] = race.femaleVoice
-                if 'Body-M' in bashTags:
-                    for key in ['male'+key for key in self.bodyKeys]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'Body-F' in bashTags:
-                    for key in ['female'+key for key in self.bodyKeys]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'Body-Size-M' in bashTags:
-                    for key in ['male'+key for key in self.sizeKeys]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'Body-Size-F' in bashTags:
-                    for key in ['female'+key for key in self.sizeKeys]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Teeth' in bashTags:
-                    for key in ('teethLower','teethUpper'):
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Mouth' in bashTags:
-                    for key in ('mouth','tongue'):
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Head' in bashTags:
-                    tempRaceData['head'] = race.head
-                if 'R.Ears' in bashTags:
-                    for key in ('maleEars','femaleEars'):
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Relations' in bashTags:
-                    relations = raceData.setdefault('relations',{})
-                    for x in race.relations:
-                        relations[x.faction] = x.mod
-                if 'R.Attributes-F' in bashTags:
-                    for key in ['female'+key for key in self.raceAttributes]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Attributes-M' in bashTags:
-                    for key in ['male'+key for key in self.raceAttributes]:
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.Skills' in bashTags:
-                    for key in self.raceSkills:
-                        tempRaceData[key] = getattr(race,key)
-                if 'R.AddSpells' in bashTags:
-                    tempRaceData['AddSpells'] = race.spells
-                if 'R.ChangeSpells' in bashTags:
-                    raceData['spellsOverride'] = race.spells
-                if 'R.Description' in bashTags:
-                    tempRaceData['text'] = race.text
-            for master in masters:
-                if not master in modInfos: continue # or break filter mods
-                if master in cachedMasters:
-                    masterFile = cachedMasters[master]
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreAmmo,MreFlst)
+
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        for blockType in ('AMMO','FLST'):
+            modBlock = getattr(modFile,blockType)
+            patchBlock = getattr(patchFile,blockType)
+            id_records = patchBlock.id_records
+            for record in modBlock.getActiveRecords():
+                if mapper(record.fid) not in id_records:
+                    record = record.getTypeCopy(mapper)
+                    patchBlock.setRecord(record)
+
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        count = {}
+        format = self.choiceValues[self.chosen][0]
+        keep = patchFile.getKeeper()
+        weights = {}
+        weightRe = re.compile(r"^(.*)( \(WG \d+\.\d+\))$")
+        listEidRe = re.compile(r"^AmmoWeight(\d)(\d{2})List$")
+        for record in patchFile.FLST.records:
+            m = listEidRe.match(record.eid)
+            if m:
+                weight = format % (m.group(1), m.group(2))
+                for fid in record.fids:
+                    weights[fid] = weight
+        for record in patchFile.AMMO.records:
+            if not record.full: continue
+            weight = weights.get(record.fid)
+            if weight:
+                m = weightRe.match(record.full)
+                if m:
+                    record.full = m.group(1) + weight
                 else:
-                    masterInfo = modInfos[master]
-                    masterFile = ModFile(masterInfo,loadFactory)
-                    masterFile.load(True)
-                    if 'RACE' not in masterFile.tops: continue
-                    masterFile.convertToLongFids(('RACE',))
-                    cachedMasters[master] = masterFile
-                for race in masterFile.RACE.getActiveRecords():
-                    if race.fid not in self.tempRaceData: continue
-                    tempRaceData = self.tempRaceData[race.fid]
-                    raceData = self.raceData[race.fid]
-                    if 'AddSpells' in tempRaceData:
-                        raceData.setdefault('AddSpells', [])
-                        for spell in tempRaceData['AddSpells']:
-                            if spell not in race.spells:
-                                if spell not in raceData['AddSpells']:
-                                    raceData['AddSpells'].append(spell)
-                        del tempRaceData['AddSpells']
-                    for key in tempRaceData:
-                        if not tempRaceData[key] == getattr(race,key):
-                            raceData[key] = tempRaceData[key]
-            progress.plus()
+                    record.full = record.full + weight
+                keep(record.fid)
+                srcMod = record.fid[0]
+                count[srcMod] = count.get(srcMod,0) + 1
+        #--Log
+        log(_('* %s: %d') % (self.label,sum(count.values())))
+        for srcMod in modInfos.getOrdered(count.keys()):
+            log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+#------------------------------------------------------------------------------
+class NamesTweaker(MultiTweaker):
+    """Tweaks record full names in various ways."""
+    scanOrder = 32
+    editOrder = 32
+    name = _('Tweak Names')
+    text = _("Tweak object names in various ways such as lore friendlyness or show type/quality.")
+    tweaks = sorted([
+        NamesTweak_Body(_("Armor/Clothes"),_("Rename armor to sort by type."),'ARMO',
+            (_('A Naughty Nightwear'),  '%s '),
+            (_('A. Naughty Nightwear'), '%s. '),
+            (_('A - Naughty Nightwear'),'%s - '),
+            (_('(A) Naughty Nightwear'),'(%s) '),
+            ('----','----'),
+            (_('A01 Naughty Nightwear'),  '%s%02d '),
+            (_('A01. Naughty Nightwear'), '%s%02d. '),
+            (_('A01 - Naughty Nightwear'),'%s%02d - '),
+            (_('(A01) Naughty Nightwear'),'(%s%02d) '),
+            ),
+        NamesTweak_Potions(),
+        NamesTweak_Weapons(),
+        NamesTweak_AmmoWeight(),
+        ],key=lambda a: a.label.lower())
+    tweaks.insert(0,NamesTweak_BodyTags())
+    tweaks.append(NamesTweak_SortInventory())
 
+    #--Patch Phase ------------------------------------------------------------
     def getReadClasses(self):
         """Returns load factory classes needed for reading."""
-        return (None,(MreRace,MreEyes,MreHair,MreNpc))[self.isActive]
+        if not self.isActive: return None
+        classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
+        return sum(classTuples,tuple())
 
     def getWriteClasses(self):
         """Returns load factory classes needed for writing."""
-        return (None,(MreRace,MreEyes,MreHair,MreNpc))[self.isActive]
+        if not self.isActive: return None
+        classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
+        return sum(classTuples,tuple())
 
-    def scanModFile(self, modFile, progress):
-        """Add appropriate records from modFile."""
+    def scanModFile(self,modFile,progress):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
         if not self.isActive: return
-        eye_mesh = self.eye_mesh
-        modName = modFile.fileInfo.name
-        mapper = modFile.getLongMapper()
-        if not (set(modFile.tops) & self.scanTypes): return
-        modFile.convertToLongFids(('RACE','EYES','NPC_'))
-        srcEyes = set([record.fid for record in modFile.EYES.getActiveRecords()])
-        #--Eyes, Hair
-        for type in ('EYES','HAIR'):
-            patchBlock = getattr(self.patchFile,type)
-            id_records = patchBlock.id_records
-            for record in getattr(modFile,type).getActiveRecords():
-                if record.fid not in id_records:
-                    patchBlock.setRecord(record.getTypeCopy(mapper))
-        #--Npcs with unassigned eyes
-        patchBlock = self.patchFile.NPC_
-        id_records = patchBlock.id_records
-        for record in modFile.NPC_.getActiveRecords():
-            if not record.eye and record.fid not in id_records:
-                patchBlock.setRecord(record.getTypeCopy(mapper))
-        #--Race block
-        patchBlock = self.patchFile.RACE
-        id_records = patchBlock.id_records
-        for record in modFile.RACE.getActiveRecords():
-            if record.fid not in id_records:
-                patchBlock.setRecord(record.getTypeCopy(mapper))
-            if not record.rightEye or not record.leftEye:
-                deprint(_('No right and/or no left eye recorded in race %s, from mod %s') % (record.full, modName))
-                continue
-            for eye in record.eyes:
-                if eye in srcEyes:
-                    eye_mesh[eye] = (record.rightEye.modPath.lower(),record.leftEye.modPath.lower())
+        for tweak in self.enabledTweaks:
+            tweak.scanModFile(modFile,progress,self.patchFile)
 
     def buildPatch(self,log,progress):
-        """Updates races as needed."""
-        debug = False
+        """Applies individual clothes tweaks."""
         if not self.isActive: return
-        patchFile = self.patchFile
+        log.setHeader('= '+self.__class__.name,True)
+        for tweak in self.enabledTweaks:
+            tweak.buildPatch(log,progress,self.patchFile)
+
+# class CBash_NamesTweaker(CBash_MultiTweaker):
+#     """Tweaks record full names in various ways."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _('Tweak Names')
+#     text = _("Tweak object names in various ways such as lore friendlyness or show type/quality.")
+#     tweaks = sorted([
+#         CBash_NamesTweak_Body(_("Armor"),_("Rename armor to sort by type."),'ARMO',
+#             (_('BL Leather Boots'),  '%s '),
+#             (_('BL. Leather Boots'), '%s. '),
+#             (_('BL - Leather Boots'),'%s - '),
+#             (_('(BL) Leather Boots'),'(%s) '),
+#             ('----','----'),
+#             (_('BL02 Leather Boots'),  '%s%02d '),
+#             (_('BL02. Leather Boots'), '%s%02d. '),
+#             (_('BL02 - Leather Boots'),'%s%02d - '),
+#             (_('(BL02) Leather Boots'),'(%s%02d) '),
+#             ),
+#         CBash_NamesTweak_Body(_("Clothes"),_("Rename clothes to sort by type."),'CLOT',
+#             (_('P Grey Trousers'),  '%s '),
+#             (_('P. Grey Trousers'), '%s. '),
+#             (_('P - Grey Trousers'),'%s - '),
+#             (_('(P) Grey Trousers'),'(%s) '),
+#             ),
+#         CBash_NamesTweak_Potions(),
+#         CBash_NamesTweak_Scrolls(),
+#         CBash_NamesTweak_Spells(),
+#         CBash_NamesTweak_Weapons(),
+#         CBash_NamesTweak_Dwarven(),
+#         ],key=lambda a: a.label.lower())
+#     tweaks.insert(0,CBash_NamesTweak_BodyTags())
+#     #--Config Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         for tweak in self.tweaks[1:]:
+#             tweak.patchFile = patchFile
+#         bodyTagPatcher = self.tweaks[0]
+#         patchFile.bodyTags = bodyTagPatcher.choiceValues[bodyTagPatcher.chosen][0]
+#         patchFile.indexMGEFs = True
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for tweak in self.enabledTweaks:
+#             for type in tweak.getTypes():
+#                 type_patchers.setdefault(type,[]).append(tweak)
+#             tweak.format = tweak.choiceValues[tweak.chosen][0]
+#             if isinstance(tweak, CBash_NamesTweak_Body):
+#                 tweak.showStat = '%02d' in tweak.format
+#                 tweak.codes = getattr(self.patchFile,'bodyTags','ARGHTCCPBS')
+#                 tweak.amulet,tweak.ring,tweak.gloves,tweak.head,tweak.tail,tweak.robe,tweak.chest,tweak.pants,tweak.shoes,tweak.shield = [
+#                     x for x in tweak.codes]
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatchLog(log)
+#------------------------------------------------------------------------------
+class BasalNPCTweaker(MultiTweakItem):
+    """Base for all NPC tweakers"""
+
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        # Override this segment with real info.
+        MultiTweakItem.__init__(self,_("Title"),
+            _('Description'),
+            'Ignored',
+            ('1.0',  '1.0'),
+            )
+
+    #--Patch Phase ------------------------------------------------------------
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreNpc,)
+
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreNpc,)
+
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        patchRecords = patchFile.NPC_
+        for record in modFile.NPC_.getActiveRecords():
+            record = record.getTypeCopy(mapper)
+            patchRecords.setRecord(record)
+
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        # override this section too!
+        count = {}
         keep = patchFile.getKeeper()
-        if 'RACE' not in patchFile.tops: return
-        racesPatched = []
-        racesSorted = []
-        racesFiltered = []
-        mod_npcsFixed = {}
-        reProcess = re.compile(r'(?:dremora)|(?:akaos)|(?:lathulet)|(?:orthe)|(?:ranyu)',re.I)
-        #--Import race info
-        for race in patchFile.RACE.records:
-            #~~print 'Building',race.eid
-            raceData = self.raceData.get(race.fid,None)
-            if not raceData: continue
-            raceChanged = False
-            #-- Racial Hair and  Eye sets
-            if 'hairs' in raceData and (set(race.hairs) != set(raceData['hairs'])):
-                race.hairs = raceData['hairs']
-                raceChanged = True
-            if 'eyes' in raceData:
-                if set(race.eyes) != set(raceData['eyes']):
-                    race.eyes = raceData['eyes']
-                    raceChanged = True
-            #-- Eye paths:
-            if 'rightEye' in raceData:
-                if not race.rightEye: deprint(_('Very odd race %s found - no right eye assigned') % (race.full))
-                else:
-                    if race.rightEye.modPath != raceData['rightEye'].modPath:
-                        race.rightEye.modPath = raceData['rightEye'].modPath
-                        raceChanged = True
-            if 'leftEye' in raceData:
-                if not race.leftEye: deprint(_('Very odd race %s found - no left eye assigned') % (race.full))
-                else:
-                    if race.leftEye.modPath != raceData['leftEye'].modPath:
-                        race.leftEye.modPath = raceData['leftEye'].modPath
-                        raceChanged = True
-            #--Teeth/Mouth/head/ears/description
-            for key in ('teethLower','teethUpper','mouth','tongue','text','head'):
-                if key in raceData:
-                    if getattr(race,key) != raceData[key]:
-                        setattr(race,key,raceData[key])
-                        raceChanged = True
-            #--spells
-            if 'spellsOverride' in raceData:
-                race.spells = raceData['spellsOverride']
-            if 'AddSpells' in raceData:
-                raceData['spells'] = race.spells
-                for spell in raceData['AddSpells']:
-                    raceData['spells'].append(spell)
-                race.spells = raceData['spells']
-            #--skills
-            for key in self.raceSkills:
-                if key in raceData:
-                    if getattr(race,key) != raceData[key]:
-                        setattr(race,key,raceData[key])
-                        raceChanged = True
-            #--Gender info (voice, gender specific body data)
-            for gender in ('male','female'):
-                bodyKeys = self.bodyKeys.union(self.raceAttributes.union(set(('Ears','Voice'))))
-                bodyKeys = [gender+key for key in bodyKeys]
-                for key in bodyKeys:
-                    if key in raceData:
-                        if getattr(race,key) != raceData[key]:
-                            setattr(race,key,raceData[key])
-                            raceChanged = True
-            #--Relations
-            if 'relations' in raceData:
-                relations = raceData['relations']
-                oldRelations = set((x.faction,x.mod) for x in race.relations)
-                newRelations = set(relations.iteritems())
-                if newRelations != oldRelations:
-                    del race.relations[:]
-                    for faction,mod in newRelations:
-                        entry = MelObject()
-                        entry.faction = faction
-                        entry.mod = mod
-                        race.relations.append(entry)
-                    raceChanged = True
-            #--Changed
-            if raceChanged:
-                racesPatched.append(race.eid)
-                keep(race.fid)
-        #--Eye Mesh filtering
-        eye_mesh = self.eye_mesh
-        blueEyeMesh = eye_mesh[(GPath('Oblivion.esm'),0x27308)]
-        argonianEyeMesh = eye_mesh[(GPath('Oblivion.esm'),0x3e91e)]
-        if debug:
-            print '== Eye Mesh Filtering'
-            print 'blueEyeMesh',blueEyeMesh
-            print 'argonianEyeMesh',argonianEyeMesh
-        for eye in (
-            (GPath('Oblivion.esm'),0x1a), #--Reanimate
-            (GPath('Oblivion.esm'),0x54bb9), #--Dark Seducer
-            (GPath('Oblivion.esm'),0x54bba), #--Golden Saint
-            (GPath('Oblivion.esm'),0x5fa43), #--Ordered
-            ):
-            eye_mesh.setdefault(eye,blueEyeMesh)
-        def setRaceEyeMesh(race,rightPath,leftPath):
-            race.rightEye.modPath = rightPath
-            race.leftEye.modPath = leftPath
-        for race in patchFile.RACE.records:
-            if debug: print '===', race.eid
-            if not race.eyes: continue #--Sheogorath. Assume is handled correctly.
-            if not race.rightEye or not race.leftEye: continue #--WIPZ race?
-            if re.match('^117[a-zA-Z]',race.eid): continue #-- x117 race?
-            raceChanged = False
-            mesh_eye = {}
-            for eye in race.eyes:
-                if eye not in eye_mesh:
-                    deprint(_('Mesh undefined for eye %s in race %s, eye removed from race list.') % (strFid(eye),race.eid,))
-                    continue
-                mesh = eye_mesh[eye]
-                if mesh not in mesh_eye:
-                    mesh_eye[mesh] = []
-                mesh_eye[mesh].append(eye)
-            currentMesh = (race.rightEye.modPath.lower(),race.leftEye.modPath.lower())
-            #print race.eid, mesh_eye
-            try:
-                maxEyesMesh = sorted(mesh_eye.keys(),key=lambda a: len(mesh_eye[a]))[0]
-            except IndexError:
-                maxEyesMesh = blueEyeMesh
-            #--Single eye mesh, but doesn't match current mesh?
-            if len(mesh_eye) == 1 and currentMesh != maxEyesMesh:
-                setRaceEyeMesh(race,*maxEyesMesh)
-                raceChanged = True
-            #--Multiple eye meshes (and playable)?
-            if debug:
-                for mesh,eyes in mesh_eye.iteritems():
-                    print mesh
-                    for eye in eyes: print ' ',strFid(eye)
-            if len(mesh_eye) > 1 and (race.flags.playable or race.fid == (GPath('Oblivion.esm'), 0x038010)):
-                #--If blueEyeMesh (mesh used for vanilla eyes) is present, use that.
-                if blueEyeMesh in mesh_eye and currentMesh != argonianEyeMesh:
-                    setRaceEyeMesh(race,*blueEyeMesh)
-                    race.eyes = mesh_eye[blueEyeMesh]
-                    raceChanged = True
-                elif argonianEyeMesh in mesh_eye:
-                    setRaceEyeMesh(race,*argonianEyeMesh)
-                    race.eyes = mesh_eye[argonianEyeMesh]
-                    raceChanged = True
-                #--Else figure that current eye mesh is the correct one
-                elif currentMesh in mesh_eye:
-                    race.eyes = mesh_eye[currentMesh]
-                    raceChanged = True
-                #--Else use most popular eye mesh
-                else:
-                    setRaceEyeMesh(race,*maxEyesMesh)
-                    race.eyes = mesh_eye[maxEyesMesh]
-                    raceChanged = True
-            if raceChanged:
-                racesFiltered.append(race.eid)
-                keep(race.fid)
-        #--Sort Eyes/Hair
-        defaultEyes = {}
-        defaultMaleHair = {}
-        defaultFemaleHair = {}
-        eyeNames  = dict((x.fid,x.full) for x in patchFile.EYES.records)
-        hairNames = dict((x.fid,x.full) for x in patchFile.HAIR.records)
-        maleHairs = set(x.fid for x in patchFile.HAIR.records if not x.flags.notMale)
-        femaleHairs = set(x.fid for x in patchFile.HAIR.records if not x.flags.notFemale)
-        for race in patchFile.RACE.records:
-            if (race.flags.playable or race.fid == (GPath('Oblivion.esm'), 0x038010)) and race.eyes:
-                defaultEyes[race.fid] = [x for x in bush.defaultEyes.get(race.fid,[]) if x in race.eyes]
-                if not defaultEyes[race.fid]:
-                    defaultEyes[race.fid] = [race.eyes[0]]
-                defaultMaleHair[race.fid] = [x for x in race.hairs if x in maleHairs]
-                defaultFemaleHair[race.fid] = [x for x in race.hairs if x in femaleHairs]
-                race.hairs.sort(key=lambda x: hairNames.get(x))
-                race.eyes.sort(key=lambda x: eyeNames.get(x))
-                racesSorted.append(race.eid)
-                keep(race.fid)
-        #--Npcs with unassigned eyes/hair
-        for npc in patchFile.NPC_.records:
-            if npc.fid == (GPath('Oblivion.esm'), 0x000007): continue #skip player
-            if npc.full is not None and npc.race == (GPath('Oblivion.esm'), 0x038010) and not reProcess.search(npc.full): continue
-            raceEyes = defaultEyes.get(npc.race)
-            if not npc.eye and raceEyes:
-                npc.eye = random.choice(raceEyes)
-                srcMod = npc.fid[0]
-                if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
-                mod_npcsFixed[srcMod].add(npc.fid)
-                keep(npc.fid)
-            raceHair = ((defaultMaleHair,defaultFemaleHair)[npc.flags.female]).get(npc.race)
-            if not npc.hair and raceHair:
-                npc.hair = random.choice(raceHair)
-                srcMod = npc.fid[0]
-                if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
-                mod_npcsFixed[srcMod].add(npc.fid)
-                keep(npc.fid)
-            if not npc.hairLength:
-                npc.hairLength = random.random()
-                srcMod = npc.fid[0]
-                if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
-                keep(npc.fid)
-                if npc.fid in mod_npcsFixed[srcMod]: continue
-                mod_npcsFixed[srcMod].add(npc.fid)
+        for record in patchFile.NPC_.records:
+            continue
+        #--Log suggestions:
+        #log.setHeader(_('===TITLE'))
+        #log(_('* %d X Tweaked') % (sum(count.values()),))
+        #for srcMod in modInfos.getOrdered(count.keys()):
+        #    log('  * %s: %d' % (srcMod.s,count[srcMod]))
+#------------------------------------------------------------------------------
+class BasalCreatureTweaker(MultiTweakItem):
+    """Base for all Creature tweakers"""
+
+    #--Config Phase -----------------------------------------------------------
+    def __init__(self):
+        # Override this segment with real info.
+        MultiTweakItem.__init__(self,_("Title"),
+            _('Description'),
+            'Ignored',
+            ('1.0',  '1.0'),
+            )
+
+    #--Patch Phase ------------------------------------------------------------
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreCrea,)
+
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreCrea,)
+
+    def scanModFile(self,modFile,progress,patchFile):
+        """Scans specified mod file to extract info. May add record to patch mod,
+        but won't alter it."""
+        mapper = modFile.getLongMapper()
+        patchRecords = patchFile.CREA
+        for record in modFile.CREA.getActiveRecords():
+            record = record.getTypeCopy(mapper)
+            patchRecords.setRecord(record)
+
+    def buildPatch(self,log,progress,patchFile):
+        """Edits patch file as desired. Will write to log."""
+        # override this section too!
+        count = {}
+        keep = patchFile.getKeeper()
+        for record in patchFile.CREA.records:
+            continue
+        #--Log suggestions:
+        #log.setHeader(_('===TITLE'))
+        #log(_('* %d X Tweaked') % (sum(count.values()),))
+        #for srcMod in modInfos.getOrdered(count.keys()):
+        #    log('  * %s: %d' % (srcMod.s,count[srcMod]))
+#------------------------------------------------------------------------------
+# class MAONPCSkeletonPatcher(BasalNPCTweaker):
+#     """Changes all NPCs to use the right Mayu's Animation Overhaul Skeleton for use with MAO."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Mayu's Animation Overhaul Skeleton Tweaker"),
+#             _('Changes all (modded and vanilla) NPCs to use the MAO skeletons.  Not compatible with VORB.  Note: ONLY use if you have MAO installed.'),
+#             'MAO Skeleton',
+#             (_('All NPCs'), 0),
+#             (_('Only Female NPCs'), 1),
+#             (_('Only Male NPCs'), 2),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.NPC_.records:
+#             if self.choiceValues[self.chosen][0] == 1 and not record.flags.female: continue
+#             elif self.choiceValues[self.chosen][0] == 2 and record.flags.female: continue
+#             if record.fid == (GPath('Oblivion.esm'),0x000007): continue #skip player record
+#             try:
+#                 oldModPath = record.model.modPath
+#             except AttributeError: #for freaking weird esps with NPC's with no skeleton assigned to them(!)
+#                 continue
+#             newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonBeast.nif"
+#             try:
+#                 if oldModPath.lower() == r'characters\_male\skeletonsesheogorath.nif':
+#                     newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonSESheogorath.nif"
+#             except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
+#                 pass
+#             if newModPath != oldModPath:
+#                 record.model.modPath = newModPath
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===MAO Skeleton Setter'))
+#         log(_('* %d Skeletons Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_MAONPCSkeletonPatcher(CBash_MultiTweakItem):
+#     """Changes all NPCs to use the right Mayu's Animation Overhaul Skeleton for use with MAO."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("MAO Skeleton Setter")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Mayu's Animation Overhaul Skeleton Tweaker"),
+#             _('Changes all (modded and vanilla) NPCs to use the MAO skeletons.  Not compatible with VORB.  Note: ONLY use if you have MAO installed.'),
+#             'MAO Skeleton',
+#             (_('All NPCs'),  0),
+#             (_('Only Female NPCs'),  1),
+#             (_('Only Male NPCs'),  2),
+#             )
+#         self.mod_count = {}
+#         self.playerFid = (GPath('Oblivion.esm'), 0x000007)
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.fid != self.playerFid: #skip player record
+#             if self.choiceValues[self.chosen][0] == 1 and record.IsMale: return
+#             elif self.choiceValues[self.chosen][0] == 2 and record.IsFemale: return
+#             oldModPath = record.modPath
+#             newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonBeast.nif"
+#             try:
+#                 if oldModPath == r'characters\_male\skeletonsesheogorath.nif': #modPaths do case insensitive comparisons by default
+#                     newModPath = r"Mayu's Projects[M]\Animation Overhaul\Vanilla\SkeletonSESheogorath.nif"
+#             except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
+#                 pass
+#             if newModPath != oldModPath:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.modPath = newModPath
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class VORB_NPCSkeletonPatcher(BasalNPCTweaker):
+#     """Changes all NPCs to use the diverse skeleton for different look."""
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("VadersApp's Oblivion Real Bodies Skeleton Tweaker"),
+#             _("Changes all (modded and vanilla) NPCs to use diverse skeletons for different look.  Not compatible with MAO, Requires VadersApp's Oblivion Real Bodies."),
+#             'VORB',
+#             (_('All NPCs'), 0),
+#             (_('Only Female NPCs'), 1),
+#             (_('Only Male NPCs'), 2),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired.  Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+
+#         #--Some setup
+#         skeletonDir = bosh.dirs['mods'].join('Meshes','Characters','_male')
+#         modSkeletonDir = GPath('Characters').join('_male')
+
+#         if skeletonDir.exists():
+#             # construct skeleton mesh collections
+#             # skeletonList gets files that match the pattern "skel_*.nif", but not "skel_special_*.nif"
+#             # skeletonSetSpecial gets files that match "skel_special_*.nif"
+#             skeletonList = [x for x in skeletonDir.list() if x.csbody.startswith('skel_') and not x.csbody.startswith('skel_special_') and x.cext == '.nif']
+#             skeletonSetSpecial = set((x.s for x in skeletonDir.list() if x.csbody.startswith('skel_special_') and x.cext == '.nif'))
+
+#             if len(skeletonList) > 0:
+#                 femaleOnly = self.choiceValues[self.chosen][0] == 1
+#                 maleOnly = self.choiceValues[self.chosen][0] == 2
+#                 playerFid = (GPath('Oblivion.esm'),0x000007)
+
+#                 for record in patchFile.NPC_.records:
+#                     # skip records (male only, female only, player)
+#                     if femaleOnly and not record.flags.female: continue
+#                     elif maleOnly and record.flags.female: continue
+#                     if record.fid == playerFid: continue
+#                     try:
+#                         oldModPath = record.model.modPath
+#                     except AttributeError:  # for freaking weird esps with NPC's with no skeleton assigned to them(!)
+#                         continue
+
+#                     specialSkelMesh = "skel_special_%X.nif" % record.fid[1]
+#                     if specialSkelMesh in skeletonSetSpecial:
+#                         newModPath = modSkeletonDir.join(specialSkelMesh)
+#                     else:
+#                         random.seed(record.fid)
+#                         randomNumber = random.randint(1, len(skeletonList))-1
+#                         newModPath = modSkeletonDir.join(skeletonList[randomNumber])
+
+#                     if newModPath != oldModPath:
+#                         record.model.modPath = newModPath.s
+#                         keep(record.fid)
+#                         srcMod = record.fid[0]
+#                         count[srcMod] = count.get(srcMod,0) + 1
+
+#         #--Log
+#         log.setHeader(_("===VadersApp's Oblivion Real Bodies"))
+#         log(_('* %d Skeletons Tweaked') % sum(count.values()))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s, count[srcMod]))
+
+# class CBash_VORB_NPCSkeletonPatcher(CBash_MultiTweakItem):
+#     """Changes all NPCs to use the diverse skeletons for different look."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("VORB Skeleton Setter")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("VadersApp's Oblivion Real Bodies Skeleton Tweaker"),
+#             _("Changes all (modded and vanilla) NPCs to use diverse skeletons for different look.  Not compatible with MAO, Requires VadersApp's Oblivion Real Bodies."),
+#             'VORB',
+#             (_('All NPCs'),  0),
+#             (_('Only Female NPCs'),  1),
+#             (_('Only Male NPCs'),  2),
+#             )
+#         self.mod_count = {}
+#         self.modSkeletonDir = GPath('Characters').join('_male')
+#         self.playerFid = (GPath('Oblivion.esm'), 0x000007)
+#         self.skeletonList = None
+#         self.skeletonSetSpecial = None
+
+#     def initSkeletonCollections(self):
+#         """ construct skeleton mesh collections
+#             skeletonList gets files that match the pattern "skel_*.nif", but not "skel_special_*.nif"
+#             skeletonSetSpecial gets files that match "skel_special_*.nif" """
+#         # Since bosh.dirs hasn't been populated when __init__ executes, we do this here
+#         if not self.skeletonList is None:
+#             return
+#         self.skeletonList = []
+#         skeletonDir = bosh.dirs['mods'].join('Meshes', 'Characters', '_male')
+#         if skeletonDir.exists():
+#             self.skeletonList = [x for x in skeletonDir.list() if x.csbody.startswith('skel_') and not x.csbody.startswith('skel_special_') and x.cext == '.nif']
+#             self.skeletonSetSpecial = set((x.s for x in skeletonDir.list() if x.csbody.startswith('skel_special_') and x.cext == '.nif'))
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.fid == self.playerFid: return #skip player record
+#         elif self.choiceValues[self.chosen][0] == 1 and record.IsMale: return
+#         elif self.choiceValues[self.chosen][0] == 2 and record.IsFemale: return
+#         self.initSkeletonCollections()
+#         if len(self.skeletonList) == 0: return
+
+#         try:
+#             oldModPath = record.modPath.lower()
+#         except AttributeError:  # for freaking weird esps with NPC's with no skeleton assigned to them(!)
+#             pass
+
+#         specialSkelMesh = "skel_special_%X.nif" % record.fid[1]
+#         if specialSkelMesh in self.skeletonSetSpecial:
+#             newModPath = self.modSkeletonDir.join(specialSkelMesh)
+#         else:
+#             random.seed(record.fid)
+#             randomNumber = random.randint(1, len(self.skeletonList))-1
+#             newModPath = self.modSkeletonDir.join(self.skeletonList[randomNumber])
+
+#         if newModPath.cs != oldModPath:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.modPath = newModPath.s
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class VanillaNPCSkeletonPatcher(MultiTweakItem):
+#     """Changes all NPCs to use the vanilla beast race skeleton."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Vanilla Beast Skeleton Tweaker"),
+#             _('Avoids bug if an NPC is a beast race but has the regular skeleton.nif selected.'),
+#             'Vanilla Skeleton',
+#             ('1.0',  '1.0'),
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreNpc,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreNpc,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.NPC_
+#         for record in modFile.NPC_.getActiveRecords():
+#             record = record.getTypeCopy(mapper)
+#             if not record.model: continue #for freaking weird esps with NPC's with no skeleton assigned to them(!)
+#             model = record.model.modPath
+#             if model.lower() == r'characters\_male\skeleton.nif':
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         newModPath = r"Characters\_Male\SkeletonBeast.nif"
+#         for record in patchFile.NPC_.records:
+#             try:
+#                 oldModPath = record.model.modPath
+#             except AttributeError: #for freaking weird esps with NPC's with no skeleton assigned to them(!)
+#                 continue
+#             try:
+#                 if oldModPath.lower() != r'characters\_male\skeleton.nif':
+#                     continue
+#             except AttributeError: #in case oldModPath was None. Try/Except has no overhead if exception isn't thrown.
+#                 pass
+#             if newModPath != oldModPath:
+#                 record.model.modPath = newModPath
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===Vanilla Beast Skeleton'))
+#         log(_('* %d Skeletons Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_VanillaNPCSkeletonPatcher(CBash_MultiTweakItem):
+#     """Changes all NPCs to use the vanilla beast race skeleton."""
+#     scanOrder = 31 #Run before MAO
+#     editOrder = 31
+#     name = _("Vanilla Beast Skeleton")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Vanilla Beast Skeleton Tweaker"),
+#             _('Avoids bug if an NPC is a beast race but has the regular skeleton.nif selected.'),
+#             'Vanilla Skeleton',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         oldModPath = record.modPath
+#         newModPath = r"Characters\_Male\SkeletonBeast.nif"
+#         try:
+#             if oldModPath != r'characters\_male\skeleton.nif': #modPaths do case insensitive comparisons by default
+#                 return
+#         except AttributeError: #in case modPath was None. Try/Except has no overhead if exception isn't thrown.
+#             pass
+#         if newModPath != oldModPath:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.modPath = newModPath
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Skeletons Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class RedguardNPCPatcher(BasalNPCTweaker):
+#     """Changes all Redguard NPCs texture symetry for Better Redguard Compatibility."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Redguard FGTS Nuller"),
+#             _('Nulls FGTS of all Redguard NPCs - for compatibility with Better Redguards.'),
+#             'RedguardFGTSPatcher',
+#             ('1.0',  '1.0'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.NPC_.records:
+#             if not record.race: continue
+#             if record.race[1] == 0x00d43:
+#                 record.fgts_p = '\x00'*200
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===Redguard FGTS Patcher'))
+#         log(_('* %d Redguard NPCs Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_RedguardNPCPatcher(CBash_MultiTweakItem):
+#     """Changes all Redguard NPCs texture symmetry for Better Redguard Compatibility."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Redguard FGTS Patcher")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Redguard FGTS Nuller"),
+#             _('Nulls FGTS of all Redguard NPCs - for compatibility with Better Redguards.'),
+#             'RedguardFGTSPatcher',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+#         self.redguardId = (GPath('Oblivion.esm'),0x00000D43)
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.race == self.redguardId: #Only affect npc's with the Redguard race
+#             oldFGTS_p = record.fgts_p
+#             newFGTS_p = [0x00] * 200
+#             if newFGTS_p != oldFGTS_p:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.fgts_p = newFGTS_p
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Redguard NPCs Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class NoBloodCreaturesPatcher(BasalCreatureTweaker):
+#     """Set all creatures to have no blood records."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("No Bloody Creatures"),
+#             _("Set all creatures to have no blood records, will have pretty much no effect when used with MMM since the MMM blood uses a different system."),
+#             'No bloody creatures',
+#             ('1.0',  '1.0'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.CREA.records:
+#             if record.bloodDecalPath or record.bloodSprayPath:
+#                 record.bloodDecalPath = None
+#                 record.bloodSprayPath = None
+#                 record.flags.noBloodSpray = True
+#                 record.flags.noBloodDecal = True
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===No Bloody Creatures'))
+#         log(_('* %d Creatures Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_NoBloodCreaturesPatcher(CBash_MultiTweakItem):
+#     """Set all creatures to have no blood records."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("No Bloody Creatures")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("No Bloody Creatures"),
+#             _("Set all creatures to have no blood records, will have pretty much no effect when used with MMM since the MMM blood uses a different system."),
+#             'No bloody creatures',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CREA']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.bloodDecalPath or record.bloodSprayPath:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.bloodDecalPath = None
+#                 override.bloodSprayPath = None
+#                 override.IsNoBloodSpray = True
+#                 override.IsNoBloodDecal = True
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AsIntendedImpsPatcher(BasalCreatureTweaker):
+#     """Set all imps to have the Bethesda imp spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
+#     reImpModPath  = re.compile(r'(imp(?!erial)|gargoyle)\\.',re.I)
+#     reImp  = re.compile(r'(imp(?!erial)|gargoyle)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_('As Intended: Imps'),
+#             _("Set imps to have the unassigned Bethesda Imp Spells as discovered by the UOP team and made into a mod by Tejon."),
+#             'vicious imps!',
+#             (_('All imps'), 'all'),
+#             (_('Only fullsize imps'), 'big'),
+#             (_('Only implings'), 'small'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         spell = (GPath('Oblivion.esm'), 0x02B53F)
+#         reImp  = self.reImp
+#         reImpModPath = self.reImpModPath
+#         for record in patchFile.CREA.records:
+#             try:
+#                 oldModPath = record.model.modPath
+#             except AttributeError:
+#                 continue
+#             if not reImpModPath.search(oldModPath or ''): continue
+
+#             for bodyPart in record.bodyParts:
+#                 if reImp.search(bodyPart):
+#                     break
+#             else:
+#                 continue
+#             if record.baseScale < 0.4:
+#                 if 'big' in self.choiceValues[self.chosen]:
+#                     continue
+#             elif 'small' in self.choiceValues[self.chosen]:
+#                 continue
+#             if spell not in record.spells:
+#                 record.spells.append(spell)
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===As Intended: Imps'))
+#         log(_('* %d Imps Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_AsIntendedImpsPatcher(CBash_MultiTweakItem):
+#     """Set all imps to have the Bethesda imp spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("As Intended: Imps")
+#     reImpModPath  = re.compile(r'(imp(?!erial)|gargoyle)\\.',re.I)
+#     reImp  = re.compile(r'(imp(?!erial)|gargoyle)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_('As Intended: Imps'),
+#             _("Set imps to have the unassigned Bethesda Imp Spells as discovered by the UOP team and made into a mod by Tejon."),
+#             'vicious imps!',
+#             (_('All imps'), 'all'),
+#             (_('Only fullsize imps'), 'big'),
+#             (_('Only implings'), 'small'),
+#             )
+#         self.mod_count = {}
+#         self.spell = (GPath('Oblivion.esm'), 0x02B53F)
+
+#     def getTypes(self):
+#         return ['CREA']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if not self.reImpModPath.search(record.modPath or ''): return
+
+#         reImp  = self.reImp
+#         for bodyPart in record.bodyParts:
+#             if reImp.search(bodyPart):
+#                 break
+#         else:
+#             return
+#         if record.baseScale < 0.4:
+#             if 'big' in self.choiceValues[self.chosen]:
+#                 return
+#         elif 'small' in self.choiceValues[self.chosen]:
+#             return
+#         spells = record.spells
+#         newSpell = self.spell
+#         if newSpell not in spells:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 spells.append(newSpell)
+#                 override.spells = spells
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Imps Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class AsIntendedBoarsPatcher(BasalCreatureTweaker):
+#     """Set all imps to have the Bethesda boar spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
+#     reBoarModPath  = re.compile(r'(boar)\\.',re.I)
+#     reBoar  = re.compile(r'(boar)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_('As Intended: Boars'),
+#             _("Set boars to have the unassigned Bethesda Boar Spells as discovered by the UOP team and made into a mod by Tejon."),
+#             'vicious boars!',
+#             ('1.0',  '1.0'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         spell = (GPath('Oblivion.esm'), 0x02B54E)
+#         keep = patchFile.getKeeper()
+#         reBoar  = self.reBoar
+#         reBoarModPath = self.reBoarModPath
+#         for record in patchFile.CREA.records:
+#             try:
+#                 oldModPath = record.model.modPath
+#             except AttributeError:
+#                 continue
+#             if not reBoarModPath.search(oldModPath or ''): continue
+
+#             for bodyPart in record.bodyParts:
+#                 if reBoar.search(bodyPart):
+#                     break
+#             else:
+#                 continue
+#             if spell not in record.spells:
+#                 record.spells.append(spell)
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===As Intended: Boars'))
+#         log(_('* %d Boars Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_AsIntendedBoarsPatcher(CBash_MultiTweakItem):
+#     """Set all imps to have the Bethesda boar spells that were never assigned (discovered by the UOP team, made into a mod by Tejon)."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("As Intended: Boars")
+#     reBoarModPath  = re.compile(r'(boar)\\.',re.I)
+#     reBoar  = re.compile(r'(boar)',re.I)
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_('As Intended: Boars'),
+#             _("Set boars to have the unassigned Bethesda Boar Spells as discovered by the UOP team and made into a mod by Tejon."),
+#             'vicious boars!',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+#         self.spell = (GPath('Oblivion.esm'), 0x02B54E)
+
+#     def getTypes(self):
+#         return ['CREA']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if not self.reBoarModPath.search(record.modPath or ''): return
+
+#         reBoar  = self.reBoar
+#         for bodyPart in record.bodyParts:
+#             if reBoar.search(bodyPart):
+#                 break
+#         else:
+#             return
+
+#         spells = record.spells
+#         newSpell = self.spell
+#         if newSpell not in spells:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 spells.append(newSpell)
+#                 override.spells = spells
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Boars Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class SWALKNPCAnimationPatcher(BasalNPCTweaker):
+#     """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Sexy Walk for female NPCs"),
+#             _("Changes all female NPCs to use Mur Zuk's Sexy Walk - Requires Mur Zuk's Sexy Walk animation file."),
+#             'Mur Zuk SWalk',
+#             ('1.0',  '1.0'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.NPC_.records:
+#             if record.flags.female == 1:
+#                 record.animations = record.animations + ['0sexywalk01.kf']
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===SWalk for Female NPCs'))
+#         log(_('* %d NPCs Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_SWALKNPCAnimationPatcher(CBash_MultiTweakItem):
+#     """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Sexy Walk for female NPCs")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Sexy Walk for female NPCs"),
+#             _("Changes all female NPCs to use Mur Zuk's Sexy Walk - Requires Mur Zuk's Sexy Walk animation file."),
+#             'Mur Zuk SWalk',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+#         self.playerFid = (GPath('Oblivion.esm'), 0x000007)
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.fid != self.playerFid: #skip player record
+#             if record.IsFemale:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.animations = override.animations + ['0sexywalk01.kf']
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* NPCs Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class RWALKNPCAnimationPatcher(BasalNPCTweaker):
+#     """Changes all female NPCs to use Mur Zuk's Real Walk."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Real Walk for female NPCs"),
+#             _("Changes all female NPCs to use Mur Zuk's Real Walk - Requires Mur Zuk's Real Walk animation file."),
+#             'Mur Zuk RWalk',
+#             ('1.0',  '1.0'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.NPC_.records:
+#             if record.flags.female == 1:
+#                 record.animations = record.animations + ['0realwalk01.kf']
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===RWalk for Female NPCs'))
+#         log(_('* %d NPCs Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_RWALKNPCAnimationPatcher(CBash_MultiTweakItem):
+#     """Changes all female NPCs to use Mur Zuk's Sexy Walk."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Real Walk for female NPCs")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Real Walk for female NPCs"),
+#             _("Changes all female NPCs to use Mur Zuk's Real Walk - Requires Mur Zuk's Real Walk animation file."),
+#             'Mur Zuk RWalk',
+#             ('1.0',  '1.0'),
+#             )
+#         self.mod_count = {}
+#         self.playerFid = (GPath('Oblivion.esm'), 0x000007)
+
+#     def getTypes(self):
+#         return ['NPC_']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.fid != self.playerFid: #skip player record
+#             if record.IsFemale:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.animations = override.animations + ['0realwalk01.kf']
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* NPCs Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class QuietFeetPatcher(BasalCreatureTweaker):
+#     """Removes 'foot' sounds from all/specified creatures - like the mod by the same name but works on all modded creatures."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_('Quiet Feet'),
+#             _("Removes all/some 'foot' sounds from creatures; on some computers can have a significant performance boost."),
+#             'silent n sneaky!',
+#             (_('All Creature Foot Sounds'), 'all'),
+#             (_('Only 4 Legged Creature Foot Sounds'), 'partial'),
+#             (_('Only Mount Foot Sounds'), 'mounts'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         chosen = self.choiceValues[self.chosen][0]
+#         for record in patchFile.CREA.records:
+#             sounds = record.sounds
+#             if chosen == 'all':
+#                 sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
+#             elif chosen == 'partial':
+#                 for sound in record.sounds:
+#                     if sound.type in [2,3]:
+#                         sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
+#                         break
+#             else: #really is: "if chosen == 'mounts':", but less cpu to do it as else.
+#                 if record.creatureType == 4:
+#                     sounds = [sound for sound in sounds if sound.type not in [0,1,2,3]]
+#             if sounds != record.sounds:
+#                 record.sounds = sounds
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===Quite Feet'))
+#         log(_('* %d Creatures Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_QuietFeetPatcher(CBash_MultiTweakItem):
+#     """Removes 'foot' sounds from all/specified creatures - like the mod by the same name but works on all modded creatures."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Quiet Feet")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_('Quiet Feet'),
+#             _("Removes all/some 'foot' sounds from creatures; on some computers can have a significant performance boost."),
+#             'silent n sneaky!',
+#             (_('All Creature Foot Sounds'), 'all'),
+#             (_('Only 4 Legged Creature Foot Sounds'), 'partial'),
+#             (_('Only Mount Foot Sounds'), 'mounts'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CREA']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         chosen = self.choiceValues[self.chosen][0]
+#         #equality operator not implemented for ObCREARecord.Sound class, so use the list version instead
+#         sounds_list = record.sounds_list
+#         #0 = IsLeftFoot, 1 = IsRightFoot, 2 = IsLeftBackFoot, 3 = IsRightBackFoot
+#         if chosen == 'all':
+#             sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
+#         elif chosen == 'partial':
+#             for sound in record.sounds:
+#                 if sound.soundType in [2,3]:
+#                     sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
+#                     break
+#         else: ##if chosen == 'mounts':
+#             if record.IsHorse:
+#                 sounds_list = [sound for sound in sounds_list if sound[0] not in [0,1,2,3]]
+#         if sounds_list != record.sounds_list:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.sounds_list = sounds_list
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class IrresponsibleCreaturesPatcher(BasalCreatureTweaker):
+#     """Sets responsibility to 0 for all/specified creatures - like the mod by the name of Irresponsible Horses but works on all modded creatures."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_('Irresponsible Creatures'),
+#             _("Sets responsibility to 0 for all/specified creatures - so they can't report you for crimes."),
+#             'whatbadguarddogs',
+#             (_('All Creatures'), 'all'),
+#             (_('Only Horses'), 'mounts'),
+#             )
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         chosen = self.choiceValues[self.chosen][0]
+#         for record in patchFile.CREA.records:
+#             if record.responsibility == 0: return
+#             if chosen == 'all':
+#                 record.responsibility = 0
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#             else: #really is: "if chosen == 'mounts':", but less cpu to do it as else.
+#                 if record.creatureType == 4:
+#                     record.responsibility = 0
+#                     keep(record.fid)
+#                     srcMod = record.fid[0]
+#                     count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===Irresponsible Creatures'))
+#         log(_('* %d Creatures Tweaked') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_IrresponsibleCreaturesPatcher(CBash_MultiTweakItem):
+#     """Sets responsibility to 0 for all/specified creatures - like the mod by the name of Irresponsible Horses but works on all modded creatures."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Irresponsible Creatures")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_('Irresponsible Creatures'),
+#             _("Sets responsibility to 0 for all/specified creatures - so they can't report you for crimes."),
+#             'whatbadguarddogs',
+#             (_('All Creatures'), 'all'),
+#             (_('Only Horses'), 'mounts'),
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['CREA']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.responsibility == 0: return
+#         if self.choiceValues[self.chosen][0] == 'mounts' and not record.IsHorse: return
+#         override = record.CopyAsOverride(self.patchFile)
+#         if override:
+#             override.responsibility = 0
+#             mod_count = self.mod_count
+#             mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#             record.UnloadRecord()
+#             record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Creatures Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class BiggerOrcsandNords(MultiTweakItem):
+#     """Adjusts the Orc and Nord race records to be taller/heavier."""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         MultiTweakItem.__init__(self,_("Bigger Nords and Orcs"),
+#             _('Adjusts the Orc and Nord race records to be taller/heavier - to be more lore friendly.'),
+#             'BiggerOrcsandNords',
+#             #('Example',(Nordmaleheight,NordFheight,NordMweight,NordFweight,Orcmaleheight,OrcFheight,OrcMweight,OrcFweight))
+#             ('Bigger Nords and Orcs', ((1.09,1.09,1.13,1.06),(1.09,1.09,1.13,1.0))),
+#             ('MMM Resized Races', ((1.08,1.07,1.28,1.19),(1.09,1.06,1.36,1.3))),
+#             ('RBP', ((1.075,1.06,1.20,1.125),(1.06,1.045,1.275,1.18)))
+#             )
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (MreRace,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (MreRace,)
+
+#     def scanModFile(self,modFile,progress,patchFile):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         mapper = modFile.getLongMapper()
+#         patchRecords = patchFile.RACE
+#         for record in modFile.RACE.getActiveRecords():
+#             if not record.full: continue
+#             if not 'orc' in record.full.lower() and not 'nord' in record.full.lower(): continue
+#             record = record.getTypeCopy(mapper)
+#             patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress,patchFile):
+#         """Edits patch file as desired. Will write to log."""
+#         count = {}
+#         keep = patchFile.getKeeper()
+#         for record in patchFile.RACE.records:
+#             if not record.full: continue
+#             if 'nord' in record.full.lower():
+#                 for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][0]):
+#                     setattr(record,attr,value)
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#                 continue
+#             elif 'orc' in record.full.lower():
+#                 for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][1]):
+#                     setattr(record,attr,value)
+#                 keep(record.fid)
+#                 srcMod = record.fid[0]
+#                 count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('===Bigger Nords and Orcs'))
+#         log(_('* %d Races tweaked.') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_BiggerOrcsandNords(CBash_MultiTweakItem):
+#     """Changes all Redguard NPCs texture symmetry for Better Redguard Compatibility."""
+#     scanOrder = 32
+#     editOrder = 32
+#     name = _("Bigger Nords and Orcs")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def __init__(self):
+#         CBash_MultiTweakItem.__init__(self,_("Bigger Nords and Orcs"),
+#             _('Adjusts the Orc and Nord race records to be taller/heavier - to be more lore friendly.'),
+#             'BiggerOrcsand Nords',
+#             #('Example',(Nordmaleheight,NordFheight,NordMweight,NordFweight,Orcmaleheight,OrcFheight,OrcMweight,OrcFweight))
+#             ('Bigger Nords and Orcs', ((1.09,1.09,1.13,1.06),(1.09,1.09,1.13,1.0))),
+#             ('MMM Resized Races', ((1.08,1.07,1.28,1.19),(1.09,1.06,1.36,1.3))),
+#             ('RBP', ((1.075,1.06,1.20,1.125),(1.06,1.045,1.275,1.18)))
+#             )
+#         self.mod_count = {}
+
+#     def getTypes(self):
+#         return ['RACE']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if not record.full: return
+#         if 'nord' in record.full.lower():
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][0]):
+#                     setattr(override,attr,value)
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+#                 return
+#         elif 'orc' in record.full.lower():
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 for attr,value in zip(['maleHeight','femaleHeight','maleWeight','femaleWeight'],self.choiceValues[self.chosen][0][1]):
+#                     setattr(override,attr,value)
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+#                 return
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('=== '+self.__class__.name)
+#         log(_('* Races tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+#------------------------------------------------------------------------------
+# class TweakActors(MultiTweaker):
+#     """Sets Creature stuff or NPC Skeletons, Animations or other settings to better work with mods or avoid bugs."""
+#     name = _('Tweak Actors')
+#     text = _("Tweak NPC and Creatures records in specified ways.")
+#     tweaks = sorted([
+#         VORB_NPCSkeletonPatcher(),
+#         MAONPCSkeletonPatcher(),
+#         VanillaNPCSkeletonPatcher(),
+#         RedguardNPCPatcher(),
+#         NoBloodCreaturesPatcher(),
+#         AsIntendedImpsPatcher(),
+#         AsIntendedBoarsPatcher(),
+#         QuietFeetPatcher(),
+#         IrresponsibleCreaturesPatcher(),
+#         BiggerOrcsandNords(),
+#         RWALKNPCAnimationPatcher(),
+#         SWALKNPCAnimationPatcher(),
+#         ],key=lambda a: a.label.lower())
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         if not self.isActive: return None
+#         classTuples = [tweak.getReadClasses() for tweak in self.enabledTweaks]
+#         return sum(classTuples,tuple())
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         if not self.isActive: return None
+#         classTuples = [tweak.getWriteClasses() for tweak in self.enabledTweaks]
+#         return sum(classTuples,tuple())
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive: return
+#         for tweak in self.enabledTweaks:
+#             tweak.scanModFile(modFile,progress,self.patchFile)
+
+#     def buildPatch(self,log,progress):
+#         """Applies individual tweaks."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatch(log,progress,self.patchFile)
+
+
+# class CBash_TweakActors(CBash_MultiTweaker):
+#     """Sets Creature stuff or NPC Skeletons, Animations or other settings to better work with mods or avoid bugs."""
+#     name = _('Tweak Actors')
+#     text = _("Tweak NPC and Creatures records in specified ways.")
+#     tweaks = sorted([
+#         CBash_VORB_NPCSkeletonPatcher(),
+#         CBash_MAONPCSkeletonPatcher(),
+#         CBash_VanillaNPCSkeletonPatcher(),
+#         CBash_RedguardNPCPatcher(),
+#         CBash_NoBloodCreaturesPatcher(),
+#         CBash_AsIntendedImpsPatcher(),
+#         CBash_AsIntendedBoarsPatcher(),
+#         CBash_QuietFeetPatcher(),
+#         CBash_IrresponsibleCreaturesPatcher(),
+#         CBash_BiggerOrcsandNords(),
+#         CBash_RWALKNPCAnimationPatcher(),
+#         CBash_SWALKNPCAnimationPatcher(),
+#         ],key=lambda a: a.label.lower())
+#     #--Config Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         for tweak in self.tweaks:
+#             tweak.patchFile = patchFile
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         log.setHeader('= '+self.__class__.name,True)
+#         for tweak in self.enabledTweaks:
+#             tweak.buildPatchLog(log)
+# Patchers: 40 ----------------------------------------------------------------
+class SpecialPatcher:
+    """Provides default group, scan and edit orders."""
+    group = _('Special')
+    scanOrder = 40
+    editOrder = 40
 
-        #--Done
-        log.setHeader('= '+self.__class__.name)
-        log(_("=== Source Mods"))
-        for mod in self.srcMods:
-            log("* " +mod.s)
-        log(_("\n=== Merged"))
-        if not racesPatched:
-            log(_(". ~~None~~"))
-        else:
-            for eid in sorted(racesPatched):
-                log("* "+eid)
-        log(_("\n=== Eyes/Hair Sorted"))
-        if not racesSorted:
-            log(_(". ~~None~~"))
-        else:
-            for eid in sorted(racesSorted):
-                log("* "+eid)
-        log(_("\n=== Eye Meshes Filtered"))
-        if not racesFiltered:
-            log(_(". ~~None~~"))
-        else:
-            log(_("In order to prevent 'googly eyes', incompatible eyes have been removed from the following races."))
-            for eid in sorted(racesFiltered):
-                log("* "+eid)
-        if mod_npcsFixed:
-            log(_("\n=== Eyes/Hair Assigned for NPCs"))
-            for srcMod in sorted(mod_npcsFixed):
-                log("* %s: %d" % (srcMod.s,len(mod_npcsFixed[srcMod])))
+#------------------------------------------------------------------------------
+# class AlchemicalCatalogs(SpecialPatcher,Patcher):
+#     """Updates COBL alchemical catalogs."""
+#     name = _('Cobl Catalogs')
+#     text = _("Update COBL's catalogs of alchemical ingredients and effects.\n\nWill only run if Cobl Main.esm is loaded.")
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = (GPath('COBL Main.esm') in loadMods)
+#         self.id_ingred = {}
+
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         if not self.isActive: return tuple()
+#         return (MreIngr,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         if not self.isActive: return tuple()
+#         return (MreBook,)
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive: return
+#         id_ingred = self.id_ingred
+#         mapper = modFile.getLongMapper()
+#         for record in modFile.INGR.getActiveRecords():
+#             if not record.full: continue #--Ingredient must have name!
+#             effects = record.getEffects()
+#             if not ('SEFF',0) in effects:
+#                 id_ingred[mapper(record.fid)] = (record.eid, record.full, effects)
+
+#     def buildPatch(self,log,progress):
+#         """Edits patch file as desired. Will write to log."""
+#         if not self.isActive: return
+#         #--Setup
+#         mgef_name = self.patchFile.getMgefName()
+#         for mgef in mgef_name:
+#             mgef_name[mgef] = re.sub(_('(Attribute|Skill)'),'',mgef_name[mgef])
+#         actorEffects = bush.genericAVEffects
+#         actorNames = bush.actorValues
+#         keep = self.patchFile.getKeeper()
+#         #--Book generatator
+#         def getBook(objectId,eid,full,value,iconPath,modelPath,modb_p):
+#             book = MreBook(('BOOK',0,0,0,0))
+#             book.longFids = True
+#             book.changed = True
+#             book.eid = eid
+#             book.full = Encode(full, 'mbcs')
+#             book.value = value
+#             book.weight = 0.2
+#             book.fid = keep((GPath('Cobl Main.esm'),objectId))
+#             book.text = '<div align="left"><font face=3 color=4444>'
+#             book.text += Encode(_("Salan's Catalog of %s\r\n\r\n") % full, 'mbcs')
+#             book.iconPath = iconPath
+#             book.model = book.getDefault('model')
+#             book.model.modPath = modelPath
+#             book.model.modb_p = modb_p
+#             book.modb = book
+#             self.patchFile.BOOK.setRecord(book)
+#             return book
+#         #--Ingredients Catalog
+#         id_ingred = self.id_ingred
+#         iconPath,modPath,modb_p = ('Clutter\IconBook9.dds','Clutter\Books\Octavo02.NIF','\x03>@A')
+#         for (num,objectId,full,value) in bush.ingred_alchem:
+#             book = getBook(objectId,'cobCatAlchemIngreds'+`num`,full,value,iconPath,modPath,modb_p)
+#             buff = stringBuffer()
+#             buff.write(book.text)
+#             for eid,full,effects in sorted(id_ingred.values(),key=lambda a: a[1].lower()):
+#                 buff.write(full+'\r\n')
+#                 for mgef,actorValue in effects[:num]:
+#                     effectName = Encode(mgef_name[mgef],'mbcs')
+#                     if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
+#                     buff.write('  '+effectName+'\r\n')
+#                 buff.write('\r\n')
+#             book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
+#         #--Get Ingredients by Effect
+#         effect_ingred = {}
+#         for fid,(eid,full,effects) in id_ingred.iteritems():
+#             for index,(mgef,actorValue) in enumerate(effects):
+#                 effectName = Encode(mgef_name[mgef],'mbcs')
+#                 if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
+#                 if effectName not in effect_ingred: effect_ingred[effectName] = []
+#                 effect_ingred[effectName].append((index,full))
+#         #--Effect catalogs
+#         iconPath,modPath,modb_p = ('Clutter\IconBook7.dds','Clutter\Books\Octavo01.NIF','\x03>@A')
+#         for (num,objectId,full,value) in bush.effect_alchem:
+#             book = getBook(objectId,'cobCatAlchemEffects'+`num`,full,value,iconPath,modPath,modb_p)
+#             buff = stringBuffer()
+#             buff.write(book.text)
+#             for effectName in sorted(effect_ingred.keys()):
+#                 effects = [indexFull for indexFull in effect_ingred[effectName] if indexFull[0] < num]
+#                 if effects:
+#                     buff.write(effectName+'\r\n')
+#                     for (index,full) in sorted(effects,key=lambda a: a[1].lower()):
+#                         exSpace = ('',' ')[index == 0]
+#                         buff.write(' '+`index + 1`+exSpace+' '+full+'\r\n')
+#                     buff.write('\r\n')
+#             book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
+#         #--Log
+#         log.setHeader('= '+self.__class__.name)
+#         log(_('* Ingredients Cataloged: %d') % (len(id_ingred),))
+#         log(_('* Effects Cataloged: %d') % (len(effect_ingred)))
+
+# class CBash_AlchemicalCatalogs(SpecialPatcher,CBash_Patcher):
+#     """Updates COBL alchemical catalogs."""
+#     name = _('Cobl Catalogs')
+#     text = _("Update COBL's catalogs of alchemical ingredients and effects.\n\nWill only run if Cobl Main.esm is loaded.")
+#     unloadedText = ""
+#     srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = GPath('Cobl Main.esm') in loadMods
+#         if not self.isActive: return
+#         patchFile.indexMGEFs = True
+#         self.id_ingred = {}
+#         self.effect_ingred = {}
+#         self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+#         self.DebugPrintOnce = 0
+
+#     def getTypes(self):
+#         return ['INGR']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if (record.full):
+#             SEFFValue = self.SEFFValue
+#             for effect in record.effects:
+#                 if effect.name == SEFFValue:
+#                     return
+#             self.id_ingred[record.fid] = (record.eid, record.full, record.effects_list)
+
+#     def finishPatch(self,patchFile,progress):
+#         """Edits the bashed patch file directly."""
+#         subProgress = SubProgress(progress)
+#         subProgress.setFull(len(bush.effect_alchem) + len(bush.ingred_alchem))
+#         pstate = 0
+#         #--Setup
+#         try:
+#             coblMod = patchFile.ObCollection.LookupModFile('Cobl Main.esm')
+#         except KeyError, error:
+#             print "CBash_AlchemicalCatalogs:finishPatch"
+#             print error[0]
+#             return
+
+#         mgef_name = patchFile.mgef_name.copy()
+#         for mgef in mgef_name:
+#             mgef_name[mgef] = re.sub(_('(Attribute|Skill)'),'',mgef_name[mgef])
+#         actorEffects = bush.genericAVEffects
+#         actorNames = bush.actorValues
+#         #--Book generator
+#         def getBook(patchFile, objectId):
+#             book = coblMod.LookupRecord((GPath('Cobl Main.esm'),objectId))
+#             #There have been reports of this patcher failing, hence the sanity checks
+#             if book:
+#                 if book.recType != 'BOOK':
+#                     print PrintFormID(fid)
+#                     print patchFile.ObCollection.Debug_DumpModFiles()
+#                     print book
+#                     raise StateError(_("Cobl Catalogs: Unable to lookup book record in Cobl Main.esm!"))
+#                 book = book.CopyAsOverride(self.patchFile)
+#                 if not book:
+#                     print PrintFormID(fid)
+#                     print patchFile.ObCollection.Debug_DumpModFiles()
+#                     print book
+#                     book = coblMod.LookupRecord((GPath('Cobl Main.esm'),objectId))
+#                     print book
+#                     print book.text
+#                     print
+#                     raise StateError(_("Cobl Catalogs: Unable to create book!"))
+#             return book
+#         #--Ingredients Catalog
+#         id_ingred = self.id_ingred
+#         for (num,objectId,full,value) in bush.ingred_alchem:
+#             subProgress(pstate, _("Cataloging Ingredients...\n%s") % full)
+#             pstate += 1
+#             book = getBook(patchFile, objectId)
+#             if not book: continue
+#             buff = stringBuffer()
+#             buff.write('<div align="left"><font face=3 color=4444>' + Encode(_("Salan's Catalog of %s\r\n\r\n") % full,'mbcs'))
+#             for eid,full,effects_list in sorted(id_ingred.values(),key=lambda a: a[1].lower()):
+#                 buff.write(Encode(full,'mbcs')+'\r\n')
+#                 for effect in effects_list[:num]:
+#                     mgef = effect[0] #name field
+#                     try:
+#                         effectName = mgef_name[mgef]
+#                     except KeyError:
+#                         if not self.DebugPrintOnce:
+#                             self.DebugPrintOnce = 1
+#                             deprint(patchFile.ObCollection.Debug_DumpModFiles())
+#                             deprint()
+#                             deprint('mgef_name:', mgef_name)
+#                             deprint()
+#                             deprint('mgef:', mgef)
+#                             deprint()
+#                         if mgef in bush.mgef_name:
+#                             deprint('mgef found in bush.mgef_name')
+#                             effectName = re.sub(_('(Attribute|Skill)'),'',bush.mgef_name[mgef])
+#                         else:
+#                             deprint('mgef not found in bush.mgef_name')
+#                             effectName = 'Unknown Effect'
+#                     effectName = Encode(effectName,'mbcs')
+#                     if mgef in actorEffects: effectName += Encode(actorNames[effect[5]],'mbcs') #actorValue field
+#                     buff.write('  '+effectName+'\r\n')
+#                 buff.write('\r\n')
+#             book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
+#         #--Get Ingredients by Effect
+#         effect_ingred = self.effect_ingred = {}
+#         for fid,(eid,full,effects_list) in id_ingred.iteritems():
+#             for index,effect in enumerate(effects_list):
+#                 mgef, actorValue = effect[0], effect[5]
+#                 try:
+#                     effectName = mgef_name[mgef]
+#                 except KeyError:
+#                     if not self.DebugPrintOnce:
+#                         self.DebugPrintOnce = 1
+#                         deprint(patchFile.ObCollection.Debug_DumpModFiles())
+#                         deprint()
+#                         deprint(mgef_name)
+#                         deprint()
+#                     if mgef in bush.mgef_name:
+#                         deprint('mgef found in bush.mgef_name')
+#                         effectName = re.sub(_('(Attribute|Skill)'),'',bush.mgef_name[mgef])
+#                     else:
+#                         deprint('mgef not found in bush.mgef_name')
+#                         effectName = 'Unknown Effect'
+#                 effectName = Encode(effectName,'mbcs')
+#                 if mgef in actorEffects: effectName += Encode(actorNames[actorValue],'mbcs')
+#                 effect_ingred.setdefault(effectName, []).append((index,full))
+#         #--Effect catalogs
+#         for (num,objectId,full,value) in bush.effect_alchem:
+#             subProgress(pstate, _("Cataloging Effects...\n%s") % full)
+#             book = getBook(patchFile,objectId)
+#             buff = stringBuffer()
+#             buff.write('<div align="left"><font face=3 color=4444>' + Encode(_("Salan's Catalog of %s\r\n\r\n") % full, 'mbcs'))
+#             for effectName in sorted(effect_ingred.keys()):
+#                 effects = [indexFull for indexFull in effect_ingred[effectName] if indexFull[0] < num]
+#                 if effects:
+#                     buff.write(effectName+'\r\n')
+#                     for (index,full) in sorted(effects,key=lambda a: a[1].lower()):
+#                         exSpace = ('',' ')[index == 0]
+#                         buff.write(' '+`index + 1`+exSpace+' '+full+'\r\n')
+#                     buff.write('\r\n')
+#             book.text = re.sub('\r\n','<br>\r\n',buff.getvalue())
+#             pstate += 1
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         id_ingred = self.id_ingred
+#         effect_ingred = self.effect_ingred
+#         log.setHeader('= '+self.__class__.name)
+#         log(_('* Ingredients Cataloged: %d') % (len(id_ingred),))
+#         log(_('* Effects Cataloged: %d') % (len(effect_ingred)))
+#------------------------------------------------------------------------------
+# class CoblExhaustion(SpecialPatcher,ListPatcher):
+#     """Modifies most Greater power to work with Cobl's power exhaustion feature."""
+#     name = _('Cobl Exhaustion')
+#     text = _("Modify greater powers to use Cobl's Power Exhaustion feature.\n\nWill only run if Cobl Main v1.66 (or higher) is active.")
+#     autoKey = 'Exhaust'
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.cobl = GPath('Cobl Main.esm')
+#         self.srcFiles = self.getConfigChecked()
+#         self.isActive = bool(self.srcFiles) and (self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.65)
+#         self.id_exhaustion = {}
+
+#     def readFromText(self,textPath):
+#         """Imports type_id_name from specified text file."""
+#         aliases = self.patchFile.aliases
+#         id_exhaustion = self.id_exhaustion
+#         textPath = GPath(textPath)
+#         ins = bolt.CsvReader(textPath)
+#         reNum = re.compile(r'\d+')
+#         for fields in ins:
+#             if len(fields) < 4 or fields[1][:2] != '0x' or not reNum.match(fields[3]): continue
+#             mod,objectIndex,eid,time = fields[:4]
+#             mod = GPath(mod)
+#             longid = (aliases.get(mod,mod),int(objectIndex[2:],16))
+#             id_exhaustion[longid] = int(time)
+#         ins.close()
+
+#     def initData(self,progress):
+#         """Get names from source files."""
+#         if not self.isActive: return
+#         progress.setFull(len(self.srcFiles))
+#         for srcFile in self.srcFiles:
+#             srcPath = GPath(srcFile)
+#             patchesDir = dirs['patches'].list()
+#             if srcPath not in patchesDir: continue
+#             self.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         if not self.isActive: return tuple()
+#         return (MreSpel,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         if not self.isActive: return tuple()
+#         return (MreSpel,)
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive: return
+#         mapper = modFile.getLongMapper()
+#         patchRecords = self.patchFile.SPEL
+#         for record in modFile.SPEL.getActiveRecords():
+#             if not record.spellType == 2: continue
+#             record = record.getTypeCopy(mapper)
+#             if record.fid in self.id_exhaustion:
+#                 patchRecords.setRecord(record)
+
+#     def buildPatch(self,log,progress):
+#         """Edits patch file as desired. Will write to log."""
+#         if not self.isActive: return
+#         count = {}
+#         exhaustId = (self.cobl,0x05139B)
+#         keep = self.patchFile.getKeeper()
+#         for record in self.patchFile.SPEL.records:
+#             #--Skip this one?
+#             duration = self.id_exhaustion.get(record.fid,0)
+#             if not (duration and record.spellType == 2): continue
+#             isExhausted = False
+#             for effect in record.effects:
+#                 if effect.name == 'SEFF' and effect.scriptEffect.script == exhaustId:
+#                     duration = 0
+#                     break
+#             if not duration: continue
+#             #--Okay, do it
+#             record.full = '+'+record.full
+#             record.spellType = 3 #--Lesser power
+#             effect = record.getDefault('effects')
+#             effect.name = 'SEFF'
+#             effect.duration = duration
+#             scriptEffect = record.getDefault('effects.scriptEffect')
+#             scriptEffect.full = _("Power Exhaustion")
+#             scriptEffect.script = exhaustId
+#             scriptEffect.school = 2
+#             scriptEffect.visual = null4
+#             scriptEffect.flags.hostile = False
+#             effect.scriptEffect = scriptEffect
+#             record.effects.append(effect)
+#             keep(record.fid)
+#             srcMod = record.fid[0]
+#             count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader('= '+self.__class__.name)
+#         log(_('* Powers Tweaked: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+# class CBash_CoblExhaustion(SpecialPatcher,CBash_ListPatcher):
+#     """Modifies most Greater power to work with Cobl's power exhaustion feature."""
+#     name = _('Cobl Exhaustion')
+#     text = _("Modify greater powers to use Cobl's Power Exhaustion feature.\n\nWill only run if Cobl Main v1.66 (or higher) is active.")
+#     autoKey = set(('Exhaust',))
+#     defaultItemCheck = inisettings['AutoItemCheck'] #--GUI: Whether new items are checked by default or not.
+#     unloadedText = ""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.cobl = GPath('Cobl Main.esm')
+#         self.isActive = (self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.65)
+#         self.id_exhaustion = {}
+#         self.mod_count = {}
+#         self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#              type_patchers.setdefault(type,[]).append(self)
+#         progress.setFull(len(self.srcs))
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             patchesDir = dirs['patches'].list()
+#             if srcPath not in patchesDir: continue
+#             self.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+
+#     def getTypes(self):
+#         return ['SPEL']
+
+#     def readFromText(self,textPath):
+#         """Imports type_id_name from specified text file."""
+#         aliases = self.patchFile.aliases
+#         id_exhaustion = self.id_exhaustion
+#         textPath = GPath(textPath)
+#         ins = bolt.CsvReader(textPath)
+#         reNum = re.compile(r'\d+')
+#         for fields in ins:
+#             if len(fields) < 4 or fields[1][:2] != '0x' or not reNum.match(fields[3]): continue
+#             mod,objectIndex,eid,time = fields[:4]
+#             mod = GPath(mod)
+#             longid = (aliases.get(mod,mod),int(objectIndex[2:],16))
+#             id_exhaustion[longid] = int(time)
+#         ins.close()
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if (record.spellType == 2):
+#             #--Skip this one?
+#             duration = self.id_exhaustion.get(record.fid,0)
+#             if not duration: return
+#             for effect in record.effects:
+#                 if effect.name == self.SEFFValue and effect.script == (self.cobl,0x05139B):
+#                     return
+#             #--Okay, do it
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 override.full = '+'+override.full
+#                 override.spellType = 3 #--Lesser power
+#                 effect = override.create_effect()
+#                 effect.name = 'SEFF'
+#                 effect.duration = duration
+#                 effect.full = _("Power Exhaustion")
+#                 effect.script = (self.cobl,0x05139B)
+#                 effect.school = 2
+#                 effect.visual = null4
+#                 effect.IsHostile = False
+
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= '+self.__class__.name)
+#         log(_('* Powers Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-class CBash_RacePatcher_Relations(SpecialPatcher):
-    """Merges changes to race relations."""
-    autoKey = set(('R.Relations',))
-    iiMode = False
-    allowUnloaded = True
-    scanRequiresChecked = True
-    applyRequiresChecked = False
+#------------------------------------------------------------------------------
+class ListsMerger(SpecialPatcher,ListPatcher):
+    """Merged leveled lists mod file."""
+    scanOrder = 45
+    editOrder = 45
+    name = _('Leveled Lists')
+    text = _("Merges changes to leveled lists from ACTIVE/MERGED MODS ONLY.\n\nAdvanced users may override Relev/Delev tags for any mod (active or inactive) using the list below.")
+    tip = _("Merges changes to leveled lists from all active mods.")
+    choiceMenu = ('Auto','----','Delev','Relev') #--List of possible choices for each config item. Item 0 is default.
+    autoKey = ('Delev','Relev')
+    forceAuto = False
+    forceItemCheck = True #--Force configChecked to True for all items
+    iiMode = True
+    selectCommands = False
+
+    #--Static------------------------------------------------------------------
+    @staticmethod
+    def getDefaultTags():
+        tags = {}
+        for fileName in ('Leveled Lists.csv','My Leveled Lists.csv'):
+            textPath = dirs['patches'].join(fileName)
+            if textPath.exists():
+                reader = bolt.CsvReader(textPath)
+                for fields in reader:
+                    if len(fields) < 2 or not fields[0] or fields[1] not in ('DR','R','D','RD',''): continue
+                    tags[GPath(fields[0])] = fields[1]
+                reader.close()
+        return tags
 
     #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,srcs,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        self.srcs = srcs
-        self.isActive = bool(srcs)
-        if not self.isActive: return
-        self.racesPatched = set()
-        self.fid_faction_mod = {}
+    def getChoice(self,item):
+        """Get default config choice."""
+        choice = self.configChoices.get(item)
+        if not isinstance(choice,set): choice = set(('Auto',))
+        if 'Auto' in choice:
+            if item in modInfos:
+                choice = set(('Auto',))
+                bashTags = modInfos[item].getBashTags()
+                for key in ('Delev','Relev'):
+                    if key in bashTags: choice.add(key)
+        self.configChoices[item] = choice
+        return choice
 
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-            type_patchers.setdefault(type,[]).append(self)
+    def getItemLabel(self,item):
+        """Returns label for item to be used in list"""
+        choice = map(itemgetter(0),self.configChoices.get(item,tuple()))
+        if isinstance(item,bolt.Path): item = item.s
+        if choice:
+            return '%s [%s]' % (item,''.join(sorted(choice)))
+        else:
+            return item
 
-    def getTypes(self):
-        return ['RACE']
     #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        if bashTags & self.autoKey:
-            relations = record.relations_list
-            if relations:
-                self.fid_faction_mod.setdefault(record.fid,{}).update(relations)
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.srcMods = set(self.getConfigChecked()) & set(loadMods)
+        self.listTypes = ('LVLC','LVLI','LVSP','LVLN')
+        self.type_list = dict([(type,{}) for type in self.listTypes])
+        self.masterItems = {}
+        self.mastersScanned = set()
+        self.levelers = None #--Will initialize later
+        self.empties = set()
+        # OverhaulCompat = False
+        # OOOMods = set([GPath("Oscuro's_Oblivion_Overhaul.esm"),GPath("Oscuro's_Oblivion_Overhaul.esp")])
+        # FransMods = set([GPath("Francesco's Leveled Creatures-Items Mod.esm"),GPath("Francesco.esp")])
+        # WCMods = set([GPath("Oblivion Warcry.esp"),GPath("Oblivion Warcry EV.esp")])
+        # TIEMods = set([GPath("TIE.esp")])
+        # if GPath("Unofficial Oblivion Patch.esp") in self.srcMods:
+        #     if (OOOMods|WCMods) & self.srcMods:
+        #         OverhaulCompat = True
+        #     elif FransMods & self.srcMods:
+        #         if TIEMods & self.srcMods:
+        #             pass
+        #         else:
+        #             OverhaulCompat = True
+        # if OverhaulCompat:
+        #     self.OverhaulUOPSkips = set([
+        #         (GPath('Oblivion.esm'),x) for x in [
+        #             0x03AB5D,   # VendorWeaponBlunt
+        #             0x03C7F1,   # LL0LootWeapon0Magic4Dwarven100
+        #             0x03C7F2,   # LL0LootWeapon0Magic7Ebony100
+        #             0x03C7F3,   # LL0LootWeapon0Magic5Elven100
+        #             0x03C7F4,   # LL0LootWeapon0Magic6Glass100
+        #             0x03C7F5,   # LL0LootWeapon0Magic3Silver100
+        #             0x03C7F7,   # LL0LootWeapon0Magic2Steel100
+        #             0x03E4D2,   # LL0NPCWeapon0MagicClaymore100
+        #             0x03E4D3,   # LL0NPCWeapon0MagicClaymoreLvl100
+        #             0x03E4DA,   # LL0NPCWeapon0MagicWaraxe100
+        #             0x03E4DB,   # LL0NPCWeapon0MagicWaraxeLvl100
+        #             0x03E4DC,   # LL0NPCWeapon0MagicWarhammer100
+        #             0x03E4DD,   # LL0NPCWeapon0MagicWarhammerLvl100
+        #             0x0733EA,   # ArenaLeveledHeavyShield,
+        #             0x0C7615,   # FGNPCWeapon0MagicClaymoreLvl100
+        #             0x181C66,   # SQ02LL0NPCWeapon0MagicClaymoreLvl100
+        #             0x053877,   # LL0NPCArmor0MagicLightGauntlets100
+        #             0x053878,   # LL0NPCArmor0MagicLightBoots100
+        #             0x05387A,   # LL0NPCArmor0MagicLightCuirass100
+        #             0x053892,   # LL0NPCArmor0MagicLightBootsLvl100
+        #             0x053893,   # LL0NPCArmor0MagicLightCuirassLvl100
+        #             0x053894,   # LL0NPCArmor0MagicLightGauntletsLvl100
+        #             0x053D82,   # LL0LootArmor0MagicLight5Elven100
+        #             0x053D83,   # LL0LootArmor0MagicLight6Glass100
+        #             0x052D89,   # LL0LootArmor0MagicLight4Mithril100
+        #             ]
+        #         ])
+        # else:
+        #     self.OverhaulUOPSkips = set()
+        self.OverhaulUOPSkips = set()
 
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break        
-        recordId = record.fid
-        if(recordId in self.fid_faction_mod):
-            newRelations = set((faction,mod) for faction,mod in self.fid_faction_mod[recordId].iteritems())
-            curRelations = set(record.relations_list)
-            changed = newRelations - curRelations
-            if changed:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    for faction,mod in changed:
-                        for relation in override.relations:
-                            if relation.faction == faction:
-                                relation.mod = mod
-                                break
-                        else:
-                            relation = override.create_relation()
-                            relation.faction,relation.mod = faction,mod
-                    self.racesPatched.add(record.eid)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-class CBash_RacePatcher_Imports(SpecialPatcher):
-    """Imports various race fields."""
-    autoKey = set(('Hair','Body-M','Body-F','Voice-M','Voice-F','R.Teeth',
-               'R.Mouth','R.Ears','R.Head','R.Attributes-F','R.Attributes-M',
-               'R.Skills','R.Description', 'Body-Size-F','Body-Size-M'))
-    tag_attrs = {
-        'Hair'  : ('hairs',),
-        'Body-M': ('maleTail_list','maleUpperBodyPath','maleLowerBodyPath',
-                   'maleHandPath','maleFootPath','maleTailPath'),
-        'Body-F': ('femaleTail_list','femaleUpperBodyPath','femaleLowerBodyPath',
-                   'femaleHandPath','femaleFootPath','femaleTailPath'),
-        'Body-Size-M': ('maleHeight','maleWeight'),
-        'Body-Size-F': ('femaleHeight','femaleWeight'),
-        'Voice-M': ('maleVoice',),
-        'Voice-F': ('femaleVoice',),
-        'R.Teeth': ('teethLower_list','teethUpper_list',),
-        'R.Mouth': ('mouth_list','tongue_list',),
-        'R.Ears': ('maleEars_list','femaleEars_list',),
-        'R.Head': ('head_list','fggs_p','fgga_p','fgts_p','snam_p'),
-        'R.Attributes-M': ('maleStrength','maleIntelligence','maleWillpower','maleAgility','maleSpeed','maleEndurance','malePersonality','maleLuck'),
-        'R.Attributes-F': ('femaleStrength','femaleIntelligence','femaleWillpower','femaleAgility','femaleSpeed','femaleEndurance','femalePersonality','femaleLuck'),
-        'R.Skills': ('skill1','skill1Boost','skill2','skill2Boost','skill3','skill3Boost','skill4','skill4Boost','skill5','skill5Boost','skill6','skill6Boost','skill7','skill7Boost'),
-        'R.Description': ('text',),
-        }
-    iiMode = False
-    allowUnloaded = True
-    scanRequiresChecked = True
-    applyRequiresChecked = False
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreLvlc,MreLvli,MreLvsp,MreLvln)
 
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,srcs,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        self.srcs = srcs
-        self.isActive = bool(srcs)
-        if not self.isActive: return
-        self.racesPatched = set()
-        self.id_tag_values = {}
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreLvlc,MreLvli,MreLvsp,MreLvln)
 
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-            type_patchers.setdefault(type,[]).append(self)
+    def scanModFile(self, modFile, progress):
+        """Add lists from modFile."""
+        #--Level Masters (complete initialization)
+        if self.levelers == None:
+            allMods = set(self.patchFile.allMods)
+            self.levelers = [leveler for leveler in self.getConfigChecked() if leveler in allMods]
+            self.delevMasters = set()
+            for leveler in self.levelers:
+                self.delevMasters.update(modInfos[leveler].header.masters)
+        #--Begin regular scan
+        modName = modFile.fileInfo.name
+        modFile.convertToLongFids(self.listTypes)
+        #--PreScan for later Relevs/Delevs?
+        if modName in self.delevMasters:
+            for type in self.listTypes:
+                for levList in getattr(modFile,type).getActiveRecords():
+                    masterItems = self.masterItems.setdefault(levList.fid,{})
+                    masterItems[modName] = set([entry.listId for entry in levList.entries])
+            self.mastersScanned.add(modName)
+        #--Relev/Delev setup
+        configChoice = self.configChoices.get(modName,tuple())
+        isRelev = ('Relev' in configChoice)
+        isDelev = ('Delev' in configChoice)
+        #--Scan
+        for type in self.listTypes:
+            levLists = self.type_list[type]
+            newLevLists = getattr(modFile,type)
+            for newLevList in newLevLists.getActiveRecords():
+                listId = newLevList.fid
+                # if listId in self.OverhaulUOPSkips and modName == 'Unofficial Oblivion Patch.esp':
+                #     levLists[listId].mergeOverLast = True
+                #     continue
+                isListOwner = (listId[0] == modName)
+                #--Items, delevs and relevs sets
+                newLevList.items = items = set([entry.listId for entry in newLevList.entries])
+                if not isListOwner:
+                    #--Relevs
+                    newLevList.relevs = (set(),items.copy())[isRelev]
+                    #--Delevs: all items in masters minus current items
+                    newLevList.delevs = delevs = set()
+                    if isDelev:
+                        id_masterItems = self.masterItems.get(newLevList.fid)
+                        if id_masterItems:
+                            for masterName in modFile.tes4.masters:
+                                if masterName in id_masterItems:
+                                    delevs |= id_masterItems[masterName]
+                            delevs -= items
+                            newLevList.items |= delevs
+                #--Cache/Merge
+                if isListOwner:
+                    levList = copy.deepcopy(newLevList)
+                    levList.mergeSources = []
+                    levLists[listId] = levList
+                elif listId not in levLists:
+                    levList = copy.deepcopy(newLevList)
+                    levList.mergeSources = [modName]
+                    levLists[listId] = levList
+                else:
+                    levLists[listId].mergeWith(newLevList,modName)
 
-    def getTypes(self):
-        return ['RACE']
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        recordId = record.fid
-        for bashKey in bashTags & self.autoKey:
-            if bashKey == 'Hair':
-                #Using sets would make this clearer, and probably faster (though speed isn't a concern)
-                #So this is a bit convulated, but makes the apply section work without special casing this tag
-                #Hairs should perhaps have it's own patcher, but...
-                allHairs = self.id_tag_values.setdefault(recordId,{}).setdefault(bashKey,[[]])
-                allHairs[0] += (hair for hair in record.hairs if hair not in allHairs[0] and hair[0])
-            else:
-                self.id_tag_values.setdefault(recordId,{})[bashKey] = map(record.__getattribute__,self.tag_attrs[bashKey])
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        keep = self.patchFile.getKeeper()
+        #--Relevs/Delevs List
+        log.setHeader('= '+self.__class__.name,True)
+        log.setHeader(_('=== Delevelers/Relevelers'))
+        for leveler in (self.levelers or []):
+            log('* '+self.getItemLabel(leveler))
+        #--Save to patch file
+        for label, type in ((_('Creature'),'LVLC'), (_('Item'),'LVLI'), (_('Spell'),'LVSP'), (_('NPC'),'LVLN')):
+            log.setHeader(_('=== Merged %s Lists') % label)
+            patchBlock = getattr(self.patchFile,type)
+            levLists = self.type_list[type]
+            for record in sorted(levLists.values(),key=attrgetter('eid')):
+                if not record.mergeOverLast: continue
+                fid = keep(record.fid)
+                patchBlock.setRecord(levLists[fid])
+                log('* '+record.eid)
+                for mod in record.mergeSources:
+                    log('  * ' + self.getItemLabel(mod))
+        #--Discard empty sublists
+        for label, type in ((_('Creature'),'LVLC'), (_('Item'),'LVLI'), (_('Spell'),'LVSP'), (_('NPC'),'LVLN')):
+            patchBlock = getattr(self.patchFile,type)
+            levLists = self.type_list[type]
+            #--Empty lists
+            empties = []
+            sub_supers = dict((x,[]) for x in levLists.keys())
+            for record in sorted(levLists.values()):
+                listId = record.fid
+                if not record.items:
+                    empties.append(listId)
+                else:
+                    subLists = [x for x in record.items if x in sub_supers]
+                    for subList in subLists:
+                        sub_supers[subList].append(listId)
+            #--Clear empties
+            removed = set()
+            cleaned = set()
+            while empties:
+                empty = empties.pop()
+                if empty not in sub_supers: continue
+                for super in sub_supers[empty]:
+                    record = levLists[super]
+                    record.entries = [x for x in record.entries if x.listId != empty]
+                    record.items.remove(empty)
+                    patchBlock.setRecord(record)
+                    if not record.items:
+                        empties.append(super)
+                    cleaned.add(record.eid)
+                    removed.add(levLists[empty].eid)
+                    keep(super)
+            log.setHeader(_('=== Empty %s Sublists') % label)
+            for eid in sorted(removed,key=string.lower):
+                log('* '+eid)
+            log.setHeader(_('=== Empty %s Sublists Removed') % label)
+            for eid in sorted(cleaned,key=string.lower):
+                log('* '+eid)
 
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        recordId = record.fid
-        if(recordId in self.id_tag_values):
-            allAttrs = []
-            prevValues = []
-            recValues = []
-            for bashKey in self.tag_attrs:
-                attrs = self.tag_attrs[bashKey]
-                allAttrs += attrs
-                tagValues = map(record.__getattribute__,attrs)
-                prevValues += self.id_tag_values[recordId].get(bashKey, tagValues)
-                recValues += tagValues
-            if recValues != prevValues:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    map(override.__setattr__, allAttrs, prevValues)
-                    self.racesPatched.add(record.eid)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+# class CBash_ListsMerger(SpecialPatcher,CBash_ListPatcher):
+#     """Merged leveled lists mod file."""
+#     scanOrder = 45
+#     editOrder = 45
+#     name = _('Leveled Lists')
+#     text = _("Merges changes to leveled lists from ACTIVE/MERGED MODS ONLY.\n\nAdvanced users may override Relev/Delev tags for any mod (active or inactive) using the list below.")
+#     tip = _("Merges changes to leveled lists from all active mods.")
+#     choiceMenu = ('Auto','----','Delev','Relev') #--List of possible choices for each config item. Item 0 is default.
+#     autoKey = set(('Delev','Relev'))
+#     forceAuto = False
+#     forceItemCheck = True #--Force configChecked to True for all items
+#     iiMode = True
+#     selectCommands = False
+#     allowUnloaded = False
+#     scanRequiresChecked = False
+#     applyRequiresChecked = False
+
+#     #--Static------------------------------------------------------------------
+#     @staticmethod
+#     def getDefaultTags():
+#         tags = {}
+#         for fileName in ('Leveled Lists.csv','My Leveled Lists.csv'):
+#             textPath = dirs['patches'].join(fileName)
+#             if textPath.exists():
+#                 reader = bolt.CsvReader(textPath)
+#                 for fields in reader:
+#                     if len(fields) < 2 or not fields[0] or fields[1] not in ('DR','R','D','RD',''): continue
+#                     tags[GPath(fields[0])] = fields[1]
+#                 reader.close()
+#         return tags
+
+#     #--Config Phase -----------------------------------------------------------
+#     def getChoice(self,item):
+#         """Get default config choice."""
+#         choice = self.configChoices.get(item)
+#         if not isinstance(choice,set): choice = set(('Auto',))
+#         if 'Auto' in choice:
+#             if item in modInfos:
+#                 choice = set(('Auto',))
+#                 bashTags = modInfos[item].getBashTags()
+#                 for key in ('Delev','Relev'):
+#                     if key in bashTags: choice.add(key)
+#         self.configChoices[item] = choice
+#         return choice
+
+#     def getItemLabel(self,item):
+#         """Returns label for item to be used in list"""
+#         choice = map(itemgetter(0),self.configChoices.get(item,tuple()))
+#         if isinstance(item,bolt.Path): item = item.s
+#         if choice:
+#             return '%s [%s]' % (item,''.join(sorted(choice)))
+#         else:
+#             return item
+
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = True
+#         self.id_delevs = {}
+#         self.id_list = {}
+#         self.id_attrs = {}
+#         self.mod_count = {}
+#         self.empties = set()
+#         importMods = set(self.srcs) & set(loadMods)
+#         OverhaulCompat = False
+#         OOOMods = set([GPath("Oscuro's_Oblivion_Overhaul.esm"),GPath("Oscuro's_Oblivion_Overhaul.esp")])
+#         FransMods = set([GPath("Francesco's Leveled Creatures-Items Mod.esm"),GPath("Francesco.esp")])
+#         WCMods = set([GPath("Oblivion Warcry.esp"),GPath("Oblivion Warcry EV.esp")])
+#         TIEMods = set([GPath("TIE.esp")])
+#         if GPath("Unofficial Oblivion Patch.esp") in importMods:
+#             if (OOOMods|WCMods) & importMods:
+#                 OverhaulCompat = True
+#             elif FransMods & importMods:
+#                 if TIEMods & importMods:
+#                     pass
+#                 else:
+#                     OverhaulCompat = True
+#         if OverhaulCompat:
+#             self.OverhaulUOPSkips = set([
+#                 (GPath('Oblivion.esm'),x) for x in [
+#                     0x03AB5D,   # VendorWeaponBlunt
+#                     0x03C7F1,   # LL0LootWeapon0Magic4Dwarven100
+#                     0x03C7F2,   # LL0LootWeapon0Magic7Ebony100
+#                     0x03C7F3,   # LL0LootWeapon0Magic5Elven100
+#                     0x03C7F4,   # LL0LootWeapon0Magic6Glass100
+#                     0x03C7F5,   # LL0LootWeapon0Magic3Silver100
+#                     0x03C7F7,   # LL0LootWeapon0Magic2Steel100
+#                     0x03E4D2,   # LL0NPCWeapon0MagicClaymore100
+#                     0x03E4D3,   # LL0NPCWeapon0MagicClaymoreLvl100
+#                     0x03E4DA,   # LL0NPCWeapon0MagicWaraxe100
+#                     0x03E4DB,   # LL0NPCWeapon0MagicWaraxeLvl100
+#                     0x03E4DC,   # LL0NPCWeapon0MagicWarhammer100
+#                     0x03E4DD,   # LL0NPCWeapon0MagicWarhammerLvl100
+#                     0x0733EA,   # ArenaLeveledHeavyShield,
+#                     0x0C7615,   # FGNPCWeapon0MagicClaymoreLvl100
+#                     0x181C66,   # SQ02LL0NPCWeapon0MagicClaymoreLvl100
+#                     0x053877,   # LL0NPCArmor0MagicLightGauntlets100
+#                     0x053878,   # LL0NPCArmor0MagicLightBoots100
+#                     0x05387A,   # LL0NPCArmor0MagicLightCuirass100
+#                     0x053892,   # LL0NPCArmor0MagicLightBootsLvl100
+#                     0x053893,   # LL0NPCArmor0MagicLightCuirassLvl100
+#                     0x053894,   # LL0NPCArmor0MagicLightGauntletsLvl100
+#                     0x053D82,   # LL0LootArmor0MagicLight5Elven100
+#                     0x053D83,   # LL0LootArmor0MagicLight6Glass100
+#                     0x052D89,   # LL0LootArmor0MagicLight4Mithril100
+#                     ]
+#                 ])
+#         else:
+#             self.OverhaulUOPSkips = set()
+
+#     def getTypes(self):
+#         return ['LVLC','LVLI','LVSP']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         recordId = record.fid
+#         if recordId in self.OverhaulUOPSkips and modFile.GName == GPath('Unofficial Oblivion Patch.esp'):
+#             return
+#         if recordId not in self.id_list:
+#             #['level', 'listId', 'count']
+#             self.id_list[recordId] = record.entries_list #[(entry.listId, entry.level, entry.count) for entry in record.entries]
+#             self.id_attrs[recordId] = [record.chanceNone, record.script, record.template, (record.flags or 0)]
+#         else:
+#             mergedList = self.id_list[recordId]
+#             configChoice = self.configChoices.get(modFile.GName,tuple())
+#             isRelev = 'Relev' in configChoice
+#             isDelev = 'Delev' in configChoice
+#             delevs = self.id_delevs.setdefault(recordId, set())
+#             curItems = set([entry.listId for entry in record.entries])
+#             if isRelev:
+#                 #Can add and set the level/count of items, but not delete items
+#                 #Ironically, the first step is to delete items that the list will add right back
+#                 #This is an easier way to update level/count than actually checking if they need changing
+
+#                 #Filter out any records that may have their level/count updated
+#                 mergedList = [entry for entry in mergedList if entry[1] not in curItems] #entry[1] = listId
+#                 #Add any new records as well as any that were filtered out
+#                 mergedList += record.entries_list
+#                 #Remove the added items from the deleveled list
+#                 delevs -= curItems
+#                 self.id_attrs[recordId] = [record.chanceNone, record.script, record.template, (record.flags or 0)]
+#             else:
+#                 #Can add new items, but can't change existing ones
+#                 items = set([entry[1] for entry in mergedList]) #entry[1] = listId
+#                 mergedList += [entry for entry in record.entries_list if entry[1] not in items] #entry[1] = listId
+#                 mergedAttrs = self.id_attrs[recordId]
+#                 self.id_attrs[recordId] = [record.chanceNone or mergedAttrs[0], record.script or mergedAttrs[1], record.template or mergedAttrs[2], (record.flags or 0) | mergedAttrs[3]]
+#             #--Delevs: all items in masters minus current items
+#             if isDelev:
+#                 deletedItems = set([entry.listId for master in record.History() for entry in master.entries]) - curItems
+#                 delevs |= deletedItems
+
+#             #Remove any items that were deleveled
+#             mergedList = [entry for entry in mergedList if entry[1] not in delevs] #entry[1] = listId
+#             self.id_list[recordId] = mergedList
+#             self.id_delevs[recordId] = delevs
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         recordId = record.fid
+#         merged = recordId in self.id_list
+#         if merged:
+#             self.scan(modFile,record,bashTags)
+#             mergedList = self.id_list[recordId]
+#             mergedAttrs = self.id_attrs[recordId]
+#             newList = record.entries_list
+#             newAttrs = [record.chanceNone, record.script, record.template, (record.flags or 0)]
+#         #Can't tell if any sublists are actually empty until they've all been processed/merged
+#         #So every level list gets copied into the patch, so that they can be checked after the regular patch process
+#         #They'll get deleted from the patch there as needed.
+#         override = record.CopyAsOverride(self.patchFile)
+#         if override:
+#             record.UnloadRecord()
+#             record._ModID, record._RecordID = override._ModID, override._RecordID
+#             if merged and (sorted(newList, key=itemgetter(1)) != sorted(mergedList, key=itemgetter(1)) or newAttrs != mergedAttrs):
+#                 mod_count = self.mod_count
+#                 mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                 override.chanceNone, override.script, override.template, override.flags = mergedAttrs
+#                 try:
+#                     override.entries_list = mergedList
+#                 except:
+#                     newMergedList = []
+#                     for entry in mergedList:
+#                         fid = entry[1]
+#                         if not fid:
+#                             deprint("WARNING: LeveledList with FormID ('%s',%06X) in '%s' has a malformed entry %s." % (record.fid[0],record.fid[1],record.GName,fid))
+#                             continue
+#                         if fid[0] == None: continue
+#                         newMergedList.append(entry)
+#                     override.entries_list = newMergedList
+
+#     def finishPatch(self,patchFile, progress):
+#         """Edits the bashed patch file directly."""
+#         if self.empties is None: return
+#         subProgress = SubProgress(progress)
+#         subProgress.setFull(len(self.getTypes()))
+#         pstate = 0
+#         #Clean up any empty sublists
+#         empties = self.empties
+#         emptiesAdd = empties.add
+#         emptiesDiscard = empties.discard
+#         for type in self.getTypes():
+#             subProgress(pstate, _("Looking for empty %s sublists...\n") % type)
+#             #Remove any empty sublists
+#             madeChanges = True
+#             while madeChanges:
+#                 madeChanges = False
+#                 oldEmpties = empties.copy()
+#                 for record in getattr(patchFile,type):
+#                     recordId = record.fid
+#                     items = set([entry.listId for entry in record.entries])
+#                     if items:
+#                         emptiesDiscard(recordId)
+#                     else:
+#                         emptiesAdd(recordId)
+#                     toRemove = empties & items
+#                     if toRemove:
+#                         madeChanges = True
+#                         cleanedEntries = [entry for entry in record.entries if entry.listId not in toRemove]
+#                         record.entries = cleanedEntries
+#                         if cleanedEntries:
+#                             emptiesDiscard(recordId)
+#                         else:
+#                             emptiesAdd(recordId)
+#                 if oldEmpties != empties:
+#                     oldEmpties = empties.copy()
+#                     madeChanges = True
+
+#             #Remove any identical to master lists, except those that were merged into the patch
+#             for record in getattr(patchFile,type):
+#                 conflicts = record.Conflicts()
+#                 numConflicts = len(conflicts)
+#                 if numConflicts:
+#                     curConflict = 1 #Conflict at 0 will be the patchfile. No sense comparing it to itself.
+#                     #Find the first conflicting record that wasn't merged
+#                     while curConflict < numConflicts:
+#                         prevRecord = conflicts[curConflict]
+#                         if prevRecord.GName not in patchFile.mergeSet:
+#                             break
+#                         curConflict += 1
+#                     else:
+#                         continue
+#                     #If the record in the patchfile matches the previous non-merged record, delete it.
+#                     #Ordering doesn't matter, hence the conversion to sets
+#                     if set(prevRecord.entries_list) == set(record.entries_list) and [record.chanceNone, record.script, record.template, record.flags] == [prevRecord.chanceNone, prevRecord.script, prevRecord.template, prevRecord.flags]:
+#                         record.DeleteRecord()
+#             pstate += 1
+#         self.empties = None
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Modified LVL: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+class FidListsMerger(SpecialPatcher,ListPatcher):
+    """Merged FormID lists mod file."""
+    scanOrder = 46
+    editOrder = 46
+    name = _('FormID Lists')
+    text = _("Merges changes to formid lists from ACTIVE/MERGED MODS ONLY.\n\nAdvanced users may override Deflst tags for any mod (active or inactive) using the list below.")
+    tip = _("Merges changes to formid lists from all active mods.")
+    choiceMenu = ('Auto','----','Deflst') #--List of possible choices for each config item. Item 0 is default.
+    autoKey = ('Deflst',)
+    forceAuto = False
+    forceItemCheck = True #--Force configChecked to True for all items
+    iiMode = True
 
-class CBash_RacePatcher_Spells(SpecialPatcher):
-    """Merges changes to race spells."""
-    autoKey = set(('R.AddSpells', 'R.ChangeSpells'))
-    iiMode = False
-    allowUnloaded = True
-    scanRequiresChecked = True
-    applyRequiresChecked = False
+    #--Static------------------------------------------------------------------
+    @staticmethod
+    def getDefaultTags():
+        tags = {}
+        for fileName in ('FormID Lists.csv','My FormId Lists.csv'):
+            textPath = dirs['patches'].join(fileName)
+            if textPath.exists():
+                reader = bolt.CsvReader(textPath)
+                for fields in reader:
+                    if len(fields) < 2 or not fields[0] or fields[1] not in ('DR','R','D','RD',''): continue
+                    tags[GPath(fields[0])] = fields[1]
+                reader.close()
+        return tags
 
     #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,srcs,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        self.srcs = srcs
-        self.isActive = bool(srcs)
-        if not self.isActive: return
-        self.racesPatched = set()
-        self.id_spells = {}
-
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-            type_patchers.setdefault(type,[]).append(self)
+    def getChoice(self,item):
+        """Get default config choice."""
+        choice = self.configChoices.get(item)
+        if not isinstance(choice,set): choice = set(('Auto',))
+        if 'Auto' in choice:
+            if item in modInfos:
+                choice = set(('Auto',))
+                bashTags = modInfos[item].getBashTags()
+                for key in ('Deflst',):
+                    if key in bashTags: choice.add(key)
+        self.configChoices[item] = choice
+        return choice
 
-    def getTypes(self):
-        return ['RACE']
+    def getItemLabel(self,item):
+        """Returns label for item to be used in list"""
+        choice = map(itemgetter(0),self.configChoices.get(item,tuple()))
+        if isinstance(item,bolt.Path): item = item.s
+        if choice:
+            return '%s [%s]' % (item,''.join(sorted(choice)))
+        else:
+            return item
 
     #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        tags = bashTags & self.autoKey
-        if tags:
-            if 'R.ChangeSpells' in tags and 'R.AddSpells' in tags:
-                raise BoltError(_('WARNING mod %s has both R.AddSpells and R.ChangeSpells tags - only one of those tags should be on a mod at one time') % (modFile.ModName))
-            curSpells = set(record.spells)
-            if curSpells:
-                spells = self.id_spells.setdefault(record.fid,set())
-                if 'R.ChangeSpells' in tags:
-                    spells = curSpells
-                elif 'R.AddSpells' in tags:
-                    spells |= curSpells
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs:
-            self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break        
-        recordId = record.fid
-        if(recordId in self.id_spells):
-            newSpells = self.id_spells[recordId]
-            curSpells = set(record.spells)
-            changed = newSpells - curSpells
-            if changed:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.spells = newSpells
-                    self.racesPatched.add(record.eid)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-class CBash_RacePatcher_Eyes(SpecialPatcher):
-    """Merges and filters changes to race eyes."""
-    autoKey = set(('Eyes-D','Eyes-R','Eyes-E','Eyes'))
-    blueEye = (GPath('Oblivion.esm'),0x27308)
-    argonianEye = (GPath('Oblivion.esm'),0x3e91e)
-    dremoraRace = (GPath('Oblivion.esm'),0x038010)
-##    defaultMesh = (r'characters\imperial\eyerighthuman.nif', r'characters\imperial\eyelefthuman.nif')
-    reX117 = re.compile('^117[a-z]',re.I)
-    iiMode = False
-    allowUnloaded = True
-    scanRequiresChecked = False
-    applyRequiresChecked = False
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,srcs,patchFile,loadMods):
+    def initPatchFile(self,patchFile,loadMods):
         """Prepare to handle specified patch mod. All functions are called after this."""
-        self.patchFile = patchFile
-        self.srcs = srcs
-        self.isActive = True #--Always partially enabled to support eye filtering
-        self.racesPatched = set()
-        self.racesSorted = set()
-        self.racesFiltered = []
-        self.mod_npcsFixed = {}
-        self.hairNames = {}
-        self.eyeNames = {}
-        self.maleHairs = set()
-        self.femaleHairs = set()
-        self.id_meshes = {}
-        self.id_eyes = {}
-        self.eye_meshes = {}
-        self.finishedOnce = False
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.listTypes = ('FLST',)
+        self.type_list = dict([(type,{}) for type in self.listTypes])
+        self.masterItems = {}
+        self.mastersScanned = set()
+        self.levelers = None #--Will initialize later
 
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        if not self.isActive: return
-        for type in self.getTypes():
-            type_patchers.setdefault(type,[]).append(self)
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (MreFlst,)
 
-    def getTypes(self):
-        return ['EYES','HAIR','RACE']
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (MreFlst,)
 
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        recordId = record.fid
-        if record._Type == 'HAIR':
-            if record.IsMale:
-                self.maleHairs.add(recordId)
-            else:
-                self.femaleHairs.add(recordId)
-            self.hairNames.update({recordId:record.full})
-            return
-        elif record._Type == 'EYES':
-            self.eyeNames.update({record.fid:record.full})
-            return
-        eye_meshes = self.eye_meshes
-        curEyes = set(record.eyes)
-        eyePaths = (record.rightEye.modPath, record.leftEye.modPath)
-        for eye in curEyes:
-            if eye not in eye_meshes:
-                eye_meshes[eye] = eyePaths
-        if modFile.GName in self.srcs and self.autoKey & bashTags:
-            allEyes = self.id_eyes.setdefault(recordId,set())
-            allEyes |= set(curEyes)
-            self.id_meshes[recordId] = eyePaths
+    def scanModFile(self, modFile, progress):
+        """Add lists from modFile."""
+        #--Level Masters (complete initialization)
+        if self.levelers == None:
+            allMods = set(self.patchFile.allMods)
+            self.levelers = [leveler for leveler in self.getConfigChecked() if leveler in allMods]
+            self.deflstMasters = set()
+            for leveler in self.levelers:
+                self.deflstMasters.update(modInfos[leveler].header.masters)
+        #--Begin regular scan
+        modName = modFile.fileInfo.name
+        modFile.convertToLongFids(self.listTypes)
+        #--PreScan for later Deflsts?
+        if modName in self.deflstMasters:
+            for type in self.listTypes:
+                for levList in getattr(modFile,type).getActiveRecords():
+                    masterItems = self.masterItems.setdefault(levList.fid,{})
+                    masterItems[modName] = set(levList.fids)
+            self.mastersScanned.add(modName)
+        #--Deflst setup
+        configChoice = self.configChoices.get(modName,tuple())
+        isDeflst = ('Deflst' in configChoice)
+        #--Scan
+        for type in self.listTypes:
+            levLists = self.type_list[type]
+            newLevLists = getattr(modFile,type)
+            for newLevList in newLevLists.getActiveRecords():
+                listId = newLevList.fid
+                isListOwner = (listId[0] == modName)
+                #--Items, deflsts sets
+                newLevList.items = items = set(newLevList.fids)
+                if not isListOwner:
+                    #--Deflsts: all items in masters minus current items
+                    newLevList.deflsts = deflsts = set()
+                    if isDeflst:
+                        id_masterItems = self.masterItems.get(newLevList.fid)
+                        if id_masterItems:
+                            for masterName in modFile.tes4.masters:
+                                if masterName in id_masterItems:
+                                    deflsts |= id_masterItems[masterName]
+                            deflsts -= items
+                            newLevList.items |= deflsts
+                #--Cache/Merge
+                if isListOwner:
+                    levList = copy.deepcopy(newLevList)
+                    levList.mergeSources = []
+                    levLists[listId] = levList
+                elif listId not in levLists:
+                    levList = copy.deepcopy(newLevList)
+                    levList.mergeSources = [modName]
+                    levLists[listId] = levList
+                else:
+                    levLists[listId].mergeWith(newLevList,modName)
 
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        self.scan(modFile,record,bashTags)
-        #Must check for "unloaded" conflicts that occur past the winning record
-        #If any exist, they have to be scanned
-        for conflict in record.Conflicts(True):
-            if conflict != record:
-                mod = ObModFile(conflict._CollectionID, conflict._ModID)
-                if mod.GName in self.srcs:
-                    tags = modInfos[mod.GName].getBashTags()
-                    self.scan(mod,conflict,tags)
-            else: break
-        if record._Type in ('HAIR','EYES'):
-            return
+    def buildPatch(self,log,progress):
+        """Adds merged lists to patchfile."""
+        keep = self.patchFile.getKeeper()
+        #--Deflsts List
+        log.setHeader('= '+self.__class__.name,True)
+        log.setHeader(_('=== Deflsters'))
+        for leveler in (self.levelers or []):
+            log('* '+self.getItemLabel(leveler))
+        #--Save to patch file
+        for label, type in ((_('FormID'),'FLST'),):
+            log.setHeader(_('=== Merged %s Lists') % label)
+            patchBlock = getattr(self.patchFile,type)
+            levLists = self.type_list[type]
+            for record in sorted(levLists.values(),key=attrgetter('eid')):
+                if not record.mergeOverLast: continue
+                fid = keep(record.fid)
+                patchBlock.setRecord(levLists[fid])
+                log('* '+record.eid)
+                for mod in record.mergeSources:
+                    log('  * ' + self.getItemLabel(mod))
+        # #--Discard empty sublists
+        # for label, type in ((_('FormID'),'FLST'),):
+        #     patchBlock = getattr(self.patchFile,type)
+        #     levLists = self.type_list[type]
+        #     #--Empty lists
+        #     empties = []
+        #     sub_supers = dict((x,[]) for x in levLists.keys())
+        #     for record in sorted(levLists.values()):
+        #         listId = record.fid
+        #         if not record.items:
+        #             empties.append(listId)
+        #         else:
+        #             subLists = [x for x in record.items if x in sub_supers]
+        #             for subList in subLists:
+        #                 sub_supers[subList].append(listId)
+        #     #--Clear empties
+        #     removed = set()
+        #     cleaned = set()
+        #     while empties:
+        #         empty = empties.pop()
+        #         if empty not in sub_supers: continue
+        #         for super in sub_supers[empty]:
+        #             record = levLists[super]
+        #             #record.entries = [x for x in record.entries if x.listId != empty]
+        #             record.fids = [x for x in record.fids if x != empty] # maybe
+        #             record.items.remove(empty)
+        #             patchBlock.setRecord(record)
+        #             if not record.items:
+        #                 empties.append(super)
+        #             cleaned.add(record.eid)
+        #             removed.add(levLists[empty].eid)
+        #             keep(super)
+        #     log.setHeader(_('=== Empty %s Sublists') % label)
+        #     for eid in sorted(removed,key=string.lower):
+        #         log('* '+eid)
+        #     log.setHeader(_('=== Empty %s Sublists Removed') % label)
+        #     for eid in sorted(cleaned,key=string.lower):
+        #         log('* '+eid)
+
+#------------------------------------------------------------------------------
+# class MFactMarker(SpecialPatcher,ListPatcher):
+#     """Mark factions that player can acquire while morphing."""
+#     name = _('Morph Factions')
+#     text = _("Mark factions that player can acquire while morphing.\n\nRequires Cobl 1.28 and Wrye Morph or similar.")
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = 'MFact'
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.id_info = {} #--Morphable factions keyed by fid
+#         self.srcFiles = self.getConfigChecked()
+#         self.isActive = bool(self.srcFiles) and GPath("Cobl Main.esm") in modInfos.ordered
+#         self.mFactLong = (GPath("Cobl Main.esm"),0x33FB)
+
+#     def initData(self,progress):
+#         """Get names from source files."""
+#         if not self.isActive: return
+#         aliases = self.patchFile.aliases
+#         id_info = self.id_info
+#         for srcFile in self.srcFiles:
+#             textPath = dirs['patches'].join(srcFile)
+#             if not textPath.exists(): continue
+#             ins = bolt.CsvReader(textPath)
+#             for fields in ins:
+#                 if len(fields) < 6 or fields[1][:2] != '0x':
+#                     continue
+#                 mod,objectIndex = fields[:2]
+#                 mod = GPath(mod)
+#                 longid = (aliases.get(mod,mod),int(objectIndex,0))
+#                 morphName = fields[4].strip()
+#                 rankName = fields[5].strip()
+#                 if not morphName: continue
+#                 if not rankName: rankName = _('Member')
+#                 id_info[longid] = (morphName,rankName)
+#             ins.close()
+
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         return (None,(MreFact,))[self.isActive]
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         return (None,(MreFact,))[self.isActive]
+
+#     def scanModFile(self, modFile, progress):
+#         """Scan modFile."""
+#         if not self.isActive: return
+#         id_info = self.id_info
+#         modName = modFile.fileInfo.name
+#         mapper = modFile.getLongMapper()
+#         patchBlock = self.patchFile.FACT
+#         if modFile.fileInfo.name == GPath("Cobl Main.esm"):
+#             modFile.convertToLongFids(('FACT',))
+#             record = modFile.FACT.getRecord(self.mFactLong)
+#             if record:
+#                 patchBlock.setRecord(record.getTypeCopy())
+#         for record in modFile.FACT.getActiveRecords():
+#             fid = record.fid
+#             if not record.longFids: fid = mapper(fid)
+#             if fid in id_info:
+#                 patchBlock.setRecord(record.getTypeCopy(mapper))
+
+#     def buildPatch(self,log,progress):
+#         """Make changes to patchfile."""
+#         if not self.isActive: return
+#         mFactLong = self.mFactLong
+#         id_info = self.id_info
+#         modFile = self.patchFile
+#         keep = self.patchFile.getKeeper()
+#         changed = {}
+#         mFactable = []
+#         for record in modFile.FACT.getActiveRecords():
+#             if record.fid not in id_info: continue
+#             if record.fid == mFactLong: continue
+#             mFactable.append(record.fid)
+#             #--Update record if it doesn't have an existing relation with mFactLong
+#             if mFactLong not in [relation.faction for relation in record.relations]:
+#                 record.flags.hiddenFromPC = False
+#                 relation = record.getDefault('relations')
+#                 relation.faction = mFactLong
+#                 relation.mod = 10
+#                 record.relations.append(relation)
+#                 mname,rankName = id_info[record.fid]
+#                 record.full = mname
+#                 if not record.ranks:
+#                     record.ranks = [record.getDefault('ranks')]
+#                 for rank in record.ranks:
+#                     if not rank.male: rank.male = rankName
+#                     if not rank.female: rank.female = rank.male
+#                     if not rank.insigniaPath:
+#                         rank.insigniaPath = r'Menus\Stats\Cobl\generic%02d.dds' % rank.rank
+#                 keep(record.fid)
+#                 mod = record.fid[0]
+#                 changed[mod] = changed.setdefault(mod,0) + 1
+#         #--MFact record
+#         record = modFile.FACT.getRecord(mFactLong)
+#         if record:
+#             relations = record.relations
+#             del relations[:]
+#             for faction in mFactable:
+#                 relation = record.getDefault('relations')
+#                 relation.faction = faction
+#                 relation.mod = 10
+#                 relations.append(relation)
+#             keep(record.fid)
+#         log.setHeader('= '+self.__class__.name)
+#         log(_("=== Source Mods/Files"))
+#         for file in self.srcFiles:
+#             log("* " +file.s)
+#         log(_("\n=== Morphable Factions"))
+#         for mod in sorted(changed):
+#             log("* %s: %d" % (mod.s,changed[mod]))
+
+# class CBash_MFactMarker(SpecialPatcher,CBash_ListPatcher):
+#     """Mark factions that player can acquire while morphing."""
+#     name = _('Morph Factions')
+#     text = _("Mark factions that player can acquire while morphing.\n\nRequires Cobl 1.28 and Wrye Morph or similar.")
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('MFact',))
+#     unloadedText = ""
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+#         if not self.isActive: return
+#         self.cobl = GPath('Cobl Main.esm')
+#         self.isActive = self.cobl in loadMods and modInfos.getVersionFloat(self.cobl) > 1.27
+#         self.id_info = {} #--Morphable factions keyed by fid
+#         self.mFactLong = (self.cobl,0x33FB)
+#         self.mod_count = {}
+#         self.mFactable = set()
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#              type_patchers.setdefault(type,[]).append(self)
+#         progress.setFull(len(self.srcs))
+#         for srcFile in self.srcs:
+#             srcPath = GPath(srcFile)
+#             patchesDir = dirs['patches'].list()
+#             if srcPath not in patchesDir: continue
+#             self.readFromText(dirs['patches'].join(srcFile))
+#             progress.plus()
+
+#     def getTypes(self):
+#         return ['FACT']
+
+#     def readFromText(self,textPath):
+#         """Imports id_info from specified text file."""
+#         aliases = self.patchFile.aliases
+#         id_info = self.id_info
+#         textPath = GPath(textPath)
+#         if not textPath.exists(): return
+#         ins = bolt.CsvReader(textPath)
+#         for fields in ins:
+#             if len(fields) < 6 or fields[1][:2] != '0x':
+#                 continue
+#             mod,objectIndex = fields[:2]
+#             mod = GPath(mod)
+#             longid = (aliases.get(mod,mod),int(objectIndex,0))
+#             morphName = fields[4].strip()
+#             rankName = fields[5].strip()
+#             if not morphName: continue
+#             if not rankName: rankName = _('Member')
+#             id_info[longid] = (morphName,rankName)
+#         ins.close()
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         id_info = self.id_info
+#         recordId = record.fid
+#         mFactLong = self.mFactLong
+#         if recordId in id_info and recordId != mFactLong:
+#             self.mFactable.add(recordId)
+#             if mFactLong not in [relation.faction for relation in record.relations]:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.IsHiddenFromPC = False
+#                     relation = override.create_relation()
+#                     relation.faction = mFactLong
+#                     relation.mod = 10
+#                     mname,rankName = id_info[recordId]
+#                     override.full = mname
+#                     ranks = override.ranks
+#                     if not ranks:
+#                         ranks = [override.create_rank()]
+#                     for rank in ranks:
+#                         if not rank.male: rank.male = rankName
+#                         if not rank.female: rank.female = rank.male
+#                         if not rank.insigniaPath:
+#                             rank.insigniaPath = r'Menus\Stats\Cobl\generic%02d.dds' % rank.rank
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def finishPatch(self,patchFile,progress):
+#         """Edits the bashed patch file directly."""
+#         mFactable = self.mFactable
+#         if not mFactable: return
+#         subProgress = SubProgress(progress)
+#         subProgress.setFull(max(len(mFactable),1))
+#         pstate = 0
+#         try:
+#             coblMod = patchFile.ObCollection.LookupModFile(self.cobl.s)
+#         except KeyError, error:
+#             print "CBash_MFactMarker:finishPatch"
+#             print error[0]
+#             return
+
+#         record = coblMod.LookupRecord(self.mFactLong)
+#         if record.recType != 'FACT':
+#             print PrintFormID(mFactLong)
+#             print patchFile.ObCollection.Debug_DumpModFiles()
+#             print record
+#             raise StateError(_("Cobl Morph Factions: Unable to lookup morphable faction record in Cobl Main.esm!"))
+
+#         override = record.CopyAsOverride(patchFile)
+#         if override:
+#             override.relations = None
+#             pstate = 0
+#             for faction in mFactable:
+#                 subProgress(pstate, _("Marking Morphable Factions...\n"))
+#                 relation = override.create_relation()
+#                 relation.faction = faction
+#                 relation.mod = 10
+#                 pstate += 1
+#         mFactable.clear()
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= '+self.__class__.name)
+#         log(_("=== Source Mods/Files"))
+#         for file in self.srcs:
+#             log("* " +file.s)
+#         log(_("\n=== Morphable Factions"))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log("* %s: %d" % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
+
+#------------------------------------------------------------------------------
+# class PowerExhaustion(SpecialPatcher,Patcher):
+#     """Modifies most Greater power to work with Wrye's Power Exhaustion mod."""
+#     name = _('Power Exhaustion')
+#     text = _("Modify greater powers to work with Power Exhaustion mod.\n\nWill only run if Power Exhaustion mod is installed and active.")
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = (GPath('Power Exhaustion.esp') in loadMods)
+#         self.id_exhaustion = bush.id_exhaustion
+
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         if not self.isActive: return tuple()
+#         return (MreSpel,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         if not self.isActive: return tuple()
+#         return (MreSpel,)
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive: return
+#         mapper = modFile.getLongMapper()
+#         patchRecords = self.patchFile.SPEL
+#         for record in modFile.SPEL.getActiveRecords():
+#             if not record.spellType == 2: continue
+#             record = record.getTypeCopy(mapper)
+#             if record.fid in self.id_exhaustion or ('FOAT',5) in record.getEffects():
+#                 patchRecords.setRecord(record)
+#                 continue
+
+#     def buildPatch(self,log,progress):
+#         """Edits patch file as desired. Will write to log."""
+#         if not self.isActive: return
+#         count = {}
+#         exhaustId = (GPath('Power Exhaustion.esp'),0xCE7)
+#         keep = self.patchFile.getKeeper()
+#         for record in self.patchFile.SPEL.records:
+#             #--Skip this one?
+#             if record.spellType != 2: continue
+#             if record.fid not in self.id_exhaustion and ('FOAT',5) not in record.getEffects():
+#                 continue
+#             newEffects = []
+#             duration = self.id_exhaustion.get(record.fid,0)
+#             for effect in record.effects:
+#                 if effect.name == 'FOAT' and effect.actorValue == 5 and effect.magnitude == 1:
+#                     duration = effect.duration
+#                 else:
+#                     newEffects.append(effect)
+#             if not duration: continue
+#             record.effects = newEffects
+#             #--Okay, do it
+#             record.full = '+'+record.full
+#             record.spellType = 3 #--Lesser power
+#             effect = record.getDefault('effects')
+#             effect.name = 'SEFF'
+#             effect.duration = duration
+#             scriptEffect = record.getDefault('effects.scriptEffect')
+#             scriptEffect.full = _("Power Exhaustion")
+#             scriptEffect.script = exhaustId
+#             scriptEffect.school = 2
+#             scriptEffect.visual = null4
+#             scriptEffect.flags.hostile = False
+#             effect.scriptEffect = scriptEffect
+#             record.effects.append(effect)
+#             keep(record.fid)
+#             srcMod = record.fid[0]
+#             count[srcMod] = count.get(srcMod,0) + 1
+#         #--Log
+#         log.setHeader(_('= Power Exhaustion'))
+#         log(_('* Powers Tweaked: %d') % (sum(count.values()),))
+#         for srcMod in modInfos.getOrdered(count.keys()):
+#             log('  * %s: %d' % (srcMod.s,count[srcMod]))
+
+# class CBash_PowerExhaustion(SpecialPatcher,CBash_Patcher):
+#     """Modifies most Greater power to work with Wrye's Power Exhaustion mod."""
+#     name = _('Power Exhaustion')
+#     text = _("Modify greater powers to work with Power Exhaustion mod.\n\nWill only run if Power Exhaustion mod is installed and active.")
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = (GPath('Power Exhaustion.esp') in loadMods)
+#         if not self.isActive: return
+#         self.id_exhaustion = bush.id_exhaustion
+#         self.mod_count = {}
+#         self.exhaustId = (GPath('Power Exhaustion.esp'),0xCE7)
+#         self.FOATValue = cast('FOAT', POINTER(c_ulong)).contents.value
+#         self.SEFFValue = cast('SEFF', POINTER(c_ulong)).contents.value
+
+#     def getTypes(self):
+#         return ['SPEL']
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired. """
+#         if record.IsPower:
+#             recordId = record.fid
+#             id_exhaustion = self.id_exhaustion
+#             FOATValue = self.FOATValue
+#             Effects = record.effects_list
+#             newEffects = []
+#             duration = id_exhaustion.get(recordId,0)
+#             for effect in Effects:
+#                 if effect[0] == FOATValue and effect[5] == 5 and effect[1] == 1:
+#                     duration = effect[3]
+#                 else:
+#                     newEffects.append(effect)
+#             if duration:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.effects_list = newEffects
+#                     #--Okay, do it
+#                     override.full = '+'+override.full
+#                     override.spellType = 3 #--Lesser power
+#                     effect = override.create_effect()
+#                     effect.name = self.SEFFValue
+#                     effect.duration = duration
+#                     effect.full = _("Power Exhaustion")
+#                     effect.script = self.exhaustId
+#                     effect.school = 2
+#                     effect.visual = None
+#                     effect.IsHostile = False
+
+#                     mod_count = self.mod_count
+#                     mod_count[modFile.GName] = mod_count.get(modFile.GName,0) + 1
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_count = self.mod_count
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_('* Powers Tweaked: %d') % (sum(mod_count.values()),))
+#         for srcMod in modInfos.getOrdered(mod_count.keys()):
+#             log('  * %s: %d' % (srcMod.s,mod_count[srcMod]))
+#         self.mod_count = {}
 
-        recordId = record.fid
-        if self.isActive and (recordId in self.id_eyes):
-            curEyes = set(record.eyes)
-            newEyes = self.id_eyes[recordId]
-            changed = newEyes - curEyes
-            if not changed:
-                newRightEye, newLeftEye = self.id_meshes[recordId]
-                curRightEye, curLeftEye = (record.rightEye.modPath, record.leftEye.modPath)
-                changed = (newRightEye, newLeftEye) != (curRightEye, curLeftEye) #modPaths do case insensitive comparison by default
-            if changed:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    override.eyes = newEyes
-                    override.rightEye.modPath, override.leftEye.modPath = self.id_meshes[recordId]
-                    self.racesPatched.add(record.eid)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
+#------------------------------------------------------------------------------
+class RacePatcher(SpecialPatcher,ListPatcher):
+    """Merged leveled lists mod file."""
+    name = _('Race Records')
+    text = _("Merge race eyes, hair, body, voice from ACTIVE AND/OR MERGED mods. Any non-active, non-merged mods in the following list will be IGNORED.\n\nEven if none of the below mods are checked, this will sort hairs and eyes and attempt to remove googly eyes from all active mods. It will also randomly assign hairs and eyes to npcs that are otherwise missing them.")
+    tip = _("Merge race eyes, hair, body, voice from mods.")
+    autoRe = re.compile(r"^UNDEFINED$",re.I)
+    autoKey = ('Hair','Eyes-D','Eyes-R','Eyes-E','Eyes','Body-M','Body-F',
+        'Body-Size-M','Body-Size-F','Voice-M','Voice-F','R.Teeth',
+        'R.Mouth','R.Ears', 'R.Head','R.Attributes-F', 'R.Attributes-M',
+        'R.Skills', 'R.Description')
+    forceAuto = True
 
-    def finishPatch(self,patchFile,progress):
-        """Edits the bashed patch file directly."""
-        #The patcher gets registered multiple times due to the multiple getTypes
-        #This ensures the finishPatch only runs once per bashed patch
-        if self.finishedOnce: return
-        self.finishedOnce = True
-        racesSorted = self.racesSorted
-        racesFiltered = self.racesFiltered
-        mod_npcsFixed = self.mod_npcsFixed
-        ObCollection = patchFile.ObCollection
-        subProgress = SubProgress(progress)
-        subProgress.setFull(max(len(ObCollection.LoadOrderMods) * 2,1))
-        reX117 = self.reX117
-        defaultEyes = {}
-        defaultMaleHair = {}
-        defaultFemaleHair = {}
-        hairNames = self.hairNames
-        eyeNames = self.eyeNames
-        maleHairs = self.maleHairs
-        femaleHairs = self.femaleHairs
-        playableRaces = set([self.dremoraRace])
+    #--Config Phase -----------------------------------------------------------
+    def getAutoItems(self):
+        """Returns list of items to be used for automatic configuration."""
+        autoItems = []
+        autoRe = self.__class__.autoRe
+        autoKey = set(self.__class__.autoKey)
+        for modInfo in modInfos.data.values():
+            if autoRe.match(modInfo.name.s) or (autoKey & set(modInfo.getBashTags())):
+                if modInfo.mtime > PatchFile.patchTime: continue
+                autoItems.append(modInfo.name)
+        return autoItems
 
-        #--Eye Mesh filtering
-        eye_meshes = self.eye_meshes
-        try:
-            blueEyeMeshes = eye_meshes[self.blueEye]
-        except KeyError, errd:
-            print errd
-            print _("Skipping the race eye patcher: unable to locate the default blue eye (%s, %06X).") % (self.blueEye[0].s, self.blueEye[1])
-            print _("Please copy this entire message and report it on the current official thread at http://forums.bethsoft.com/index.php?/forum/25-mods/.")
-            print
-            print ObCollection.Debug_DumpModFiles()
-            print
-            print _("eye_meshes contents")
-            for eye, meshes in eye_meshes.iteritems():
-                print PrintFormID(eye), ":", meshes
-            return
-        try:
-            argonianEyeMeshes = eye_meshes[self.argonianEye]
-        except KeyError, errd:
-            print errd
-            print _("Skipping the race eye patcher: unable to locate the default argonian eye (%s, %06X).") % (self.argonian[0].s, self.argonian[1])
-            print _("Please copy this entire message and report it on the current official thread at http://forums.bethsoft.com/index.php?/forum/25-mods/.")
-            print
-            print ObCollection.Debug_DumpModFiles()
-            print
-            print _("eye_meshes contents")
-            for eye, meshes in eye_meshes.iteritems():
-                print PrintFormID(eye), ":", meshes
-            return
-        fixedRaces = set()
-        fixedNPCs = set([(GPath('Oblivion.esm'), 0x000007)]) #causes player to be skipped
-        for eye in (
-            (GPath('Oblivion.esm'),0x1a), #--Reanimate
-            (GPath('Oblivion.esm'),0x54bb9), #--Dark Seducer
-            (GPath('Oblivion.esm'),0x54bba), #--Golden Saint
-            (GPath('Oblivion.esm'),0x5fa43), #--Ordered
-            self.dremoraRace,
-            ):
-            eye_meshes.setdefault(eye,blueEyeMeshes)
-        def setRaceEyeMesh(race,rightPath,leftPath):
-            race.rightEye.modPath = rightPath
-            race.leftEye.modPath = leftPath
-        #Scan hairs and eyes for later sorting and/or assigning to non-haired npcs
-        pstate = 0
-        noEyes = 0
-        noHair = 0
-        for modFile in ObCollection.LoadOrderMods:
-            subProgress(pstate, _("Filtering eyes...\n"))
-            for race in modFile.RACE:
-                recordId = race.fid
-                if race.IsPlayable:
-                    playableRaces.add(recordId)
-                currentEyes = race.eyes
-                if not currentEyes: continue #--Sheogorath. Assume is handled correctly.
-                if not race.rightEye or not race.leftEye: continue #no eye set for either right or left... skip.
-                curRightEye, curLeftEye = race.rightEye.modPath, race.leftEye.modPath
-                if not curRightEye or not curLeftEye: continue #--WIPZ race?
-                if reX117.match(race.eid): continue #-- x117 race?
-                if recordId in fixedRaces: continue #--already processed once (added to patchFile, and now the patchFile is being processed)
-                #IsNewest
-                if race.IsWinning():
-                    raceChanged = False
-                    currentMeshes = (curRightEye, curLeftEye)
-                    meshes_eyes = {}
-                    for eye in currentEyes:
-                        if eye not in eye_meshes:
-                            deprint(_('Mesh undefined for eye %s in race %s') % (strFid(eye),race.eid))
-                            continue
-                        rightEye, leftEye = eye_meshes[eye]
-                        meshes_eyes.setdefault((rightEye, leftEye),[]).append(eye)
+    #--Patch Phase ------------------------------------------------------------
+    def initPatchFile(self,patchFile,loadMods):
+        """Prepare to handle specified patch mod. All functions are called after this."""
+        Patcher.initPatchFile(self,patchFile,loadMods)
+        self.raceData = {} #--Race eye meshes, hair,eyes
+        self.tempRaceData = {}
+        #--Restrict srcMods to active/merged mods.
+        self.srcMods = [x for x in self.getConfigChecked() if x in patchFile.allSet]
+        self.isActive = True #--Always enabled to support eye filtering
+        self.bodyKeys = set(('UpperBody','RightHand','LeftHand','UpperBodyTexture'))
+        self.sizeKeys = set(('Height','Weight'))
+        self.raceAttributes = set(('BaseAttribute',))
+        self.raceSkills = set(('skill1','skill1Boost','skill2','skill2Boost','skill3','skill3Boost','skill4','skill4Boost','skill5','skill5Boost','skill6','skill6Boost','skill7','skill7Boost'))
+        self.eyeKeys = set(('Eyes-D','Eyes-R','Eyes-E','Eyes'))
+        #--Mesh tuple for each defined eye. Derived from race records.
+        #defaultMesh = (r'characters\imperial\eyerighthuman.nif', r'characters\imperial\eyelefthuman.nif')
+        self.eye_mesh = {}
+        self.scanTypes = set(('RACE','EYES','HAIR','NPC_'))
 
-                    try:
-                        maxEyesMeshes = sorted(meshes_eyes.keys(),key=lambda a: len(meshes_eyes[a]))[0]
-                    except IndexError:
-                        maxEyesMeshes = blueEyeMeshes
-                    meshesCount = len(meshes_eyes)
-                    #--Single eye mesh, but doesn't match current mesh?
-                    if meshesCount == 1 and currentMeshes != maxEyesMeshes:
-                        currentMeshes = maxEyesMeshes
-                        currentEyes = meshes_eyes[maxEyesMeshes]
-                        raceChanged = True
-                    #--Multiple eye meshes (and playable)?
-                    elif meshesCount > 1 and recordId in playableRaces:
-                        #--If blueEyeMesh (mesh used for vanilla eyes) is present, use that.
-                        if blueEyeMeshes in meshes_eyes and currentMeshes != argonianEyeMeshes:
-                            currentMeshes = blueEyeMeshes
-                            currentEyes = meshes_eyes[blueEyeMeshes]
-                            raceChanged = True
-                        elif argonianEyeMeshes in meshes_eyes:
-                            currentMeshes = argonianEyeMeshes
-                            currentEyes = meshes_eyes[argonianEyeMeshes]
-                            raceChanged = True
-                        #--Else figure that current eye mesh is the correct one
-                        elif currentMeshes in meshes_eyes:
-                            currentEyes = meshes_eyes[currentMeshes]
-                            raceChanged = True
-                        #--Else use most popular eye mesh
-                        else:
-                            currentMeshes = maxEyesMeshes
-                            currentEyes = meshes_eyes[maxEyesMeshes]
-                            raceChanged = True
-                    if raceChanged:
-                        racesFiltered.append(race.eid)
-
-                    #--Sort Eyes/Hair
-                    oldHairs = race.hairs
-                    currentHairs = oldHairs
-                    if recordId in playableRaces:
-                        currentHairs = sorted(oldHairs,key=lambda x: hairNames.get(x))
-                        if currentHairs != oldHairs:
-                            racesSorted.add(race.eid)
-                            raceChanged = True
-                        oldEyes = currentEyes
-                        currentEyes = sorted(oldEyes,key=lambda x: eyeNames.get(x))
-                        if currentEyes != oldEyes:
-                            racesSorted.add(race.eid)
-                            raceChanged = True
-                        defaultEyes[recordId] = [x for x in bush.defaultEyes.get(recordId,[]) if x in currentEyes] or currentEyes
-                        defaultMaleHair[recordId] = [x for x in currentHairs if x in maleHairs]
-                        defaultFemaleHair[recordId] = [x for x in currentHairs if x in femaleHairs]
-
-                    if raceChanged:
-                        fixedRaces.add(recordId)
-                        override = race.CopyAsOverride(patchFile)
-                        if override:
-                            override.eyes = currentEyes
-                            override.hairs = currentHairs
-                            override.rightEye.modPath, override.leftEye.modPath = currentMeshes
-                race.UnloadRecord()
-            pstate += 1
-        for modFile in ObCollection.LoadOrderMods:
-            #--Npcs with unassigned eyes/hair
-            #--Must run after all race records have been processed
-            subProgress(pstate, _("Assigning random eyes and hairs to npcs missing them...\n"))
-            reProcess = re.compile(r'(?:dremora)|(?:akaos)|(?:lathulet)|(?:orthe)|(?:ranyu)',re.I)
-            for npc in modFile.NPC_:
-                recordId = npc.fid
-                if recordId in fixedNPCs: continue #--already processed once (added to patchFile, and now the patchFile is being processed)
-                raceId = npc.race
-                if raceId not in playableRaces: continue
-                if npc.full is not None and raceId == self.dremoraRace and not reProcess.search(npc.full): continue # So as not to give OOO's spectral warriors different hairs/eyes since they are dremora race. 
-                #IsNewest
-                if npc.IsWinning():
-                    npcChanged = False
-                    raceEyes = defaultEyes.get(raceId)
-                    eye = npc.eye
-                    if eye is None and raceEyes:
-                        eye = random.choice(raceEyes)
-                        npcChanged = True
-                    raceHair = ((defaultMaleHair,defaultFemaleHair)[npc.IsFemale]).get(raceId)
-                    hair = npc.hair
-                    if hair is None and raceHair:
-                        hair = random.choice(raceHair)
-                        npcChanged = True
-                    if npcChanged:
-                        fixedNPCs.add(recordId)
-                        override = npc.CopyAsOverride(patchFile)
-                        if override:
-                            override.eye = eye
-                            override.hair = hair
-                            if not override.hairLength:
-                                override.hairLength = random.random()
-                            mod_npcsFixed.setdefault(modFile.GName,set()).add(recordId)
-                npc.UnloadRecord()
-            pstate += 1
+    def initData(self,progress):
+        """Get data from source files."""
+        if not self.isActive or not self.srcMods: return
+        loadFactory = LoadFactory(False,MreRace)
+        progress.setFull(len(self.srcMods))
+        cachedMasters = {}
+        for index,srcMod in enumerate(self.srcMods):
+            if srcMod not in modInfos: continue
+            srcInfo = modInfos[srcMod]
+            srcFile = ModFile(srcInfo,loadFactory)
+            srcFile.load(True)
+            masters = srcInfo.header.masters
+            bashTags = srcInfo.getBashTags()
+            if 'RACE' not in srcFile.tops: continue
+            srcFile.convertToLongFids(('RACE',))
+            self.tempRaceData = {} #so as not to carry anything over!
+            if 'R.ChangeSpells' in bashTags and 'R.AddSpells' in bashTags:
+                raise BoltError(_('WARNING mod %s has both R.AddSpells and R.ChangeSpells tags - only one of those tags should be on a mod at one time') % (srcMod.s))
+            for race in srcFile.RACE.getActiveRecords():
+                tempRaceData = self.tempRaceData.setdefault(race.fid,{})
+                raceData = self.raceData.setdefault(race.fid,{})
+                if 'Hair' in bashTags:
+                    raceHair = raceData.setdefault('hairs',[])
+                    for hair in race.hairs:
+                        if hair not in raceHair: raceHair.append(hair)
+                if self.eyeKeys & bashTags:
+                    tempRaceData['femaleLeftEye'] = race.femaleLeftEye
+                    tempRaceData['femaleRightEye'] = race.femaleRightEye
+                    tempRaceData['maleLeftEye'] = race.maleLeftEye
+                    tempRaceData['maleRightEye'] = race.maleRightEye
+                    raceEyes = raceData.setdefault('eyes',[])
+                    for eye in race.eyes:
+                        if eye not in raceEyes: raceEyes.append(eye)
+                if 'Voice-M' in bashTags:
+                    tempRaceData['maleVoice'] = race.maleVoice
+                if 'Voice-F' in bashTags:
+                    tempRaceData['femaleVoice'] = race.femaleVoice
+                if 'Body-M' in bashTags:
+                    for key in ['male'+key for key in self.bodyKeys]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'Body-F' in bashTags:
+                    for key in ['female'+key for key in self.bodyKeys]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'Body-Size-M' in bashTags:
+                    for key in ['male'+key for key in self.sizeKeys]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'Body-Size-F' in bashTags:
+                    for key in ['female'+key for key in self.sizeKeys]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Teeth' in bashTags:
+                    for key in ('maleTeethLower','femaleTeethLower','maleTeethUpper','femaleTeethUpper'):
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Mouth' in bashTags:
+                    for key in ('maleMouth','femaleMouth','maleTongue','femaleTongue'):
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Head' in bashTags:
+                    tempRaceData['head'] = race.head
+                if 'R.Ears' in bashTags:
+                    for key in ('maleEars','femaleEars'):
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Attributes-F' in bashTags:
+                    for key in ['female'+key for key in self.raceAttributes]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Attributes-M' in bashTags:
+                    for key in ['male'+key for key in self.raceAttributes]:
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Skills' in bashTags:
+                    for key in self.raceSkills:
+                        tempRaceData[key] = getattr(race,key)
+                if 'R.Description' in bashTags:
+                    tempRaceData['text'] = race.text
+            for master in masters:
+                if not master in modInfos: continue # or break filter mods
+                if master in cachedMasters:
+                    masterFile = cachedMasters[master]
+                else:
+                    masterInfo = modInfos[master]
+                    masterFile = ModFile(masterInfo,loadFactory)
+                    masterFile.load(True)
+                    if 'RACE' not in masterFile.tops: continue
+                    masterFile.convertToLongFids(('RACE',))
+                    cachedMasters[master] = masterFile
+                for race in masterFile.RACE.getActiveRecords():
+                    if race.fid not in self.tempRaceData: continue
+                    tempRaceData = self.tempRaceData[race.fid]
+                    raceData = self.raceData[race.fid]
+                    if 'AddSpells' in tempRaceData:
+                        raceData.setdefault('AddSpells', [])
+                        for spell in tempRaceData['AddSpells']:
+                            if spell not in race.spells:
+                                if spell not in raceData['AddSpells']:
+                                    raceData['AddSpells'].append(spell)
+                        del tempRaceData['AddSpells']
+                    for key in tempRaceData:
+                        if not tempRaceData[key] == getattr(race,key):
+                            raceData[key] = tempRaceData[key]
+            progress.plus()
 
-class CBash_RacePatcher(SpecialPatcher,CBash_ListPatcher):
-    """Merged leveled lists mod file."""
-    name = _('Race Records')
-    text = _("Merge race eyes, hair, body, voice from ACTIVE AND/OR MERGED mods.\n\nEven if none of the below mods are checked, this will sort hairs and eyes and attempt to remove googly eyes from all active mods. It will also randomly assign hairs and eyes to npcs that are otherwise missing them.")
-    tip = _("Merge race eyes, hair, body, voice from mods.")
-    autoRe = re.compile(r"^UNDEFINED$",re.I)
-    autoKey = set(('Hair','Eyes-D','Eyes-R','Eyes-E','Eyes','Body-M','Body-F',
-        'Voice-M','Voice-F','R.Relations','R.Teeth','R.Mouth','R.Ears', 'R.Head',
-        'R.Attributes-F', 'R.Attributes-M', 'R.Skills', 'R.Description',
-        'R.AddSpells', 'R.ChangeSpells','Body-Size-M','Body-Size-F',))
-    forceAuto = True
-    tweaks = [
-        CBash_RacePatcher_Relations(),
-        CBash_RacePatcher_Imports(),
-        CBash_RacePatcher_Spells(),
-        CBash_RacePatcher_Eyes(),
-        ]
+    def getReadClasses(self):
+        """Returns load factory classes needed for reading."""
+        return (None,(MreRace,MreEyes,MreHair,MreNpc))[self.isActive]
 
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
-        #This single tweak is broken into several parts to make it easier to manage
-        #Each part is a group of tags that are processed similarly
-        for tweak in self.tweaks:
-            tweak.initPatchFile(self.srcs,patchFile,loadMods)
+    def getWriteClasses(self):
+        """Returns load factory classes needed for writing."""
+        return (None,(MreRace,MreEyes,MreHair,MreNpc))[self.isActive]
 
-    def initData(self,type_patchers,progress):
-        """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
-        for tweak in self.tweaks:
-            tweak.initData(type_patchers,progress)
+    def scanModFile(self, modFile, progress):
+        """Add appropriate records from modFile."""
+        if not self.isActive: return
+        eye_mesh = self.eye_mesh
+        modName = modFile.fileInfo.name
+        mapper = modFile.getLongMapper()
+        if not (set(modFile.tops) & self.scanTypes): return
+        modFile.convertToLongFids(('RACE','EYES','NPC_'))
+        srcEyes = set([record.fid for record in modFile.EYES.getActiveRecords()])
+        #--Eyes, Hair
+        for type in ('EYES','HAIR'):
+            patchBlock = getattr(self.patchFile,type)
+            id_records = patchBlock.id_records
+            for record in getattr(modFile,type).getActiveRecords():
+                if record.fid not in id_records:
+                    patchBlock.setRecord(record.getTypeCopy(mapper))
+        #--Npcs with unassigned eyes
+        patchBlock = self.patchFile.NPC_
+        id_records = patchBlock.id_records
+        for record in modFile.NPC_.getActiveRecords():
+            if not record.eye and record.fid not in id_records:
+                patchBlock.setRecord(record.getTypeCopy(mapper))
+        #--Race block
+        patchBlock = self.patchFile.RACE
+        id_records = patchBlock.id_records
+        for record in modFile.RACE.getActiveRecords():
+            if record.fid not in id_records:
+                patchBlock.setRecord(record.getTypeCopy(mapper))
+            if not record.maleRightEye or not record.maleLeftEye:
+                deprint(_('No right and/or no left eye recorded in race %s, from mod %s') % (record.full, modName))
+                continue
+            for eye in record.eyes:
+                if eye in srcEyes:
+                    eye_mesh[eye] = (record.maleRightEye.modPath.lower(),record.maleLeftEye.modPath.lower(),
+                                     record.femaleRightEye.modPath.lower(),record.femaleLeftEye.modPath.lower())
 
-    #--Patch Phase ------------------------------------------------------------
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        racesPatched = set()
-        racesSorted = set()
+    def buildPatch(self,log,progress):
+        """Updates races as needed."""
+        debug = False
+        if not self.isActive: return
+        patchFile = self.patchFile
+        keep = patchFile.getKeeper()
+        if 'RACE' not in patchFile.tops: return
+        racesPatched = []
+        racesSorted = []
         racesFiltered = []
         mod_npcsFixed = {}
-        for tweak in self.tweaks:
-            if hasattr(tweak, 'racesPatched'):
-                racesPatched |= tweak.racesPatched
-            if hasattr(tweak, 'racesSorted'):
-                racesSorted |= tweak.racesSorted
-            if hasattr(tweak, 'racesFiltered'):
-                racesFiltered += tweak.racesFiltered
-            if hasattr(tweak, 'mod_npcsFixed'):
-                mod_npcsFixed.update(tweak.mod_npcsFixed)
+        #reProcess = re.compile(r'(?:dremora)|(?:akaos)|(?:lathulet)|(?:orthe)|(?:ranyu)',re.I)
+        #--Import race info
+        for race in patchFile.RACE.records:
+            #~~print 'Building',race.eid
+            raceData = self.raceData.get(race.fid,None)
+            if not raceData: continue
+            raceChanged = False
+            #-- Racial Hair and  Eye sets
+            if 'hairs' in raceData and (set(race.hairs) != set(raceData['hairs'])):
+                race.hairs = raceData['hairs']
+                raceChanged = True
+            if 'eyes' in raceData:
+                if set(race.eyes) != set(raceData['eyes']):
+                    race.eyes = raceData['eyes']
+                    raceChanged = True
+            #-- Eye paths:
+            if 'femaleRightEye' in raceData:
+                if not race.femaleRightEye: deprint(_('Very odd race %s found - no female right eye assigned') % (race.full))
+                else:
+                    if race.femaleRightEye.modPath != raceData['femaleRightEye'].modPath:
+                        race.femaleRightEye.modPath = raceData['femaleRightEye'].modPath
+                        raceChanged = True
+            if 'femaleLeftEye' in raceData:
+                if not race.femaleLeftEye: deprint(_('Very odd race %s found - no female left eye assigned') % (race.full))
+                else:
+                    if race.femaleLeftEye.modPath != raceData['femaleLeftEye'].modPath:
+                        race.femaleLeftEye.modPath = raceData['femaleLeftEye'].modPath
+                        raceChanged = True
+            if 'maleRightEye' in raceData:
+                if not race.maleRightEye: deprint(_('Very odd race %s found - no male right eye assigned') % (race.full))
+                else:
+                    if race.maleRightEye.modPath != raceData['maleRightEye'].modPath:
+                        race.maleRightEye.modPath = raceData['maleRightEye'].modPath
+                        raceChanged = True
+            if 'maleLeftEye' in raceData:
+                if not race.maleLeftEye: deprint(_('Very odd race %s found - no male left eye assigned') % (race.full))
+                else:
+                    if race.maleLeftEye.modPath != raceData['maleLeftEye'].modPath:
+                        race.maleLeftEye.modPath = raceData['maleLeftEye'].modPath
+                        raceChanged = True
+            #--description
+            if 'text' in raceData:
+                if race.text != raceData['text']:
+                    race.text = raceData['text']
+                    raceChanged = True
+            #--skills
+            for key in self.raceSkills:
+                if key in raceData:
+                    if getattr(race,key) != raceData[key]:
+                        setattr(race,key,raceData[key])
+                        raceChanged = True
+            #--Gender info (voice, gender specific body data)
+            for gender in ('male','female'):
+                bodyKeys = self.bodyKeys.union(self.raceAttributes.union(set(('Ears','Voice','TeethLower','TeethUpper','Mouth','Tongue','Head'))))
+                bodyKeys = [gender+key for key in bodyKeys]
+                for key in bodyKeys:
+                    if key in raceData:
+                        if getattr(race,key) != raceData[key]:
+                            setattr(race,key,raceData[key])
+                            raceChanged = True
+            #--Changed
+            if raceChanged:
+                racesPatched.append(race.eid)
+                keep(race.fid)
+        #--Eye Mesh filtering
+        # eye_mesh = self.eye_mesh
+        # ghoulEyeMesh = eye_mesh[(GPath('Fallout3.esm'),0x35e4f)]
+        # hazelEyeMesh = eye_mesh[(GPath('Fallout3.esm'),0x4255)]
+        # if debug:
+        #     print '== Eye Mesh Filtering'
+        #     print 'hazelEyeMesh',hazelEyeMesh
+        #     print 'ghoulEyeMesh',ghoulEyeMesh
+        # for eye in (
+        #     (GPath('Fallout3.esm'),0x1a), #--Reanimate
+        #     #(GPath('Oblivion.esm'),0x54bb9), #--Dark Seducer
+        #     #(GPath('Oblivion.esm'),0x54bba), #--Golden Saint
+        #     #(GPath('Oblivion.esm'),0x5fa43), #--Ordered
+        #     ):
+        #     eye_mesh.setdefault(eye,hazelEyeMesh)
+        # def setRaceEyeMesh(race,maleRightPath,femaleRightPath,femaleLeftPath,maleLeftPath):
+        #     race.maleRightEye.modPath = maleRightPath
+        #     race.femaleRightEye.modPath = femaleRightPath
+        #     race.maleLeftEye.modPath = maleLeftPath
+        #     race.femaleLeftEye.modPath = femaleLeftPath
+        # for race in patchFile.RACE.records:
+        #     if debug: print '===', race.eid
+        #     if not race.eyes: continue #--Sheogorath. Assume is handled correctly.
+        #     if not race.maleRightEye or not race.femaleRightEye or not race.maleLeftEye or not race.femaleLeftEye: continue #--WIPZ race?
+        #     raceChanged = False
+        #     mesh_eye = {}
+        #     for eye in race.eyes:
+        #         if eye not in eye_mesh:
+        #             raise StateError(_('Mesh undefined for eye %s in race %s') % (strFid(eye),race.eid,))
+        #         mesh = eye_mesh[eye]
+        #         if mesh not in mesh_eye:
+        #             mesh_eye[mesh] = []
+        #         mesh_eye[mesh].append(eye)
+        #     currentMesh = (race.maleRightEye.modPath.lower(),race.maleLeftEye.modPath.lower(),
+        #                    race.femaleRightEye.modPath.lower(),race.femaleLeftEye.modPath.lower())
+        #     #print race.eid, mesh_eye
+        #     maxEyesMesh = sorted(mesh_eye.keys(),key=lambda a: len(mesh_eye[a]))[0]
+        #     #--Single eye mesh, but doesn't match current mesh?
+        #     if len(mesh_eye) == 1 and currentMesh != maxEyesMesh:
+        #         setRaceEyeMesh(race,*maxEyesMesh)
+        #         raceChanged = True
+        #     #--Multiple eye meshes (and playable)?
+        #     if debug:
+        #         for mesh,eyes in mesh_eye.iteritems():
+        #             print mesh
+        #             for eye in eyes: print ' ',strFid(eye)
+        #     if len(mesh_eye) > 1 and race.flags.playable:
+        #         #--If hazelEyeMesh (mesh used for vanilla eyes) is present, use that.
+        #         if hazelEyeMesh in mesh_eye and currentMesh != hazelEyeMesh:
+        #             setRaceEyeMesh(race,*hazelEyeMesh)
+        #             race.eyes = mesh_eye[hazelEyeMesh]
+        #             raceChanged = True
+        #         #elif ghoulEyeMesh in mesh_eye:
+        #         #    setRaceEyeMesh(race,*ghoulEyeMesh)
+        #         #    race.eyes = mesh_eye[ghoulEyeMesh]
+        #         #    raceChanged = True
+        #         #--Else figure that current eye mesh is the correct one
+        #         elif currentMesh in mesh_eye:
+        #             race.eyes = mesh_eye[currentMesh]
+        #             raceChanged = True
+        #         #--Else use most popular eye mesh
+        #         else:
+        #             setRaceEyeMesh(race,*maxEyesMeshes)
+        #             race.eyes = mesh_eye[maxEyesMesh]
+        #             raceChanged = True
+        #     if raceChanged:
+        #         racesFiltered.append(race.eid)
+        #         keep(race.fid)
+        #--Sort Eyes/Hair
+        defaultEyes = {}
+        defaultMaleHair = {}
+        defaultFemaleHair = {}
+        eyeNames  = dict((x.fid,x.full) for x in patchFile.EYES.records)
+        hairNames = dict((x.fid,x.full) for x in patchFile.HAIR.records)
+        maleHairs = set(x.fid for x in patchFile.HAIR.records if not x.flags.notMale)
+        femaleHairs = set(x.fid for x in patchFile.HAIR.records if not x.flags.notFemale)
+        for race in patchFile.RACE.records:
+            #if (race.flags.playable or race.fid == (GPath('Oblivion.esm'), 0x038010)) and race.eyes:
+            if race.flags.playable and race.eyes:
+                defaultEyes[race.fid] = [x for x in bush.defaultEyes.get(race.fid,[]) if x in race.eyes]
+                if not defaultEyes[race.fid]:
+                    defaultEyes[race.fid] = [race.eyes[0]]
+                defaultMaleHair[race.fid] = [x for x in race.hairs if x in maleHairs]
+                defaultFemaleHair[race.fid] = [x for x in race.hairs if x in femaleHairs]
+                race.hairs.sort(key=lambda x: hairNames.get(x))
+                race.eyes.sort(key=lambda x: eyeNames.get(x))
+                racesSorted.append(race.eid)
+                keep(race.fid)
+        #--Npcs with unassigned eyes/hair
+        for npc in patchFile.NPC_.records:
+            #if npc.fid == (GPath('Oblivion.esm'), 0x000007): continue #skip player
+            #if npc.full is not None and npc.race == (GPath('Oblivion.esm'), 0x038010) and not reProcess.search(npc.full): continue
+            raceEyes = defaultEyes.get(npc.race)
+            if not npc.eye and raceEyes:
+                npc.eye = random.choice(raceEyes)
+                srcMod = npc.fid[0]
+                if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
+                mod_npcsFixed[srcMod].add(npc.fid)
+                keep(npc.fid)
+            # raceHair = ((defaultMaleHair,defaultFemaleHair)[npc.flags.female]).get(npc.race)
+            # if not npc.hair and raceHair:
+            #     npc.hair = random.choice(raceHair)
+            #     srcMod = npc.fid[0]
+            #     if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
+            #     mod_npcsFixed[srcMod].add(npc.fid)
+            #     keep(npc.fid)
+            # if not npc.hairLength:
+            #     npc.hairLength = random.random()
+            #     srcMod = npc.fid[0]
+            #     if srcMod not in mod_npcsFixed: mod_npcsFixed[srcMod] = set()
+            #     keep(npc.fid)
+            #     if npc.fid in mod_npcsFixed[srcMod]: continue
+            #     mod_npcsFixed[srcMod].add(npc.fid)
+
         #--Done
         log.setHeader('= '+self.__class__.name)
         log(_("=== Source Mods"))
-        if not self.srcs:
-            log(_(". ~~None~~"))
-        else:
-            for mod in self.srcs:
-                log("* " +mod.s)
+        for mod in self.srcMods:
+            log("* " +mod.s)
         log(_("\n=== Merged"))
-
         if not racesPatched:
             log(_(". ~~None~~"))
         else:
@@ -33209,144 +34463,739 @@ class CBash_RacePatcher(SpecialPatcher,CBash_ListPatcher):
         if mod_npcsFixed:
             log(_("\n=== Eyes/Hair Assigned for NPCs"))
             for srcMod in sorted(mod_npcsFixed):
-                if srcMod.cext == '.tmp':
-                    name = srcMod.sbody
-                else:
-                    name = srcMod.s
-                log("* %s: %d" % (name,len(mod_npcsFixed[srcMod])))
+                log("* %s: %d" % (srcMod.s,len(mod_npcsFixed[srcMod])))
+
+# class CBash_RacePatcher_Relations(SpecialPatcher):
+#     """Merges changes to race relations."""
+#     autoKey = set(('R.Relations',))
+#     iiMode = False
+#     allowUnloaded = True
+#     scanRequiresChecked = True
+#     applyRequiresChecked = False
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,srcs,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         self.srcs = srcs
+#         self.isActive = bool(srcs)
+#         if not self.isActive: return
+#         self.racesPatched = set()
+#         self.fid_faction_mod = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#             type_patchers.setdefault(type,[]).append(self)
+
+#     def getTypes(self):
+#         return ['RACE']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         if bashTags & self.autoKey:
+#             relations = record.relations_list
+#             if relations:
+#                 self.fid_faction_mod.setdefault(record.fid,{}).update(relations)
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         if(recordId in self.fid_faction_mod):
+#             newRelations = set((faction,mod) for faction,mod in self.fid_faction_mod[recordId].iteritems())
+#             curRelations = set(record.relations_list)
+#             changed = newRelations - curRelations
+#             if changed:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     for faction,mod in changed:
+#                         for relation in override.relations:
+#                             if relation.faction == faction:
+#                                 relation.mod = mod
+#                                 break
+#                         else:
+#                             relation = override.create_relation()
+#                             relation.faction,relation.mod = faction,mod
+#                     self.racesPatched.add(record.eid)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+# class CBash_RacePatcher_Imports(SpecialPatcher):
+#     """Imports various race fields."""
+#     autoKey = set(('Hair','Body-M','Body-F','Voice-M','Voice-F','R.Teeth',
+#                'R.Mouth','R.Ears','R.Head','R.Attributes-F','R.Attributes-M',
+#                'R.Skills','R.Description', 'Body-Size-F','Body-Size-M'))
+#     tag_attrs = {
+#         'Hair'  : ('hairs',),
+#         'Body-M': ('maleTail_list','maleUpperBodyPath','maleLowerBodyPath',
+#                    'maleHandPath','maleFootPath','maleTailPath'),
+#         'Body-F': ('femaleTail_list','femaleUpperBodyPath','femaleLowerBodyPath',
+#                    'femaleHandPath','femaleFootPath','femaleTailPath'),
+#         'Body-Size-M': ('maleHeight','maleWeight'),
+#         'Body-Size-F': ('femaleHeight','femaleWeight'),
+#         'Voice-M': ('maleVoice',),
+#         'Voice-F': ('femaleVoice',),
+#         'R.Teeth': ('teethLower_list','teethUpper_list',),
+#         'R.Mouth': ('mouth_list','tongue_list',),
+#         'R.Ears': ('maleEars_list','femaleEars_list',),
+#         'R.Head': ('head_list','fggs_p','fgga_p','fgts_p','snam_p'),
+#         'R.Attributes-M': ('maleStrength','maleIntelligence','maleWillpower','maleAgility','maleSpeed','maleEndurance','malePersonality','maleLuck'),
+#         'R.Attributes-F': ('femaleStrength','femaleIntelligence','femaleWillpower','femaleAgility','femaleSpeed','femaleEndurance','femalePersonality','femaleLuck'),
+#         'R.Skills': ('skill1','skill1Boost','skill2','skill2Boost','skill3','skill3Boost','skill4','skill4Boost','skill5','skill5Boost','skill6','skill6Boost','skill7','skill7Boost'),
+#         'R.Description': ('text',),
+#         }
+#     iiMode = False
+#     allowUnloaded = True
+#     scanRequiresChecked = True
+#     applyRequiresChecked = False
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,srcs,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         self.srcs = srcs
+#         self.isActive = bool(srcs)
+#         if not self.isActive: return
+#         self.racesPatched = set()
+#         self.id_tag_values = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#             type_patchers.setdefault(type,[]).append(self)
+
+#     def getTypes(self):
+#         return ['RACE']
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         recordId = record.fid
+#         for bashKey in bashTags & self.autoKey:
+#             if bashKey == 'Hair':
+#                 #Using sets would make this clearer, and probably faster (though speed isn't a concern)
+#                 #So this is a bit convulated, but makes the apply section work without special casing this tag
+#                 #Hairs should perhaps have it's own patcher, but...
+#                 allHairs = self.id_tag_values.setdefault(recordId,{}).setdefault(bashKey,[[]])
+#                 allHairs[0] += (hair for hair in record.hairs if hair not in allHairs[0] and hair[0])
+#             else:
+#                 self.id_tag_values.setdefault(recordId,{})[bashKey] = map(record.__getattribute__,self.tag_attrs[bashKey])
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         if(recordId in self.id_tag_values):
+#             allAttrs = []
+#             prevValues = []
+#             recValues = []
+#             for bashKey in self.tag_attrs:
+#                 attrs = self.tag_attrs[bashKey]
+#                 allAttrs += attrs
+#                 tagValues = map(record.__getattribute__,attrs)
+#                 prevValues += self.id_tag_values[recordId].get(bashKey, tagValues)
+#                 recValues += tagValues
+#             if recValues != prevValues:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     map(override.__setattr__, allAttrs, prevValues)
+#                     self.racesPatched.add(record.eid)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+# class CBash_RacePatcher_Spells(SpecialPatcher):
+#     """Merges changes to race spells."""
+#     autoKey = set(('R.AddSpells', 'R.ChangeSpells'))
+#     iiMode = False
+#     allowUnloaded = True
+#     scanRequiresChecked = True
+#     applyRequiresChecked = False
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,srcs,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         self.srcs = srcs
+#         self.isActive = bool(srcs)
+#         if not self.isActive: return
+#         self.racesPatched = set()
+#         self.id_spells = {}
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#             type_patchers.setdefault(type,[]).append(self)
+
+#     def getTypes(self):
+#         return ['RACE']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         tags = bashTags & self.autoKey
+#         if tags:
+#             if 'R.ChangeSpells' in tags and 'R.AddSpells' in tags:
+#                 raise BoltError(_('WARNING mod %s has both R.AddSpells and R.ChangeSpells tags - only one of those tags should be on a mod at one time') % (modFile.ModName))
+#             curSpells = set(record.spells)
+#             if curSpells:
+#                 spells = self.id_spells.setdefault(record.fid,set())
+#                 if 'R.ChangeSpells' in tags:
+#                     spells = curSpells
+#                 elif 'R.AddSpells' in tags:
+#                     spells |= curSpells
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs:
+#             self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         recordId = record.fid
+#         if(recordId in self.id_spells):
+#             newSpells = self.id_spells[recordId]
+#             curSpells = set(record.spells)
+#             changed = newSpells - curSpells
+#             if changed:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.spells = newSpells
+#                     self.racesPatched.add(record.eid)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+# class CBash_RacePatcher_Eyes(SpecialPatcher):
+#     """Merges and filters changes to race eyes."""
+#     autoKey = set(('Eyes-D','Eyes-R','Eyes-E','Eyes'))
+#     blueEye = (GPath('Oblivion.esm'),0x27308)
+#     argonianEye = (GPath('Oblivion.esm'),0x3e91e)
+#     dremoraRace = (GPath('Oblivion.esm'),0x038010)
+# ##    defaultMesh = (r'characters\imperial\eyerighthuman.nif', r'characters\imperial\eyelefthuman.nif')
+#     reX117 = re.compile('^117[a-z]',re.I)
+#     iiMode = False
+#     allowUnloaded = True
+#     scanRequiresChecked = False
+#     applyRequiresChecked = False
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,srcs,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         self.patchFile = patchFile
+#         self.srcs = srcs
+#         self.isActive = True #--Always partially enabled to support eye filtering
+#         self.racesPatched = set()
+#         self.racesSorted = set()
+#         self.racesFiltered = []
+#         self.mod_npcsFixed = {}
+#         self.hairNames = {}
+#         self.eyeNames = {}
+#         self.maleHairs = set()
+#         self.femaleHairs = set()
+#         self.id_meshes = {}
+#         self.id_eyes = {}
+#         self.eye_meshes = {}
+#         self.finishedOnce = False
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         if not self.isActive: return
+#         for type in self.getTypes():
+#             type_patchers.setdefault(type,[]).append(self)
+
+#     def getTypes(self):
+#         return ['EYES','HAIR','RACE']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         recordId = record.fid
+#         if record._Type == 'HAIR':
+#             if record.IsMale:
+#                 self.maleHairs.add(recordId)
+#             else:
+#                 self.femaleHairs.add(recordId)
+#             self.hairNames.update({recordId:record.full})
+#             return
+#         elif record._Type == 'EYES':
+#             self.eyeNames.update({record.fid:record.full})
+#             return
+#         eye_meshes = self.eye_meshes
+#         curEyes = set(record.eyes)
+#         eyePaths = (record.rightEye.modPath, record.leftEye.modPath)
+#         for eye in curEyes:
+#             if eye not in eye_meshes:
+#                 eye_meshes[eye] = eyePaths
+#         if modFile.GName in self.srcs and self.autoKey & bashTags:
+#             allEyes = self.id_eyes.setdefault(recordId,set())
+#             allEyes |= set(curEyes)
+#             self.id_meshes[recordId] = eyePaths
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         self.scan(modFile,record,bashTags)
+#         #Must check for "unloaded" conflicts that occur past the winning record
+#         #If any exist, they have to be scanned
+#         for conflict in record.Conflicts(True):
+#             if conflict != record:
+#                 mod = ObModFile(conflict._CollectionID, conflict._ModID)
+#                 if mod.GName in self.srcs:
+#                     tags = modInfos[mod.GName].getBashTags()
+#                     self.scan(mod,conflict,tags)
+#             else: break
+#         if record._Type in ('HAIR','EYES'):
+#             return
+
+#         recordId = record.fid
+#         if self.isActive and (recordId in self.id_eyes):
+#             curEyes = set(record.eyes)
+#             newEyes = self.id_eyes[recordId]
+#             changed = newEyes - curEyes
+#             if not changed:
+#                 newRightEye, newLeftEye = self.id_meshes[recordId]
+#                 curRightEye, curLeftEye = (record.rightEye.modPath, record.leftEye.modPath)
+#                 changed = (newRightEye, newLeftEye) != (curRightEye, curLeftEye) #modPaths do case insensitive comparison by default
+#             if changed:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     override.eyes = newEyes
+#                     override.rightEye.modPath, override.leftEye.modPath = self.id_meshes[recordId]
+#                     self.racesPatched.add(record.eid)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def finishPatch(self,patchFile,progress):
+#         """Edits the bashed patch file directly."""
+#         #The patcher gets registered multiple times due to the multiple getTypes
+#         #This ensures the finishPatch only runs once per bashed patch
+#         if self.finishedOnce: return
+#         self.finishedOnce = True
+#         racesSorted = self.racesSorted
+#         racesFiltered = self.racesFiltered
+#         mod_npcsFixed = self.mod_npcsFixed
+#         ObCollection = patchFile.ObCollection
+#         subProgress = SubProgress(progress)
+#         subProgress.setFull(max(len(ObCollection.LoadOrderMods) * 2,1))
+#         reX117 = self.reX117
+#         defaultEyes = {}
+#         defaultMaleHair = {}
+#         defaultFemaleHair = {}
+#         hairNames = self.hairNames
+#         eyeNames = self.eyeNames
+#         maleHairs = self.maleHairs
+#         femaleHairs = self.femaleHairs
+#         playableRaces = set([self.dremoraRace])
+
+#         #--Eye Mesh filtering
+#         eye_meshes = self.eye_meshes
+#         try:
+#             blueEyeMeshes = eye_meshes[self.blueEye]
+#         except KeyError, errd:
+#             print errd
+#             print _("Skipping the race eye patcher: unable to locate the default blue eye (%s, %06X).") % (self.blueEye[0].s, self.blueEye[1])
+#             print _("Please copy this entire message and report it on the current official thread at http://forums.bethsoft.com/index.php?/forum/25-mods/.")
+#             print
+#             print ObCollection.Debug_DumpModFiles()
+#             print
+#             print _("eye_meshes contents")
+#             for eye, meshes in eye_meshes.iteritems():
+#                 print PrintFormID(eye), ":", meshes
+#             return
+#         try:
+#             argonianEyeMeshes = eye_meshes[self.argonianEye]
+#         except KeyError, errd:
+#             print errd
+#             print _("Skipping the race eye patcher: unable to locate the default argonian eye (%s, %06X).") % (self.argonian[0].s, self.argonian[1])
+#             print _("Please copy this entire message and report it on the current official thread at http://forums.bethsoft.com/index.php?/forum/25-mods/.")
+#             print
+#             print ObCollection.Debug_DumpModFiles()
+#             print
+#             print _("eye_meshes contents")
+#             for eye, meshes in eye_meshes.iteritems():
+#                 print PrintFormID(eye), ":", meshes
+#             return
+#         fixedRaces = set()
+#         fixedNPCs = set([(GPath('Oblivion.esm'), 0x000007)]) #causes player to be skipped
+#         for eye in (
+#             (GPath('Oblivion.esm'),0x1a), #--Reanimate
+#             (GPath('Oblivion.esm'),0x54bb9), #--Dark Seducer
+#             (GPath('Oblivion.esm'),0x54bba), #--Golden Saint
+#             (GPath('Oblivion.esm'),0x5fa43), #--Ordered
+#             self.dremoraRace,
+#             ):
+#             eye_meshes.setdefault(eye,blueEyeMeshes)
+#         def setRaceEyeMesh(race,rightPath,leftPath):
+#             race.rightEye.modPath = rightPath
+#             race.leftEye.modPath = leftPath
+#         #Scan hairs and eyes for later sorting and/or assigning to non-haired npcs
+#         pstate = 0
+#         noEyes = 0
+#         noHair = 0
+#         for modFile in ObCollection.LoadOrderMods:
+#             subProgress(pstate, _("Filtering eyes...\n"))
+#             for race in modFile.RACE:
+#                 recordId = race.fid
+#                 if race.IsPlayable:
+#                     playableRaces.add(recordId)
+#                 currentEyes = race.eyes
+#                 if not currentEyes: continue #--Sheogorath. Assume is handled correctly.
+#                 if not race.rightEye or not race.leftEye: continue #no eye set for either right or left... skip.
+#                 curRightEye, curLeftEye = race.rightEye.modPath, race.leftEye.modPath
+#                 if not curRightEye or not curLeftEye: continue #--WIPZ race?
+#                 if reX117.match(race.eid): continue #-- x117 race?
+#                 if recordId in fixedRaces: continue #--already processed once (added to patchFile, and now the patchFile is being processed)
+#                 #IsNewest
+#                 if race.IsWinning():
+#                     raceChanged = False
+#                     currentMeshes = (curRightEye, curLeftEye)
+#                     meshes_eyes = {}
+#                     for eye in currentEyes:
+#                         if eye not in eye_meshes:
+#                             deprint(_('Mesh undefined for eye %s in race %s') % (strFid(eye),race.eid))
+#                             continue
+#                         rightEye, leftEye = eye_meshes[eye]
+#                         meshes_eyes.setdefault((rightEye, leftEye),[]).append(eye)
+
+#                     try:
+#                         maxEyesMeshes = sorted(meshes_eyes.keys(),key=lambda a: len(meshes_eyes[a]))[0]
+#                     except IndexError:
+#                         maxEyesMeshes = blueEyeMeshes
+#                     meshesCount = len(meshes_eyes)
+#                     #--Single eye mesh, but doesn't match current mesh?
+#                     if meshesCount == 1 and currentMeshes != maxEyesMeshes:
+#                         currentMeshes = maxEyesMeshes
+#                         currentEyes = meshes_eyes[maxEyesMeshes]
+#                         raceChanged = True
+#                     #--Multiple eye meshes (and playable)?
+#                     elif meshesCount > 1 and recordId in playableRaces:
+#                         #--If blueEyeMesh (mesh used for vanilla eyes) is present, use that.
+#                         if blueEyeMeshes in meshes_eyes and currentMeshes != argonianEyeMeshes:
+#                             currentMeshes = blueEyeMeshes
+#                             currentEyes = meshes_eyes[blueEyeMeshes]
+#                             raceChanged = True
+#                         elif argonianEyeMeshes in meshes_eyes:
+#                             currentMeshes = argonianEyeMeshes
+#                             currentEyes = meshes_eyes[argonianEyeMeshes]
+#                             raceChanged = True
+#                         #--Else figure that current eye mesh is the correct one
+#                         elif currentMeshes in meshes_eyes:
+#                             currentEyes = meshes_eyes[currentMeshes]
+#                             raceChanged = True
+#                         #--Else use most popular eye mesh
+#                         else:
+#                             currentMeshes = maxEyesMeshes
+#                             currentEyes = meshes_eyes[maxEyesMeshes]
+#                             raceChanged = True
+#                     if raceChanged:
+#                         racesFiltered.append(race.eid)
+
+#                     #--Sort Eyes/Hair
+#                     oldHairs = race.hairs
+#                     currentHairs = oldHairs
+#                     if recordId in playableRaces:
+#                         currentHairs = sorted(oldHairs,key=lambda x: hairNames.get(x))
+#                         if currentHairs != oldHairs:
+#                             racesSorted.add(race.eid)
+#                             raceChanged = True
+#                         oldEyes = currentEyes
+#                         currentEyes = sorted(oldEyes,key=lambda x: eyeNames.get(x))
+#                         if currentEyes != oldEyes:
+#                             racesSorted.add(race.eid)
+#                             raceChanged = True
+#                         defaultEyes[recordId] = [x for x in bush.defaultEyes.get(recordId,[]) if x in currentEyes] or currentEyes
+#                         defaultMaleHair[recordId] = [x for x in currentHairs if x in maleHairs]
+#                         defaultFemaleHair[recordId] = [x for x in currentHairs if x in femaleHairs]
+
+#                     if raceChanged:
+#                         fixedRaces.add(recordId)
+#                         override = race.CopyAsOverride(patchFile)
+#                         if override:
+#                             override.eyes = currentEyes
+#                             override.hairs = currentHairs
+#                             override.rightEye.modPath, override.leftEye.modPath = currentMeshes
+#                 race.UnloadRecord()
+#             pstate += 1
+#         for modFile in ObCollection.LoadOrderMods:
+#             #--Npcs with unassigned eyes/hair
+#             #--Must run after all race records have been processed
+#             subProgress(pstate, _("Assigning random eyes and hairs to npcs missing them...\n"))
+#             reProcess = re.compile(r'(?:dremora)|(?:akaos)|(?:lathulet)|(?:orthe)|(?:ranyu)',re.I)
+#             for npc in modFile.NPC_:
+#                 recordId = npc.fid
+#                 if recordId in fixedNPCs: continue #--already processed once (added to patchFile, and now the patchFile is being processed)
+#                 raceId = npc.race
+#                 if raceId not in playableRaces: continue
+#                 if npc.full is not None and raceId == self.dremoraRace and not reProcess.search(npc.full): continue # So as not to give OOO's spectral warriors different hairs/eyes since they are dremora race.
+#                 #IsNewest
+#                 if npc.IsWinning():
+#                     npcChanged = False
+#                     raceEyes = defaultEyes.get(raceId)
+#                     eye = npc.eye
+#                     if eye is None and raceEyes:
+#                         eye = random.choice(raceEyes)
+#                         npcChanged = True
+#                     raceHair = ((defaultMaleHair,defaultFemaleHair)[npc.IsFemale]).get(raceId)
+#                     hair = npc.hair
+#                     if hair is None and raceHair:
+#                         hair = random.choice(raceHair)
+#                         npcChanged = True
+#                     if npcChanged:
+#                         fixedNPCs.add(recordId)
+#                         override = npc.CopyAsOverride(patchFile)
+#                         if override:
+#                             override.eye = eye
+#                             override.hair = hair
+#                             if not override.hairLength:
+#                                 override.hairLength = random.random()
+#                             mod_npcsFixed.setdefault(modFile.GName,set()).add(recordId)
+#                 npc.UnloadRecord()
+#             pstate += 1
+
+# class CBash_RacePatcher(SpecialPatcher,CBash_ListPatcher):
+#     """Merged leveled lists mod file."""
+#     name = _('Race Records')
+#     text = _("Merge race eyes, hair, body, voice from ACTIVE AND/OR MERGED mods.\n\nEven if none of the below mods are checked, this will sort hairs and eyes and attempt to remove googly eyes from all active mods. It will also randomly assign hairs and eyes to npcs that are otherwise missing them.")
+#     tip = _("Merge race eyes, hair, body, voice from mods.")
+#     autoRe = re.compile(r"^UNDEFINED$",re.I)
+#     autoKey = set(('Hair','Eyes-D','Eyes-R','Eyes-E','Eyes','Body-M','Body-F',
+#         'Voice-M','Voice-F','R.Relations','R.Teeth','R.Mouth','R.Ears', 'R.Head',
+#         'R.Attributes-F', 'R.Attributes-M', 'R.Skills', 'R.Description',
+#         'R.AddSpells', 'R.ChangeSpells','Body-Size-M','Body-Size-F',))
+#     forceAuto = True
+#     tweaks = [
+#         CBash_RacePatcher_Relations(),
+#         CBash_RacePatcher_Imports(),
+#         CBash_RacePatcher_Spells(),
+#         CBash_RacePatcher_Eyes(),
+#         ]
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_ListPatcher.initPatchFile(self,patchFile,loadMods)
+#         #This single tweak is broken into several parts to make it easier to manage
+#         #Each part is a group of tags that are processed similarly
+#         for tweak in self.tweaks:
+#             tweak.initPatchFile(self.srcs,patchFile,loadMods)
+
+#     def initData(self,type_patchers,progress):
+#         """Compiles material, i.e. reads source text, esp's, etc. as necessary."""
+#         for tweak in self.tweaks:
+#             tweak.initData(type_patchers,progress)
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         racesPatched = set()
+#         racesSorted = set()
+#         racesFiltered = []
+#         mod_npcsFixed = {}
+#         for tweak in self.tweaks:
+#             if hasattr(tweak, 'racesPatched'):
+#                 racesPatched |= tweak.racesPatched
+#             if hasattr(tweak, 'racesSorted'):
+#                 racesSorted |= tweak.racesSorted
+#             if hasattr(tweak, 'racesFiltered'):
+#                 racesFiltered += tweak.racesFiltered
+#             if hasattr(tweak, 'mod_npcsFixed'):
+#                 mod_npcsFixed.update(tweak.mod_npcsFixed)
+#         #--Done
+#         log.setHeader('= '+self.__class__.name)
+#         log(_("=== Source Mods"))
+#         if not self.srcs:
+#             log(_(". ~~None~~"))
+#         else:
+#             for mod in self.srcs:
+#                 log("* " +mod.s)
+#         log(_("\n=== Merged"))
+
+#         if not racesPatched:
+#             log(_(". ~~None~~"))
+#         else:
+#             for eid in sorted(racesPatched):
+#                 log("* "+eid)
+#         log(_("\n=== Eyes/Hair Sorted"))
+#         if not racesSorted:
+#             log(_(". ~~None~~"))
+#         else:
+#             for eid in sorted(racesSorted):
+#                 log("* "+eid)
+#         log(_("\n=== Eye Meshes Filtered"))
+#         if not racesFiltered:
+#             log(_(". ~~None~~"))
+#         else:
+#             log(_("In order to prevent 'googly eyes', incompatible eyes have been removed from the following races."))
+#             for eid in sorted(racesFiltered):
+#                 log("* "+eid)
+#         if mod_npcsFixed:
+#             log(_("\n=== Eyes/Hair Assigned for NPCs"))
+#             for srcMod in sorted(mod_npcsFixed):
+#                 if srcMod.cext == '.tmp':
+#                     name = srcMod.sbody
+#                 else:
+#                     name = srcMod.s
+#                 log("* %s: %d" % (name,len(mod_npcsFixed[srcMod])))
 
 #--------------------------------------------
 #------------------------------------------------------------------------------
-class SEWorldEnforcer(SpecialPatcher,Patcher):
-    """Suspends Cyrodiil quests while in Shivering Isles."""
-    name = _('SEWorld Tests')
-    text = _("Suspends Cyrodiil quests while in Shivering Isles. I.e. re-instates GetPlayerInSEWorld tests as necessary.")
-
-    #--Config Phase -----------------------------------------------------------
-    #--Patch Phase ------------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        Patcher.initPatchFile(self,patchFile,loadMods)
-        self.cyrodiilQuests = set()
-        if GPath('Oblivion.esm') in loadMods:
-            loadFactory = LoadFactory(False,MreQust)
-            modInfo = modInfos[GPath('Oblivion.esm')]
-            modFile = ModFile(modInfo,loadFactory)
-            modFile.load(True)
-            mapper = modFile.getLongMapper()
-            for record in modFile.QUST.getActiveRecords():
-                for condition in record.conditions:
-                    if condition.ifunc == 365 and condition.compValue == 0:
-                        self.cyrodiilQuests.add(mapper(record.fid))
-                        break
-        self.isActive = bool(self.cyrodiilQuests)
-
-    def getReadClasses(self):
-        """Returns load factory classes needed for reading."""
-        if not self.isActive: return tuple()
-        return (MreQust,)
-
-    def getWriteClasses(self):
-        """Returns load factory classes needed for writing."""
-        if not self.isActive: return tuple()
-        return (MreQust,)
-
-    def scanModFile(self,modFile,progress):
-        """Scans specified mod file to extract info. May add record to patch mod,
-        but won't alter it."""
-        if not self.isActive: return
-        if modFile.fileInfo.name == GPath('Oblivion.esm'): return
-        cyrodiilQuests = self.cyrodiilQuests
-        mapper = modFile.getLongMapper()
-        patchBlock = self.patchFile.QUST
-        for record in modFile.QUST.getActiveRecords():
-            fid = mapper(record.fid)
-            if fid not in cyrodiilQuests: continue
-            for condition in record.conditions:
-                if condition.ifunc == 365: break #--365: playerInSeWorld
-            else:
-                record = record.getTypeCopy(mapper)
-                patchBlock.setRecord(record)
-
-    def buildPatch(self,log,progress):
-        """Edits patch file as desired. Will write to log."""
-        if not self.isActive: return
-        cyrodiilQuests = self.cyrodiilQuests
-        patchFile = self.patchFile
-        keep = patchFile.getKeeper()
-        patched = []
-        for record in patchFile.QUST.getActiveRecords():
-            if record.fid not in cyrodiilQuests: continue
-            for condition in record.conditions:
-                if condition.ifunc == 365: break #--365: playerInSeWorld
-            else:
-                condition = record.getDefault('conditions')
-                condition.ifunc = 365
-                record.conditions.insert(0,condition)
-                keep(record.fid)
-                patched.append(record.eid)
-        log.setHeader('= '+self.__class__.name)
-        log(_('===Quests Patched: %d') % (len(patched),))
-
-class CBash_SEWorldEnforcer(SpecialPatcher,CBash_Patcher):
-    """Suspends Cyrodiil quests while in Shivering Isles."""
-    name = _('SEWorld Tests')
-    text = _("Suspends Cyrodiil quests while in Shivering Isles. I.e. re-instates GetPlayerInSEWorld tests as necessary.")
-    scanRequiresChecked = True
-    applyRequiresChecked = False
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        self.cyrodiilQuests = set()
-        self.srcs = [GPath('Oblivion.esm')]
-        self.isActive = self.srcs[0] in loadMods
-        self.mod_eids = {}
-
-    def getTypes(self):
-        return ['QUST']
-
-    #--Patch Phase ------------------------------------------------------------
-    def scan(self,modFile,record,bashTags):
-        """Records information needed to apply the patch."""
-        for condition in record.conditions:
-            if condition.ifunc == 365 and condition.compValue == 0:
-                self.cyrodiilQuests.add(record.fid)
-                return
-
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        if modFile.GName in self.srcs: return
-
-        recordId = record.fid
-        if(recordId in self.cyrodiilQuests):
-            for condition in record.conditions:
-                if condition.ifunc == 365: return #--365: playerInSeWorld
-            else:
-                override = record.CopyAsOverride(self.patchFile)
-                if override:
-                    conditions = override.conditions
-                    condition = override.create_condition()
-                    condition.ifunc = 365
-                    conditions.insert(0,condition)
-                    override.conditions = conditions
-                    self.mod_eids.setdefault(modFile.GName,[]).append(override.eid)
-                    record.UnloadRecord()
-                    record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_eids = self.mod_eids
-        log.setHeader('= ' +self.__class__.name)
-        log(_("\n=== Quests Patched"))
-        for mod,eids in mod_eids.iteritems():
-            log(_('* %s: %d') % (mod.s,len(eids)))
-            for eid in sorted(eids):
-                log('  * %s' % (eid))
-        self.mod_eids = {}
+# class SEWorldEnforcer(SpecialPatcher,Patcher):
+#     """Suspends Cyrodiil quests while in Shivering Isles."""
+#     name = _('SEWorld Tests')
+#     text = _("Suspends Cyrodiil quests while in Shivering Isles. I.e. re-instates GetPlayerInSEWorld tests as necessary.")
+
+#     #--Config Phase -----------------------------------------------------------
+#     #--Patch Phase ------------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.cyrodiilQuests = set()
+#         if GPath('Oblivion.esm') in loadMods:
+#             loadFactory = LoadFactory(False,MreQust)
+#             modInfo = modInfos[GPath('Oblivion.esm')]
+#             modFile = ModFile(modInfo,loadFactory)
+#             modFile.load(True)
+#             mapper = modFile.getLongMapper()
+#             for record in modFile.QUST.getActiveRecords():
+#                 for condition in record.conditions:
+#                     if condition.ifunc == 365 and condition.compValue == 0:
+#                         self.cyrodiilQuests.add(mapper(record.fid))
+#                         break
+#         self.isActive = bool(self.cyrodiilQuests)
+
+#     def getReadClasses(self):
+#         """Returns load factory classes needed for reading."""
+#         if not self.isActive: return tuple()
+#         return (MreQust,)
+
+#     def getWriteClasses(self):
+#         """Returns load factory classes needed for writing."""
+#         if not self.isActive: return tuple()
+#         return (MreQust,)
+
+#     def scanModFile(self,modFile,progress):
+#         """Scans specified mod file to extract info. May add record to patch mod,
+#         but won't alter it."""
+#         if not self.isActive: return
+#         if modFile.fileInfo.name == GPath('Oblivion.esm'): return
+#         cyrodiilQuests = self.cyrodiilQuests
+#         mapper = modFile.getLongMapper()
+#         patchBlock = self.patchFile.QUST
+#         for record in modFile.QUST.getActiveRecords():
+#             fid = mapper(record.fid)
+#             if fid not in cyrodiilQuests: continue
+#             for condition in record.conditions:
+#                 if condition.ifunc == 365: break #--365: playerInSeWorld
+#             else:
+#                 record = record.getTypeCopy(mapper)
+#                 patchBlock.setRecord(record)
+
+#     def buildPatch(self,log,progress):
+#         """Edits patch file as desired. Will write to log."""
+#         if not self.isActive: return
+#         cyrodiilQuests = self.cyrodiilQuests
+#         patchFile = self.patchFile
+#         keep = patchFile.getKeeper()
+#         patched = []
+#         for record in patchFile.QUST.getActiveRecords():
+#             if record.fid not in cyrodiilQuests: continue
+#             for condition in record.conditions:
+#                 if condition.ifunc == 365: break #--365: playerInSeWorld
+#             else:
+#                 condition = record.getDefault('conditions')
+#                 condition.ifunc = 365
+#                 record.conditions.insert(0,condition)
+#                 keep(record.fid)
+#                 patched.append(record.eid)
+#         log.setHeader('= '+self.__class__.name)
+#         log(_('===Quests Patched: %d') % (len(patched),))
+
+# class CBash_SEWorldEnforcer(SpecialPatcher,CBash_Patcher):
+#     """Suspends Cyrodiil quests while in Shivering Isles."""
+#     name = _('SEWorld Tests')
+#     text = _("Suspends Cyrodiil quests while in Shivering Isles. I.e. re-instates GetPlayerInSEWorld tests as necessary.")
+#     scanRequiresChecked = True
+#     applyRequiresChecked = False
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.cyrodiilQuests = set()
+#         self.srcs = [GPath('Oblivion.esm')]
+#         self.isActive = self.srcs[0] in loadMods
+#         self.mod_eids = {}
+
+#     def getTypes(self):
+#         return ['QUST']
+
+#     #--Patch Phase ------------------------------------------------------------
+#     def scan(self,modFile,record,bashTags):
+#         """Records information needed to apply the patch."""
+#         for condition in record.conditions:
+#             if condition.ifunc == 365 and condition.compValue == 0:
+#                 self.cyrodiilQuests.add(record.fid)
+#                 return
+
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         if modFile.GName in self.srcs: return
+
+#         recordId = record.fid
+#         if(recordId in self.cyrodiilQuests):
+#             for condition in record.conditions:
+#                 if condition.ifunc == 365: return #--365: playerInSeWorld
+#             else:
+#                 override = record.CopyAsOverride(self.patchFile)
+#                 if override:
+#                     conditions = override.conditions
+#                     condition = override.create_condition()
+#                     condition.ifunc = 365
+#                     conditions.insert(0,condition)
+#                     override.conditions = conditions
+#                     self.mod_eids.setdefault(modFile.GName,[]).append(override.eid)
+#                     record.UnloadRecord()
+#                     record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_eids = self.mod_eids
+#         log.setHeader('= ' +self.__class__.name)
+#         log(_("\n=== Quests Patched"))
+#         for mod,eids in mod_eids.iteritems():
+#             log(_('* %s: %d') % (mod.s,len(eids)))
+#             for eid in sorted(eids):
+#                 log('  * %s' % (eid))
+#         self.mod_eids = {}
 #------------------------------------------------------------------------------
 class ContentsChecker(SpecialPatcher,Patcher):
     """Checks contents of leveled lists, inventories and containers for correct content types."""
@@ -33361,9 +35210,10 @@ class ContentsChecker(SpecialPatcher,Patcher):
         Patcher.initPatchFile(self,patchFile,loadMods)
         self.contType_entryTypes = {
             'LVSP':'LVSP,SPEL,'.split(','),
-            'LVLC':'LVLC,NPC_,CREA'.split(','),
+            'LVLC':'LVLC,CREA,'.split(','),
+            'LVLN':'LVLN,NPC_,'.split(','),
             #--LVLI will also be applied for containers.
-            'LVLI':'LVLI,ALCH,AMMO,APPA,ARMO,BOOK,CLOT,INGR,KEYM,LIGH,MISC,SGST,SLGM,WEAP'.split(','),
+            'LVLI':'LVLI,ALCH,AMMO,APPA,ARMO,BOOK,CLOT,INGR,KEYM,LIGH,MISC,SGST,SLGM,WEAP,NOTE,MSTT,STAT'.split(','),
             }
         self.contType_entryTypes['CONT'] = self.contType_entryTypes['LVLI']
         self.contType_entryTypes['CREA'] = self.contType_entryTypes['LVLI']
@@ -33420,7 +35270,7 @@ class ContentsChecker(SpecialPatcher,Patcher):
         log.setHeader('= '+self.__class__.name)
         #--Lists
         for cAttr,eAttr,types in (
-            ('entries','listId',('LVSP','LVLI','LVLC')),
+            ('entries','listId',('LVSP','LVLI','LVLC','LVLN')),
             ('items','item',('CONT','CREA','NPC_')),
             ):
             for type in types:
@@ -33450,105 +35300,105 @@ class ContentsChecker(SpecialPatcher,Patcher):
                             mod,index = removedId
                             log('  . %s: %06X' % (mod.s,index))
 
-class CBash_ContentsChecker(SpecialPatcher,CBash_Patcher):
-    """Checks contents of leveled lists, inventories and containers for correct content types."""
-    scanOrder = 50
-    editOrder = 50
-    name = _('Contents Checker')
-    text = _("Checks contents of leveled lists, inventories and containers for correct types.")
-    srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
-
-    #--Config Phase -----------------------------------------------------------
-    def initPatchFile(self,patchFile,loadMods):
-        """Prepare to handle specified patch mod. All functions are called after this."""
-        CBash_Patcher.initPatchFile(self,patchFile,loadMods)
-        self.isActive = True
-        self.type_validEntries = {'LVSP':set(['LVSP','SPEL']),
-                                'LVLC':set(['LVLC','NPC_','CREA']),
-                                'LVLI':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
-                                'CONT':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
-                                'CREA':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
-                                'NPC_':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP'])}
-        self.listTypes = set(['LVSP','LVLC','LVLI'])
-        self.containerTypes = set(['CONT','CREA','NPC_'])
-        self.mod_type_id_badEntries = {}
-        self.knownGood = set()
-
-    def getTypes(self):
-        """Returns the group types that this patcher checks"""
-        return ['CONT','CREA','NPC_','LVLI','LVLC','LVSP']
-    #--Patch Phase ------------------------------------------------------------
-    def apply(self,modFile,record,bashTags):
-        """Edits patch file as desired."""
-        type = record._Type
-        ObCollection = self.patchFile.ObCollection
-        badEntries = set()
-        goodEntries = []
-        knownGood = self.knownGood
-        knownGoodAdd = knownGood.add
-        goodAppend = goodEntries.append
-        badAdd = badEntries.add
-        validEntries = self.type_validEntries[type]
-        if type in self.listTypes:
-            topattr, subattr = ('entries','listId')
-        else: #Is a container type
-            topattr, subattr = ('items','item')
-
-        for entry in getattr(record,topattr):
-            entryId = getattr(entry,subattr)
-            #Cache known good entries to decrease execution time
-            if entryId in knownGood:
-                goodAppend(entry)
-            else:
-                if entryId[0] is not None:
-                    entryRecords = ObCollection.LookupRecords(entryId)
-                else:
-                    entryRecords = None
-                if not entryRecords:
-                    badAdd((_('NONE'),entryId,None,_('NONE')))
-                else:
-                    entryRecord = entryRecords[0]
-                    if entryRecord.recType in validEntries:
-                        knownGoodAdd(entryId)
-                        goodAppend(entry)
-                    else:
-                        badAdd((entryRecord.eid,entryId,entryRecord.GName,entryRecord.recType))
-                        entryRecord.UnloadRecord()
-
-        if badEntries:
-            override = record.CopyAsOverride(self.patchFile)
-            if override:
-                setattr(override, topattr, goodEntries)
-                type_id_badEntries = self.mod_type_id_badEntries.setdefault(modFile.GName, {})
-                id_badEntries = type_id_badEntries.setdefault(type, {})
-                id_badEntries[record.eid] = badEntries.copy()
-                record.UnloadRecord()
-                record._ModID, record._RecordID = override._ModID, override._RecordID
-
-    def buildPatchLog(self,log):
-        """Will write to log."""
-        if not self.isActive: return
-        #--Log
-        mod_type_id_badEntries = self.mod_type_id_badEntries
-        log.setHeader('= ' +self.__class__.name)
-        for mod, type_id_badEntries in mod_type_id_badEntries.iteritems():
-            log('\n=== %s' % (mod.s))
-            for type,id_badEntries in type_id_badEntries.iteritems():
-                log(_('  * Cleaned %s: %d') % (type,len(id_badEntries)))
-                for id, badEntries in id_badEntries.iteritems():
-                    log('    * %s : %d' % (id,len(badEntries)))
-                    for entry in sorted(badEntries, key=itemgetter(0)):
-                        longId = entry[1]
-                        if entry[2]:
-                            modName = entry[2].s
-                        else:
-                            try:
-                                modName = longId[0].s
-                            except:
-                                log(_('        . Unloaded Object or Undefined Reference'))
-                                continue
-                        log(_('        . Editor ID: "%s", Object ID %06X: Defined in mod "%s" as %s') % (entry[0],longId[1],modName,entry[3]))
-        self.mod_type_id_badEntries = {}
+# class CBash_ContentsChecker(SpecialPatcher,CBash_Patcher):
+#     """Checks contents of leveled lists, inventories and containers for correct content types."""
+#     scanOrder = 50
+#     editOrder = 50
+#     name = _('Contents Checker')
+#     text = _("Checks contents of leveled lists, inventories and containers for correct types.")
+#     srcs = [] #so as not to fail screaming when determining load mods - but with the least processing required.
+
+#     #--Config Phase -----------------------------------------------------------
+#     def initPatchFile(self,patchFile,loadMods):
+#         """Prepare to handle specified patch mod. All functions are called after this."""
+#         CBash_Patcher.initPatchFile(self,patchFile,loadMods)
+#         self.isActive = True
+#         self.type_validEntries = {'LVSP':set(['LVSP','SPEL']),
+#                                 'LVLC':set(['LVLC','NPC_','CREA']),
+#                                 'LVLI':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
+#                                 'CONT':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
+#                                 'CREA':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP']),
+#                                 'NPC_':set(['LVLI','ALCH','AMMO','APPA','ARMO','BOOK','CLOT','INGR','KEYM','LIGH','MISC','SGST','SLGM','WEAP'])}
+#         self.listTypes = set(['LVSP','LVLC','LVLI'])
+#         self.containerTypes = set(['CONT','CREA','NPC_'])
+#         self.mod_type_id_badEntries = {}
+#         self.knownGood = set()
+
+#     def getTypes(self):
+#         """Returns the group types that this patcher checks"""
+#         return ['CONT','CREA','NPC_','LVLI','LVLC','LVSP']
+#     #--Patch Phase ------------------------------------------------------------
+#     def apply(self,modFile,record,bashTags):
+#         """Edits patch file as desired."""
+#         type = record._Type
+#         ObCollection = self.patchFile.ObCollection
+#         badEntries = set()
+#         goodEntries = []
+#         knownGood = self.knownGood
+#         knownGoodAdd = knownGood.add
+#         goodAppend = goodEntries.append
+#         badAdd = badEntries.add
+#         validEntries = self.type_validEntries[type]
+#         if type in self.listTypes:
+#             topattr, subattr = ('entries','listId')
+#         else: #Is a container type
+#             topattr, subattr = ('items','item')
+
+#         for entry in getattr(record,topattr):
+#             entryId = getattr(entry,subattr)
+#             #Cache known good entries to decrease execution time
+#             if entryId in knownGood:
+#                 goodAppend(entry)
+#             else:
+#                 if entryId[0] is not None:
+#                     entryRecords = ObCollection.LookupRecords(entryId)
+#                 else:
+#                     entryRecords = None
+#                 if not entryRecords:
+#                     badAdd((_('NONE'),entryId,None,_('NONE')))
+#                 else:
+#                     entryRecord = entryRecords[0]
+#                     if entryRecord.recType in validEntries:
+#                         knownGoodAdd(entryId)
+#                         goodAppend(entry)
+#                     else:
+#                         badAdd((entryRecord.eid,entryId,entryRecord.GName,entryRecord.recType))
+#                         entryRecord.UnloadRecord()
+
+#         if badEntries:
+#             override = record.CopyAsOverride(self.patchFile)
+#             if override:
+#                 setattr(override, topattr, goodEntries)
+#                 type_id_badEntries = self.mod_type_id_badEntries.setdefault(modFile.GName, {})
+#                 id_badEntries = type_id_badEntries.setdefault(type, {})
+#                 id_badEntries[record.eid] = badEntries.copy()
+#                 record.UnloadRecord()
+#                 record._ModID, record._RecordID = override._ModID, override._RecordID
+
+#     def buildPatchLog(self,log):
+#         """Will write to log."""
+#         if not self.isActive: return
+#         #--Log
+#         mod_type_id_badEntries = self.mod_type_id_badEntries
+#         log.setHeader('= ' +self.__class__.name)
+#         for mod, type_id_badEntries in mod_type_id_badEntries.iteritems():
+#             log('\n=== %s' % (mod.s))
+#             for type,id_badEntries in type_id_badEntries.iteritems():
+#                 log(_('  * Cleaned %s: %d') % (type,len(id_badEntries)))
+#                 for id, badEntries in id_badEntries.iteritems():
+#                     log('    * %s : %d' % (id,len(badEntries)))
+#                     for entry in sorted(badEntries, key=itemgetter(0)):
+#                         longId = entry[1]
+#                         if entry[2]:
+#                             modName = entry[2].s
+#                         else:
+#                             try:
+#                                 modName = longId[0].s
+#                             except:
+#                                 log(_('        . Unloaded Object or Undefined Reference'))
+#                                 continue
+#                         log(_('        . Editor ID: "%s", Object ID %06X: Defined in mod "%s" as %s') % (entry[0],longId[1],modName,entry[3]))
+#         self.mod_type_id_badEntries = {}
 
 # Initialization --------------------------------------------------------------
 
@@ -33653,20 +35503,20 @@ def testPermissions(path,permissions='rwcd'):
         else: raise
     return True
 
-def getOblivionPath(bashIni, path):
+def getFalloutPath(bashIni, path):
     if path: path = GPath(path)
-    elif bashIni and bashIni.has_option('General', 'sOblivionPath') and not bashIni.get('General', 'sOblivionPath') == '.':
-        path = GPath(bashIni.get('General', 'sOblivionPath').strip())
+    elif bashIni and bashIni.has_option('General', 'sFallout3Path') and not bashIni.get('General', 'sFallout3Path') == '.':
+        path = GPath(bashIni.get('General', 'sFallout3Path').strip())
     else:
-        path = bolt.Path.getcwd().head #Assume bash is in right place (\Oblivion\Mopy\)
+        path = bolt.Path.getcwd().head #Assume bash is in right place (\Fallout (New Vegas|3)\Mopy\)
         #but for bashmon have to do a checky.
         if path.s[-4:].lower() == 'mopy':
             path = GPath(path.s[:-5])
     #--If path is relative, make absolute
     if not path.isabs(): path = dirs['mopy'].join(path)
     #--Error check
-    if not path.join('Oblivion.exe').exists():
-        raise BoltError(_("Install Error\nFailed to find Oblivion.exe in %s.\nNote that the Mopy folder should be in the same folder as Oblivion.exe.") % path)
+    if not path.join('Fallout3.exe').exists():
+        raise BoltError(_("Install Error\nFailed to find Fallout3.exe in %s.\nNote that the Mopy folder should be in the same folder as Fallout3.exe.") % path)
     return path
 
 def getPersonalPath(bashIni, path):
@@ -33717,11 +35567,11 @@ def getLocalAppDataPath(bashIni, path):
             % (path.s, sErrorInfo))
     return path
 
-def getOblivionModsPath(bashIni):
-    if bashIni and bashIni.has_option('General','sOblivionMods'):
-        path = GPath(bashIni.get('General','sOblivionMods').strip())
+def getFalloutModsPath(bashIni):
+    if bashIni and bashIni.has_option('General','sFallout3Mods'):
+        path = GPath(bashIni.get('General','sFallout3Mods').strip())
     else:
-        path = GPath(r'..\Oblivion Mods')
+        path = GPath(r'..\Fallout 3 Mods')
     if not path.isabs(): path = dirs['app'].join(path)
     return path
 
@@ -33738,13 +35588,13 @@ def getBashModDataPath(bashIni):
         path = GPath(bashIni.get('General','sBashModData').strip())
         if not path.isabs(): path = dirs['app'].join(path)
     else:
-        path = getOblivionModsPath(bashIni).join('Bash Mod Data')
+        path = getFalloutModsPath(bashIni).join('Bash Mod Data')
     return path
 
 def getLegacyPath(newPath, oldPath):
     return (oldPath,newPath)[newPath.isdir() or not oldPath.isdir()]
 
-def initDirs(bashIni, personal, localAppData, oblivionPath):
+def initDirs(bashIni, personal, localAppData, falloutPath):
     #--Mopy directories
     dirs['mopy'] = bolt.Path.getcwd().root
     dirs['bash'] = dirs['mopy'].join('bash')
@@ -33754,41 +35604,41 @@ def initDirs(bashIni, personal, localAppData, oblivionPath):
     dirs['templates'] = dirs['mopy'].join('templates')
     dirs['images'] = dirs['bash'].join('images')
 
-    #--Oblivion (Application) Directories
-    dirs['app'] = getOblivionPath(bashIni,oblivionPath)
+    #--Fallout (Application) Directories
+    dirs['app'] = getFalloutPath(bashIni,falloutPath)
     dirs['mods'] = dirs['app'].join('Data')
     dirs['builds'] = dirs['app'].join('Builds')
     dirs['patches'] = dirs['mods'].join('Bash Patches')
 
     #  Personal
     personal = getPersonalPath(bashIni,personal)
-    dirs['saveBase'] = personal.join(r'My Games','Oblivion')
+    dirs['saveBase'] = personal.join(r'My Games','Fallout3')
 
     #  Local Application Data
     localAppData = getLocalAppDataPath(bashIni,localAppData)
-    dirs['userApp'] = localAppData.join('Oblivion')
+    dirs['userApp'] = localAppData.join('Fallout3')
 
-    # Use local paths if bUseMyGamesDirectory=0 in Oblivion.ini
-    oblivionIni = OblivionIni()
+    # Use local paths if bUseMyGamesDirectory=0 in Fallout.ini
+    falloutIni = FalloutIni()
     try:
-        if oblivionIni.getSetting('General','bUseMyGamesDirectory','1') == '0':
-            # Set the save game folder to the Oblivion directory
+        if falloutIni.getSetting('General','bUseMyGamesDirectory','1') == '0':
+            # Set the save game folder to the Fallout directory
             dirs['saveBase'] = dirs['app']
             # Set the data folder to sLocalMasterPath
-            dirs['mods'] = dirs['app'].join(oblivionIni.getSetting('General', 'SLocalMasterPath','Data\\'))
+            dirs['mods'] = dirs['app'].join(falloutIni.getSetting('General', 'SLocalMasterPath','Data\\'))
             # this one is relative to the mods path so it must be updated too
             dirs['patches'] = dirs['mods'].join('Bash Patches')
     except:
-        # Error accessing folders for Oblivion.ini
+        # Error accessing folders for Fallout.ini
         # We'll show an error later
         pass
 
     #--Mod Data, Installers
-    oblivionMods = getOblivionModsPath(bashIni)
+    falloutMods = getFalloutModsPath(bashIni)
     dirs['modsBash'] = getBashModDataPath(bashIni)
     dirs['modsBash'] = getLegacyPath(dirs['modsBash'],dirs['app'].join('Data','Bash'))
 
-    dirs['installers'] = oblivionMods.join('Bash Installers')
+    dirs['installers'] = falloutMods.join('Bash Installers')
     dirs['installers'] = getLegacyPath(dirs['installers'],dirs['app'].join('Installers'))
 
     dirs['bainData'] = getBainDataPath(bashIni)
@@ -33802,8 +35652,8 @@ def initDirs(bashIni, personal, localAppData, oblivionPath):
     for dir in dirs:
         if not testPermissions(dirs[dir]):
             badPermissions.append(dirs[dir])
-    if not testPermissions(oblivionMods):
-        badPermissions.append(oblivionMods)
+    if not testPermissions(falloutMods):
+        badPermissions.append(falloutMods)
     if len(badPermissions) > 0:
         # Do not have all the required permissions for all directories
         # TODO: make this gracefully degrade.  IE, if only the BAIN paths are
@@ -33841,11 +35691,12 @@ def initDefaultTools():
     pf = [GPath(r'C:\Program Files'),GPath(r'C:\Program Files (x86)')]
     def pathlist(*args): return [x.join(*args) for x in pf]
 
-    tooldirs['Tes4FilesPath'] = dirs['app'].join('Tools','TES4Files.exe')
-    tooldirs['Tes4EditPath'] = dirs['app'].join('TES4Edit.exe')
-    tooldirs['Tes4LodGenPath'] = dirs['app'].join('TES4LodGen.exe')
-    tooldirs['Tes4GeckoPath'] = dirs['app'].join('Tes4Gecko.jar')
-    tooldirs['OblivionBookCreatorPath'] = dirs['mods'].join('OblivionBookCreator.jar')
+    tooldirs['FOMMPath'] = pathlist('GeMM','fomm.exe')
+    #tooldirs['Tes4FilesPath'] = dirs['app'].join('TES4Files.exe')
+    tooldirs['FO3EditPath'] = dirs['app'].join('FO3Edit.exe')
+    #tooldirs['Tes4LodGenPath'] = dirs['app'].join('TES4LodGen.exe')
+    #tooldirs['Tes4GeckoPath'] = dirs['app'].join('Tes4Gecko.jar')
+    #tooldirs['OblivionBookCreatorPath'] = dirs['mods'].join('OblivionBookCreator.jar')
     tooldirs['NifskopePath'] = pathlist('NifTools','NifSkope','Nifskope.exe')
     tooldirs['BlenderPath'] = pathlist('Blender Foundation','Blender','blender.exe')
     tooldirs['GmaxPath'] = GPath(r'C:\GMAX\gmax.exe')
@@ -33930,7 +35781,7 @@ def initDefaultSettings():
     inisettings['EnableReplacers'] = False
     inisettings['EnableBalo'] = False
     inisettings['ResetBSATimestamps'] = True
-    inisettings['OblivionTexturesBSAName'] = 'Oblivion - Textures - Compressed.bsa'
+    inisettings['FalloutTexturesBSAName'] = GPath('Fallout - Textures.bsa')
     inisettings['ClearRO'] = True
     inisettings['Tes4GeckoJavaArg'] = '-Xmx1024m'
     inisettings['OblivionBookCreatorJavaArg'] = '-Xmx1024m'
@@ -33993,8 +35844,8 @@ def initOptions(bashIni):
                 elif compValue != compDefaultValue:
                     usedSettings[usedKey] = value
 
-    tooldirs['Tes4ViewPath'] = tooldirs['Tes4EditPath'].head.join('TES4View.exe')
-    tooldirs['Tes4TransPath'] = tooldirs['Tes4EditPath'].head.join('TES4Trans.exe')
+    tooldirs['FO3MasterUpdatePath'] = tooldirs['FO3EditPath'].head.join('FO3MasterUpdate.exe')
+    tooldirs['FO3MasterRestorePath'] = tooldirs['FO3EditPath'].head.join('FO3MasterRestore.exe')
 
 def initLogFile():
     if inisettings['KeepLog'] == 0:
@@ -34005,14 +35856,14 @@ def initLogFile():
         log.write(_('%s Wrye Bash ini file read, Keep Log level: %d, initialized.\r\n') % (datetime.datetime.now(),inisettings['KeepLog']))
         log.close()
 
-def initBosh(personal='',localAppData='',oblivionPath=''):
+def initBosh(personal='',localAppData='',falloutPath=''):
     #--Bash Ini
     bashIni = None
     if GPath('bash.ini').exists():
         bashIni = ConfigParser.ConfigParser()
         bashIni.read('bash.ini')
 
-    initDirs(bashIni,personal,localAppData, oblivionPath)
+    initDirs(bashIni,personal,localAppData, falloutPath)
     initOptions(bashIni)
     initLogFile()
 
